; Listing generated by Microsoft (R) Optimizing Compiler Version 12.00.8943.0 

	TITLE	C:\duke4\Cannibal\MacMain.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT PARA USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0BF@MBIJ@Cannot?5init?5CPrintfT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_00A@?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DM@CGKC@SetDataSize?5with?5incompatible?5el@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BB@OEJH@Invalid?5importer?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BB@PIMA@Invalid?5exporter?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03NCKM@cpj?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BB@DFOH@Cannibal?5Project?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03LMJE@geo?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BC@LDNG@Cannibal?5Geometry?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03CAHH@srf?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BB@HJJD@Cannibal?5Surface?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03OJBK@lod?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BC@GAMJ@Cannibal?5LOD?5Data?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03OILG@skl?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BC@MLFJ@Cannibal?5Skeleton?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03LAFA@frm?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BH@NIOG@Cannibal?5Vertex?5Frames?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03NHBO@seq?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BC@KGFM@Cannibal?5Sequence?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03CMEC@mac?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BM@NPDB@Cannibal?5Model?5Actor?5Config?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_01KBOJ@s?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09KJDM@SetAuthor?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09OANE@OMacActor?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0P@HBI@SetDescription?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03CLFC@fff?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09NIBD@SetOrigin?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08OKHL@SetScale?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@BIJC@SetRotation?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@KGJ@SetBoundsMin?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@OJDP@SetBoundsMax?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@KHLN@SetGeometry?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_02HNOA@is?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@BCFB@SetSurface?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@BJMB@SetLodData?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@NPDC@SetSkeleton?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09ONCB@AddFrames?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04BAK@NULL?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@JOIN@AddSequences?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07ILDF@OObject?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03HJPD@GEO?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03CNNB@SKL?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03CMHN@LOD?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03OFBA@SRF?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03HFDH@FRM?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03BCHJ@SEQ?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08PDKO@autoexec?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0P@HLNL@SetAuthor?5?$CC?$CFs?$CC?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BE@JMPP@SetDescription?5?$CC?$CFs?$CC?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BD@GKMM@SetOrigin?5?$CFf?5?$CFf?5?$CFf?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BC@NICM@SetScale?5?$CFf?5?$CFf?5?$CFf?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BF@LOLC@SetRotation?5?$CFf?5?$CFf?5?$CFf?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BG@BKJK@SetBoundsMin?5?$CFf?5?$CFf?5?$CFf?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BG@JCEN@SetBoundsMax?5?$CFf?5?$CFf?5?$CFf?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BB@PBDG@SetGeometry?5?$CC?$CFs?$CC?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BB@BEIB@SetSkeleton?5?$CC?$CFs?$CC?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BA@FMNO@SetLodData?5?$CC?$CFs?$CC?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BD@DNEA@SetSurface?5?$CFd?5?$CC?$CFs?$CC?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BB@PHGO@AddFrames?5?$CCNULL?$CC?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0P@LABC@AddFrames?5?$CC?$CFs?$CC?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BE@HFDO@AddSequences?5?$CCNULL?$CC?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BC@FMMO@AddSequences?5?$CC?$CFs?$CC?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@BDBM@OMacChannel?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BE@NKOE@OMacSequenceChannel?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0O@HJCN@OMacIKChannel?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CRT$XCA	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCA	ENDS
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
CRT$XCL	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCL	ENDS
CRT$XCC	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCC	ENDS
CRT$XCZ	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCZ	ENDS
;	COMDAT __imp_??0autochar@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1autochar@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??4autochar@@QAEAAV0@PAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??Bautochar@@QAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0XRef@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0XListState@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0XChainState@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0XChainState@@QAE@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0MemGrow@@QAE@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1MemGrow@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0MemStats@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?add_count@XStatistic@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?add_tick@XStatistic@@QAEX_K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?add_alloc@XStatistic@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?add_alloc2@XStatistic@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?add_alloc3@XStatistic@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??3XStatistic@@SAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?push@XStatManager@@QAEXPAVXStatistic@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?pop@XStatManager@@QAEXPAVXStatistic@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0CError@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?is_locked@XMutex@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?assert@XGlobal@@QAEXPBDK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0CSysObj@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1CSysObj@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1CStrObj@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??3CStrObj@@SAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?reset@CPrintf@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?str@CPrintf@@QAEKPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?get_len@CPrintf@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?get_str@CPrintf@@QAEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?get_cur@CPrintf@@QAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?get_last@CPrintf@@QAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?set_cur@CPrintf@@QAEPADPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?reset@StrGrow@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??BStrGrow@@QAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0XBufferReadInt@@QAE@PAVCBaseStream@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1XBufferReadInt@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0XBufferWriteInt@@QAE@PAVCBaseStream@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1XBufferWriteInt@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1XStreamRdDirect@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??3XStreamRdDirect@@SAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1XStreamWrDirect@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??3XStreamWrDirect@@SAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1XMemRdBuffer@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??3XMemRdBuffer@@SAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?is_open@CBaseStream@@IAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1CBaseStream@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FindState@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Set@CCorString@@QAEXPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Cat@CCorString@@QAEXPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Setf@CCorString@@QAAXPADZZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Catf@CCorString@@QAAXPADZZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CCorString@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CCorString@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CCorString@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CCorString@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4CCorString@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4CCorString@@QAEAAV0@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??YCCorString@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??YCCorString@@QAEAAV0@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??H@YA?AVCCorString@@ABV0@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8CCorString@@QAE_NABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9CCorString@@QAE_NABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??ECCorString@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??ECCorString@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??FCCorString@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??FCCorString@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??HCCorString@@QAE?AV0@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??GCCorString@@QAE?AV0@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DCCorString@@QBEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Len@CCorString@@QBEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Str@CCorString@@QBEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetStaticMemSize@CCorString@@SAKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReadByte@ICorStreamRead@@QAEEXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReadWord@ICorStreamRead@@QAEGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReadDword@ICorStreamRead@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReadSByte@ICorStreamRead@@QAECXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReadSWord@ICorStreamRead@@QAEFXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReadSDword@ICorStreamRead@@QAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReadFloat@ICorStreamRead@@QAEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReadDouble@ICorStreamRead@@QAENXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReadString@ICorStreamRead@@QAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?WriteByte@ICorStreamWrite@@QAE_NE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?WriteWord@ICorStreamWrite@@QAE_NG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?WriteDword@ICorStreamWrite@@QAE_NK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?WriteSByte@ICorStreamWrite@@QAE_NC@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?WriteSWord@ICorStreamWrite@@QAE_NF@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?WriteSDword@ICorStreamWrite@@QAE_NJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?WriteFloat@ICorStreamWrite@@QAE_NM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?WriteDouble@ICorStreamWrite@@QAE_NN@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?WriteString@ICorStreamWrite@@QAE_NPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Realloc@CCorArray@@IAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CCorArray@@IAE@KK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CCorArray@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@CCorArray@@QAEXKKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?M_Fabs@@YAMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?M_Det2x2@@YAMMMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?M_Det3x3@@YAMMMMMMMMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0VVec2@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0VVec2@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0VVec2@@QAE@MM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4VVec2@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Length2@VVec2@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Length@VVec2@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Normalize@VVec2@@QAEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??H@YA?AVVVec2@@ABV0@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??G@YA?AVVVec2@@ABV0@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??D@YA?AVVVec2@@ABV0@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??I@YAMABVVVec2@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??U@YAMABVVVec2@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??S@YA?AVVVec2@@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0VVec3@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0VVec3@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0VVec3@@QAE@MMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0VVec3@@QAE@ABVVVec2@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4VVec3@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??YVVec3@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??ZVVec3@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??XVVec3@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_0VVec3@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??XVVec3@@QAEAAV0@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_0VVec3@@QAEAAV0@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVVec3@@QAEPAMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVVec3@@QBEPAMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Length2@VVec3@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Length@VVec3@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Normalize@VVec3@@QAEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Dominant@VVec3@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??G@YA?AVVVec3@@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??H@YA?AVVVec3@@ABV0@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??G@YA?AVVVec3@@ABV0@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??D@YA?AVVVec3@@ABV0@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??K@YA?AVVVec3@@ABV0@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??D@YA?AVVVec3@@ABV0@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??K@YA?AVVVec3@@ABV0@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??I@YAMABVVVec3@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??U@YAMABVVVec3@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??T@YA?AVVVec3@@ABV0@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??S@YA?AVVVec3@@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0VVec4@@QAE@MMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVVec4@@QAEPAMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Length2@VVec4@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Length@VVec4@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??G@YA?AVVVec4@@ABV0@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0VQuat3@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0VQuat3@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0VQuat3@@QAE@ABVVVec3@@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AxisAngle@VQuat3@@QAEXABVVVec3@@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4VQuat3@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Length@VQuat3@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Normalize@VQuat3@@QAEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??G@YA?AVVQuat3@@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??D@YA?AVVQuat3@@ABV0@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??U@YAMABVVQuat3@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8@YA_NABVVQuat3@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0VEulers3@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0VEulers3@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0VEulers3@@QAE@MMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4VEulers3@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8@YA_NABVVEulers3@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0VAxes3@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0VAxes3@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0VAxes3@@QAE@ABVVVec3@@00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0VAxes3@@QAE@ABVVQuat3@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0VAxes3@@QAE@ABVVEulers3@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4VAxes3@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_2VAxes3@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??S@YA?AVVAxes3@@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??5@YA?AVVVec3@@ABV0@ABVVAxes3@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6@YA?AVVVec3@@ABV0@ABVVAxes3@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??5@YA?AVVAxes3@@ABV0@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6@YA?AVVAxes3@@ABV0@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0VCoords3@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0VCoords3@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0VCoords3@@QAE@ABVVAxes3@@ABVVVec3@@1@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4VCoords3@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_2VCoords3@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_3VCoords3@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??S@YA?AVVCoords3@@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??5@YA?AVVVec3@@ABV0@ABVVCoords3@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6@YA?AVVVec3@@ABV0@ABVVCoords3@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??5@YA?AVVCoords3@@ABV0@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6@YA?AVVCoords3@@ABV0@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_3VVec3@@QAEAAV0@ABVVCoords3@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0VQuat3@@QAE@ABVVAxes3@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Slerp@VQuat3@@QAEXABV1@0MM_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IMsgRouter@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IMsgRouter@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4IMsgRouter@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IMsgTarget@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IMsgTarget@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4IMsgTarget@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetFirstInterface@CObjInterface@@SAPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetNextInterface@CObjInterface@@QAEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CObjInterface@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4CObjInterface@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetFirstClass@CObjClass@@SAPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetNextClass@CObjClass@@QAEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CObjClass@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CObjClass@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4CObjClass@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetChild@CObjLink@@QAEPAVOObject@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetChild@CObjLink@@QAEXPAVOObject@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetParent@CObjLink@@QAEPAVOObject@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetParent@CObjLink@@QAEXPAVOObject@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetNext@CObjLink@@QAEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetNext@CObjLink@@QAEXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPrev@CObjLink@@QAEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetPrev@CObjLink@@QAEXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PreConstruct@CObjLink@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CObjLink@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CObjLink@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4CObjLink@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2OObject@@CAPAXIPAV0@PAVCObjClass@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3OObject@@CAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3OObject@@CAXPAXPAV0@PAVCObjClass@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetStaticClass@OObject@@SAPAVCObjClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?New@OObject@@SAPAV1@PAV1@PAVCObjClass@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClass@OObject@@UAEPAVCObjClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetClass@OObject@@QAEXPAVCObjClass@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetValid@OObject@@QAEX_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetObjectCount@OObject@@SAKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HasName@OObject@@QAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetName@OObject@@QAEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetNameHash@OObject@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetName@OObject@@QAEXPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetFlags@OObject@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetFlags@OObject@@QAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddFlags@OObject@@QAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SubFlags@OObject@@QAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsValid@OObject@@QAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HasChildren@OObject@@UAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsA@OObject@@UAE_NPAVCObjClass@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0OObject@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4OObject@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GOObject@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_EOObject@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetObject@CObjIter@@IAEPAVOObject@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetNext@CObjIter@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Advance@CObjIter@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Reset@CObjIter@@QAEXPAVOObject@@_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CObjIter@@QAE@PAVOObject@@_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BCObjIter@@QAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LinkBefore@CObjLink@@QAEXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LinkAfter@CObjLink@@QAEXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Unlink@CObjLink@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2OCpjRes@@CAPAXIPAVOObject@@PAVCObjClass@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3OCpjRes@@CAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3OCpjRes@@CAXPAXPAVOObject@@PAVCObjClass@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetStaticClass@OCpjRes@@SAPAVCObjClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?New@OCpjRes@@SAPAV1@PAVOObject@@PAVCObjClass@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClass@OCpjRes@@UAEPAVCObjClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetFileExtension@OCpjRes@@UAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetFileDescription@OCpjRes@@UAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LoadFile@OCpjRes@@UAE_NPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SaveFile@OCpjRes@@UAE_NPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0OCpjRes@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0OCpjRes@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4OCpjRes@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1OCpjRes@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GOCpjRes@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_EOCpjRes@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2OCpjChunk@@CAPAXIPAVOObject@@PAVCObjClass@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3OCpjChunk@@CAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3OCpjChunk@@CAXPAXPAVOObject@@PAVCObjClass@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetStaticClass@OCpjChunk@@SAPAVCObjClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?New@OCpjChunk@@SAPAV1@PAVOObject@@PAVCObjClass@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClass@OCpjChunk@@UAEPAVCObjClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Create@OCpjChunk@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetFourCC@OCpjChunk@@UAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LoadChunk@OCpjChunk@@UAE_NPAXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SaveChunk@OCpjChunk@@UAE_NPAXPAK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0OCpjChunk@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0OCpjChunk@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4OCpjChunk@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1OCpjChunk@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GOCpjChunk@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_EOCpjChunk@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2OCpjUnkChunk@@CAPAXIPAVOObject@@PAVCObjClass@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3OCpjUnkChunk@@CAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3OCpjUnkChunk@@CAXPAXPAVOObject@@PAVCObjClass@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetStaticClass@OCpjUnkChunk@@SAPAVCObjClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?New@OCpjUnkChunk@@SAPAV1@PAVOObject@@PAVCObjClass@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClass@OCpjUnkChunk@@UAEPAVCObjClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0OCpjUnkChunk@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0OCpjUnkChunk@@QAE@AAV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4OCpjUnkChunk@@QAEAAV0@AAV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1OCpjUnkChunk@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GOCpjUnkChunk@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_EOCpjUnkChunk@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2OCpjImporter@@CAPAXIPAVOObject@@PAVCObjClass@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3OCpjImporter@@CAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3OCpjImporter@@CAXPAXPAVOObject@@PAVCObjClass@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetStaticClass@OCpjImporter@@SAPAVCObjClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?New@OCpjImporter@@SAPAV1@PAVOObject@@PAVCObjClass@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClass@OCpjImporter@@UAEPAVCObjClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetImportClass@OCpjImporter@@UAEPAVCObjClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetFileExtension@OCpjImporter@@UAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetFileDescription@OCpjImporter@@UAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Configure@OCpjImporter@@UAE_NPAVOObject@@PAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Import@OCpjImporter@@UAE_NPAVOObject@@PAD1@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0OCpjImporter@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0OCpjImporter@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4OCpjImporter@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1OCpjImporter@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GOCpjImporter@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_EOCpjImporter@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2OCpjExporter@@CAPAXIPAVOObject@@PAVCObjClass@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3OCpjExporter@@CAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3OCpjExporter@@CAXPAXPAVOObject@@PAVCObjClass@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetStaticClass@OCpjExporter@@SAPAVCObjClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?New@OCpjExporter@@SAPAV1@PAVOObject@@PAVCObjClass@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClass@OCpjExporter@@UAEPAVCObjClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetExportClass@OCpjExporter@@UAEPAVCObjClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetFileExtension@OCpjExporter@@UAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetFileDescription@OCpjExporter@@UAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Configure@OCpjExporter@@UAE_NPAVOObject@@PAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Export@OCpjExporter@@UAE_NPAVOObject@@PAD1@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0OCpjExporter@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0OCpjExporter@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4OCpjExporter@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1OCpjExporter@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GOCpjExporter@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_EOCpjExporter@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2OCpjProject@@CAPAXIPAVOObject@@PAVCObjClass@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3OCpjProject@@CAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3OCpjProject@@CAXPAXPAVOObject@@PAVCObjClass@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetStaticClass@OCpjProject@@SAPAVCObjClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?New@OCpjProject@@SAPAV1@PAVOObject@@PAVCObjClass@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClass@OCpjProject@@UAEPAVCObjClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Create@OCpjProject@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Destroy@OCpjProject@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Lock@OCpjProject@@QAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Unlock@OCpjProject@@QAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsLocked@OCpjProject@@QAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetFileName@OCpjProject@@QAEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetFileExtension@OCpjProject@@UAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetFileDescription@OCpjProject@@UAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0OCpjProject@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0OCpjProject@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4OCpjProject@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1OCpjProject@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GOCpjProject@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_EOCpjProject@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2OCpjGeometry@@CAPAXIPAVOObject@@PAVCObjClass@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3OCpjGeometry@@CAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3OCpjGeometry@@CAXPAXPAVOObject@@PAVCObjClass@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetStaticClass@OCpjGeometry@@SAPAVCObjClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?New@OCpjGeometry@@SAPAV1@PAVOObject@@PAVCObjClass@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClass@OCpjGeometry@@UAEPAVCObjClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetFileExtension@OCpjGeometry@@UAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetFileDescription@OCpjGeometry@@UAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0OCpjGeometry@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0OCpjGeometry@@QAE@AAV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4OCpjGeometry@@QAEAAV0@AAV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1OCpjGeometry@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GOCpjGeometry@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_EOCpjGeometry@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2OCpjSurface@@CAPAXIPAVOObject@@PAVCObjClass@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3OCpjSurface@@CAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3OCpjSurface@@CAXPAXPAVOObject@@PAVCObjClass@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetStaticClass@OCpjSurface@@SAPAVCObjClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?New@OCpjSurface@@SAPAV1@PAVOObject@@PAVCObjClass@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClass@OCpjSurface@@UAEPAVCObjClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetFileExtension@OCpjSurface@@UAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetFileDescription@OCpjSurface@@UAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0OCpjSurface@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0OCpjSurface@@QAE@AAV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4OCpjSurface@@QAEAAV0@AAV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1OCpjSurface@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GOCpjSurface@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_EOCpjSurface@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2OCpjLodData@@CAPAXIPAVOObject@@PAVCObjClass@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3OCpjLodData@@CAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3OCpjLodData@@CAXPAXPAVOObject@@PAVCObjClass@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetStaticClass@OCpjLodData@@SAPAVCObjClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?New@OCpjLodData@@SAPAV1@PAVOObject@@PAVCObjClass@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClass@OCpjLodData@@UAEPAVCObjClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetFileExtension@OCpjLodData@@UAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetFileDescription@OCpjLodData@@UAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0OCpjLodData@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0OCpjLodData@@QAE@AAV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4OCpjLodData@@QAEAAV0@AAV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1OCpjLodData@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GOCpjLodData@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_EOCpjLodData@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2OCpjSkeleton@@CAPAXIPAVOObject@@PAVCObjClass@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3OCpjSkeleton@@CAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3OCpjSkeleton@@CAXPAXPAVOObject@@PAVCObjClass@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetStaticClass@OCpjSkeleton@@SAPAVCObjClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?New@OCpjSkeleton@@SAPAV1@PAVOObject@@PAVCObjClass@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClass@OCpjSkeleton@@UAEPAVCObjClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetFileExtension@OCpjSkeleton@@UAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetFileDescription@OCpjSkeleton@@UAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0OCpjSkeleton@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0OCpjSkeleton@@QAE@AAV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4OCpjSkeleton@@QAEAAV0@AAV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1OCpjSkeleton@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GOCpjSkeleton@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_EOCpjSkeleton@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CCpjFrmFrame@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CCpjFrmFrame@@QAE@AAV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4CCpjFrmFrame@@QAEAAV0@AAV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CCpjFrmFrame@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_H@YGXPAXIHP6EX0@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2OCpjFrames@@CAPAXIPAVOObject@@PAVCObjClass@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3OCpjFrames@@CAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3OCpjFrames@@CAXPAXPAVOObject@@PAVCObjClass@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetStaticClass@OCpjFrames@@SAPAVCObjClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?New@OCpjFrames@@SAPAV1@PAVOObject@@PAVCObjClass@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClass@OCpjFrames@@UAEPAVCObjClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Create@OCpjFrames@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetFileExtension@OCpjFrames@@UAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetFileDescription@OCpjFrames@@UAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0OCpjFrames@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0OCpjFrames@@QAE@AAV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4OCpjFrames@@QAEAAV0@AAV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1OCpjFrames@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GOCpjFrames@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_EOCpjFrames@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2OCpjSequence@@CAPAXIPAVOObject@@PAVCObjClass@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3OCpjSequence@@CAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3OCpjSequence@@CAXPAXPAVOObject@@PAVCObjClass@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetStaticClass@OCpjSequence@@SAPAVCObjClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?New@OCpjSequence@@SAPAV1@PAVOObject@@PAVCObjClass@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClass@OCpjSequence@@UAEPAVCObjClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Create@OCpjSequence@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetFileExtension@OCpjSequence@@UAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetFileDescription@OCpjSequence@@UAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0OCpjSequence@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0OCpjSequence@@QAE@AAV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4OCpjSequence@@QAEAAV0@AAV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1OCpjSequence@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GOCpjSequence@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_EOCpjSequence@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2OCpjConfig@@CAPAXIPAVOObject@@PAVCObjClass@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3OCpjConfig@@CAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3OCpjConfig@@CAXPAXPAVOObject@@PAVCObjClass@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetStaticClass@OCpjConfig@@SAPAVCObjClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?New@OCpjConfig@@SAPAV1@PAVOObject@@PAVCObjClass@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClass@OCpjConfig@@UAEPAVCObjClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetFileExtension@OCpjConfig@@UAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetFileDescription@OCpjConfig@@UAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0OCpjConfig@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0OCpjConfig@@QAE@AAV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4OCpjConfig@@QAEAAV0@AAV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1OCpjConfig@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GOCpjConfig@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_EOCpjConfig@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Nearest@VLine2@@QBE?AVVVec2@@ABV2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??I@YAMABVVLine2@@ABVVVec2@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0VLine3@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0VLine3@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0VLine3@@QAE@ABVVLine2@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0VLine3@@QAE@ABVVVec3@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TwoPoint@VLine3@@QAEXABVVVec3@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Nearest@VLine3@@QBE?AVVVec3@@ABV2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??I@YAMABVVLine3@@ABVVVec3@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0VPlane3@@QAE@ABVVVec3@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Nearest@VPlane3@@QBE?AVVVec3@@ABV2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Intersection@VPlane3@@QBE?AVVVec3@@ABVVLine3@@PAM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??I@YAMABVVPlane3@@ABVVVec3@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Nearest@VSphere3@@QBE?AVVVec3@@ABV2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??I@YAMABVVSphere3@@ABVVVec3@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0VBox3@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0VBox3@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0VBox3@@QAE@ABVVVec3@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4VBox3@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Intersects@VBox3@@QBE_NABVVLine3@@PAM1@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CMacBone@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CMacBone@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4CMacBone@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Unlink@CMacActorLink@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Link@CMacActorLink@@AAEXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CMacActorLink@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CMacActorLink@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetFirst@CMacActorLink@@SAPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetNext@CMacActorLink@@QAEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsDone@CMacActorLink@@QAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetActor@CMacActorLink@@QAEPAVOMacActor@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetActor@CMacActorLink@@QAEXPAVOMacActor@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4CMacActorLink@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2OMacActor@@CAPAXIPAVOObject@@PAVCObjClass@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3OMacActor@@CAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3OMacActor@@CAXPAXPAVOObject@@PAVCObjClass@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetStaticClass@OMacActor@@SAPAVCObjClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?New@OMacActor@@SAPAV1@PAVOObject@@PAVCObjClass@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClass@OMacActor@@UAEPAVCObjClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0OMacActor@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0OMacActor@@QAE@AAV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4OMacActor@@QAEAAV0@AAV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1OMacActor@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GOMacActor@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_EOMacActor@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2OMacChannel@@CAPAXIPAVOObject@@PAVCObjClass@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3OMacChannel@@CAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3OMacChannel@@CAXPAXPAVOObject@@PAVCObjClass@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetStaticClass@OMacChannel@@SAPAVCObjClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?New@OMacChannel@@SAPAV1@PAVOObject@@PAVCObjClass@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClass@OMacChannel@@UAEPAVCObjClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EvalBones@OMacChannel@@UAE_NPAVOMacActor@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EvalVerts@OMacChannel@@UAE_NPAVOMacActor@@KPAGPAVVVec3@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0OMacChannel@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0OMacChannel@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4OMacChannel@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1OMacChannel@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GOMacChannel@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_EOMacChannel@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2OMacSequenceChannel@@CAPAXIPAVOObject@@PAVCObjClass@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3OMacSequenceChannel@@CAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3OMacSequenceChannel@@CAXPAXPAVOObject@@PAVCObjClass@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetStaticClass@OMacSequenceChannel@@SAPAVCObjClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?New@OMacSequenceChannel@@SAPAV1@PAVOObject@@PAVCObjClass@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClass@OMacSequenceChannel@@UAEPAVCObjClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Create@OMacSequenceChannel@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0OMacSequenceChannel@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0OMacSequenceChannel@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4OMacSequenceChannel@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1OMacSequenceChannel@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GOMacSequenceChannel@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_EOMacSequenceChannel@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2OMacIKChannel@@CAPAXIPAVOObject@@PAVCObjClass@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3OMacIKChannel@@CAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3OMacIKChannel@@CAXPAXPAVOObject@@PAVCObjClass@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetStaticClass@OMacIKChannel@@SAPAVCObjClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?New@OMacIKChannel@@SAPAV1@PAVOObject@@PAVCObjClass@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClass@OMacIKChannel@@UAEPAVCObjClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Create@OMacIKChannel@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0OMacIKChannel@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0OMacIKChannel@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4OMacIKChannel@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1OMacIKChannel@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GOMacIKChannel@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_EOMacIKChannel@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CMacTraceInfo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CMacTraceInfo@@QAE@AAV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4CMacTraceInfo@@QAEAAV0@AAV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CMacTraceInfo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E40
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E41
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E43
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E44
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _SetAuthor_msg_OMacActor
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E46
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E47
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _SetDescription_msg_OMacActor
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E49
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E50
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _SetOrigin_msg_OMacActor
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E52
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E53
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _SetScale_msg_OMacActor
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E55
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E56
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _SetRotation_msg_OMacActor
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E58
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E59
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _SetBoundsMin_msg_OMacActor
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E61
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E62
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _SetBoundsMax_msg_OMacActor
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E64
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E65
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _SetGeometry_msg_OMacActor
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E67
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E68
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _SetSurface_msg_OMacActor
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E70
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E71
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _SetLodData_msg_OMacActor
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E73
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E74
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _SetSkeleton_msg_OMacActor
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E76
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E77
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _AddFrames_msg_OMacActor
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E79
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E80
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _AddSequences_msg_OMacActor
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Tick@OMacActor@@SAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ValidateAbs@CMacBone@@IAEX_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetCoords@CMacBone@@QAE?AVVCoords3@@_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetCoords@CMacBone@@QAEXABVVCoords3@@_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ResetCoords@CMacBone@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E82
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E83
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E84
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E85
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E87
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E88
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E90
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E91
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E93
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E94
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MsgGetChild@OMacActor@@UAEPAVIMsgTarget@@PAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Create@OMacActor@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FindBone@OMacActor@@QAEPAVCMacBone@@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FindFrame@OMacActor@@QAEPAVCCpjFrmFrame@@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FindSequence@OMacActor@@QAEPAVOCpjSequence@@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetGeometry@OMacActor@@QAE_NPAVOCpjGeometry@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetSkeleton@OMacActor@@QAE_NPAVOCpjSkeleton@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetLodData@OMacActor@@QAE_NPAVOCpjLodData@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetSurface@OMacActor@@QAE_NKPAVOCpjSurface@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddFrames@OMacActor@@QAE_NPAVOCpjProject@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddSequences@OMacActor@@QAE_NPAVOCpjProject@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LoadConfig@OMacActor@@QAE_NPAVOCpjConfig@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SaveConfig@OMacActor@@QAE_NPAVOCpjConfig@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetLodInfo@OMacActor@@QAEPAVCCpjLodLevel@@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EvaluateTris@OMacActor@@QAEKMPAUSMacTri@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EvaluateVerts@OMacActor@@QAEKMMPAVVVec3@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EvaluateTriVerts@OMacActor@@QAE_NKMPAVVVec3@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RayTriIntersect@@YA_NABVVLine3@@ABVVVec3@@11AAMAAV2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TraceRay@OMacActor@@QAE_NKPAUSMacTri@@KPAVVVec3@@ABVVLine3@@PAKPAM1PAPAVCCpjSklBone@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveReferencesTo@OMacActor@@QAE_NPAVOCpjChunk@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveAllReferencesTo@OMacActor@@SA_NPAVOCpjChunk@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E96
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E97
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E98
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E99
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E101
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E102
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E104
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E105
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E106
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E107
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E109
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E110
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E114
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E113
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EvalVerts@OMacSequenceChannel@@UAE_NPAVOMacActor@@KPAGPAVVVec3@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E115
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E116
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E117
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E118
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E120
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E121
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EvalBones@OMacIKChannel@@UAE_NPAVOMacActor@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E123
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E124
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E126
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E127
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StaticFindInfo@CMacTraceInfo@@SAPAV1@PAVOMacActor@@PAVOCpjGeometry@@PAVOCpjSkeleton@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Construct@CMacTraceInfo@@QAEXPAVOMacActor@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E131
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E130
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$XChain@VXStatistic@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?get_head@?$XList@VXStatistic@@@@QAEPAVXStatistic@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TCorArray@E@@QAE@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TCorArray@E@@QAE@AAV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$TCorArray@E@@QAEAAV0@AAV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TCorArray@E@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$TCorArray@E@@QAEAAEH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetCount@?$TCorArray@E@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$TCorArray@E@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Shrink@?$TCorArray@E@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Add@?$TCorArray@E@@QAEKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TCorArray@PAVCCpjGeoEdge@@@@QAE@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TCorArray@PAVCCpjGeoEdge@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TCorArray@PAVCCpjGeoTri@@@@QAE@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TCorArray@PAVCCpjGeoTri@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TCorArray@VCCpjGeoVert@@@@QAE@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TCorArray@VCCpjGeoVert@@@@QAE@AAV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$TCorArray@VCCpjGeoVert@@@@QAEAAV0@AAV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TCorArray@VCCpjGeoVert@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$TCorArray@VCCpjGeoVert@@@@QAEAAVCCpjGeoVert@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetCount@?$TCorArray@VCCpjGeoVert@@@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TCorArray@VCCpjGeoEdge@@@@QAE@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TCorArray@VCCpjGeoEdge@@@@QAE@AAV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$TCorArray@VCCpjGeoEdge@@@@QAEAAV0@AAV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TCorArray@VCCpjGeoEdge@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TCorArray@VCCpjGeoTri@@@@QAE@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TCorArray@VCCpjGeoTri@@@@QAE@AAV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$TCorArray@VCCpjGeoTri@@@@QAEAAV0@AAV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TCorArray@VCCpjGeoTri@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$TCorArray@VCCpjGeoTri@@@@QAEAAVCCpjGeoTri@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetCount@?$TCorArray@VCCpjGeoTri@@@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TCorArray@VCCpjGeoMount@@@@QAE@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TCorArray@VCCpjGeoMount@@@@QAE@AAV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$TCorArray@VCCpjGeoMount@@@@QAEAAV0@AAV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TCorArray@VCCpjGeoMount@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TCorArray@VCCpjSrfTex@@@@QAE@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TCorArray@VCCpjSrfTex@@@@QAE@AAV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$TCorArray@VCCpjSrfTex@@@@QAEAAV0@AAV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TCorArray@VCCpjSrfTex@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$TCorArray@VCCpjSrfTex@@@@QAEAAVCCpjSrfTex@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetCount@?$TCorArray@VCCpjSrfTex@@@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TCorArray@VCCpjSrfTri@@@@QAE@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TCorArray@VCCpjSrfTri@@@@QAE@AAV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$TCorArray@VCCpjSrfTri@@@@QAEAAV0@AAV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TCorArray@VCCpjSrfTri@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$TCorArray@VCCpjSrfTri@@@@QAEAAVCCpjSrfTri@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetCount@?$TCorArray@VCCpjSrfTri@@@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TCorArray@VVVec2@@@@QAE@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TCorArray@VVVec2@@@@QAE@AAV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$TCorArray@VVVec2@@@@QAEAAV0@AAV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TCorArray@VVVec2@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$TCorArray@VVVec2@@@@QAEAAVVVec2@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TCorArray@G@@QAE@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TCorArray@G@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$TCorArray@G@@QAEAAGH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetCount@?$TCorArray@G@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TCorArray@VCCpjLodTri@@@@QAE@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TCorArray@VCCpjLodTri@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$TCorArray@VCCpjLodTri@@@@QAEAAVCCpjLodTri@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetCount@?$TCorArray@VCCpjLodTri@@@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TCorArray@VCCpjLodLevel@@@@QAE@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TCorArray@VCCpjLodLevel@@@@QAE@AAV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$TCorArray@VCCpjLodLevel@@@@QAEAAV0@AAV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TCorArray@VCCpjLodLevel@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$TCorArray@VCCpjLodLevel@@@@QAEAAVCCpjLodLevel@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetCount@?$TCorArray@VCCpjLodLevel@@@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TCorArray@VCCpjSklWeight@@@@QAE@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TCorArray@VCCpjSklWeight@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$TCorArray@VCCpjSklWeight@@@@QAEAAVCCpjSklWeight@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetCount@?$TCorArray@VCCpjSklWeight@@@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TCorArray@VCCpjSklBone@@@@QAE@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TCorArray@VCCpjSklBone@@@@QAE@AAV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$TCorArray@VCCpjSklBone@@@@QAEAAV0@AAV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TCorArray@VCCpjSklBone@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$TCorArray@VCCpjSklBone@@@@QAEAAVCCpjSklBone@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetCount@?$TCorArray@VCCpjSklBone@@@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TCorArray@VCCpjSklVert@@@@QAE@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TCorArray@VCCpjSklVert@@@@QAE@AAV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$TCorArray@VCCpjSklVert@@@@QAEAAV0@AAV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TCorArray@VCCpjSklVert@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$TCorArray@VCCpjSklVert@@@@QAEAAVCCpjSklVert@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetCount@?$TCorArray@VCCpjSklVert@@@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TCorArray@VCCpjSklMount@@@@QAE@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TCorArray@VCCpjSklMount@@@@QAE@AAV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$TCorArray@VCCpjSklMount@@@@QAEAAV0@AAV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TCorArray@VCCpjSklMount@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TCorArray@VCCpjFrmGroup@@@@QAE@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TCorArray@VCCpjFrmGroup@@@@QAE@AAV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$TCorArray@VCCpjFrmGroup@@@@QAEAAV0@AAV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TCorArray@VCCpjFrmGroup@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$TCorArray@VCCpjFrmGroup@@@@QAEAAVCCpjFrmGroup@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TCorArray@VCCpjFrmBytePos@@@@QAE@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TCorArray@VCCpjFrmBytePos@@@@QAE@AAV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$TCorArray@VCCpjFrmBytePos@@@@QAEAAV0@AAV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TCorArray@VCCpjFrmBytePos@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$TCorArray@VCCpjFrmBytePos@@@@QAEAAVCCpjFrmBytePos@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TCorArray@VVVec3@@@@QAE@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TCorArray@VVVec3@@@@QAE@AAV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$TCorArray@VVVec3@@@@QAEAAV0@AAV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TCorArray@VVVec3@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$TCorArray@VVVec3@@@@QAEAAVVVec3@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TCorArray@VCCpjFrmFrame@@@@QAE@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TCorArray@VCCpjFrmFrame@@@@QAE@AAV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$TCorArray@VCCpjFrmFrame@@@@QAEAAV0@AAV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TCorArray@VCCpjFrmFrame@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$TCorArray@VCCpjFrmFrame@@@@QAEAAVCCpjFrmFrame@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetCount@?$TCorArray@VCCpjFrmFrame@@@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TCorArray@VCCpjSeqTranslate@@@@QAE@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TCorArray@VCCpjSeqTranslate@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$TCorArray@VCCpjSeqTranslate@@@@QAEAAVCCpjSeqTranslate@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetCount@?$TCorArray@VCCpjSeqTranslate@@@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TCorArray@VCCpjSeqRotate@@@@QAE@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TCorArray@VCCpjSeqRotate@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$TCorArray@VCCpjSeqRotate@@@@QAEAAVCCpjSeqRotate@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetCount@?$TCorArray@VCCpjSeqRotate@@@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TCorArray@VCCpjSeqScale@@@@QAE@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TCorArray@VCCpjSeqScale@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$TCorArray@VCCpjSeqScale@@@@QAEAAVCCpjSeqScale@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetCount@?$TCorArray@VCCpjSeqScale@@@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TCorArray@VCCpjSeqFrame@@@@QAE@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TCorArray@VCCpjSeqFrame@@@@QAE@AAV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$TCorArray@VCCpjSeqFrame@@@@QAEAAV0@AAV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TCorArray@VCCpjSeqFrame@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$TCorArray@VCCpjSeqFrame@@@@QAEAAVCCpjSeqFrame@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetCount@?$TCorArray@VCCpjSeqFrame@@@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TCorArray@VCCpjSeqEvent@@@@QAE@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TCorArray@VCCpjSeqEvent@@@@QAE@AAV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$TCorArray@VCCpjSeqEvent@@@@QAEAAV0@AAV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TCorArray@VCCpjSeqEvent@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TCorArray@VCCpjSeqBoneInfo@@@@QAE@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TCorArray@VCCpjSeqBoneInfo@@@@QAE@AAV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$TCorArray@VCCpjSeqBoneInfo@@@@QAEAAV0@AAV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TCorArray@VCCpjSeqBoneInfo@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$TCorArray@VCCpjSeqBoneInfo@@@@QAEAAVCCpjSeqBoneInfo@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetCount@?$TCorArray@VCCpjSeqBoneInfo@@@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TCorArray@VCCorString@@@@QAE@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TCorArray@VCCorString@@@@QAE@AAV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$TCorArray@VCCorString@@@@QAEAAV0@AAV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TCorArray@VCCorString@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$TCorArray@VCCorString@@@@QAEAAVCCorString@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetCount@?$TCorArray@VCCorString@@@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$TCorArray@VCCorString@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Shrink@?$TCorArray@VCCorString@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddItem@?$TCorArray@VCCorString@@@@QAEKABVCCorString@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TCorArray@VCCpjMacSection@@@@QAE@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TCorArray@VCCpjMacSection@@@@QAE@AAV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$TCorArray@VCCpjMacSection@@@@QAEAAV0@AAV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TCorArray@VCCpjMacSection@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$TCorArray@VCCpjMacSection@@@@QAEAAVCCpjMacSection@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetCount@?$TCorArray@VCCpjMacSection@@@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Add@?$TCorArray@VCCpjMacSection@@@@QAEKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TCorArray@PAVOCpjSurface@@@@QAE@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TCorArray@PAVOCpjSurface@@@@QAE@AAV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$TCorArray@PAVOCpjSurface@@@@QAEAAV0@AAV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TCorArray@PAVOCpjSurface@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$TCorArray@PAVOCpjSurface@@@@QAEAAPAVOCpjSurface@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetCount@?$TCorArray@PAVOCpjSurface@@@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$TCorArray@PAVOCpjSurface@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Shrink@?$TCorArray@PAVOCpjSurface@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddZeroed@?$TCorArray@PAVOCpjSurface@@@@QAEKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TCorArray@PAVOCpjFrames@@@@QAE@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TCorArray@PAVOCpjFrames@@@@QAE@AAV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$TCorArray@PAVOCpjFrames@@@@QAEAAV0@AAV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TCorArray@PAVOCpjFrames@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$TCorArray@PAVOCpjFrames@@@@QAEAAPAVOCpjFrames@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetCount@?$TCorArray@PAVOCpjFrames@@@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$TCorArray@PAVOCpjFrames@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Shrink@?$TCorArray@PAVOCpjFrames@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddItem@?$TCorArray@PAVOCpjFrames@@@@QAEKABQAVOCpjFrames@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TCorArray@PAVOCpjSequence@@@@QAE@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TCorArray@PAVOCpjSequence@@@@QAE@AAV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$TCorArray@PAVOCpjSequence@@@@QAEAAV0@AAV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TCorArray@PAVOCpjSequence@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$TCorArray@PAVOCpjSequence@@@@QAEAAPAVOCpjSequence@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetCount@?$TCorArray@PAVOCpjSequence@@@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$TCorArray@PAVOCpjSequence@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Shrink@?$TCorArray@PAVOCpjSequence@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddItem@?$TCorArray@PAVOCpjSequence@@@@QAEKABQAVOCpjSequence@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TCorArray@VCMacBone@@@@QAE@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TCorArray@VCMacBone@@@@QAE@AAV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$TCorArray@VCMacBone@@@@QAEAAV0@AAV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TCorArray@VCMacBone@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$TCorArray@VCMacBone@@@@QAEAAVCMacBone@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetCount@?$TCorArray@VCMacBone@@@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$TCorArray@VCMacBone@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Shrink@?$TCorArray@VCMacBone@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Add@?$TCorArray@VCMacBone@@@@QAEKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TCorArray@PAVOMacChannel@@@@QAE@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TCorArray@PAVOMacChannel@@@@QAE@AAV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$TCorArray@PAVOMacChannel@@@@QAEAAV0@AAV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TCorArray@PAVOMacChannel@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$TCorArray@PAVOMacChannel@@@@QAEAAPAVOMacChannel@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetCount@?$TCorArray@PAVOMacChannel@@@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$TCorArray@PAVOMacChannel@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Shrink@?$TCorArray@PAVOMacChannel@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddZeroed@?$TCorArray@PAVOMacChannel@@@@QAEKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TCorArray@VCMacTraceInfo@@@@QAE@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TCorArray@VCMacTraceInfo@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$TCorArray@VCMacTraceInfo@@@@QAEAAVCMacTraceInfo@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetCount@?$TCorArray@VCMacTraceInfo@@@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Add@?$TCorArray@VCMacTraceInfo@@@@QAEKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TCorArray@VVBox3@@@@QAE@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TCorArray@VVBox3@@@@QAE@AAV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$TCorArray@VVBox3@@@@QAEAAV0@AAV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TCorArray@VVBox3@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$TCorArray@VVBox3@@@@QAEAAVVBox3@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetCount@?$TCorArray@VVBox3@@@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Add@?$TCorArray@VVBox3@@@@QAEKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TObjIter@VOCpjFrames@@@@QAE@PAVOObject@@_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??E?$TObjIter@VOCpjFrames@@@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??D?$TObjIter@VOCpjFrames@@@@QAEPAVOCpjFrames@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TObjIter@VOCpjSequence@@@@QAE@PAVOObject@@_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??E?$TObjIter@VOCpjSequence@@@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??D?$TObjIter@VOCpjSequence@@@@QAEPAVOCpjSequence@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TCorArray@PAVOCpjProject@@@@QAE@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TCorArray@PAVOCpjProject@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$TCorArray@PAVOCpjProject@@@@QAEAAPAVOCpjProject@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetCount@?$TCorArray@PAVOCpjProject@@@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddUnique@?$TCorArray@PAVOCpjProject@@@@QAEKABQAVOCpjProject@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CCpjGeoVert@@QAE@AAV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CCpjGeoEdge@@QAE@AAV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CCpjGeoMount@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CCpjLodLevel@@QAE@AAV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CCpjSklBone@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CCpjSklVert@@QAE@AAV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CCpjSklMount@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CCpjFrmGroup@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CCpjSeqFrame@@QAE@AAV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CCpjSeqEvent@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CCpjSeqBoneInfo@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CCpjMacSection@@QAE@AAV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CCpjMacSection@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddNoConstruct@?$TCorArray@E@@QAEKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TCorArray@E@@QAEXKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TCorArray@PAVCCpjGeoEdge@@@@QAE@AAV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$TCorArray@PAVCCpjGeoEdge@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TCorArray@PAVCCpjGeoTri@@@@QAE@AAV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$TCorArray@PAVCCpjGeoTri@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$TCorArray@VCCpjGeoVert@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddNoConstruct@?$TCorArray@VCCpjGeoVert@@@@QAEKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$TCorArray@VCCpjGeoEdge@@@@QAEAAVCCpjGeoEdge@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$TCorArray@VCCpjGeoEdge@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddNoConstruct@?$TCorArray@VCCpjGeoEdge@@@@QAEKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$TCorArray@VCCpjGeoTri@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddNoConstruct@?$TCorArray@VCCpjGeoTri@@@@QAEKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$TCorArray@VCCpjGeoMount@@@@QAEAAVCCpjGeoMount@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$TCorArray@VCCpjGeoMount@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddNoConstruct@?$TCorArray@VCCpjGeoMount@@@@QAEKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$TCorArray@VCCpjSrfTex@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddNoConstruct@?$TCorArray@VCCpjSrfTex@@@@QAEKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$TCorArray@VCCpjSrfTri@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddNoConstruct@?$TCorArray@VCCpjSrfTri@@@@QAEKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$TCorArray@VVVec2@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddNoConstruct@?$TCorArray@VVVec2@@@@QAEKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TCorArray@G@@QAE@AAV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$TCorArray@G@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TCorArray@VCCpjLodTri@@@@QAE@AAV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$TCorArray@VCCpjLodTri@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$TCorArray@VCCpjLodLevel@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddNoConstruct@?$TCorArray@VCCpjLodLevel@@@@QAEKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TCorArray@VCCpjSklWeight@@@@QAE@AAV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$TCorArray@VCCpjSklWeight@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$TCorArray@VCCpjSklBone@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddNoConstruct@?$TCorArray@VCCpjSklBone@@@@QAEKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$TCorArray@VCCpjSklVert@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddNoConstruct@?$TCorArray@VCCpjSklVert@@@@QAEKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$TCorArray@VCCpjSklMount@@@@QAEAAVCCpjSklMount@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$TCorArray@VCCpjSklMount@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddNoConstruct@?$TCorArray@VCCpjSklMount@@@@QAEKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$TCorArray@VCCpjFrmGroup@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddNoConstruct@?$TCorArray@VCCpjFrmGroup@@@@QAEKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$TCorArray@VCCpjFrmBytePos@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddNoConstruct@?$TCorArray@VCCpjFrmBytePos@@@@QAEKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$TCorArray@VVVec3@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddNoConstruct@?$TCorArray@VVVec3@@@@QAEKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$TCorArray@VCCpjFrmFrame@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddNoConstruct@?$TCorArray@VCCpjFrmFrame@@@@QAEKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TCorArray@VCCpjSeqTranslate@@@@QAE@AAV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$TCorArray@VCCpjSeqTranslate@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TCorArray@VCCpjSeqRotate@@@@QAE@AAV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$TCorArray@VCCpjSeqRotate@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TCorArray@VCCpjSeqScale@@@@QAE@AAV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$TCorArray@VCCpjSeqScale@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$TCorArray@VCCpjSeqFrame@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddNoConstruct@?$TCorArray@VCCpjSeqFrame@@@@QAEKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$TCorArray@VCCpjSeqEvent@@@@QAEAAVCCpjSeqEvent@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$TCorArray@VCCpjSeqEvent@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddNoConstruct@?$TCorArray@VCCpjSeqEvent@@@@QAEKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$TCorArray@VCCpjSeqBoneInfo@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddNoConstruct@?$TCorArray@VCCpjSeqBoneInfo@@@@QAEKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddNoConstruct@?$TCorArray@VCCorString@@@@QAEKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Add@?$TCorArray@VCCorString@@@@QAEKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TCorArray@VCCorString@@@@QAEXKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$TCorArray@VCCpjMacSection@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddNoConstruct@?$TCorArray@VCCpjMacSection@@@@QAEKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddNoConstruct@?$TCorArray@PAVOCpjSurface@@@@QAEKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TCorArray@PAVOCpjSurface@@@@QAEXKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddNoConstruct@?$TCorArray@PAVOCpjFrames@@@@QAEKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Add@?$TCorArray@PAVOCpjFrames@@@@QAEKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TCorArray@PAVOCpjFrames@@@@QAEXKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddNoConstruct@?$TCorArray@PAVOCpjSequence@@@@QAEKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Add@?$TCorArray@PAVOCpjSequence@@@@QAEKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TCorArray@PAVOCpjSequence@@@@QAEXKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddNoConstruct@?$TCorArray@VCMacBone@@@@QAEKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TCorArray@VCMacBone@@@@QAEXKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddNoConstruct@?$TCorArray@PAVOMacChannel@@@@QAEKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TCorArray@PAVOMacChannel@@@@QAEXKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$TCorArray@VCMacTraceInfo@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddNoConstruct@?$TCorArray@VCMacTraceInfo@@@@QAEKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$TCorArray@VVBox3@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddNoConstruct@?$TCorArray@VVBox3@@@@QAEKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AdvanceToType@?$TObjIter@VOCpjFrames@@@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Reset@?$TObjIter@VOCpjFrames@@@@QAEXPAVOObject@@_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AdvanceToType@?$TObjIter@VOCpjSequence@@@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Reset@?$TObjIter@VOCpjSequence@@@@QAEXPAVOObject@@_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$TCorArray@PAVOCpjProject@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddItem@?$TCorArray@PAVOCpjProject@@@@QAEKABQAVOCpjProject@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FindItem@?$TCorArray@PAVOCpjProject@@@@QBE_NABQAVOCpjProject@@PAK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CCpjSklWeight@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CCpjSeqTranslate@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CCpjSeqRotate@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CCpjSeqScale@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCCorString@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$TCorArray@PAVCCpjGeoEdge@@@@QAEAAPAVCCpjGeoEdge@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddNoConstruct@?$TCorArray@PAVCCpjGeoEdge@@@@QAEKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TCorArray@PAVCCpjGeoEdge@@@@QAEXKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$TCorArray@PAVCCpjGeoTri@@@@QAEAAPAVCCpjGeoTri@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddNoConstruct@?$TCorArray@PAVCCpjGeoTri@@@@QAEKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TCorArray@PAVCCpjGeoTri@@@@QAEXKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TCorArray@VCCpjGeoVert@@@@QAEXKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TCorArray@VCCpjGeoEdge@@@@QAEXKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TCorArray@VCCpjGeoTri@@@@QAEXKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TCorArray@VCCpjGeoMount@@@@QAEXKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TCorArray@VCCpjSrfTex@@@@QAEXKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TCorArray@VCCpjSrfTri@@@@QAEXKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TCorArray@VVVec2@@@@QAEXKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddNoConstruct@?$TCorArray@G@@QAEKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TCorArray@G@@QAEXKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddNoConstruct@?$TCorArray@VCCpjLodTri@@@@QAEKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TCorArray@VCCpjLodTri@@@@QAEXKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TCorArray@VCCpjLodLevel@@@@QAEXKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddNoConstruct@?$TCorArray@VCCpjSklWeight@@@@QAEKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TCorArray@VCCpjSklWeight@@@@QAEXKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TCorArray@VCCpjSklBone@@@@QAEXKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TCorArray@VCCpjSklVert@@@@QAEXKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TCorArray@VCCpjSklMount@@@@QAEXKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TCorArray@VCCpjFrmGroup@@@@QAEXKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TCorArray@VCCpjFrmBytePos@@@@QAEXKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TCorArray@VVVec3@@@@QAEXKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TCorArray@VCCpjFrmFrame@@@@QAEXKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddNoConstruct@?$TCorArray@VCCpjSeqTranslate@@@@QAEKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TCorArray@VCCpjSeqTranslate@@@@QAEXKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddNoConstruct@?$TCorArray@VCCpjSeqRotate@@@@QAEKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TCorArray@VCCpjSeqRotate@@@@QAEXKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddNoConstruct@?$TCorArray@VCCpjSeqScale@@@@QAEKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TCorArray@VCCpjSeqScale@@@@QAEXKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TCorArray@VCCpjSeqFrame@@@@QAEXKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TCorArray@VCCpjSeqEvent@@@@QAEXKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TCorArray@VCCpjSeqBoneInfo@@@@QAEXKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TCorArray@VCCpjMacSection@@@@QAEXKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TCorArray@VCMacTraceInfo@@@@QAEXKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TCorArray@VVBox3@@@@QAEXKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Add@?$TCorArray@PAVOCpjProject@@@@QAEKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TCorArray@PAVOCpjProject@@@@QAEXKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCCpjGeoVert@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCCpjGeoEdge@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCCpjLodLevel@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCCpjSklBone@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCCpjSklVert@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCCpjSklMount@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCCpjFrmFrame@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCCpjSeqFrame@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCCpjSeqEvent@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCCpjSeqBoneInfo@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCCpjMacSection@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCMacTraceInfo@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CCpjGeoVert@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CCpjGeoEdge@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CCpjLodLevel@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CCpjSklBone@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CCpjSklVert@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CCpjSklMount@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CCpjSeqFrame@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CCpjSeqEvent@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CCpjSeqBoneInfo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CCpjMacSection@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddNoConstruct@?$TCorArray@PAVOCpjProject@@@@QAEKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$XChain@VXStatistic@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?free_list@?$XChain@VXStatistic@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$XList@VXStatistic@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$XList@VXStatistic@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?free_list@?$XList@VXStatistic@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?add_head@?$XList@VXStatistic@@@@QAEPAU_XPos@@PAVXStatistic@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?remove_head@?$XList@VXStatistic@@@@QAEPAVXStatistic@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$XRcBase@VCStrObj@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$XRcBase@VCStrObj@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$XRcPtr@VCPathObj@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$XRcPtr@VCPathObj@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$XList@VXFindLevel@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$XList@VXFindLevel@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCSysObj@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GXFindLevel@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1XFindLevel@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?new_node@?$XList@VXStatistic@@@@IAEPAUXNode@1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?free_nodes@?$XList@VXStatistic@@@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?free_nodes@?$XList@VXFindLevel@@@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DelRef@?$XRcBase@VCStrObj@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DelRef@?$XRcPtr@VCPathObj@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCStrObj@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCPathObj@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7IMsgRouter@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7OCpjFrames@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7OCpjConfig@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7OCpjRes@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?rot1@?1???0VQuat3@@QAE@ABVVAxes3@@@Z@4PAHA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_7OMacActor@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7OCpjSkeleton@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7OCpjImporter@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7OMacChannel@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7OCpjUnkChunk@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7OCpjLodData@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CMemMap@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7OCpjSequence@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7OCpjExporter@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7OObject@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7OCpjGeometry@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7IMsgTarget@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7OCpjSurface@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?rot1@?1??Intersection@VPlane3@@QAE?AVVLine3@@AAV2@@Z@4PAHA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_7OCpjChunk@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7OCpjProject@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7OMacSequenceChannel@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?rot2@?1??Intersection@VPlane3@@QAE?AVVLine3@@AAV2@@Z@4PAHA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_7OMacIKChannel@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7XMutex@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
FLAT	GROUP _DATA, CONST, _BSS, CRT$XCA, CRT$XCU, CRT$XCL, CRT$XCC, CRT$XCZ
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?OMacActor_objClassInstance@@3VCObjClass@@A	; OMacActor_objClassInstance
PUBLIC	?staticObjClass@OMacIKChannel@@0PAVCObjClass@@A	; OMacIKChannel::staticObjClass
PUBLIC	?OMacIKChannel_objClassInstance@@3VCObjClass@@A	; OMacIKChannel_objClassInstance
PUBLIC	?sTraceInfoList@CMacTraceInfo@@2V?$TCorArray@VCMacTraceInfo@@@@A ; CMacTraceInfo::sTraceInfoList
PUBLIC	?sHeadLink@CMacActorLink@@0V1@A			; CMacActorLink::sHeadLink
PUBLIC	?staticObjClass@OMacActor@@0PAVCObjClass@@A	; OMacActor::staticObjClass
PUBLIC	?FrameCount@OMacActor@@2KA			; OMacActor::FrameCount
PUBLIC	?Evaluations@OMacActor@@2KA			; OMacActor::Evaluations
PUBLIC	?SetAuthor_msg_OMacActor_dummy@@3_NA		; SetAuthor_msg_OMacActor_dummy
PUBLIC	?SetDescription_msg_OMacActor_dummy@@3_NA	; SetDescription_msg_OMacActor_dummy
PUBLIC	?SetOrigin_msg_OMacActor_dummy@@3_NA		; SetOrigin_msg_OMacActor_dummy
PUBLIC	?SetScale_msg_OMacActor_dummy@@3_NA		; SetScale_msg_OMacActor_dummy
PUBLIC	?SetRotation_msg_OMacActor_dummy@@3_NA		; SetRotation_msg_OMacActor_dummy
PUBLIC	?OMacChannel_objClassInstance@@3VCObjClass@@A	; OMacChannel_objClassInstance
PUBLIC	?SetBoundsMin_msg_OMacActor_dummy@@3_NA		; SetBoundsMin_msg_OMacActor_dummy
PUBLIC	?OMacSequenceChannel_objClassInstance@@3VCObjClass@@A ; OMacSequenceChannel_objClassInstance
PUBLIC	?SetBoundsMax_msg_OMacActor_dummy@@3_NA		; SetBoundsMax_msg_OMacActor_dummy
PUBLIC	?SetGeometry_msg_OMacActor_dummy@@3_NA		; SetGeometry_msg_OMacActor_dummy
PUBLIC	?staticObjClass@OMacChannel@@0PAVCObjClass@@A	; OMacChannel::staticObjClass
PUBLIC	?SetSurface_msg_OMacActor_dummy@@3_NA		; SetSurface_msg_OMacActor_dummy
PUBLIC	?SetLodData_msg_OMacActor_dummy@@3_NA		; SetLodData_msg_OMacActor_dummy
PUBLIC	?SetSkeleton_msg_OMacActor_dummy@@3_NA		; SetSkeleton_msg_OMacActor_dummy
PUBLIC	?AddFrames_msg_OMacActor_dummy@@3_NA		; AddFrames_msg_OMacActor_dummy
PUBLIC	?staticObjClass@OMacSequenceChannel@@0PAVCObjClass@@A ; OMacSequenceChannel::staticObjClass
PUBLIC	?AddSequences_msg_OMacActor_dummy@@3_NA		; AddSequences_msg_OMacActor_dummy
_BSS	SEGMENT
?OMacActor_objClassInstance@@3VCObjClass@@A DB 024H DUP (?) ; OMacActor_objClassInstance
?staticObjClass@OMacIKChannel@@0PAVCObjClass@@A DD 01H DUP (?) ; OMacIKChannel::staticObjClass
?OMacIKChannel_objClassInstance@@3VCObjClass@@A DB 024H DUP (?) ; OMacIKChannel_objClassInstance
?sTraceInfoList@CMacTraceInfo@@2V?$TCorArray@VCMacTraceInfo@@@@A DB 010H DUP (?) ; CMacTraceInfo::sTraceInfoList
?sHeadLink@CMacActorLink@@0V1@A DB 0cH DUP (?)		; CMacActorLink::sHeadLink
?staticObjClass@OMacActor@@0PAVCObjClass@@A DD 01H DUP (?) ; OMacActor::staticObjClass
?FrameCount@OMacActor@@2KA DD 01H DUP (?)		; OMacActor::FrameCount
?Evaluations@OMacActor@@2KA DD 01H DUP (?)		; OMacActor::Evaluations
?SetAuthor_msg_OMacActor_dummy@@3_NA DB 01H DUP (?)	; SetAuthor_msg_OMacActor_dummy
	ALIGN	4

?SetDescription_msg_OMacActor_dummy@@3_NA DB 01H DUP (?) ; SetDescription_msg_OMacActor_dummy
	ALIGN	4

?SetOrigin_msg_OMacActor_dummy@@3_NA DB 01H DUP (?)	; SetOrigin_msg_OMacActor_dummy
	ALIGN	4

?SetScale_msg_OMacActor_dummy@@3_NA DB 01H DUP (?)	; SetScale_msg_OMacActor_dummy
	ALIGN	4

?SetRotation_msg_OMacActor_dummy@@3_NA DB 01H DUP (?)	; SetRotation_msg_OMacActor_dummy
	ALIGN	4

?OMacChannel_objClassInstance@@3VCObjClass@@A DB 024H DUP (?) ; OMacChannel_objClassInstance
?SetBoundsMin_msg_OMacActor_dummy@@3_NA DB 01H DUP (?)	; SetBoundsMin_msg_OMacActor_dummy
	ALIGN	4

?OMacSequenceChannel_objClassInstance@@3VCObjClass@@A DB 024H DUP (?) ; OMacSequenceChannel_objClassInstance
?SetBoundsMax_msg_OMacActor_dummy@@3_NA DB 01H DUP (?)	; SetBoundsMax_msg_OMacActor_dummy
	ALIGN	4

?SetGeometry_msg_OMacActor_dummy@@3_NA DB 01H DUP (?)	; SetGeometry_msg_OMacActor_dummy
	ALIGN	4

?staticObjClass@OMacChannel@@0PAVCObjClass@@A DD 01H DUP (?) ; OMacChannel::staticObjClass
?SetSurface_msg_OMacActor_dummy@@3_NA DB 01H DUP (?)	; SetSurface_msg_OMacActor_dummy
	ALIGN	4

?SetLodData_msg_OMacActor_dummy@@3_NA DB 01H DUP (?)	; SetLodData_msg_OMacActor_dummy
	ALIGN	4

?SetSkeleton_msg_OMacActor_dummy@@3_NA DB 01H DUP (?)	; SetSkeleton_msg_OMacActor_dummy
	ALIGN	4

?AddFrames_msg_OMacActor_dummy@@3_NA DB 01H DUP (?)	; AddFrames_msg_OMacActor_dummy
	ALIGN	4

?staticObjClass@OMacSequenceChannel@@0PAVCObjClass@@A DD 01H DUP (?) ; OMacSequenceChannel::staticObjClass
?AddSequences_msg_OMacActor_dummy@@3_NA DB 01H DUP (?)	; AddSequences_msg_OMacActor_dummy
	ALIGN	4

?defaultRelayInitialized@?BC@??EvalVerts@OMacSequenceChannel@@UAE_NPAVOMacActor@@KPAGPAVVVec3@@@Z@4_NA DB 01H DUP (?) ; defaultRelayInitialized
_BSS	ENDS
CRT$XCU	SEGMENT
_$S42	DD	FLAT:_$E41
_$S45	DD	FLAT:_$E44
_$S48	DD	FLAT:_$E47
_$S51	DD	FLAT:_$E50
_$S54	DD	FLAT:_$E53
_$S57	DD	FLAT:_$E56
_$S60	DD	FLAT:_$E59
_$S63	DD	FLAT:_$E62
_$S66	DD	FLAT:_$E65
_$S69	DD	FLAT:_$E68
_$S72	DD	FLAT:_$E71
_$S75	DD	FLAT:_$E74
_$S78	DD	FLAT:_$E77
_$S81	DD	FLAT:_$E80
_$S86	DD	FLAT:_$E85
_$S89	DD	FLAT:_$E88
_$S95	DD	FLAT:_$E94
CRT$XCU	ENDS
_DATA	SEGMENT
?rot1@?1??EvaluateTris@OMacActor@@QAEKMPAUSMacTri@@@Z@4PAHA DD 01H ; rot1
	DD	02H
	DD	00H
?rot2@?1??EvaluateTris@OMacActor@@QAEKMPAUSMacTri@@@Z@4PAHA DD 02H ; rot2
	DD	00H
	DD	01H
_DATA	ENDS
CRT$XCU	SEGMENT
_$S100	DD	FLAT:_$E99
_$S103	DD	FLAT:_$E102
_$S108	DD	FLAT:_$E107
_$S111	DD	FLAT:_$E110
_$S119	DD	FLAT:_$E118
_$S122	DD	FLAT:_$E121
_$S128	DD	FLAT:_$E127
; Function compile flags: /Ogty
CRT$XCU	ENDS
;	COMDAT _$E41
_TEXT	SEGMENT
_$E41	PROC NEAR					; COMDAT
	ret	0
_$E41	ENDP
_TEXT	ENDS
PUBLIC	_SetAuthor_msg_OMacActor
PUBLIC	??_C@_01KBOJ@s?$AA@				; `string'
PUBLIC	??_C@_09KJDM@SetAuthor?$AA@			; `string'
PUBLIC	??_C@_09OANE@OMacActor?$AA@			; `string'
EXTRN	?MSG_RegisterHandlerC@@YA_NPBD0PAX0@Z:NEAR	; MSG_RegisterHandlerC
;	COMDAT ??_C@_01KBOJ@s?$AA@
; File C:\duke4\Cannibal\MacMain.cpp
_DATA	SEGMENT
??_C@_01KBOJ@s?$AA@ DB 's', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_09KJDM@SetAuthor?$AA@
_DATA	SEGMENT
??_C@_09KJDM@SetAuthor?$AA@ DB 'SetAuthor', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_09OANE@OMacActor?$AA@
_DATA	SEGMENT
??_C@_09OANE@OMacActor?$AA@ DB 'OMacActor', 00H		; `string'
; Function compile flags: /Ogty
_DATA	ENDS
;	COMDAT _$E44
_TEXT	SEGMENT
_$E44	PROC NEAR					; COMDAT
	push	OFFSET FLAT:??_C@_01KBOJ@s?$AA@		; `string'
	push	OFFSET FLAT:_SetAuthor_msg_OMacActor
	push	OFFSET FLAT:??_C@_09KJDM@SetAuthor?$AA@	; `string'
	push	OFFSET FLAT:??_C@_09OANE@OMacActor?$AA@	; `string'
	call	?MSG_RegisterHandlerC@@YA_NPBD0PAX0@Z	; MSG_RegisterHandlerC
	add	esp, 16					; 00000010H
	mov	BYTE PTR ?SetAuthor_msg_OMacActor_dummy@@3_NA, al ; SetAuthor_msg_OMacActor_dummy
	ret	0
_$E44	ENDP
_TEXT	ENDS
EXTRN	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ:NEAR		; MEM_GetAlloc
EXTRN	?sMemTotal@CCorString@@0KA:DWORD		; CCorString::sMemTotal
; Function compile flags: /Ogty
;	COMDAT _SetAuthor_msg_OMacActor
_TEXT	SEGMENT
_This$ = 8
_inAuthor$ = 16
_SetAuthor_msg_OMacActor PROC NEAR			; COMDAT

; 42   : MSG_FUNC_C(OMacActor, SetAuthor, "s", (OMacActor* This, IMsg*, NChar* inAuthor)) { This->mAuthor = inAuthor; return(1); }

	push	ebx
	mov	ebx, DWORD PTR _This$[esp]
	push	ebp
	mov	ebp, DWORD PTR _inAuthor$[esp+4]
	push	esi
	push	edi
	test	ebp, ebp
	je	SHORT $L16992
	cmp	BYTE PTR [ebp], 0
	jne	SHORT $L16992
	xor	ebp, ebp
$L16992:
	mov	edi, DWORD PTR [ebx+72]
	test	edi, edi
	je	SHORT $L16993
	or	ecx, -1
	xor	eax, eax
	repne scasb
	mov	edi, DWORD PTR ?sMemTotal@CCorString@@0KA ; CCorString::sMemTotal
	or	eax, -1
	not	ecx
	dec	ecx
	sub	eax, ecx
	add	edi, eax
	mov	DWORD PTR ?sMemTotal@CCorString@@0KA, edi ; CCorString::sMemTotal
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [ebx+72]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L16993:
	test	ebp, ebp
	mov	DWORD PTR [ebx+72], 0
	je	SHORT $L17002
	mov	edi, ebp
	or	ecx, -1
	xor	eax, eax
	repne scasb
	not	ecx
	dec	ecx
	mov	esi, ecx
	inc	esi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	ecx, eax
	call	DWORD PTR [edx]
	test	eax, eax
	mov	DWORD PTR [ebx+72], eax
	je	SHORT $L17002
	mov	edx, ebp
$L16998:
	mov	cl, BYTE PTR [edx]
	inc	edx
	mov	BYTE PTR [eax], cl
	inc	eax
	test	cl, cl
	jne	SHORT $L16998
	add	DWORD PTR ?sMemTotal@CCorString@@0KA, esi ; CCorString::sMemTotal
$L17002:
	pop	edi
	pop	esi
	pop	ebp
	mov	al, 1
	pop	ebx
	ret	0
_SetAuthor_msg_OMacActor ENDP
_TEXT	ENDS
PUBLIC	_SetDescription_msg_OMacActor
PUBLIC	??_C@_0P@HBI@SetDescription?$AA@		; `string'
;	COMDAT ??_C@_0P@HBI@SetDescription?$AA@
_DATA	SEGMENT
??_C@_0P@HBI@SetDescription?$AA@ DB 'SetDescription', 00H ; `string'
; Function compile flags: /Ogty
_DATA	ENDS
;	COMDAT _$E47
_TEXT	SEGMENT
_$E47	PROC NEAR					; COMDAT
	push	OFFSET FLAT:??_C@_01KBOJ@s?$AA@		; `string'
	push	OFFSET FLAT:_SetDescription_msg_OMacActor
	push	OFFSET FLAT:??_C@_0P@HBI@SetDescription?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_09OANE@OMacActor?$AA@	; `string'
	call	?MSG_RegisterHandlerC@@YA_NPBD0PAX0@Z	; MSG_RegisterHandlerC
	add	esp, 16					; 00000010H
	mov	BYTE PTR ?SetDescription_msg_OMacActor_dummy@@3_NA, al ; SetDescription_msg_OMacActor_dummy
	ret	0
_$E47	ENDP
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT _SetDescription_msg_OMacActor
_TEXT	SEGMENT
_This$ = 8
_inDesc$ = 16
_SetDescription_msg_OMacActor PROC NEAR			; COMDAT

; 43   : MSG_FUNC_C(OMacActor, SetDescription, "s", (OMacActor* This, IMsg*, NChar* inDesc)) { This->mDescription = inDesc; return(1); }

	push	ebx
	mov	ebx, DWORD PTR _This$[esp]
	push	ebp
	mov	ebp, DWORD PTR _inDesc$[esp+4]
	push	esi
	push	edi
	test	ebp, ebp
	je	SHORT $L17027
	cmp	BYTE PTR [ebp], 0
	jne	SHORT $L17027
	xor	ebp, ebp
$L17027:
	mov	edi, DWORD PTR [ebx+76]
	test	edi, edi
	je	SHORT $L17028
	or	ecx, -1
	xor	eax, eax
	repne scasb
	mov	edi, DWORD PTR ?sMemTotal@CCorString@@0KA ; CCorString::sMemTotal
	or	eax, -1
	not	ecx
	dec	ecx
	sub	eax, ecx
	add	edi, eax
	mov	DWORD PTR ?sMemTotal@CCorString@@0KA, edi ; CCorString::sMemTotal
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [ebx+76]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L17028:
	test	ebp, ebp
	mov	DWORD PTR [ebx+76], 0
	je	SHORT $L17037
	mov	edi, ebp
	or	ecx, -1
	xor	eax, eax
	repne scasb
	not	ecx
	dec	ecx
	mov	esi, ecx
	inc	esi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	ecx, eax
	call	DWORD PTR [edx]
	test	eax, eax
	mov	DWORD PTR [ebx+76], eax
	je	SHORT $L17037
	mov	edx, ebp
$L17033:
	mov	cl, BYTE PTR [edx]
	inc	edx
	mov	BYTE PTR [eax], cl
	inc	eax
	test	cl, cl
	jne	SHORT $L17033
	add	DWORD PTR ?sMemTotal@CCorString@@0KA, esi ; CCorString::sMemTotal
$L17037:
	pop	edi
	pop	esi
	pop	ebp
	mov	al, 1
	pop	ebx
	ret	0
_SetDescription_msg_OMacActor ENDP
_TEXT	ENDS
PUBLIC	_SetOrigin_msg_OMacActor
PUBLIC	??_C@_03CLFC@fff?$AA@				; `string'
PUBLIC	??_C@_09NIBD@SetOrigin?$AA@			; `string'
;	COMDAT ??_C@_03CLFC@fff?$AA@
_DATA	SEGMENT
??_C@_03CLFC@fff?$AA@ DB 'fff', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_09NIBD@SetOrigin?$AA@
_DATA	SEGMENT
??_C@_09NIBD@SetOrigin?$AA@ DB 'SetOrigin', 00H		; `string'
; Function compile flags: /Ogty
_DATA	ENDS
;	COMDAT _$E50
_TEXT	SEGMENT
_$E50	PROC NEAR					; COMDAT
	push	OFFSET FLAT:??_C@_03CLFC@fff?$AA@	; `string'
	push	OFFSET FLAT:_SetOrigin_msg_OMacActor
	push	OFFSET FLAT:??_C@_09NIBD@SetOrigin?$AA@	; `string'
	push	OFFSET FLAT:??_C@_09OANE@OMacActor?$AA@	; `string'
	call	?MSG_RegisterHandlerC@@YA_NPBD0PAX0@Z	; MSG_RegisterHandlerC
	add	esp, 16					; 00000010H
	mov	BYTE PTR ?SetOrigin_msg_OMacActor_dummy@@3_NA, al ; SetOrigin_msg_OMacActor_dummy
	ret	0
_$E50	ENDP
_TEXT	ENDS
EXTRN	__fltused:NEAR
; Function compile flags: /Ogty
;	COMDAT _SetOrigin_msg_OMacActor
_TEXT	SEGMENT
_This$ = 8
_inX$ = 16
_inY$ = 20
_inZ$ = 24
_SetOrigin_msg_OMacActor PROC NEAR			; COMDAT

; 44   : MSG_FUNC_C(OMacActor, SetOrigin, "fff", (OMacActor* This, IMsg*, NFloat inX, NFloat inY, NFloat inZ)) { This->mOrigin = VVec3(inX,inY,inZ); return(1); }

	mov	eax, DWORD PTR _This$[esp-4]
	mov	ecx, DWORD PTR _inX$[esp-4]
	mov	edx, DWORD PTR _inY$[esp-4]
	mov	DWORD PTR [eax+80], ecx
	mov	ecx, DWORD PTR _inZ$[esp-4]
	mov	DWORD PTR [eax+84], edx
	mov	DWORD PTR [eax+88], ecx
	mov	al, 1
	ret	0
_SetOrigin_msg_OMacActor ENDP
_TEXT	ENDS
PUBLIC	_SetScale_msg_OMacActor
PUBLIC	??_C@_08OKHL@SetScale?$AA@			; `string'
;	COMDAT ??_C@_08OKHL@SetScale?$AA@
_DATA	SEGMENT
??_C@_08OKHL@SetScale?$AA@ DB 'SetScale', 00H		; `string'
; Function compile flags: /Ogty
_DATA	ENDS
;	COMDAT _$E53
_TEXT	SEGMENT
_$E53	PROC NEAR					; COMDAT
	push	OFFSET FLAT:??_C@_03CLFC@fff?$AA@	; `string'
	push	OFFSET FLAT:_SetScale_msg_OMacActor
	push	OFFSET FLAT:??_C@_08OKHL@SetScale?$AA@	; `string'
	push	OFFSET FLAT:??_C@_09OANE@OMacActor?$AA@	; `string'
	call	?MSG_RegisterHandlerC@@YA_NPBD0PAX0@Z	; MSG_RegisterHandlerC
	add	esp, 16					; 00000010H
	mov	BYTE PTR ?SetScale_msg_OMacActor_dummy@@3_NA, al ; SetScale_msg_OMacActor_dummy
	ret	0
_$E53	ENDP
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT _SetScale_msg_OMacActor
_TEXT	SEGMENT
_This$ = 8
_inX$ = 16
_inY$ = 20
_inZ$ = 24
_SetScale_msg_OMacActor PROC NEAR			; COMDAT

; 45   : MSG_FUNC_C(OMacActor, SetScale, "fff", (OMacActor* This, IMsg*, NFloat inX, NFloat inY, NFloat inZ)) { This->mScale = VVec3(inX,inY,inZ); return(1); }

	mov	eax, DWORD PTR _This$[esp-4]
	mov	ecx, DWORD PTR _inX$[esp-4]
	mov	edx, DWORD PTR _inY$[esp-4]
	mov	DWORD PTR [eax+92], ecx
	mov	ecx, DWORD PTR _inZ$[esp-4]
	mov	DWORD PTR [eax+96], edx
	mov	DWORD PTR [eax+100], ecx
	mov	al, 1
	ret	0
_SetScale_msg_OMacActor ENDP
_TEXT	ENDS
PUBLIC	_SetRotation_msg_OMacActor
PUBLIC	??_C@_0M@BIJC@SetRotation?$AA@			; `string'
;	COMDAT ??_C@_0M@BIJC@SetRotation?$AA@
_DATA	SEGMENT
??_C@_0M@BIJC@SetRotation?$AA@ DB 'SetRotation', 00H	; `string'
; Function compile flags: /Ogty
_DATA	ENDS
;	COMDAT _$E56
_TEXT	SEGMENT
_$E56	PROC NEAR					; COMDAT
	push	OFFSET FLAT:??_C@_03CLFC@fff?$AA@	; `string'
	push	OFFSET FLAT:_SetRotation_msg_OMacActor
	push	OFFSET FLAT:??_C@_0M@BIJC@SetRotation?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_09OANE@OMacActor?$AA@	; `string'
	call	?MSG_RegisterHandlerC@@YA_NPBD0PAX0@Z	; MSG_RegisterHandlerC
	add	esp, 16					; 00000010H
	mov	BYTE PTR ?SetRotation_msg_OMacActor_dummy@@3_NA, al ; SetRotation_msg_OMacActor_dummy
	ret	0
_$E56	ENDP
_TEXT	ENDS
PUBLIC	__real@40490fdb
PUBLIC	__real@3bb60b61
;	COMDAT __real@40490fdb
; File C:\duke4\Cannibal\VecMain.h
CONST	SEGMENT
__real@40490fdb DD 040490fdbr			; 3.14159
CONST	ENDS
;	COMDAT __real@3bb60b61
CONST	SEGMENT
__real@3bb60b61 DD 03bb60b61r			; 0.00555556
; Function compile flags: /Ogty
; File C:\duke4\Cannibal\MacMain.cpp
CONST	ENDS
;	COMDAT _SetRotation_msg_OMacActor
_TEXT	SEGMENT
_This$ = 8
_inRoll$ = 16
_inPitch$ = 20
_inYaw$ = 24
$T17082 = -12
_SetRotation_msg_OMacActor PROC NEAR			; COMDAT

; 47   : {

	sub	esp, 12					; 0000000cH

; 48   : 	This->mRotation = VEulers3(M_DEGTORAD(inRoll),M_DEGTORAD(inPitch),M_DEGTORAD(inYaw));

	fld	DWORD PTR _inRoll$[esp+8]
	fmul	DWORD PTR __real@40490fdb
	mov	eax, DWORD PTR _This$[esp+8]
	fmul	DWORD PTR __real@3bb60b61
	fld	DWORD PTR _inPitch$[esp+8]
	fmul	DWORD PTR __real@40490fdb
	fmul	DWORD PTR __real@3bb60b61
	fld	DWORD PTR _inYaw$[esp+8]
	fmul	DWORD PTR __real@40490fdb
	fmul	DWORD PTR __real@3bb60b61
	fstp	DWORD PTR $T17082[esp+20]
	mov	ecx, DWORD PTR $T17082[esp+20]
	fxch	ST(1)
	fstp	DWORD PTR [eax+104]
	mov	DWORD PTR [eax+112], ecx
	fstp	DWORD PTR [eax+108]

; 49   : 	return(1);

	mov	al, 1

; 50   : }

	add	esp, 12					; 0000000cH
	ret	0
_SetRotation_msg_OMacActor ENDP
_TEXT	ENDS
PUBLIC	_SetBoundsMin_msg_OMacActor
PUBLIC	??_C@_0N@KGJ@SetBoundsMin?$AA@			; `string'
;	COMDAT ??_C@_0N@KGJ@SetBoundsMin?$AA@
_DATA	SEGMENT
??_C@_0N@KGJ@SetBoundsMin?$AA@ DB 'SetBoundsMin', 00H	; `string'
; Function compile flags: /Ogty
_DATA	ENDS
;	COMDAT _$E59
_TEXT	SEGMENT
_$E59	PROC NEAR					; COMDAT
	push	OFFSET FLAT:??_C@_03CLFC@fff?$AA@	; `string'
	push	OFFSET FLAT:_SetBoundsMin_msg_OMacActor
	push	OFFSET FLAT:??_C@_0N@KGJ@SetBoundsMin?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_09OANE@OMacActor?$AA@	; `string'
	call	?MSG_RegisterHandlerC@@YA_NPBD0PAX0@Z	; MSG_RegisterHandlerC
	add	esp, 16					; 00000010H
	mov	BYTE PTR ?SetBoundsMin_msg_OMacActor_dummy@@3_NA, al ; SetBoundsMin_msg_OMacActor_dummy
	ret	0
_$E59	ENDP
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT _SetBoundsMin_msg_OMacActor
_TEXT	SEGMENT
_This$ = 8
_inX$ = 16
_inY$ = 20
_inZ$ = 24
_SetBoundsMin_msg_OMacActor PROC NEAR			; COMDAT

; 51   : MSG_FUNC_C(OMacActor, SetBoundsMin, "fff", (OMacActor* This, IMsg*, NFloat inX, NFloat inY, NFloat inZ)) { This->mBounds[0] = VVec3(inX,inY,inZ); return(1); }

	mov	eax, DWORD PTR _This$[esp-4]
	mov	ecx, DWORD PTR _inX$[esp-4]
	mov	edx, DWORD PTR _inY$[esp-4]
	mov	DWORD PTR [eax+116], ecx
	mov	ecx, DWORD PTR _inZ$[esp-4]
	mov	DWORD PTR [eax+120], edx
	mov	DWORD PTR [eax+124], ecx
	mov	al, 1
	ret	0
_SetBoundsMin_msg_OMacActor ENDP
_TEXT	ENDS
PUBLIC	_SetBoundsMax_msg_OMacActor
PUBLIC	??_C@_0N@OJDP@SetBoundsMax?$AA@			; `string'
;	COMDAT ??_C@_0N@OJDP@SetBoundsMax?$AA@
_DATA	SEGMENT
??_C@_0N@OJDP@SetBoundsMax?$AA@ DB 'SetBoundsMax', 00H	; `string'
; Function compile flags: /Ogty
_DATA	ENDS
;	COMDAT _$E62
_TEXT	SEGMENT
_$E62	PROC NEAR					; COMDAT
	push	OFFSET FLAT:??_C@_03CLFC@fff?$AA@	; `string'
	push	OFFSET FLAT:_SetBoundsMax_msg_OMacActor
	push	OFFSET FLAT:??_C@_0N@OJDP@SetBoundsMax?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_09OANE@OMacActor?$AA@	; `string'
	call	?MSG_RegisterHandlerC@@YA_NPBD0PAX0@Z	; MSG_RegisterHandlerC
	add	esp, 16					; 00000010H
	mov	BYTE PTR ?SetBoundsMax_msg_OMacActor_dummy@@3_NA, al ; SetBoundsMax_msg_OMacActor_dummy
	ret	0
_$E62	ENDP
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT _SetBoundsMax_msg_OMacActor
_TEXT	SEGMENT
_This$ = 8
_inX$ = 16
_inY$ = 20
_inZ$ = 24
_SetBoundsMax_msg_OMacActor PROC NEAR			; COMDAT

; 52   : MSG_FUNC_C(OMacActor, SetBoundsMax, "fff", (OMacActor* This, IMsg*, NFloat inX, NFloat inY, NFloat inZ)) { This->mBounds[1] = VVec3(inX,inY,inZ); return(1); }

	mov	eax, DWORD PTR _This$[esp-4]
	mov	ecx, DWORD PTR _inX$[esp-4]
	mov	edx, DWORD PTR _inY$[esp-4]
	mov	DWORD PTR [eax+128], ecx
	mov	ecx, DWORD PTR _inZ$[esp-4]
	mov	DWORD PTR [eax+132], edx
	mov	DWORD PTR [eax+136], ecx
	mov	al, 1
	ret	0
_SetBoundsMax_msg_OMacActor ENDP
_TEXT	ENDS
PUBLIC	_SetGeometry_msg_OMacActor
PUBLIC	??_C@_0M@KHLN@SetGeometry?$AA@			; `string'
;	COMDAT ??_C@_0M@KHLN@SetGeometry?$AA@
_DATA	SEGMENT
??_C@_0M@KHLN@SetGeometry?$AA@ DB 'SetGeometry', 00H	; `string'
; Function compile flags: /Ogty
_DATA	ENDS
;	COMDAT _$E65
_TEXT	SEGMENT
_$E65	PROC NEAR					; COMDAT
	push	OFFSET FLAT:??_C@_01KBOJ@s?$AA@		; `string'
	push	OFFSET FLAT:_SetGeometry_msg_OMacActor
	push	OFFSET FLAT:??_C@_0M@KHLN@SetGeometry?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_09OANE@OMacActor?$AA@	; `string'
	call	?MSG_RegisterHandlerC@@YA_NPBD0PAX0@Z	; MSG_RegisterHandlerC
	add	esp, 16					; 00000010H
	mov	BYTE PTR ?SetGeometry_msg_OMacActor_dummy@@3_NA, al ; SetGeometry_msg_OMacActor_dummy
	ret	0
_$E65	ENDP
_TEXT	ENDS
EXTRN	?CacheIn@OCpjChunk@@QAE_NXZ:NEAR		; OCpjChunk::CacheIn
EXTRN	?CPJ_FindChunk@@YAPAVOCpjChunk@@PAVOCpjProject@@PAVCObjClass@@PBD@Z:NEAR ; CPJ_FindChunk
EXTRN	?staticObjClass@OCpjGeometry@@0PAVCObjClass@@A:DWORD ; OCpjGeometry::staticObjClass
; Function compile flags: /Ogty
;	COMDAT _SetGeometry_msg_OMacActor
_TEXT	SEGMENT
_This$ = 8
_inChunkPath$ = 16
_SetGeometry_msg_OMacActor PROC NEAR			; COMDAT

; 56   : 	This->SetGeometry((OCpjGeometry*)CPJ_FindChunk(This->mLoadProject, OCpjGeometry::GetStaticClass(), inChunkPath));

	mov	eax, DWORD PTR _inChunkPath$[esp-4]
	mov	ecx, DWORD PTR ?staticObjClass@OCpjGeometry@@0PAVCObjClass@@A ; OCpjGeometry::staticObjClass
	push	esi
	mov	esi, DWORD PTR _This$[esp]
	push	eax
	push	ecx
	mov	edx, DWORD PTR [esi+68]
	push	edx
	call	?CPJ_FindChunk@@YAPAVOCpjChunk@@PAVOCpjProject@@PAVCObjClass@@PBD@Z ; CPJ_FindChunk
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esi+140], eax
	test	eax, eax
	pop	esi
	je	SHORT $L17145
	mov	ecx, eax
	call	?CacheIn@OCpjChunk@@QAE_NXZ		; OCpjChunk::CacheIn
$L17145:

; 57   : 	return(1);

	mov	al, 1

; 58   : }

	ret	0
_SetGeometry_msg_OMacActor ENDP
_TEXT	ENDS
PUBLIC	_SetSurface_msg_OMacActor
PUBLIC	??_C@_02HNOA@is?$AA@				; `string'
PUBLIC	??_C@_0L@BCFB@SetSurface?$AA@			; `string'
;	COMDAT ??_C@_02HNOA@is?$AA@
_DATA	SEGMENT
??_C@_02HNOA@is?$AA@ DB 'is', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@BCFB@SetSurface?$AA@
_DATA	SEGMENT
??_C@_0L@BCFB@SetSurface?$AA@ DB 'SetSurface', 00H	; `string'
; Function compile flags: /Ogty
_DATA	ENDS
;	COMDAT _$E68
_TEXT	SEGMENT
_$E68	PROC NEAR					; COMDAT
	push	OFFSET FLAT:??_C@_02HNOA@is?$AA@	; `string'
	push	OFFSET FLAT:_SetSurface_msg_OMacActor
	push	OFFSET FLAT:??_C@_0L@BCFB@SetSurface?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_09OANE@OMacActor?$AA@	; `string'
	call	?MSG_RegisterHandlerC@@YA_NPBD0PAX0@Z	; MSG_RegisterHandlerC
	add	esp, 16					; 00000010H
	mov	BYTE PTR ?SetSurface_msg_OMacActor_dummy@@3_NA, al ; SetSurface_msg_OMacActor_dummy
	ret	0
_$E68	ENDP
_TEXT	ENDS
PUBLIC	?Realloc@CCorArray@@IAEXK@Z			; CCorArray::Realloc
EXTRN	?staticObjClass@OCpjSurface@@0PAVCObjClass@@A:DWORD ; OCpjSurface::staticObjClass
; Function compile flags: /Ogty
;	COMDAT _SetSurface_msg_OMacActor
_TEXT	SEGMENT
_This$ = 8
_inIndex$ = 16
_inChunkPath$ = 20
$T17209 = 20
_SetSurface_msg_OMacActor PROC NEAR			; COMDAT

; 61   : 	This->SetSurface(inIndex, (OCpjSurface*)CPJ_FindChunk(This->mLoadProject, OCpjSurface::GetStaticClass(), inChunkPath));

	mov	eax, DWORD PTR _inChunkPath$[esp-4]
	mov	ecx, DWORD PTR ?staticObjClass@OCpjSurface@@0PAVCObjClass@@A ; OCpjSurface::staticObjClass
	push	ebp
	mov	ebp, DWORD PTR _This$[esp]
	push	eax
	push	ecx
	mov	edx, DWORD PTR [ebp+68]
	push	edx
	call	?CPJ_FindChunk@@YAPAVOCpjChunk@@PAVOCpjProject@@PAVCObjClass@@PBD@Z ; CPJ_FindChunk
	mov	edx, DWORD PTR _inIndex$[esp+12]
	mov	ecx, eax
	mov	eax, DWORD PTR [ebp+156]
	add	esp, 12					; 0000000cH
	cmp	eax, edx
	mov	DWORD PTR $T17209[esp], ecx
	ja	SHORT $L17198
	push	ebx
	mov	ebx, DWORD PTR [ebp+156]
	push	esi
	mov	ecx, DWORD PTR [ebp+160]
	push	edi
	mov	esi, edx
	lea	edi, DWORD PTR [ebp+152]
	sub	esi, eax
	inc	esi
	lea	eax, DWORD PTR [ebx+esi]
	cmp	eax, ecx
	mov	DWORD PTR [edi+4], eax
	jbe	SHORT $L17203
	mov	ecx, eax
	push	4
	shr	ecx, 2
	lea	edx, DWORD PTR [ecx+eax+32]
	mov	ecx, edi
	mov	DWORD PTR [edi+8], edx
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
	mov	edx, DWORD PTR _inIndex$[esp+12]
$L17203:
	mov	ecx, esi
	mov	esi, DWORD PTR [edi]
	xor	eax, eax
	lea	edi, DWORD PTR [esi+ebx*4]
	rep stosd
	mov	ecx, DWORD PTR $T17209[esp+12]
	pop	edi
	pop	esi
	pop	ebx
$L17198:
	mov	eax, DWORD PTR [ebp+152]
	pop	ebp
	test	ecx, ecx
	mov	DWORD PTR [eax+edx*4], ecx
	je	SHORT $L17210
	call	?CacheIn@OCpjChunk@@QAE_NXZ		; OCpjChunk::CacheIn
$L17210:

; 62   : 	return(1);

	mov	al, 1

; 63   : }

	ret	0
_SetSurface_msg_OMacActor ENDP
_TEXT	ENDS
PUBLIC	_SetLodData_msg_OMacActor
PUBLIC	??_C@_0L@BJMB@SetLodData?$AA@			; `string'
;	COMDAT ??_C@_0L@BJMB@SetLodData?$AA@
_DATA	SEGMENT
??_C@_0L@BJMB@SetLodData?$AA@ DB 'SetLodData', 00H	; `string'
; Function compile flags: /Ogty
_DATA	ENDS
;	COMDAT _$E71
_TEXT	SEGMENT
_$E71	PROC NEAR					; COMDAT
	push	OFFSET FLAT:??_C@_01KBOJ@s?$AA@		; `string'
	push	OFFSET FLAT:_SetLodData_msg_OMacActor
	push	OFFSET FLAT:??_C@_0L@BJMB@SetLodData?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_09OANE@OMacActor?$AA@	; `string'
	call	?MSG_RegisterHandlerC@@YA_NPBD0PAX0@Z	; MSG_RegisterHandlerC
	add	esp, 16					; 00000010H
	mov	BYTE PTR ?SetLodData_msg_OMacActor_dummy@@3_NA, al ; SetLodData_msg_OMacActor_dummy
	ret	0
_$E71	ENDP
_TEXT	ENDS
EXTRN	?staticObjClass@OCpjLodData@@0PAVCObjClass@@A:DWORD ; OCpjLodData::staticObjClass
; Function compile flags: /Ogty
;	COMDAT _SetLodData_msg_OMacActor
_TEXT	SEGMENT
_This$ = 8
_inChunkPath$ = 16
_SetLodData_msg_OMacActor PROC NEAR			; COMDAT

; 66   : 	This->SetLodData((OCpjLodData*)CPJ_FindChunk(This->mLoadProject, OCpjLodData::GetStaticClass(), inChunkPath));

	mov	eax, DWORD PTR _inChunkPath$[esp-4]
	mov	ecx, DWORD PTR ?staticObjClass@OCpjLodData@@0PAVCObjClass@@A ; OCpjLodData::staticObjClass
	push	esi
	mov	esi, DWORD PTR _This$[esp]
	push	eax
	push	ecx
	mov	edx, DWORD PTR [esi+68]
	push	edx
	call	?CPJ_FindChunk@@YAPAVOCpjChunk@@PAVOCpjProject@@PAVCObjClass@@PBD@Z ; CPJ_FindChunk
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esi+148], eax
	test	eax, eax
	pop	esi
	je	SHORT $L17228
	mov	ecx, eax
	call	?CacheIn@OCpjChunk@@QAE_NXZ		; OCpjChunk::CacheIn
$L17228:

; 67   : 	return(1);

	mov	al, 1

; 68   : }

	ret	0
_SetLodData_msg_OMacActor ENDP
_TEXT	ENDS
PUBLIC	_SetSkeleton_msg_OMacActor
PUBLIC	??_C@_0M@NPDC@SetSkeleton?$AA@			; `string'
;	COMDAT ??_C@_0M@NPDC@SetSkeleton?$AA@
_DATA	SEGMENT
??_C@_0M@NPDC@SetSkeleton?$AA@ DB 'SetSkeleton', 00H	; `string'
; Function compile flags: /Ogty
_DATA	ENDS
;	COMDAT _$E74
_TEXT	SEGMENT
_$E74	PROC NEAR					; COMDAT
	push	OFFSET FLAT:??_C@_01KBOJ@s?$AA@		; `string'
	push	OFFSET FLAT:_SetSkeleton_msg_OMacActor
	push	OFFSET FLAT:??_C@_0M@NPDC@SetSkeleton?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_09OANE@OMacActor?$AA@	; `string'
	call	?MSG_RegisterHandlerC@@YA_NPBD0PAX0@Z	; MSG_RegisterHandlerC
	add	esp, 16					; 00000010H
	mov	BYTE PTR ?SetSkeleton_msg_OMacActor_dummy@@3_NA, al ; SetSkeleton_msg_OMacActor_dummy
	ret	0
_$E74	ENDP
_TEXT	ENDS
PUBLIC	?SetSkeleton@OMacActor@@QAE_NPAVOCpjSkeleton@@@Z ; OMacActor::SetSkeleton
EXTRN	?staticObjClass@OCpjSkeleton@@0PAVCObjClass@@A:DWORD ; OCpjSkeleton::staticObjClass
; Function compile flags: /Ogty
;	COMDAT _SetSkeleton_msg_OMacActor
_TEXT	SEGMENT
_This$ = 8
_inChunkPath$ = 16
_SetSkeleton_msg_OMacActor PROC NEAR			; COMDAT

; 71   : 	This->SetSkeleton((OCpjSkeleton*)CPJ_FindChunk(This->mLoadProject, OCpjSkeleton::GetStaticClass(), inChunkPath));

	mov	eax, DWORD PTR _inChunkPath$[esp-4]
	mov	ecx, DWORD PTR ?staticObjClass@OCpjSkeleton@@0PAVCObjClass@@A ; OCpjSkeleton::staticObjClass
	push	esi
	mov	esi, DWORD PTR _This$[esp]
	push	eax
	push	ecx
	mov	edx, DWORD PTR [esi+68]
	push	edx
	call	?CPJ_FindChunk@@YAPAVOCpjChunk@@PAVOCpjProject@@PAVCObjClass@@PBD@Z ; CPJ_FindChunk
	add	esp, 12					; 0000000cH
	mov	ecx, esi
	push	eax
	call	?SetSkeleton@OMacActor@@QAE_NPAVOCpjSkeleton@@@Z ; OMacActor::SetSkeleton

; 72   : 	return(1);

	mov	al, 1
	pop	esi

; 73   : }

	ret	0
_SetSkeleton_msg_OMacActor ENDP
_TEXT	ENDS
PUBLIC	_AddFrames_msg_OMacActor
PUBLIC	??_C@_09ONCB@AddFrames?$AA@			; `string'
;	COMDAT ??_C@_09ONCB@AddFrames?$AA@
_DATA	SEGMENT
??_C@_09ONCB@AddFrames?$AA@ DB 'AddFrames', 00H		; `string'
; Function compile flags: /Ogty
_DATA	ENDS
;	COMDAT _$E77
_TEXT	SEGMENT
_$E77	PROC NEAR					; COMDAT
	push	OFFSET FLAT:??_C@_01KBOJ@s?$AA@		; `string'
	push	OFFSET FLAT:_AddFrames_msg_OMacActor
	push	OFFSET FLAT:??_C@_09ONCB@AddFrames?$AA@	; `string'
	push	OFFSET FLAT:??_C@_09OANE@OMacActor?$AA@	; `string'
	call	?MSG_RegisterHandlerC@@YA_NPBD0PAX0@Z	; MSG_RegisterHandlerC
	add	esp, 16					; 00000010H
	mov	BYTE PTR ?AddFrames_msg_OMacActor_dummy@@3_NA, al ; AddFrames_msg_OMacActor_dummy
	ret	0
_$E77	ENDP
_TEXT	ENDS
PUBLIC	?AdvanceToType@?$TObjIter@VOCpjFrames@@@@IAEXXZ	; TObjIter<OCpjFrames>::AdvanceToType
PUBLIC	?Reset@?$TObjIter@VOCpjFrames@@@@QAEXPAVOObject@@_N@Z ; TObjIter<OCpjFrames>::Reset
PUBLIC	??0?$TObjIter@VOCpjFrames@@@@QAE@PAVOObject@@_N@Z ; TObjIter<OCpjFrames>::TObjIter<OCpjFrames>
PUBLIC	?Set@CCorString@@QAEXPAD@Z			; CCorString::Set
PUBLIC	?AddItem@?$TCorArray@PAVOCpjFrames@@@@QAEKABQAVOCpjFrames@@@Z ; TCorArray<OCpjFrames *>::AddItem
PUBLIC	?Add@?$TCorArray@PAVOCpjFrames@@@@QAEKK@Z	; TCorArray<OCpjFrames *>::Add
PUBLIC	??H@YA?AVCCorString@@ABV0@PBD@Z			; operator+
PUBLIC	??_C@_00A@?$AA@					; `string'
PUBLIC	?Add@?$TCorArray@VCCorString@@@@QAEKK@Z		; TCorArray<CCorString>::Add
PUBLIC	?GetObject@CObjIter@@IAEPAVOObject@@XZ		; CObjIter::GetObject
PUBLIC	?GetNext@CObjIter@@IAEXXZ			; CObjIter::GetNext
PUBLIC	??0CObjIter@@QAE@PAVOObject@@_N@Z		; CObjIter::CObjIter
PUBLIC	??_C@_04BAK@NULL?$AA@				; `string'
EXTRN	__imp__strchr:NEAR
EXTRN	?STR_FileFind@@YAPADPADPAHPAK@Z:NEAR		; STR_FileFind
EXTRN	__imp__stricmp:NEAR
EXTRN	?CPJ_SetBasePath@@YAXPBD@Z:NEAR			; CPJ_SetBasePath
EXTRN	?CPJ_GetBasePath@@YAPBDXZ:NEAR			; CPJ_GetBasePath
EXTRN	?CPJ_FindProject@@YAPAVOCpjProject@@PBD@Z:NEAR	; CPJ_FindProject
;	COMDAT ??_C@_00A@?$AA@
; File C:\duke4\Cannibal\CorMain.h
_BSS	SEGMENT
??_C@_00A@?$AA@ DB 01H DUP (?)				; `string'
_BSS	ENDS
;	COMDAT ??_C@_04BAK@NULL?$AA@
_DATA	SEGMENT
??_C@_04BAK@NULL?$AA@ DB 'NULL', 00H			; `string'
; Function compile flags: /Ogty
; File C:\duke4\Cannibal\MacMain.cpp
_DATA	ENDS
;	COMDAT _AddFrames_msg_OMacActor
_TEXT	SEGMENT
$T17275 = 8
$T17347 = 8
_it$17358 = -12
_it$17471 = -12
_This$ = 8
_inProjectPath$ = 16
_oldBasePath$12126 = 8
_spec$12127 = 16
$T17250 = 8
$T17251 = -16
_it$17270 = -12
_AddFrames_msg_OMacActor PROC NEAR			; COMDAT

; 75   : {

	sub	esp, 16					; 00000010H
	push	ebx

; 76   : 	if (!stricmp(inProjectPath, "NULL"))

	mov	ebx, DWORD PTR _inProjectPath$[esp+16]
	push	ebp
	mov	ebp, DWORD PTR __imp__stricmp
	push	esi
	push	edi
	push	OFFSET FLAT:??_C@_04BAK@NULL?$AA@	; `string'
	push	ebx
	call	ebp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L12109

; 77   : 	{
; 78   : 		This->AddFrames(This->mLoadProject);

	mov	esi, DWORD PTR _This$[esp+28]
	mov	eax, DWORD PTR [esi+68]
	test	eax, eax
	je	$L17526
	push	0
	push	eax
	lea	ecx, DWORD PTR _it$17270[esp+40]
	call	??0?$TObjIter@VOCpjFrames@@@@QAE@PAVOObject@@_N@Z ; TObjIter<OCpjFrames>::TObjIter<OCpjFrames>
	lea	ecx, DWORD PTR _it$17270[esp+32]
	call	?GetObject@CObjIter@@IAEPAVOObject@@XZ	; CObjIter::GetObject
	test	eax, eax
	je	$L17526
	add	esi, 168				; 000000a8H
$L17276:
	lea	ecx, DWORD PTR _it$17270[esp+32]
	call	?GetObject@CObjIter@@IAEPAVOObject@@XZ	; CObjIter::GetObject
	mov	DWORD PTR $T17275[esp+28], eax
	lea	eax, DWORD PTR $T17275[esp+28]
	push	eax
	mov	ecx, esi
	call	?AddItem@?$TCorArray@PAVOCpjFrames@@@@QAEKABQAVOCpjFrames@@@Z ; TCorArray<OCpjFrames *>::AddItem
	mov	ecx, DWORD PTR _it$17270[esp+36]
	mov	DWORD PTR _it$17270[esp+32], ecx
	lea	ecx, DWORD PTR _it$17270[esp+32]
	call	?GetNext@CObjIter@@IAEXXZ		; CObjIter::GetNext
	lea	ecx, DWORD PTR _it$17270[esp+32]
	call	?AdvanceToType@?$TObjIter@VOCpjFrames@@@@IAEXXZ ; TObjIter<OCpjFrames>::AdvanceToType
	lea	ecx, DWORD PTR _it$17270[esp+32]
	call	?GetObject@CObjIter@@IAEPAVOObject@@XZ	; CObjIter::GetObject
	test	eax, eax
	jne	SHORT $L17276
	pop	edi
	pop	esi
	pop	ebp

; 115  : 	return(1);

	mov	al, 1
	pop	ebx

; 116  : }

	add	esp, 16					; 00000010H
	ret	0
$L12109:

; 79   : 		return(1);
; 80   : 	}
; 81   : 	if (!strchr(inProjectPath, '*'))

	push	42					; 0000002aH
	push	ebx
	call	DWORD PTR __imp__strchr
	add	esp, 8

; 82   : 	{
; 83   : 		for (NDword i=0;i<This->mFramesFiles.GetCount();i++)

	xor	esi, esi
	test	eax, eax
	jne	$L12111
	mov	edi, DWORD PTR _This$[esp+28]
	mov	eax, DWORD PTR [edi+204]
	test	eax, eax
	jbe	SHORT $L17539
$L12113:
	mov	edx, DWORD PTR [edi+200]
	lea	eax, DWORD PTR [edx+esi*4]

; 84   : 		{
; 85   : 			if (!stricmp(*This->mFramesFiles[i], inProjectPath))

	mov	eax, DWORD PTR [edx+esi*4]
	test	eax, eax
	jne	SHORT $L17300
	mov	eax, OFFSET FLAT:??_C@_00A@?$AA@	; `string'
$L17300:
	push	ebx
	push	eax
	call	ebp
	add	esp, 8
	test	eax, eax
	je	SHORT $L17539
	mov	eax, DWORD PTR [edi+204]
	inc	esi
	cmp	esi, eax
	jb	SHORT $L12113
$L17539:

; 86   : 				break;
; 87   : 		}
; 88   : 		if (i==This->mFramesFiles.GetCount())

	cmp	esi, DWORD PTR [edi+204]
	jne	$L17526

; 89   : 		{
; 90   : 			This->mFramesFiles.AddItem(inProjectPath);

	push	ebx
	lea	ecx, DWORD PTR $T17250[esp+32]
	mov	DWORD PTR $T17250[esp+32], 0
	call	?Set@CCorString@@QAEXPAD@Z		; CCorString::Set
	lea	esi, DWORD PTR [edi+200]
	push	1
	mov	ecx, esi
	call	?Add@?$TCorArray@VCCorString@@@@QAEKK@Z	; TCorArray<CCorString>::Add
	mov	ecx, DWORD PTR $T17250[esp+28]
	mov	edx, DWORD PTR [esi]
	push	ecx
	lea	ecx, DWORD PTR [edx+eax*4]
	call	?Set@CCorString@@QAEXPAD@Z		; CCorString::Set
	push	0
	lea	ecx, DWORD PTR $T17250[esp+32]
	call	?Set@CCorString@@QAEXPAD@Z		; CCorString::Set

; 91   : 			This->AddFrames(CPJ_FindProject(inProjectPath));

	push	ebx
	call	?CPJ_FindProject@@YAPAVOCpjProject@@PBD@Z ; CPJ_FindProject
	add	esp, 4
	test	eax, eax
	je	$L17526
	push	0
	push	eax
	lea	ecx, DWORD PTR _it$17358[esp+40]
	call	??0?$TObjIter@VOCpjFrames@@@@QAE@PAVOObject@@_N@Z ; TObjIter<OCpjFrames>::TObjIter<OCpjFrames>
	lea	ecx, DWORD PTR _it$17358[esp+32]
	call	?GetObject@CObjIter@@IAEPAVOObject@@XZ	; CObjIter::GetObject
	test	eax, eax
	je	$L17526
	lea	esi, DWORD PTR [edi+168]
$L17351:
	lea	ecx, DWORD PTR _it$17358[esp+32]
	call	?GetObject@CObjIter@@IAEPAVOObject@@XZ	; CObjIter::GetObject
	mov	DWORD PTR $T17347[esp+28], eax
	lea	eax, DWORD PTR $T17347[esp+28]
	push	eax
	mov	ecx, esi
	call	?AddItem@?$TCorArray@PAVOCpjFrames@@@@QAEKABQAVOCpjFrames@@@Z ; TCorArray<OCpjFrames *>::AddItem
	mov	ecx, DWORD PTR _it$17358[esp+36]
	mov	DWORD PTR _it$17358[esp+32], ecx
	lea	ecx, DWORD PTR _it$17358[esp+32]
	call	?GetNext@CObjIter@@IAEXXZ		; CObjIter::GetNext
	lea	ecx, DWORD PTR _it$17358[esp+32]
	call	?AdvanceToType@?$TObjIter@VOCpjFrames@@@@IAEXXZ ; TObjIter<OCpjFrames>::AdvanceToType
	lea	ecx, DWORD PTR _it$17358[esp+32]
	call	?GetObject@CObjIter@@IAEPAVOObject@@XZ	; CObjIter::GetObject
	test	eax, eax
	jne	SHORT $L17351
	pop	edi
	pop	esi
	pop	ebp

; 115  : 	return(1);

	mov	al, 1
	pop	ebx

; 116  : }

	add	esp, 16					; 00000010H
	ret	0
$L12111:

; 92   : 		}
; 93   : 		return(1);
; 94   : 	}
; 95   : 
; 96   : 	for (NDword i=0;i<This->mFramesStarFiles.GetCount();i++)

	mov	ebp, DWORD PTR _This$[esp+28]
	mov	eax, DWORD PTR [ebp+220]
	test	eax, eax
	jbe	SHORT $L17540
$L12120:
	mov	edx, DWORD PTR [ebp+216]
	lea	eax, DWORD PTR [edx+esi*4]

; 97   : 	{
; 98   : 		if (!stricmp(*This->mFramesStarFiles[i], inProjectPath))

	mov	eax, DWORD PTR [edx+esi*4]
	test	eax, eax
	jne	SHORT $L17378
	mov	eax, OFFSET FLAT:??_C@_00A@?$AA@	; `string'
$L17378:
	push	ebx
	push	eax
	call	DWORD PTR __imp__stricmp
	add	esp, 8
	test	eax, eax
	je	SHORT $L17540
	mov	eax, DWORD PTR [ebp+220]
	inc	esi
	cmp	esi, eax
	jb	SHORT $L12120
$L17540:

; 99   : 			break;
; 100  : 	}
; 101  : 	if (i==This->mFramesStarFiles.GetCount())

	cmp	esi, DWORD PTR [ebp+220]
	jne	$L17526

; 102  : 	{
; 103  : 		This->mFramesStarFiles.AddItem(inProjectPath); // record the star path for later

	push	ebx
	lea	ecx, DWORD PTR $T17251[esp+36]
	mov	DWORD PTR $T17251[esp+36], 0
	call	?Set@CCorString@@QAEXPAD@Z		; CCorString::Set
	lea	esi, DWORD PTR [ebp+216]
	push	1
	mov	ecx, esi
	call	?Add@?$TCorArray@VCCorString@@@@QAEKK@Z	; TCorArray<CCorString>::Add
	mov	ecx, DWORD PTR $T17251[esp+32]
	mov	edx, DWORD PTR [esi]
	push	ecx
	lea	ecx, DWORD PTR [edx+eax*4]
	call	?Set@CCorString@@QAEXPAD@Z		; CCorString::Set
	push	0
	lea	ecx, DWORD PTR $T17251[esp+36]
	call	?Set@CCorString@@QAEXPAD@Z		; CCorString::Set

; 104  : 		CCorString oldBasePath = CPJ_GetBasePath();

	call	?CPJ_GetBasePath@@YAPBDXZ		; CPJ_GetBasePath
	push	eax
	lea	ecx, DWORD PTR _oldBasePath$12126[esp+32]
	mov	DWORD PTR _oldBasePath$12126[esp+32], 0
	call	?Set@CCorString@@QAEXPAD@Z		; CCorString::Set

; 105  : 		CPJ_SetBasePath(""); // since the file find uses absolute paths but findproject doesn't

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	call	?CPJ_SetBasePath@@YAXPBD@Z		; CPJ_SetBasePath

; 106  : 		CCorString spec = oldBasePath + inProjectPath;

	lea	eax, DWORD PTR _oldBasePath$12126[esp+32]
	push	ebx
	lea	ecx, DWORD PTR _spec$12127[esp+36]
	push	eax
	push	ecx
	call	??H@YA?AVCCorString@@ABV0@PBD@Z		; operator+

; 107  : 		NChar* fileName = STR_FileFind(*spec, NULL, NULL);

	mov	eax, DWORD PTR _spec$12127[esp+44]
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $L17420
	mov	eax, OFFSET FLAT:??_C@_00A@?$AA@	; `string'
$L17420:
	push	0
	push	0
	push	eax
	call	?STR_FileFind@@YAPADPADPAHPAK@Z		; STR_FileFind
	add	esp, 12					; 0000000cH

; 108  : 		while (fileName)

	test	eax, eax
	je	$L12132
$L12131:

; 109  : 		{
; 110  : 			This->AddFrames(CPJ_FindProject(fileName));

	push	eax
	call	?CPJ_FindProject@@YAPAVOCpjProject@@PBD@Z ; CPJ_FindProject
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	je	SHORT $L17474
	push	0
	push	esi
	lea	ecx, DWORD PTR _it$17471[esp+40]
	call	??0CObjIter@@QAE@PAVOObject@@_N@Z	; CObjIter::CObjIter
	push	0
	push	esi
	lea	ecx, DWORD PTR _it$17471[esp+40]
	call	?Reset@?$TObjIter@VOCpjFrames@@@@QAEXPAVOObject@@_N@Z ; TObjIter<OCpjFrames>::Reset
	lea	ecx, DWORD PTR _it$17471[esp+32]
	call	?GetObject@CObjIter@@IAEPAVOObject@@XZ	; CObjIter::GetObject
	test	eax, eax
	je	SHORT $L17474
	lea	esi, DWORD PTR [ebp+168]
$L17459:
	lea	ecx, DWORD PTR _it$17471[esp+32]
	call	?GetObject@CObjIter@@IAEPAVOObject@@XZ	; CObjIter::GetObject
	push	1
	mov	ecx, esi
	mov	edi, eax
	call	?Add@?$TCorArray@PAVOCpjFrames@@@@QAEKK@Z ; TCorArray<OCpjFrames *>::Add
	mov	edx, DWORD PTR [esi]
	lea	ecx, DWORD PTR _it$17471[esp+32]
	mov	DWORD PTR [edx+eax*4], edi
	mov	eax, DWORD PTR _it$17471[esp+36]
	mov	DWORD PTR _it$17471[esp+32], eax
	call	?GetNext@CObjIter@@IAEXXZ		; CObjIter::GetNext
	lea	ecx, DWORD PTR _it$17471[esp+32]
	call	?AdvanceToType@?$TObjIter@VOCpjFrames@@@@IAEXXZ ; TObjIter<OCpjFrames>::AdvanceToType
	lea	ecx, DWORD PTR _it$17471[esp+32]
	call	?GetObject@CObjIter@@IAEPAVOObject@@XZ	; CObjIter::GetObject
	test	eax, eax
	jne	SHORT $L17459
$L17474:

; 111  : 			fileName = STR_FileFind(NULL, NULL, NULL);

	push	0
	push	0
	push	0
	call	?STR_FileFind@@YAPADPADPAHPAK@Z		; STR_FileFind
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$L12131
$L12132:

; 112  : 		}
; 113  : 		CPJ_SetBasePath(*oldBasePath);

	mov	eax, DWORD PTR _oldBasePath$12126[esp+28]
	test	eax, eax
	jne	SHORT $L17484
	mov	eax, OFFSET FLAT:??_C@_00A@?$AA@	; `string'
$L17484:
	push	eax
	call	?CPJ_SetBasePath@@YAXPBD@Z		; CPJ_SetBasePath

; 114  : 	}

	mov	edi, DWORD PTR _spec$12127[esp+32]
	add	esp, 4
	test	edi, edi
	je	SHORT $L17504
	or	ecx, -1
	xor	eax, eax
	repne scasb
	mov	edi, DWORD PTR ?sMemTotal@CCorString@@0KA ; CCorString::sMemTotal
	or	edx, -1
	not	ecx
	dec	ecx
	sub	edx, ecx
	add	edi, edx
	mov	DWORD PTR ?sMemTotal@CCorString@@0KA, edi ; CCorString::sMemTotal
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR _spec$12127[esp+28]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L17504:
	mov	edi, DWORD PTR _oldBasePath$12126[esp+28]
	mov	DWORD PTR _spec$12127[esp+28], 0
	test	edi, edi
	je	SHORT $L17526
	or	ecx, -1
	xor	eax, eax
	repne scasb
	mov	edi, DWORD PTR ?sMemTotal@CCorString@@0KA ; CCorString::sMemTotal
	or	edx, -1
	not	ecx
	dec	ecx
	sub	edx, ecx
	add	edi, edx
	mov	DWORD PTR ?sMemTotal@CCorString@@0KA, edi ; CCorString::sMemTotal
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR _oldBasePath$12126[esp+28]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L17526:
	pop	edi
	pop	esi
	pop	ebp

; 115  : 	return(1);

	mov	al, 1
	pop	ebx

; 116  : }

	add	esp, 16					; 00000010H
	ret	0
_AddFrames_msg_OMacActor ENDP
_TEXT	ENDS
PUBLIC	_AddSequences_msg_OMacActor
PUBLIC	??_C@_0N@JOIN@AddSequences?$AA@			; `string'
;	COMDAT ??_C@_0N@JOIN@AddSequences?$AA@
_DATA	SEGMENT
??_C@_0N@JOIN@AddSequences?$AA@ DB 'AddSequences', 00H	; `string'
; Function compile flags: /Ogty
_DATA	ENDS
;	COMDAT _$E80
_TEXT	SEGMENT
_$E80	PROC NEAR					; COMDAT
	push	OFFSET FLAT:??_C@_01KBOJ@s?$AA@		; `string'
	push	OFFSET FLAT:_AddSequences_msg_OMacActor
	push	OFFSET FLAT:??_C@_0N@JOIN@AddSequences?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_09OANE@OMacActor?$AA@	; `string'
	call	?MSG_RegisterHandlerC@@YA_NPBD0PAX0@Z	; MSG_RegisterHandlerC
	add	esp, 16					; 00000010H
	mov	BYTE PTR ?AddSequences_msg_OMacActor_dummy@@3_NA, al ; AddSequences_msg_OMacActor_dummy
	ret	0
_$E80	ENDP
_TEXT	ENDS
PUBLIC	?AdvanceToType@?$TObjIter@VOCpjSequence@@@@IAEXXZ ; TObjIter<OCpjSequence>::AdvanceToType
PUBLIC	?Reset@?$TObjIter@VOCpjSequence@@@@QAEXPAVOObject@@_N@Z ; TObjIter<OCpjSequence>::Reset
PUBLIC	??0?$TObjIter@VOCpjSequence@@@@QAE@PAVOObject@@_N@Z ; TObjIter<OCpjSequence>::TObjIter<OCpjSequence>
PUBLIC	?AddItem@?$TCorArray@PAVOCpjSequence@@@@QAEKABQAVOCpjSequence@@@Z ; TCorArray<OCpjSequence *>::AddItem
PUBLIC	?Add@?$TCorArray@PAVOCpjSequence@@@@QAEKK@Z	; TCorArray<OCpjSequence *>::Add
; Function compile flags: /Ogty
;	COMDAT _AddSequences_msg_OMacActor
_TEXT	SEGMENT
$T17560 = 8
$T17561 = -16
_it$17580 = -12
$T17585 = 8
_it$17658 = -12
$T17663 = 8
_it$17764 = -12
_This$ = 8
_inProjectPath$ = 16
_oldBasePath$12165 = 8
_spec$12166 = 16
_AddSequences_msg_OMacActor PROC NEAR			; COMDAT

; 118  : {

	sub	esp, 16					; 00000010H
	push	ebx

; 119  : 	if (!stricmp(inProjectPath, "NULL"))

	mov	ebx, DWORD PTR _inProjectPath$[esp+16]
	push	ebp
	mov	ebp, DWORD PTR __imp__stricmp
	push	esi
	push	edi
	push	OFFSET FLAT:??_C@_04BAK@NULL?$AA@	; `string'
	push	ebx
	call	ebp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L12149

; 120  : 	{
; 121  : 		This->AddSequences(This->mLoadProject);

	mov	esi, DWORD PTR _This$[esp+28]
	mov	eax, DWORD PTR [esi+68]
	test	eax, eax
	je	$L17836
	push	0
	push	eax
	lea	ecx, DWORD PTR _it$17580[esp+40]
	call	??0?$TObjIter@VOCpjSequence@@@@QAE@PAVOObject@@_N@Z ; TObjIter<OCpjSequence>::TObjIter<OCpjSequence>
	lea	ecx, DWORD PTR _it$17580[esp+32]
	call	?GetObject@CObjIter@@IAEPAVOObject@@XZ	; CObjIter::GetObject
	test	eax, eax
	je	$L17836
	add	esi, 184				; 000000b8H
$L17589:
	lea	ecx, DWORD PTR _it$17580[esp+32]
	call	?GetObject@CObjIter@@IAEPAVOObject@@XZ	; CObjIter::GetObject
	mov	DWORD PTR $T17585[esp+28], eax
	lea	eax, DWORD PTR $T17585[esp+28]
	push	eax
	mov	ecx, esi
	call	?AddItem@?$TCorArray@PAVOCpjSequence@@@@QAEKABQAVOCpjSequence@@@Z ; TCorArray<OCpjSequence *>::AddItem
	mov	ecx, DWORD PTR _it$17580[esp+36]
	mov	DWORD PTR _it$17580[esp+32], ecx
	lea	ecx, DWORD PTR _it$17580[esp+32]
	call	?GetNext@CObjIter@@IAEXXZ		; CObjIter::GetNext
	lea	ecx, DWORD PTR _it$17580[esp+32]
	call	?AdvanceToType@?$TObjIter@VOCpjSequence@@@@IAEXXZ ; TObjIter<OCpjSequence>::AdvanceToType
	lea	ecx, DWORD PTR _it$17580[esp+32]
	call	?GetObject@CObjIter@@IAEPAVOObject@@XZ	; CObjIter::GetObject
	test	eax, eax
	jne	SHORT $L17589
	pop	edi
	pop	esi
	pop	ebp

; 158  : 	return(1);

	mov	al, 1
	pop	ebx

; 159  : }

	add	esp, 16					; 00000010H
	ret	0
$L12149:

; 122  : 		return(1);
; 123  : 	}
; 124  : 	if (!strchr(inProjectPath, '*'))

	push	42					; 0000002aH
	push	ebx
	call	DWORD PTR __imp__strchr
	add	esp, 8

; 125  : 	{
; 126  : 		for (NDword i=0;i<This->mSequencesFiles.GetCount();i++)

	xor	esi, esi
	test	eax, eax
	jne	$L12150
	mov	edi, DWORD PTR _This$[esp+28]
	mov	eax, DWORD PTR [edi+236]
	test	eax, eax
	jbe	SHORT $L17849
$L12152:
	mov	edx, DWORD PTR [edi+232]
	lea	eax, DWORD PTR [edx+esi*4]

; 127  : 		{
; 128  : 			if (!stricmp(*This->mSequencesFiles[i], inProjectPath))

	mov	eax, DWORD PTR [edx+esi*4]
	test	eax, eax
	jne	SHORT $L17610
	mov	eax, OFFSET FLAT:??_C@_00A@?$AA@	; `string'
$L17610:
	push	ebx
	push	eax
	call	ebp
	add	esp, 8
	test	eax, eax
	je	SHORT $L17849
	mov	eax, DWORD PTR [edi+236]
	inc	esi
	cmp	esi, eax
	jb	SHORT $L12152
$L17849:

; 129  : 				break;
; 130  : 		}
; 131  : 		if (i==This->mSequencesFiles.GetCount())

	cmp	esi, DWORD PTR [edi+236]
	jne	$L17836

; 132  : 		{
; 133  : 			This->mSequencesFiles.AddItem(inProjectPath);

	push	ebx
	lea	ecx, DWORD PTR $T17560[esp+32]
	mov	DWORD PTR $T17560[esp+32], 0
	call	?Set@CCorString@@QAEXPAD@Z		; CCorString::Set
	lea	esi, DWORD PTR [edi+232]
	push	1
	mov	ecx, esi
	call	?Add@?$TCorArray@VCCorString@@@@QAEKK@Z	; TCorArray<CCorString>::Add
	mov	ecx, DWORD PTR $T17560[esp+28]
	mov	edx, DWORD PTR [esi]
	push	ecx
	lea	ecx, DWORD PTR [edx+eax*4]
	call	?Set@CCorString@@QAEXPAD@Z		; CCorString::Set
	push	0
	lea	ecx, DWORD PTR $T17560[esp+32]
	call	?Set@CCorString@@QAEXPAD@Z		; CCorString::Set

; 134  : 			This->AddSequences(CPJ_FindProject(inProjectPath));

	push	ebx
	call	?CPJ_FindProject@@YAPAVOCpjProject@@PBD@Z ; CPJ_FindProject
	add	esp, 4
	test	eax, eax
	je	$L17836
	push	0
	push	eax
	lea	ecx, DWORD PTR _it$17658[esp+40]
	call	??0?$TObjIter@VOCpjSequence@@@@QAE@PAVOObject@@_N@Z ; TObjIter<OCpjSequence>::TObjIter<OCpjSequence>
	lea	ecx, DWORD PTR _it$17658[esp+32]
	call	?GetObject@CObjIter@@IAEPAVOObject@@XZ	; CObjIter::GetObject
	test	eax, eax
	je	$L17836
	lea	esi, DWORD PTR [edi+184]
$L17667:
	lea	ecx, DWORD PTR _it$17658[esp+32]
	call	?GetObject@CObjIter@@IAEPAVOObject@@XZ	; CObjIter::GetObject
	mov	DWORD PTR $T17663[esp+28], eax
	lea	eax, DWORD PTR $T17663[esp+28]
	push	eax
	mov	ecx, esi
	call	?AddItem@?$TCorArray@PAVOCpjSequence@@@@QAEKABQAVOCpjSequence@@@Z ; TCorArray<OCpjSequence *>::AddItem
	mov	ecx, DWORD PTR _it$17658[esp+36]
	mov	DWORD PTR _it$17658[esp+32], ecx
	lea	ecx, DWORD PTR _it$17658[esp+32]
	call	?GetNext@CObjIter@@IAEXXZ		; CObjIter::GetNext
	lea	ecx, DWORD PTR _it$17658[esp+32]
	call	?AdvanceToType@?$TObjIter@VOCpjSequence@@@@IAEXXZ ; TObjIter<OCpjSequence>::AdvanceToType
	lea	ecx, DWORD PTR _it$17658[esp+32]
	call	?GetObject@CObjIter@@IAEPAVOObject@@XZ	; CObjIter::GetObject
	test	eax, eax
	jne	SHORT $L17667
	pop	edi
	pop	esi
	pop	ebp

; 158  : 	return(1);

	mov	al, 1
	pop	ebx

; 159  : }

	add	esp, 16					; 00000010H
	ret	0
$L12150:

; 135  : 		}
; 136  : 		return(1);
; 137  : 	}
; 138  : 
; 139  : 	for (NDword i=0;i<This->mSequencesStarFiles.GetCount();i++)

	mov	ebp, DWORD PTR _This$[esp+28]
	mov	eax, DWORD PTR [ebp+252]
	test	eax, eax
	jbe	SHORT $L17850
$L12159:
	mov	edx, DWORD PTR [ebp+248]
	lea	eax, DWORD PTR [edx+esi*4]

; 140  : 	{
; 141  : 		if (!stricmp(*This->mSequencesStarFiles[i], inProjectPath))

	mov	eax, DWORD PTR [edx+esi*4]
	test	eax, eax
	jne	SHORT $L17688
	mov	eax, OFFSET FLAT:??_C@_00A@?$AA@	; `string'
$L17688:
	push	ebx
	push	eax
	call	DWORD PTR __imp__stricmp
	add	esp, 8
	test	eax, eax
	je	SHORT $L17850
	mov	eax, DWORD PTR [ebp+252]
	inc	esi
	cmp	esi, eax
	jb	SHORT $L12159
$L17850:

; 142  : 			break;
; 143  : 	}
; 144  : 	if (i==This->mSequencesStarFiles.GetCount())

	cmp	esi, DWORD PTR [ebp+252]
	jne	$L17836

; 145  : 	{
; 146  : 		This->mSequencesStarFiles.AddItem(inProjectPath); // record the star path for later

	push	ebx
	lea	ecx, DWORD PTR $T17561[esp+36]
	mov	DWORD PTR $T17561[esp+36], 0
	call	?Set@CCorString@@QAEXPAD@Z		; CCorString::Set
	lea	esi, DWORD PTR [ebp+248]
	push	1
	mov	ecx, esi
	call	?Add@?$TCorArray@VCCorString@@@@QAEKK@Z	; TCorArray<CCorString>::Add
	mov	ecx, DWORD PTR $T17561[esp+32]
	mov	edx, DWORD PTR [esi]
	push	ecx
	lea	ecx, DWORD PTR [edx+eax*4]
	call	?Set@CCorString@@QAEXPAD@Z		; CCorString::Set
	push	0
	lea	ecx, DWORD PTR $T17561[esp+36]
	call	?Set@CCorString@@QAEXPAD@Z		; CCorString::Set

; 147  : 		CCorString oldBasePath = CPJ_GetBasePath();

	call	?CPJ_GetBasePath@@YAPBDXZ		; CPJ_GetBasePath
	push	eax
	lea	ecx, DWORD PTR _oldBasePath$12165[esp+32]
	mov	DWORD PTR _oldBasePath$12165[esp+32], 0
	call	?Set@CCorString@@QAEXPAD@Z		; CCorString::Set

; 148  : 		CPJ_SetBasePath(""); // since the file find uses absolute paths but findproject doesn't

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	call	?CPJ_SetBasePath@@YAXPBD@Z		; CPJ_SetBasePath

; 149  : 		CCorString spec = oldBasePath + inProjectPath;

	lea	eax, DWORD PTR _oldBasePath$12165[esp+32]
	push	ebx
	lea	ecx, DWORD PTR _spec$12166[esp+36]
	push	eax
	push	ecx
	call	??H@YA?AVCCorString@@ABV0@PBD@Z		; operator+

; 150  : 		NChar* fileName = STR_FileFind(*spec, NULL, NULL);

	mov	eax, DWORD PTR _spec$12166[esp+44]
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $L17730
	mov	eax, OFFSET FLAT:??_C@_00A@?$AA@	; `string'
$L17730:
	push	0
	push	0
	push	eax
	call	?STR_FileFind@@YAPADPADPAHPAK@Z		; STR_FileFind
	add	esp, 12					; 0000000cH

; 151  : 		while (fileName)

	test	eax, eax
	je	$L12171
$L12170:

; 152  : 		{
; 153  : 			This->AddSequences(CPJ_FindProject(fileName));

	push	eax
	call	?CPJ_FindProject@@YAPAVOCpjProject@@PBD@Z ; CPJ_FindProject
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	je	SHORT $L17767
	push	0
	push	esi
	lea	ecx, DWORD PTR _it$17764[esp+40]
	call	??0CObjIter@@QAE@PAVOObject@@_N@Z	; CObjIter::CObjIter
	push	0
	push	esi
	lea	ecx, DWORD PTR _it$17764[esp+40]
	call	?Reset@?$TObjIter@VOCpjSequence@@@@QAEXPAVOObject@@_N@Z ; TObjIter<OCpjSequence>::Reset
	lea	ecx, DWORD PTR _it$17764[esp+32]
	call	?GetObject@CObjIter@@IAEPAVOObject@@XZ	; CObjIter::GetObject
	test	eax, eax
	je	SHORT $L17767
	lea	esi, DWORD PTR [ebp+184]
$L17772:
	lea	ecx, DWORD PTR _it$17764[esp+32]
	call	?GetObject@CObjIter@@IAEPAVOObject@@XZ	; CObjIter::GetObject
	push	1
	mov	ecx, esi
	mov	edi, eax
	call	?Add@?$TCorArray@PAVOCpjSequence@@@@QAEKK@Z ; TCorArray<OCpjSequence *>::Add
	mov	edx, DWORD PTR [esi]
	lea	ecx, DWORD PTR _it$17764[esp+32]
	mov	DWORD PTR [edx+eax*4], edi
	mov	eax, DWORD PTR _it$17764[esp+36]
	mov	DWORD PTR _it$17764[esp+32], eax
	call	?GetNext@CObjIter@@IAEXXZ		; CObjIter::GetNext
	lea	ecx, DWORD PTR _it$17764[esp+32]
	call	?AdvanceToType@?$TObjIter@VOCpjSequence@@@@IAEXXZ ; TObjIter<OCpjSequence>::AdvanceToType
	lea	ecx, DWORD PTR _it$17764[esp+32]
	call	?GetObject@CObjIter@@IAEPAVOObject@@XZ	; CObjIter::GetObject
	test	eax, eax
	jne	SHORT $L17772
$L17767:

; 154  : 			fileName = STR_FileFind(NULL, NULL, NULL);

	push	0
	push	0
	push	0
	call	?STR_FileFind@@YAPADPADPAHPAK@Z		; STR_FileFind
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$L12170
$L12171:

; 155  : 		}
; 156  : 		CPJ_SetBasePath(*oldBasePath);

	mov	eax, DWORD PTR _oldBasePath$12165[esp+28]
	test	eax, eax
	jne	SHORT $L17794
	mov	eax, OFFSET FLAT:??_C@_00A@?$AA@	; `string'
$L17794:
	push	eax
	call	?CPJ_SetBasePath@@YAXPBD@Z		; CPJ_SetBasePath

; 157  : 	}

	mov	edi, DWORD PTR _spec$12166[esp+32]
	add	esp, 4
	test	edi, edi
	je	SHORT $L17814
	or	ecx, -1
	xor	eax, eax
	repne scasb
	mov	edi, DWORD PTR ?sMemTotal@CCorString@@0KA ; CCorString::sMemTotal
	or	edx, -1
	not	ecx
	dec	ecx
	sub	edx, ecx
	add	edi, edx
	mov	DWORD PTR ?sMemTotal@CCorString@@0KA, edi ; CCorString::sMemTotal
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR _spec$12166[esp+28]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L17814:
	mov	edi, DWORD PTR _oldBasePath$12165[esp+28]
	mov	DWORD PTR _spec$12166[esp+28], 0
	test	edi, edi
	je	SHORT $L17836
	or	ecx, -1
	xor	eax, eax
	repne scasb
	mov	edi, DWORD PTR ?sMemTotal@CCorString@@0KA ; CCorString::sMemTotal
	or	edx, -1
	not	ecx
	dec	ecx
	sub	edx, ecx
	add	edi, edx
	mov	DWORD PTR ?sMemTotal@CCorString@@0KA, edi ; CCorString::sMemTotal
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR _oldBasePath$12165[esp+28]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L17836:
	pop	edi
	pop	esi
	pop	ebp

; 158  : 	return(1);

	mov	al, 1
	pop	ebx

; 159  : }

	add	esp, 16					; 00000010H
	ret	0
_AddSequences_msg_OMacActor ENDP
_TEXT	ENDS
PUBLIC	?Tick@OMacActor@@SAXXZ				; OMacActor::Tick
; Function compile flags: /Ogty
;	COMDAT ?Tick@OMacActor@@SAXXZ
_TEXT	SEGMENT
?Tick@OMacActor@@SAXXZ PROC NEAR			; OMacActor::Tick, COMDAT

; 171  : 	Evaluations = 0;
; 172  : 	FrameCount++;

	mov	eax, DWORD PTR ?FrameCount@OMacActor@@2KA ; OMacActor::FrameCount
	mov	DWORD PTR ?Evaluations@OMacActor@@2KA, 0 ; OMacActor::Evaluations
	inc	eax
	mov	DWORD PTR ?FrameCount@OMacActor@@2KA, eax ; OMacActor::FrameCount

; 173  : }

	ret	0
?Tick@OMacActor@@SAXXZ ENDP				; OMacActor::Tick
_TEXT	ENDS
PUBLIC	?ValidateAbs@CMacBone@@IAEX_N@Z			; CMacBone::ValidateAbs
; Function compile flags: /Ogty
;	COMDAT ?ValidateAbs@CMacBone@@IAEX_N@Z
_TEXT	SEGMENT
$T18324 = -12
$T18325 = -24
$T18334 = -60
$T18348 = -36
$T18349 = -48
$T18350 = -60
_inMakeValid$ = 8
?ValidateAbs@CMacBone@@IAEX_N@Z PROC NEAR		; CMacBone::ValidateAbs, COMDAT
; _this$ = ecx

; 180  : 	if (inMakeValid)

	mov	al, BYTE PTR _inMakeValid$[esp-4]
	sub	esp, 60					; 0000003cH
	test	al, al
	push	esi
	mov	esi, ecx

; 181  : 	{
; 182  : 		// validate a bone's absolute state, including its ancestors
; 183  : 		if (mAbsValid)

	mov	al, BYTE PTR [esi+120]
	je	$L12178
	test	al, al
	jne	$L12187

; 184  : 			return;
; 185  : 		if (mParent)

	mov	ecx, DWORD PTR [esi+128]
	test	ecx, ecx
	je	SHORT $L12180

; 186  : 			mParent->ValidateAbs(true);

	push	1
	call	?ValidateAbs@CMacBone@@IAEX_N@Z		; CMacBone::ValidateAbs
$L12180:

; 187  : 		mAbsCoords = mRelCoords;

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [esi+60], eax
	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [esi+64], ecx
	mov	edx, DWORD PTR [esi+8]
	mov	DWORD PTR [esi+68], edx
	mov	eax, DWORD PTR [esi+12]
	mov	DWORD PTR [esi+72], eax
	mov	ecx, DWORD PTR [esi+16]
	mov	DWORD PTR [esi+76], ecx
	mov	edx, DWORD PTR [esi+20]
	mov	DWORD PTR [esi+80], edx
	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [esi+84], eax
	mov	ecx, DWORD PTR [esi+28]
	mov	DWORD PTR [esi+88], ecx
	mov	edx, DWORD PTR [esi+32]
	mov	DWORD PTR [esi+92], edx
	mov	eax, DWORD PTR [esi+36]
	mov	DWORD PTR [esi+96], eax
	mov	ecx, DWORD PTR [esi+40]
	mov	DWORD PTR [esi+100], ecx
	mov	edx, DWORD PTR [esi+44]
	mov	DWORD PTR [esi+104], edx
	mov	eax, DWORD PTR [esi+48]
	mov	DWORD PTR [esi+108], eax
	mov	ecx, DWORD PTR [esi+52]
	mov	DWORD PTR [esi+112], ecx
	mov	edx, DWORD PTR [esi+56]
	mov	DWORD PTR [esi+116], edx

; 188  : 		if (mParent)

	mov	eax, DWORD PTR [esi+128]
	test	eax, eax
	je	$L18319

; 189  : 			mAbsCoords <<= mParent->mAbsCoords;

	fld	DWORD PTR [esi+108]
	fmul	DWORD PTR [eax+108]
	fld	DWORD PTR [esi+112]
	fmul	DWORD PTR [eax+112]
	fld	DWORD PTR [esi+116]
	fmul	DWORD PTR [eax+116]
	fstp	DWORD PTR $T18324[esp+72]
	fld	DWORD PTR [esi+96]
	fmul	DWORD PTR [eax+108]
	fld	DWORD PTR [eax+112]
	fmul	DWORD PTR [esi+100]
	fld	DWORD PTR [eax+116]
	fmul	DWORD PTR [esi+104]
	fld	ST(2)
	fmul	DWORD PTR [eax+60]
	fld	ST(1)
	fmul	DWORD PTR [eax+84]

; 198  : 		for (CMacBone* b = mFirstChild; b; b = b->mNextSibling)

	faddp	ST(1), ST(0)
	fld	ST(2)
	fmul	DWORD PTR [eax+72]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR $T18334[esp+64]
	fld	ST(2)
	fmul	DWORD PTR [eax+64]
	fld	ST(1)
	fmul	DWORD PTR [eax+88]
	faddp	ST(1), ST(0)
	fld	ST(2)
	fmul	DWORD PTR [eax+76]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR $T18334[esp+68]
	fxch	ST(2)
	fmul	DWORD PTR [eax+68]
	fxch	ST(2)
	fmul	DWORD PTR [eax+92]
	faddp	ST(2), ST(0)
	fmul	DWORD PTR [eax+80]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR $T18334[esp+72]
	fld	DWORD PTR $T18334[esp+64]
	fadd	DWORD PTR [eax+96]
	fld	DWORD PTR $T18334[esp+68]
	fadd	DWORD PTR [eax+100]
	fld	DWORD PTR $T18334[esp+72]
	fadd	DWORD PTR [eax+104]
	fstp	DWORD PTR $T18325[esp+72]
	fld	DWORD PTR [eax+84]
	fmul	DWORD PTR [esi+92]
	fld	DWORD PTR [eax+72]
	fmul	DWORD PTR [esi+88]
	faddp	ST(1), ST(0)
	fld	DWORD PTR [eax+60]
	fmul	DWORD PTR [esi+84]
	faddp	ST(1), ST(0)
	fld	DWORD PTR [eax+64]
	fmul	DWORD PTR [esi+84]
	fld	DWORD PTR [esi+92]
	fmul	DWORD PTR [eax+88]
	faddp	ST(1), ST(0)
	fld	DWORD PTR [esi+88]
	fmul	DWORD PTR [eax+76]
	faddp	ST(1), ST(0)
	fld	DWORD PTR [eax+68]
	fmul	DWORD PTR [esi+84]
	fld	DWORD PTR [esi+92]
	fmul	DWORD PTR [eax+92]
	faddp	ST(1), ST(0)
	fld	DWORD PTR [esi+88]
	fmul	DWORD PTR [eax+80]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR $T18348[esp+72]
	fld	DWORD PTR [eax+84]
	fmul	DWORD PTR [esi+80]
	fld	DWORD PTR [eax+72]
	fmul	DWORD PTR [esi+76]
	faddp	ST(1), ST(0)
	fld	DWORD PTR [eax+60]
	fmul	DWORD PTR [esi+72]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR $T18349[esp+64]
	fld	DWORD PTR [eax+88]
	fmul	DWORD PTR [esi+80]
	fld	DWORD PTR [eax+76]
	fmul	DWORD PTR [esi+76]
	faddp	ST(1), ST(0)
	fld	DWORD PTR [eax+64]
	fmul	DWORD PTR [esi+72]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR $T18349[esp+68]
	fld	DWORD PTR [eax+92]
	fmul	DWORD PTR [esi+80]
	fld	DWORD PTR [eax+80]
	fmul	DWORD PTR [esi+76]
	faddp	ST(1), ST(0)
	fld	DWORD PTR [eax+68]
	fmul	DWORD PTR [esi+72]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR $T18349[esp+72]
	fld	DWORD PTR [eax+84]
	fmul	DWORD PTR [esi+68]
	fld	DWORD PTR [eax+72]
	fmul	DWORD PTR [esi+64]
	faddp	ST(1), ST(0)
	fld	DWORD PTR [eax+60]
	fmul	DWORD PTR [esi+60]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR $T18350[esp+64]
	fld	DWORD PTR [eax+88]
	fmul	DWORD PTR [esi+68]
	fld	DWORD PTR [eax+76]
	fmul	DWORD PTR [esi+64]
	faddp	ST(1), ST(0)
	fld	DWORD PTR [eax+64]
	fmul	DWORD PTR [esi+60]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR $T18350[esp+68]
	fld	DWORD PTR [eax+92]
	fmul	DWORD PTR [esi+68]
	fld	DWORD PTR [eax+80]
	fmul	DWORD PTR [esi+64]
	mov	ecx, DWORD PTR $T18350[esp+68]
	faddp	ST(1), ST(0)
	fld	DWORD PTR [eax+68]
	fmul	DWORD PTR [esi+60]
	mov	eax, DWORD PTR $T18350[esp+64]
	mov	DWORD PTR [esi+64], ecx
	mov	DWORD PTR [esi+60], eax
	faddp	ST(1), ST(0)
	fstp	DWORD PTR $T18350[esp+72]
	mov	edx, DWORD PTR $T18350[esp+72]
	mov	eax, DWORD PTR $T18349[esp+64]
	mov	ecx, DWORD PTR $T18349[esp+68]
	mov	DWORD PTR [esi+68], edx
	mov	edx, DWORD PTR $T18349[esp+72]
	mov	DWORD PTR [esi+72], eax
	mov	eax, DWORD PTR $T18348[esp+72]
	mov	DWORD PTR [esi+76], ecx
	fxch	ST(1)
	mov	DWORD PTR [esi+80], edx
	fstp	DWORD PTR [esi+84]
	mov	ecx, DWORD PTR $T18325[esp+72]
	mov	DWORD PTR [esi+92], eax
	fstp	DWORD PTR [esi+88]
	fxch	ST(1)
	fstp	DWORD PTR [esi+96]
	mov	edx, DWORD PTR $T18324[esp+72]
	mov	DWORD PTR [esi+104], ecx
	fstp	DWORD PTR [esi+100]
	fxch	ST(1)
	fstp	DWORD PTR [esi+108]
	mov	DWORD PTR [esi+116], edx
	fstp	DWORD PTR [esi+112]
$L18319:

; 190  : 		mAbsValid = 1;

	mov	BYTE PTR [esi+120], 1
	pop	esi

; 200  : 	}
; 201  : }

	add	esp, 60					; 0000003cH
	ret	4
$L12178:

; 191  : 	}
; 192  : 	else
; 193  : 	{
; 194  : 		// invalidate a bone's absolute state, including its children
; 195  : 		if (!mAbsValid)

	test	al, al
	je	SHORT $L12187

; 196  : 			return;
; 197  : 		mAbsValid = 0;

	mov	BYTE PTR [esi+120], 0

; 198  : 		for (CMacBone* b = mFirstChild; b; b = b->mNextSibling)

	mov	esi, DWORD PTR [esi+132]
	test	esi, esi
	je	SHORT $L12187
$L12185:

; 199  : 			b->ValidateAbs(false);

	push	0
	mov	ecx, esi
	call	?ValidateAbs@CMacBone@@IAEX_N@Z		; CMacBone::ValidateAbs
	mov	esi, DWORD PTR [esi+136]
	test	esi, esi
	jne	SHORT $L12185
$L12187:
	pop	esi

; 200  : 	}
; 201  : }

	add	esp, 60					; 0000003cH
	ret	4
?ValidateAbs@CMacBone@@IAEX_N@Z ENDP			; CMacBone::ValidateAbs
_TEXT	ENDS
PUBLIC	?GetCoords@CMacBone@@QAE?AVVCoords3@@_N@Z	; CMacBone::GetCoords
; Function compile flags: /Ogty
;	COMDAT ?GetCoords@CMacBone@@QAE?AVVCoords3@@_N@Z
_TEXT	SEGMENT
_inAbsolute$ = 12
___$ReturnUdt$ = 8
?GetCoords@CMacBone@@QAE?AVVCoords3@@_N@Z PROC NEAR	; CMacBone::GetCoords, COMDAT
; _this$ = ecx

; 205  : 	if (inAbsolute)

	mov	al, BYTE PTR _inAbsolute$[esp-4]
	push	ebx
	xor	ebx, ebx
	push	esi
	cmp	al, bl
	mov	esi, ecx
	je	$L12193

; 206  : 	{
; 207  : 		ValidateAbs(true);

	push	1
	call	?ValidateAbs@CMacBone@@IAEX_N@Z		; CMacBone::ValidateAbs

; 208  : 		return(mAbsCoords);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	ecx, 1065353216				; 3f800000H
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	DWORD PTR [eax+16], ecx
	mov	DWORD PTR [eax+20], ebx
	mov	DWORD PTR [eax+24], ebx
	mov	DWORD PTR [eax+28], ebx
	mov	DWORD PTR [eax+32], ecx
	mov	ecx, DWORD PTR [esi+60]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR [esi+64]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [esi+68]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR [esi+72]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR [esi+76]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR [esi+80]
	mov	DWORD PTR [eax+20], edx
	mov	ecx, DWORD PTR [esi+84]
	mov	DWORD PTR [eax+24], ecx
	mov	edx, DWORD PTR [esi+88]
	mov	DWORD PTR [eax+28], edx
	mov	ecx, DWORD PTR [esi+92]
	mov	DWORD PTR [eax+32], ecx
	mov	edx, DWORD PTR [esi+96]
	mov	DWORD PTR [eax+36], edx
	mov	ecx, DWORD PTR [esi+100]
	mov	DWORD PTR [eax+40], ecx
	mov	edx, DWORD PTR [esi+104]
	mov	DWORD PTR [eax+44], edx
	mov	ecx, DWORD PTR [esi+108]
	mov	DWORD PTR [eax+48], ecx
	mov	edx, DWORD PTR [esi+112]
	mov	DWORD PTR [eax+52], edx
	mov	ecx, DWORD PTR [esi+116]
	pop	esi
	mov	DWORD PTR [eax+56], ecx
	pop	ebx

; 211  : }

	ret	8
$L12193:

; 209  : 	}
; 210  : 	return(mRelCoords);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	ecx, 1065353216				; 3f800000H
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	DWORD PTR [eax+16], ecx
	mov	DWORD PTR [eax+20], ebx
	mov	DWORD PTR [eax+24], ebx
	mov	DWORD PTR [eax+28], ebx
	mov	DWORD PTR [eax+32], ecx
	mov	edx, DWORD PTR [esi]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR [esi+8]
	mov	DWORD PTR [eax+8], edx
	mov	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [eax+12], ecx
	mov	edx, DWORD PTR [esi+16]
	mov	DWORD PTR [eax+16], edx
	mov	ecx, DWORD PTR [esi+20]
	mov	DWORD PTR [eax+20], ecx
	mov	edx, DWORD PTR [esi+24]
	mov	DWORD PTR [eax+24], edx
	mov	ecx, DWORD PTR [esi+28]
	mov	DWORD PTR [eax+28], ecx
	mov	edx, DWORD PTR [esi+32]
	mov	DWORD PTR [eax+32], edx
	mov	ecx, DWORD PTR [esi+36]
	mov	DWORD PTR [eax+36], ecx
	mov	edx, DWORD PTR [esi+40]
	mov	DWORD PTR [eax+40], edx
	mov	ecx, DWORD PTR [esi+44]
	mov	DWORD PTR [eax+44], ecx
	mov	edx, DWORD PTR [esi+48]
	mov	DWORD PTR [eax+48], edx
	mov	ecx, DWORD PTR [esi+52]
	mov	DWORD PTR [eax+52], ecx
	mov	edx, DWORD PTR [esi+56]
	pop	esi
	mov	DWORD PTR [eax+56], edx
	pop	ebx

; 211  : }

	ret	8
?GetCoords@CMacBone@@QAE?AVVCoords3@@_N@Z ENDP		; CMacBone::GetCoords
_TEXT	ENDS
PUBLIC	??6@YA?AVVVec3@@ABV0@ABVVCoords3@@@Z		; operator<<
PUBLIC	__real@3f800000
PUBLIC	?SetCoords@CMacBone@@QAEXABVVCoords3@@_N@Z	; CMacBone::SetCoords
PUBLIC	??0VCoords3@@QAE@ABVVAxes3@@ABVVVec3@@1@Z	; VCoords3::VCoords3
;	COMDAT __real@3f800000
; File C:\duke4\Cannibal\VecMain.h
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
; Function compile flags: /Ogty
; File C:\duke4\Cannibal\MacMain.cpp
CONST	ENDS
;	COMDAT ?SetCoords@CMacBone@@QAEXABVVCoords3@@_N@Z
_TEXT	SEGMENT
_inCoords$ = 8
_inAbsolute$ = 12
_elderCoords$12200 = -228
$T18842 = -72
$T18845 = -156
$T18846 = -12
$T18847 = -108
$T18853 = -120
$T18854 = -132
$T18855 = -168
$T19251 = -12
$T19252 = -132
$T19261 = -168
$T19281 = -120
$T19282 = -156
$T19283 = -168
?SetCoords@CMacBone@@QAEXABVVCoords3@@_N@Z PROC NEAR	; CMacBone::SetCoords, COMDAT
; _this$ = ecx

; 214  : 	if (inAbsolute)

	mov	al, BYTE PTR _inAbsolute$[esp-4]
	sub	esp, 228				; 000000e4H
	test	al, al
	push	esi
	mov	esi, ecx
	je	$L12199
	push	edi

; 215  : 	{
; 216  : 		VCoords3 elderCoords;
; 217  : 		// Get relative by backward transforming up the parent tree
; 218  : 		for (CMacBone* b = mParent; b; b = b->mParent)

	mov	edi, DWORD PTR [esi+128]
	test	edi, edi
	mov	DWORD PTR _elderCoords$12200[esp+236], 1065353216 ; 3f800000H
	mov	DWORD PTR _elderCoords$12200[esp+240], 0
	mov	DWORD PTR _elderCoords$12200[esp+244], 0
	mov	DWORD PTR _elderCoords$12200[esp+248], 0
	mov	DWORD PTR _elderCoords$12200[esp+252], 1065353216 ; 3f800000H
	mov	DWORD PTR _elderCoords$12200[esp+256], 0
	mov	DWORD PTR _elderCoords$12200[esp+260], 0
	mov	DWORD PTR _elderCoords$12200[esp+264], 0
	mov	DWORD PTR _elderCoords$12200[esp+268], 1065353216 ; 3f800000H
	mov	DWORD PTR _elderCoords$12200[esp+272], 0
	mov	DWORD PTR _elderCoords$12200[esp+276], 0
	mov	DWORD PTR _elderCoords$12200[esp+280], 0
	mov	DWORD PTR _elderCoords$12200[esp+284], 1065353216 ; 3f800000H
	mov	DWORD PTR _elderCoords$12200[esp+288], 1065353216 ; 3f800000H
	mov	DWORD PTR _elderCoords$12200[esp+292], 1065353216 ; 3f800000H
	je	$L12204
$L12202:

; 219  : 			elderCoords <<= b->mRelCoords;

	fld	DWORD PTR _elderCoords$12200[esp+284]
	fmul	DWORD PTR [edi+48]
	fstp	DWORD PTR $T18845[esp+236]
	fld	DWORD PTR _elderCoords$12200[esp+288]
	fmul	DWORD PTR [edi+52]
	fstp	DWORD PTR $T18845[esp+240]
	fld	DWORD PTR _elderCoords$12200[esp+292]
	fmul	DWORD PTR [edi+56]
	fstp	DWORD PTR $T18845[esp+244]
	fld	DWORD PTR _elderCoords$12200[esp+264]
	fmul	DWORD PTR [edi+12]
	fld	DWORD PTR _elderCoords$12200[esp+268]
	fmul	DWORD PTR [edi+24]

; 231  : 		// Invalidate absolute from here down
; 232  : 		ValidateAbs(false);

	faddp	ST(1), ST(0)
	fld	DWORD PTR _elderCoords$12200[esp+260]
	fmul	DWORD PTR [edi]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _elderCoords$12200[esp+260]
	fmul	DWORD PTR [edi+4]
	fld	DWORD PTR _elderCoords$12200[esp+268]
	fmul	DWORD PTR [edi+28]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _elderCoords$12200[esp+264]
	fmul	DWORD PTR [edi+16]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _elderCoords$12200[esp+260]
	fmul	DWORD PTR [edi+8]
	fld	DWORD PTR _elderCoords$12200[esp+268]
	fmul	DWORD PTR [edi+32]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _elderCoords$12200[esp+264]
	fmul	DWORD PTR [edi+20]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR $T18853[esp+244]
	fld	DWORD PTR _elderCoords$12200[esp+248]
	fmul	DWORD PTR [edi]
	fld	DWORD PTR _elderCoords$12200[esp+256]
	fmul	DWORD PTR [edi+24]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _elderCoords$12200[esp+252]
	fmul	DWORD PTR [edi+12]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _elderCoords$12200[esp+252]
	fmul	DWORD PTR [edi+16]
	fld	DWORD PTR _elderCoords$12200[esp+256]
	fmul	DWORD PTR [edi+28]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _elderCoords$12200[esp+248]
	fmul	DWORD PTR [edi+4]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _elderCoords$12200[esp+252]
	fmul	DWORD PTR [edi+20]
	fld	DWORD PTR _elderCoords$12200[esp+256]
	fmul	DWORD PTR [edi+32]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _elderCoords$12200[esp+248]
	fmul	DWORD PTR [edi+8]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR $T18854[esp+244]
	fld	DWORD PTR _elderCoords$12200[esp+236]
	fmul	DWORD PTR [edi]
	fld	DWORD PTR _elderCoords$12200[esp+244]
	fmul	DWORD PTR [edi+24]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _elderCoords$12200[esp+240]
	fmul	DWORD PTR [edi+12]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR $T18854[esp+244]
	mov	edx, DWORD PTR $T18853[esp+244]
	mov	DWORD PTR $T18847[esp+256], ecx
	mov	DWORD PTR $T18847[esp+268], edx
	fld	DWORD PTR _elderCoords$12200[esp+244]
	fmul	DWORD PTR [edi+28]
	fld	DWORD PTR _elderCoords$12200[esp+240]
	fmul	DWORD PTR [edi+16]
	lea	ecx, DWORD PTR _elderCoords$12200[esp+272]
	lea	edx, DWORD PTR $T18846[esp+236]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _elderCoords$12200[esp+236]
	fmul	DWORD PTR [edi+4]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _elderCoords$12200[esp+244]
	fmul	DWORD PTR [edi+32]
	fld	DWORD PTR _elderCoords$12200[esp+240]
	fmul	DWORD PTR [edi+20]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _elderCoords$12200[esp+236]
	fmul	DWORD PTR [edi+8]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR $T18855[esp+244]
	fxch	ST(1)
	fstp	DWORD PTR $T18847[esp+236]
	mov	eax, DWORD PTR $T18855[esp+244]
	fstp	DWORD PTR $T18847[esp+240]
	fxch	ST(1)
	fstp	DWORD PTR $T18847[esp+248]
	mov	DWORD PTR $T18847[esp+244], eax
	lea	eax, DWORD PTR $T18845[esp+236]
	fstp	DWORD PTR $T18847[esp+252]
	fxch	ST(1)
	fstp	DWORD PTR $T18847[esp+260]
	push	eax
	push	edi
	fstp	DWORD PTR $T18847[esp+272]
	push	ecx
	push	edx
	call	??6@YA?AVVVec3@@ABV0@ABVVCoords3@@@Z	; operator<<
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR $T18842[esp+240]
	push	eax
	lea	eax, DWORD PTR $T18847[esp+244]
	push	eax
	call	??0VCoords3@@QAE@ABVVAxes3@@ABVVVec3@@1@Z ; VCoords3::VCoords3
	mov	ecx, DWORD PTR $T18842[esp+236]
	mov	edx, DWORD PTR $T18842[esp+240]
	mov	eax, DWORD PTR $T18842[esp+244]
	mov	DWORD PTR _elderCoords$12200[esp+236], ecx
	mov	ecx, DWORD PTR $T18842[esp+248]
	mov	DWORD PTR _elderCoords$12200[esp+240], edx
	mov	edx, DWORD PTR $T18842[esp+252]
	mov	DWORD PTR _elderCoords$12200[esp+244], eax
	mov	eax, DWORD PTR $T18842[esp+256]
	mov	DWORD PTR _elderCoords$12200[esp+248], ecx
	mov	ecx, DWORD PTR $T18842[esp+260]
	mov	DWORD PTR _elderCoords$12200[esp+252], edx
	mov	edx, DWORD PTR $T18842[esp+264]
	mov	DWORD PTR _elderCoords$12200[esp+256], eax
	mov	eax, DWORD PTR $T18842[esp+268]
	mov	DWORD PTR _elderCoords$12200[esp+260], ecx
	mov	ecx, DWORD PTR $T18842[esp+272]
	mov	DWORD PTR _elderCoords$12200[esp+264], edx
	mov	edx, DWORD PTR $T18842[esp+276]
	mov	DWORD PTR _elderCoords$12200[esp+268], eax
	mov	eax, DWORD PTR $T18842[esp+280]
	mov	DWORD PTR _elderCoords$12200[esp+272], ecx
	mov	ecx, DWORD PTR $T18842[esp+284]
	mov	DWORD PTR _elderCoords$12200[esp+276], edx
	mov	edx, DWORD PTR $T18842[esp+288]
	mov	DWORD PTR _elderCoords$12200[esp+280], eax
	mov	DWORD PTR _elderCoords$12200[esp+284], ecx
	mov	DWORD PTR _elderCoords$12200[esp+288], edx
	mov	eax, DWORD PTR $T18842[esp+292]
	mov	DWORD PTR _elderCoords$12200[esp+292], eax
	mov	edi, DWORD PTR [edi+128]
	test	edi, edi
	jne	$L12202
$L12204:

; 220  : 		mRelCoords = inCoords >> elderCoords;

	fld	DWORD PTR __real@3f800000
	fdiv	DWORD PTR _elderCoords$12200[esp+284]
	mov	eax, DWORD PTR _inCoords$[esp+232]
	fst	DWORD PTR -136+[esp+236]
	fmul	DWORD PTR [eax+48]
	fld	DWORD PTR __real@3f800000
	fdiv	DWORD PTR _elderCoords$12200[esp+288]
	fst	DWORD PTR -140+[esp+236]
	fmul	DWORD PTR [eax+52]
	fld	DWORD PTR __real@3f800000
	fdiv	DWORD PTR _elderCoords$12200[esp+292]
	fst	DWORD PTR -144+[esp+236]
	fmul	DWORD PTR [eax+56]
	fstp	DWORD PTR $T19251[esp+244]
	fld	DWORD PTR [eax+36]
	fsub	DWORD PTR _elderCoords$12200[esp+272]
	fld	DWORD PTR [eax+40]
	fsub	DWORD PTR _elderCoords$12200[esp+276]
	fld	DWORD PTR [eax+44]
	fsub	DWORD PTR _elderCoords$12200[esp+280]
	fld	ST(2)
	fmul	DWORD PTR _elderCoords$12200[esp+236]
	fld	DWORD PTR _elderCoords$12200[esp+244]
	fmul	ST(0), ST(2)

; 231  : 		// Invalidate absolute from here down
; 232  : 		ValidateAbs(false);

	faddp	ST(1), ST(0)
	fld	DWORD PTR _elderCoords$12200[esp+240]
	fmul	ST(0), ST(3)
	faddp	ST(1), ST(0)
	fstp	DWORD PTR $T19261[esp+236]
	fld	DWORD PTR _elderCoords$12200[esp+248]
	fmul	ST(0), ST(3)
	fld	DWORD PTR _elderCoords$12200[esp+256]
	fmul	ST(0), ST(2)
	faddp	ST(1), ST(0)
	fld	DWORD PTR _elderCoords$12200[esp+252]
	fmul	ST(0), ST(3)
	faddp	ST(1), ST(0)
	fstp	DWORD PTR $T19261[esp+240]
	fld	DWORD PTR _elderCoords$12200[esp+268]
	fmul	ST(0), ST(1)
	fld	DWORD PTR _elderCoords$12200[esp+264]
	fmul	ST(0), ST(3)
	faddp	ST(1), ST(0)
	fld	DWORD PTR _elderCoords$12200[esp+260]
	fmul	ST(0), ST(4)
	faddp	ST(1), ST(0)
	fstp	DWORD PTR $T19261[esp+244]
	fstp	ST(0)
	fstp	ST(0)
	fstp	ST(0)
	fld	DWORD PTR -136+[esp+236]
	fmul	DWORD PTR $T19261[esp+236]
	fld	DWORD PTR $T19261[esp+240]
	fmul	DWORD PTR -140+[esp+236]
	fld	DWORD PTR $T19261[esp+244]
	fmul	DWORD PTR -144+[esp+236]
	fstp	DWORD PTR $T19252[esp+244]
	fld	DWORD PTR _elderCoords$12200[esp+244]
	fmul	DWORD PTR [eax+32]
	fld	DWORD PTR _elderCoords$12200[esp+240]
	fmul	DWORD PTR [eax+28]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _elderCoords$12200[esp+236]
	fmul	DWORD PTR [eax+24]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _elderCoords$12200[esp+256]
	fmul	DWORD PTR [eax+32]
	fld	DWORD PTR _elderCoords$12200[esp+248]
	fmul	DWORD PTR [eax+24]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _elderCoords$12200[esp+252]
	fmul	DWORD PTR [eax+28]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _elderCoords$12200[esp+268]
	fmul	DWORD PTR [eax+32]
	fld	DWORD PTR _elderCoords$12200[esp+264]
	fmul	DWORD PTR [eax+28]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _elderCoords$12200[esp+260]
	fmul	DWORD PTR [eax+24]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR $T19281[esp+244]
	fld	DWORD PTR _elderCoords$12200[esp+244]
	fmul	DWORD PTR [eax+20]
	fld	DWORD PTR _elderCoords$12200[esp+240]
	fmul	DWORD PTR [eax+16]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _elderCoords$12200[esp+236]
	fmul	DWORD PTR [eax+12]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR $T19282[esp+236]
	fld	DWORD PTR _elderCoords$12200[esp+252]
	fmul	DWORD PTR [eax+16]
	fld	DWORD PTR _elderCoords$12200[esp+256]
	fmul	DWORD PTR [eax+20]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _elderCoords$12200[esp+248]
	fmul	DWORD PTR [eax+12]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR $T19282[esp+240]
	fld	DWORD PTR _elderCoords$12200[esp+260]
	fmul	DWORD PTR [eax+12]
	fld	DWORD PTR _elderCoords$12200[esp+268]
	fmul	DWORD PTR [eax+20]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _elderCoords$12200[esp+264]
	fmul	DWORD PTR [eax+16]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR $T19282[esp+244]
	fld	DWORD PTR _elderCoords$12200[esp+244]
	fmul	DWORD PTR [eax+8]
	fld	DWORD PTR _elderCoords$12200[esp+240]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _elderCoords$12200[esp+236]
	fmul	DWORD PTR [eax]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR $T19283[esp+236]
	fld	DWORD PTR _elderCoords$12200[esp+252]
	fmul	DWORD PTR [eax+4]
	fld	DWORD PTR _elderCoords$12200[esp+256]
	fmul	DWORD PTR [eax+8]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _elderCoords$12200[esp+248]
	fmul	DWORD PTR [eax]
	mov	ecx, DWORD PTR $T19283[esp+236]
	pop	edi
	faddp	ST(1), ST(0)
	fstp	DWORD PTR $T19283[esp+236]
	fld	DWORD PTR _elderCoords$12200[esp+256]
	fmul	DWORD PTR [eax]
	fld	DWORD PTR _elderCoords$12200[esp+264]
	fmul	DWORD PTR [eax+8]
	mov	edx, DWORD PTR $T19283[esp+236]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _elderCoords$12200[esp+260]
	fmul	DWORD PTR [eax+4]
	mov	DWORD PTR [esi], ecx
	mov	DWORD PTR [esi+4], edx
	mov	edx, DWORD PTR $T19282[esp+232]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR $T19283[esp+240]
	mov	ecx, DWORD PTR $T19283[esp+240]
	mov	DWORD PTR [esi+8], ecx
	mov	ecx, DWORD PTR $T19282[esp+236]
	mov	DWORD PTR [esi+12], edx
	mov	edx, DWORD PTR $T19282[esp+240]
	fxch	ST(1)
	mov	DWORD PTR [esi+16], ecx
	mov	ecx, DWORD PTR $T19281[esp+240]
	mov	DWORD PTR [esi+20], edx
	mov	edx, DWORD PTR $T19252[esp+240]
	fstp	DWORD PTR [esi+24]
	mov	DWORD PTR [esi+32], ecx
	mov	ecx, DWORD PTR $T19251[esp+240]
	fstp	DWORD PTR [esi+28]
	fxch	ST(1)
	fstp	DWORD PTR [esi+36]
	mov	DWORD PTR [esi+44], edx
	fstp	DWORD PTR [esi+40]
	fxch	ST(1)
	fstp	DWORD PTR [esi+48]
	mov	DWORD PTR [esi+56], ecx
	fstp	DWORD PTR [esi+52]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [esi+60], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [esi+64], ecx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [esi+68], edx
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [esi+72], ecx
	mov	edx, DWORD PTR [eax+16]
	mov	DWORD PTR [esi+76], edx
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR [esi+80], ecx
	mov	edx, DWORD PTR [eax+24]
	mov	DWORD PTR [esi+84], edx
	mov	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR [esi+88], ecx
	mov	edx, DWORD PTR [eax+32]
	mov	DWORD PTR [esi+92], edx
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [esi+96], ecx
	mov	edx, DWORD PTR [eax+40]
	mov	DWORD PTR [esi+100], edx
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR [esi+104], ecx
	mov	edx, DWORD PTR [eax+48]
	mov	DWORD PTR [esi+108], edx
	mov	ecx, DWORD PTR [eax+52]
	mov	DWORD PTR [esi+112], ecx
	mov	edx, DWORD PTR [eax+56]
	mov	DWORD PTR [esi+116], edx
	mov	ecx, DWORD PTR [esi+132]
	test	ecx, ecx
	je	SHORT $L12207
	push	0
	call	?ValidateAbs@CMacBone@@IAEX_N@Z		; CMacBone::ValidateAbs
	pop	esi

; 233  : 	}
; 234  : }

	add	esp, 228				; 000000e4H
	ret	8
$L12199:

; 221  : 		// Set absolute since we have it
; 222  : 		mAbsCoords = inCoords;
; 223  : 		// Only invalidate absolute from the children down
; 224  : 		if (mFirstChild)
; 225  : 			mFirstChild->ValidateAbs(false);
; 226  : 	}
; 227  : 	else
; 228  : 	{
; 229  : 		// Set relative since we have it
; 230  : 		mRelCoords = inCoords;

	mov	eax, DWORD PTR _inCoords$[esp+228]

; 231  : 		// Invalidate absolute from here down
; 232  : 		ValidateAbs(false);

	push	0
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [esi], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [esi+4], edx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [esi+8], ecx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [esi+12], edx
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [esi+16], ecx
	mov	edx, DWORD PTR [eax+20]
	mov	DWORD PTR [esi+20], edx
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR [esi+24], ecx
	mov	edx, DWORD PTR [eax+28]
	mov	DWORD PTR [esi+28], edx
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR [esi+32], ecx
	mov	edx, DWORD PTR [eax+36]
	mov	DWORD PTR [esi+36], edx
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR [esi+40], ecx
	mov	edx, DWORD PTR [eax+44]
	mov	DWORD PTR [esi+44], edx
	mov	ecx, DWORD PTR [eax+48]
	mov	DWORD PTR [esi+48], ecx
	mov	edx, DWORD PTR [eax+52]
	mov	DWORD PTR [esi+52], edx
	mov	eax, DWORD PTR [eax+56]
	mov	ecx, esi
	mov	DWORD PTR [esi+56], eax
	call	?ValidateAbs@CMacBone@@IAEX_N@Z		; CMacBone::ValidateAbs
$L12207:
	pop	esi

; 233  : 	}
; 234  : }

	add	esp, 228				; 000000e4H
	ret	8
?SetCoords@CMacBone@@QAEXABVVCoords3@@_N@Z ENDP		; CMacBone::SetCoords
_TEXT	ENDS
PUBLIC	?ResetCoords@CMacBone@@QAEXXZ			; CMacBone::ResetCoords
; Function compile flags: /Ogty
;	COMDAT ?ResetCoords@CMacBone@@QAEXXZ
_TEXT	SEGMENT
?ResetCoords@CMacBone@@QAEXXZ PROC NEAR			; CMacBone::ResetCoords, COMDAT
; _this$ = ecx

; 237  : 	SetCoords(mSklBone->baseCoords, false);

	mov	eax, DWORD PTR [ecx+124]
	push	0
	add	eax, 12					; 0000000cH
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], edx
	mov	edx, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+16], edx
	mov	edx, DWORD PTR [eax+20]
	mov	DWORD PTR [ecx+20], edx
	mov	edx, DWORD PTR [eax+24]
	mov	DWORD PTR [ecx+24], edx
	mov	edx, DWORD PTR [eax+28]
	mov	DWORD PTR [ecx+28], edx
	mov	edx, DWORD PTR [eax+32]
	mov	DWORD PTR [ecx+32], edx
	mov	edx, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx+36], edx
	mov	edx, DWORD PTR [eax+40]
	mov	DWORD PTR [ecx+40], edx
	mov	edx, DWORD PTR [eax+44]
	mov	DWORD PTR [ecx+44], edx
	mov	edx, DWORD PTR [eax+48]
	mov	DWORD PTR [ecx+48], edx
	mov	edx, DWORD PTR [eax+52]
	mov	DWORD PTR [ecx+52], edx
	mov	eax, DWORD PTR [eax+56]
	mov	DWORD PTR [ecx+56], eax
	call	?ValidateAbs@CMacBone@@IAEX_N@Z		; CMacBone::ValidateAbs

; 238  : }

	ret	0
?ResetCoords@CMacBone@@QAEXXZ ENDP			; CMacBone::ResetCoords
_TEXT	ENDS
PUBLIC	??0CObjClass@@QAE@XZ				; CObjClass::CObjClass
EXTRN	_atexit:NEAR
; Function compile flags: /Ogty
;	COMDAT _$E85
_TEXT	SEGMENT
_$E85	PROC NEAR					; COMDAT
	mov	ecx, OFFSET FLAT:?OMacActor_objClassInstance@@3VCObjClass@@A
	call	??0CObjClass@@QAE@XZ			; CObjClass::CObjClass
	push	OFFSET FLAT:_$E83
	call	_atexit
	pop	ecx
	ret	0
_$E85	ENDP
_TEXT	ENDS
EXTRN	??1CObjClass@@QAE@XZ:NEAR			; CObjClass::~CObjClass
; Function compile flags: /Ogty
;	COMDAT _$E83
_TEXT	SEGMENT
_$E83	PROC NEAR					; COMDAT
	mov	ecx, OFFSET FLAT:?OMacActor_objClassInstance@@3VCObjClass@@A
	jmp	??1CObjClass@@QAE@XZ			; CObjClass::~CObjClass
_$E83	ENDP
_TEXT	ENDS
PUBLIC	??_C@_07ILDF@OObject?$AA@			; `string'
PUBLIC	?New@OMacActor@@SAPAV1@PAVOObject@@PAVCObjClass@@@Z ; OMacActor::New
EXTRN	?OBJ_ConstructClass@@YAPAVCObjClass@@PAV1@PBD1P6APAVOObject@@PAV2@0@ZK@Z:NEAR ; OBJ_ConstructClass
;	COMDAT ??_C@_07ILDF@OObject?$AA@
_DATA	SEGMENT
??_C@_07ILDF@OObject?$AA@ DB 'OObject', 00H		; `string'
; Function compile flags: /Ogty
_DATA	ENDS
;	COMDAT _$E88
_TEXT	SEGMENT
_$E88	PROC NEAR					; COMDAT
	push	0
	push	OFFSET FLAT:?New@OMacActor@@SAPAV1@PAVOObject@@PAVCObjClass@@@Z ; OMacActor::New
	push	OFFSET FLAT:??_C@_07ILDF@OObject?$AA@	; `string'
	push	OFFSET FLAT:??_C@_09OANE@OMacActor?$AA@	; `string'
	push	OFFSET FLAT:?OMacActor_objClassInstance@@3VCObjClass@@A ; OMacActor_objClassInstance
	call	?OBJ_ConstructClass@@YAPAVCObjClass@@PAV1@PBD1P6APAVOObject@@PAV2@0@ZK@Z ; OBJ_ConstructClass
	add	esp, 20					; 00000014H
	mov	DWORD PTR ?staticObjClass@OMacActor@@0PAVCObjClass@@A, eax ; OMacActor::staticObjClass
	ret	0
_$E88	ENDP
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT _$E94
_TEXT	SEGMENT
_$E94	PROC NEAR					; COMDAT
	mov	eax, OFFSET FLAT:?sHeadLink@CMacActorLink@@0V1@A
	push	OFFSET FLAT:_$E91
	mov	DWORD PTR ?sHeadLink@CMacActorLink@@0V1@A+8, eax
	mov	DWORD PTR ?sHeadLink@CMacActorLink@@0V1@A+4, eax
	call	_atexit
	pop	ecx
	ret	0
_$E94	ENDP
_TEXT	ENDS
_BSS	SEGMENT
	ALIGN	4

_$S92	DB	01H DUP (?)
; Function compile flags: /Ogty
_BSS	ENDS
;	COMDAT _$E91
_TEXT	SEGMENT
_$E91	PROC NEAR					; COMDAT
	mov	cl, BYTE PTR _$S92
	mov	al, 1
	test	cl, al
	jne	SHORT $L20491
	or	cl, al
	mov	eax, DWORD PTR ?sHeadLink@CMacActorLink@@0V1@A+8
	mov	BYTE PTR _$S92, cl
	mov	ecx, DWORD PTR ?sHeadLink@CMacActorLink@@0V1@A+4
	mov	DWORD PTR [eax+4], ecx
	mov	eax, DWORD PTR ?sHeadLink@CMacActorLink@@0V1@A+4
	mov	edx, DWORD PTR ?sHeadLink@CMacActorLink@@0V1@A+8
	mov	DWORD PTR [eax+8], edx
	mov	eax, OFFSET FLAT:?sHeadLink@CMacActorLink@@0V1@A
	mov	DWORD PTR ?sHeadLink@CMacActorLink@@0V1@A+8, eax
	mov	DWORD PTR ?sHeadLink@CMacActorLink@@0V1@A+4, eax
$L20491:
	ret	0
_$E91	ENDP
_TEXT	ENDS
PUBLIC	??_C@_03HJPD@GEO?$AA@				; `string'
PUBLIC	??_C@_03CNNB@SKL?$AA@				; `string'
PUBLIC	??_C@_03CMHN@LOD?$AA@				; `string'
PUBLIC	??_C@_03OFBA@SRF?$AA@				; `string'
PUBLIC	??_C@_03HFDH@FRM?$AA@				; `string'
PUBLIC	??_C@_03BCHJ@SEQ?$AA@				; `string'
PUBLIC	?MsgGetChild@OMacActor@@UAEPAVIMsgTarget@@PAD@Z	; OMacActor::MsgGetChild
EXTRN	__imp__strnicmp:NEAR
EXTRN	__imp__atoi:NEAR
EXTRN	?MsgGetChild@OObject@@UAEPAVIMsgTarget@@PAD@Z:NEAR ; OObject::MsgGetChild
;	COMDAT ??_C@_03HJPD@GEO?$AA@
; File C:\duke4\Cannibal\CorMain.h
_DATA	SEGMENT
??_C@_03HJPD@GEO?$AA@ DB 'GEO', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_03CNNB@SKL?$AA@
_DATA	SEGMENT
??_C@_03CNNB@SKL?$AA@ DB 'SKL', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_03CMHN@LOD?$AA@
_DATA	SEGMENT
??_C@_03CMHN@LOD?$AA@ DB 'LOD', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_03OFBA@SRF?$AA@
_DATA	SEGMENT
??_C@_03OFBA@SRF?$AA@ DB 'SRF', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_03HFDH@FRM?$AA@
_DATA	SEGMENT
??_C@_03HFDH@FRM?$AA@ DB 'FRM', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_03BCHJ@SEQ?$AA@
_DATA	SEGMENT
??_C@_03BCHJ@SEQ?$AA@ DB 'SEQ', 00H			; `string'
; Function compile flags: /Ogty
; File C:\duke4\Cannibal\MacMain.cpp
_DATA	ENDS
;	COMDAT ?MsgGetChild@OMacActor@@UAEPAVIMsgTarget@@PAD@Z
_TEXT	SEGMENT
_inChildName$ = 8
?MsgGetChild@OMacActor@@UAEPAVIMsgTarget@@PAD@Z PROC NEAR ; OMacActor::MsgGetChild, COMDAT
; _this$ = ecx

; 248  : {

	push	ebx
	push	esi

; 249  : 	NDword index;
; 250  : 
; 251  : 	if (!inChildName)

	mov	esi, DWORD PTR _inChildName$[esp+4]
	push	edi
	test	esi, esi
	mov	edi, ecx
	jne	SHORT $L12244
	pop	edi
	pop	esi

; 252  : 		return(NULL);

	xor	eax, eax
	pop	ebx

; 281  : }

	ret	4
$L12244:

; 253  : 	if (!stricmp(inChildName, "GEO"))

	mov	ebx, DWORD PTR __imp__stricmp
	push	OFFSET FLAT:??_C@_03HJPD@GEO?$AA@	; `string'
	push	esi
	call	ebx
	add	esp, 8
	test	eax, eax
	jne	SHORT $L12245

; 254  : 		return(mGeometry);

	mov	eax, DWORD PTR [edi+140]
	pop	edi
	pop	esi
	pop	ebx

; 281  : }

	ret	4
$L12245:

; 255  : 	if (!stricmp(inChildName, "SKL"))

	push	OFFSET FLAT:??_C@_03CNNB@SKL?$AA@	; `string'
	push	esi
	call	ebx
	add	esp, 8
	test	eax, eax
	jne	SHORT $L12247

; 256  : 		return(mSkeleton);

	mov	eax, DWORD PTR [edi+144]
	pop	edi
	pop	esi
	pop	ebx

; 281  : }

	ret	4
$L12247:

; 257  : 	if (!stricmp(inChildName, "LOD"))

	push	OFFSET FLAT:??_C@_03CMHN@LOD?$AA@	; `string'
	push	esi
	call	ebx
	add	esp, 8
	test	eax, eax
	jne	SHORT $L12249

; 258  : 		return(mLodData);

	mov	eax, DWORD PTR [edi+148]
	pop	edi
	pop	esi
	pop	ebx

; 281  : }

	ret	4
$L12249:

; 259  : 	if (!strnicmp(inChildName, "SRF", 3))

	mov	ebx, DWORD PTR __imp__strnicmp
	push	3
	push	OFFSET FLAT:??_C@_03OFBA@SRF?$AA@	; `string'
	push	esi
	call	ebx
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $L12251

; 260  : 	{
; 261  : 		index=atoi(inChildName+3);

	add	esi, 3
	push	esi
	call	DWORD PTR __imp__atoi

; 262  : 		if (index >= mSurfaces.GetCount())

	mov	ecx, DWORD PTR [edi+156]
	add	esp, 4
	cmp	eax, ecx
	jb	SHORT $L12253
	pop	edi
	pop	esi

; 263  : 			return(NULL);

	xor	eax, eax
	pop	ebx

; 281  : }

	ret	4
$L12253:

; 264  : 		return(mSurfaces[index]);

	mov	ecx, DWORD PTR [edi+152]
	pop	edi
	pop	esi
	pop	ebx
	mov	eax, DWORD PTR [ecx+eax*4]

; 281  : }

	ret	4
$L12251:

; 265  : 	}
; 266  : 	if (!strnicmp(inChildName, "FRM", 3))

	push	3
	push	OFFSET FLAT:??_C@_03HFDH@FRM?$AA@	; `string'
	push	esi
	call	ebx
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $L12254

; 267  : 	{
; 268  : 		index=atoi(inChildName+3);

	add	esi, 3
	push	esi
	call	DWORD PTR __imp__atoi

; 269  : 		if (index >= mFrames.GetCount())

	mov	ecx, DWORD PTR [edi+172]
	add	esp, 4
	cmp	eax, ecx
	jb	SHORT $L12256
	pop	edi
	pop	esi

; 270  : 			return(NULL);

	xor	eax, eax
	pop	ebx

; 281  : }

	ret	4
$L12256:

; 271  : 		return(mFrames[index]);

	mov	edx, DWORD PTR [edi+168]
	pop	edi
	pop	esi
	pop	ebx
	mov	eax, DWORD PTR [edx+eax*4]

; 281  : }

	ret	4
$L12254:

; 272  : 	}
; 273  : 	if (!strnicmp(inChildName, "SEQ", 3))

	push	3
	push	OFFSET FLAT:??_C@_03BCHJ@SEQ?$AA@	; `string'
	push	esi
	call	ebx
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $L12257

; 274  : 	{
; 275  : 		index=atoi(inChildName+3);

	add	esi, 3
	push	esi
	call	DWORD PTR __imp__atoi

; 276  : 		if (index >= mSequences.GetCount())

	mov	ecx, DWORD PTR [edi+188]
	add	esp, 4
	cmp	eax, ecx
	jb	SHORT $L12259
	pop	edi
	pop	esi

; 277  : 			return(NULL);

	xor	eax, eax
	pop	ebx

; 281  : }

	ret	4
$L12259:

; 278  : 		return(mSequences[index]);

	mov	ecx, DWORD PTR [edi+184]
	pop	edi
	pop	esi
	pop	ebx
	mov	eax, DWORD PTR [ecx+eax*4]

; 281  : }

	ret	4
$L12257:

; 279  : 	}
; 280  : 	return(Super::MsgGetChild(inChildName));

	push	esi
	mov	ecx, edi
	call	?MsgGetChild@OObject@@UAEPAVIMsgTarget@@PAD@Z ; OObject::MsgGetChild
	pop	edi
	pop	esi
	pop	ebx

; 281  : }

	ret	4
?MsgGetChild@OMacActor@@UAEPAVIMsgTarget@@PAD@Z ENDP	; OMacActor::MsgGetChild
_TEXT	ENDS
PUBLIC	?Create@OMacActor@@UAEXXZ			; OMacActor::Create
PUBLIC	?LoadConfig@OMacActor@@QAE_NPAVOCpjConfig@@@Z	; OMacActor::LoadConfig
EXTRN	?Create@OObject@@UAEXXZ:NEAR			; OObject::Create
; Function compile flags: /Ogty
;	COMDAT ?Create@OMacActor@@UAEXXZ
_TEXT	SEGMENT
?Create@OMacActor@@UAEXXZ PROC NEAR			; OMacActor::Create, COMDAT
; _this$ = ecx

; 283  : {

	push	ebx
	push	esi
	push	edi
	mov	esi, ecx

; 284  : 	Super::Create();

	call	?Create@OObject@@UAEXXZ			; OObject::Create

; 285  : 
; 286  : 	mActorLink.SetActor(this);
; 287  : 
; 288  : 	mOrigin			= VVec3(0,0,0);

	xor	ebx, ebx
	mov	DWORD PTR [esi+56], esi

; 289  : 	mScale			= VVec3(1,1,1);

	mov	eax, 1065353216				; 3f800000H
	mov	DWORD PTR [esi+80], ebx
	mov	DWORD PTR [esi+84], ebx
	mov	DWORD PTR [esi+88], ebx
	mov	DWORD PTR [esi+92], eax
	mov	DWORD PTR [esi+96], eax
	mov	DWORD PTR [esi+100], eax

; 290  : 	mRotation		= VEulers3(0,0,0);
; 291  : 	mBounds[0]		= VVec3(-1,-1,-1);

	mov	ecx, -1082130432			; bf800000H
	mov	DWORD PTR [esi+104], ebx
	mov	DWORD PTR [esi+108], ebx
	mov	DWORD PTR [esi+112], ebx
	mov	DWORD PTR [esi+116], ecx
	mov	DWORD PTR [esi+120], ecx
	mov	DWORD PTR [esi+124], ecx

; 292  : 	mBounds[1]		= VVec3(1,1,1);

	mov	DWORD PTR [esi+128], eax
	mov	DWORD PTR [esi+132], eax
	mov	DWORD PTR [esi+136], eax

; 293  : 	LastEvalFrame	= 0;

	mov	DWORD PTR [esi+264], ebx

; 294  : 	bBonesDirty		= true;

	mov	BYTE PTR [esi+268], 1

; 295  : 
; 296  : 	mActorChannels.AddZeroed(MAC_NUMCHANNELS);

	mov	edi, DWORD PTR [esi+292]
	mov	ecx, DWORD PTR [esi+296]
	lea	eax, DWORD PTR [edi+16]
	cmp	eax, ecx
	mov	DWORD PTR [esi+292], eax
	jbe	SHORT $L20604
	mov	ecx, eax
	mov	DWORD PTR [esi+300], 4
	shr	ecx, 2
	lea	eax, DWORD PTR [ecx+eax+32]
	mov	ecx, DWORD PTR [esi+288]
	cmp	ecx, ebx
	mov	DWORD PTR [esi+296], eax
	je	SHORT $L20597
	cmp	eax, ebx
	je	SHORT $L20599
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+296]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [esi+300]
	push	ecx
	mov	ecx, DWORD PTR [esi+288]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+4]
	mov	DWORD PTR [esi+288], eax
	jmp	SHORT $L20604
$L20599:
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+288]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L20603:
	mov	DWORD PTR [esi+288], ebx
$L20604:
	mov	edx, DWORD PTR [esi+288]
	mov	ecx, 16					; 00000010H
	xor	eax, eax

; 297  : 	
; 298  : 	LoadConfig(NULL);

	push	ebx
	lea	edi, DWORD PTR [edx+edi*4]
	rep stosd
	mov	ecx, esi
	call	?LoadConfig@OMacActor@@QAE_NPAVOCpjConfig@@@Z ; OMacActor::LoadConfig
	pop	edi
	pop	esi
	pop	ebx

; 299  : }

	ret	0
$L20597:

; 295  : 
; 296  : 	mActorChannels.AddZeroed(MAC_NUMCHANNELS);

	cmp	eax, ebx
	je	SHORT $L20603
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+296]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [esi+300]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	DWORD PTR [esi+288], eax
	jmp	SHORT $L20604
?Create@OMacActor@@UAEXXZ ENDP				; OMacActor::Create
_TEXT	ENDS
PUBLIC	?FindBone@OMacActor@@QAEPAVCMacBone@@PBD@Z	; OMacActor::FindBone
EXTRN	?STR_CalcHash@@YAKPAD@Z:NEAR			; STR_CalcHash
; Function compile flags: /Ogty
;	COMDAT ?FindBone@OMacActor@@QAEPAVCMacBone@@PBD@Z
_TEXT	SEGMENT
_inName$ = 8
_hash$ = -4
?FindBone@OMacActor@@QAEPAVCMacBone@@PBD@Z PROC NEAR	; OMacActor::FindBone, COMDAT
; _this$ = ecx

; 302  : {

	push	ecx

; 303  : 	if (!inName || !mSkeleton)

	mov	eax, DWORD PTR _inName$[esp]
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, ecx
	test	eax, eax
	je	SHORT $L12273
	mov	ecx, DWORD PTR [edi+144]
	test	ecx, ecx
	je	SHORT $L12273

; 305  : 	NDword hash = STR_CalcHash((NChar*)inName);

	push	eax
	call	?STR_CalcHash@@YAKPAD@Z			; STR_CalcHash
	mov	DWORD PTR _hash$[esp+24], eax

; 306  : 	for (NDword i=0;i<mActorBones.GetCount();i++)

	mov	eax, DWORD PTR [edi+276]
	add	esp, 4
	xor	ebp, ebp
	test	eax, eax
	jbe	SHORT $L12273

; 305  : 	NDword hash = STR_CalcHash((NChar*)inName);

	xor	ebx, ebx
$L12277:

; 307  : 	{
; 308  : 		CMacBone* bone = &mActorBones[i];

	mov	esi, DWORD PTR [edi+272]

; 309  : 		if (bone->mSklBone->nameHash != hash)

	mov	ecx, DWORD PTR _hash$[esp+20]
	add	esi, ebx
	mov	eax, DWORD PTR [esi+124]
	cmp	DWORD PTR [eax+4], ecx
	jne	SHORT $L12278

; 310  : 			continue;
; 311  : 		if (stricmp(*bone->mSklBone->name, inName))

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	jne	SHORT $L20631
	mov	eax, OFFSET FLAT:??_C@_00A@?$AA@	; `string'
$L20631:
	mov	edx, DWORD PTR _inName$[esp+16]
	push	edx
	push	eax
	call	DWORD PTR __imp__stricmp
	add	esp, 8
	test	eax, eax
	je	SHORT $L12282
$L12278:

; 306  : 	for (NDword i=0;i<mActorBones.GetCount();i++)

	mov	eax, DWORD PTR [edi+276]
	inc	ebp
	add	ebx, 140				; 0000008cH
	cmp	ebp, eax
	jb	SHORT $L12277
$L12273:
	pop	edi
	pop	esi
	pop	ebp

; 304  : 		return(NULL);

	xor	eax, eax
	pop	ebx

; 314  : 	}
; 315  : 	return(NULL);
; 316  : }

	pop	ecx
	ret	4
$L12282:

; 312  : 			continue;
; 313  : 		return(bone);

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 314  : 	}
; 315  : 	return(NULL);
; 316  : }

	pop	ecx
	ret	4
?FindBone@OMacActor@@QAEPAVCMacBone@@PBD@Z ENDP		; OMacActor::FindBone
_TEXT	ENDS
PUBLIC	?FindFrame@OMacActor@@QAEPAVCCpjFrmFrame@@PBD@Z	; OMacActor::FindFrame
; Function compile flags: /Ogty
;	COMDAT ?FindFrame@OMacActor@@QAEPAVCCpjFrmFrame@@PBD@Z
_TEXT	SEGMENT
_inName$ = 8
_hash$ = -4
?FindFrame@OMacActor@@QAEPAVCCpjFrmFrame@@PBD@Z PROC NEAR ; OMacActor::FindFrame, COMDAT
; _this$ = ecx

; 319  : 	if (!inName)

	mov	eax, DWORD PTR _inName$[esp-4]
	sub	esp, 8
	test	eax, eax
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	ebp, ecx

; 320  : 		return(NULL);

	je	$L12293

; 321  : 	NDword hash = STR_CalcHash((NChar*)inName);

	push	eax
	call	?STR_CalcHash@@YAKPAD@Z			; STR_CalcHash
	mov	DWORD PTR _hash$[esp+28], eax

; 322  : 	for (NDword i=0;i<mFrames.GetCount();i++)

	mov	eax, DWORD PTR [ebp+172]
	add	esp, 4
	xor	ebx, ebx
	test	eax, eax
	jbe	$L12293
$L12291:

; 323  : 	{
; 324  : 		if (!mFrames[i])

	mov	eax, DWORD PTR [ebp+168]
	xor	edi, edi
	mov	ecx, DWORD PTR [eax+ebx*4]
	cmp	ecx, edi
	je	SHORT $L12292

; 325  : 			continue;
; 326  : 		mFrames[i]->CacheIn();

	call	?CacheIn@OCpjChunk@@QAE_NXZ		; OCpjChunk::CacheIn
	mov	ecx, DWORD PTR [ebp+168]

; 327  : 		for (NDword j=0;j<mFrames[i]->m_Frames.GetCount();j++)

	mov	edx, DWORD PTR [ecx+ebx*4]
	lea	eax, DWORD PTR [ecx+ebx*4]
	cmp	DWORD PTR [edx+100], edi
	jbe	SHORT $L12292

; 325  : 			continue;
; 326  : 		mFrames[i]->CacheIn();

	mov	DWORD PTR -8+[esp+24], edi
$L12296:

; 328  : 		{
; 329  : 			CCpjFrmFrame* frm = &mFrames[i]->m_Frames[j];

	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR -8+[esp+24]
	mov	esi, DWORD PTR [eax+96]

; 330  : 			if (frm->m_NameHash != hash)

	mov	eax, DWORD PTR [esi+ecx+4]
	add	esi, ecx
	mov	ecx, DWORD PTR _hash$[esp+24]
	cmp	eax, ecx
	jne	SHORT $L12297

; 331  : 				continue;
; 332  : 			if (stricmp(*frm->m_Name, inName))

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $L20672
	mov	eax, OFFSET FLAT:??_C@_00A@?$AA@	; `string'
$L20672:
	mov	edx, DWORD PTR _inName$[esp+20]
	push	edx
	push	eax
	call	DWORD PTR __imp__stricmp
	add	esp, 8
	test	eax, eax
	je	SHORT $L12301
$L12297:

; 327  : 		for (NDword j=0;j<mFrames[i]->m_Frames.GetCount();j++)

	mov	eax, DWORD PTR [ebp+168]
	mov	esi, DWORD PTR -8+[esp+24]
	inc	edi
	add	esi, 84					; 00000054H
	mov	ecx, DWORD PTR [eax+ebx*4]
	lea	eax, DWORD PTR [eax+ebx*4]
	mov	DWORD PTR -8+[esp+24], esi
	cmp	edi, DWORD PTR [ecx+100]
	jb	SHORT $L12296
$L12292:

; 322  : 	for (NDword i=0;i<mFrames.GetCount();i++)

	mov	eax, DWORD PTR [ebp+172]
	inc	ebx
	cmp	ebx, eax
	jb	$L12291
$L12293:
	pop	edi
	pop	esi
	pop	ebp

; 335  : 		}
; 336  : 	}
; 337  : 	return(NULL);

	xor	eax, eax
	pop	ebx

; 338  : }

	add	esp, 8
	ret	4
$L12301:

; 333  : 				continue;
; 334  : 			return(frm);

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 338  : }

	add	esp, 8
	ret	4
?FindFrame@OMacActor@@QAEPAVCCpjFrmFrame@@PBD@Z ENDP	; OMacActor::FindFrame
_TEXT	ENDS
PUBLIC	?FindSequence@OMacActor@@QAEPAVOCpjSequence@@PBD@Z ; OMacActor::FindSequence
; Function compile flags: /Ogty
;	COMDAT ?FindSequence@OMacActor@@QAEPAVOCpjSequence@@PBD@Z
_TEXT	SEGMENT
_inName$ = 8
_hash$ = 8
?FindSequence@OMacActor@@QAEPAVOCpjSequence@@PBD@Z PROC NEAR ; OMacActor::FindSequence, COMDAT
; _this$ = ecx

; 340  : {

	push	ebx
	push	ebp

; 341  : 	if (!inName)

	mov	ebp, DWORD PTR _inName$[esp+4]
	push	esi
	test	ebp, ebp
	push	edi
	mov	ebx, ecx

; 342  : 		return(NULL);

	je	SHORT $L12312

; 343  : 	NDword hash = STR_CalcHash((NChar*)inName);

	push	ebp
	call	?STR_CalcHash@@YAKPAD@Z			; STR_CalcHash
	mov	DWORD PTR _hash$[esp+16], eax

; 344  : 	for (NDword i=0;i<mSequences.GetCount();i++)

	mov	eax, DWORD PTR [ebx+188]
	add	esp, 4
	xor	edi, edi
	test	eax, eax
	jbe	SHORT $L12312
$L12310:

; 345  : 	{
; 346  : 		OCpjSequence* seq = mSequences[i];

	mov	eax, DWORD PTR [ebx+184]
	mov	esi, DWORD PTR [eax+edi*4]

; 347  : 		if (!seq)

	test	esi, esi
	je	SHORT $L12311

; 348  : 			continue;
; 349  : 		if (hash != seq->GetNameHash())

	mov	ecx, DWORD PTR _hash$[esp+12]
	mov	eax, DWORD PTR [esi+48]
	cmp	ecx, eax
	jne	SHORT $L12311

; 350  : 			continue;
; 351  : 		if (stricmp(inName, seq->GetName()))

	mov	eax, DWORD PTR [esi+44]
	test	eax, eax
	jne	SHORT $L20710
	mov	eax, OFFSET FLAT:??_C@_00A@?$AA@	; `string'
$L20710:
	push	eax
	push	ebp
	call	DWORD PTR __imp__stricmp
	add	esp, 8
	test	eax, eax
	je	SHORT $L12316
$L12311:

; 344  : 	for (NDword i=0;i<mSequences.GetCount();i++)

	mov	eax, DWORD PTR [ebx+188]
	inc	edi
	cmp	edi, eax
	jb	SHORT $L12310
$L12312:
	pop	edi
	pop	esi
	pop	ebp

; 355  : 	}
; 356  : 	return(NULL);

	xor	eax, eax
	pop	ebx

; 357  : }

	ret	4
$L12316:

; 352  : 			continue;
; 353  : 		seq->CacheIn();

	mov	ecx, esi
	call	?CacheIn@OCpjChunk@@QAE_NXZ		; OCpjChunk::CacheIn

; 354  : 		return(seq);

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 357  : }

	ret	4
?FindSequence@OMacActor@@QAEPAVOCpjSequence@@PBD@Z ENDP	; OMacActor::FindSequence
_TEXT	ENDS
PUBLIC	?SetGeometry@OMacActor@@QAE_NPAVOCpjGeometry@@@Z ; OMacActor::SetGeometry
; Function compile flags: /Ogty
;	COMDAT ?SetGeometry@OMacActor@@QAE_NPAVOCpjGeometry@@@Z
_TEXT	SEGMENT
_inGeometry$ = 8
?SetGeometry@OMacActor@@QAE_NPAVOCpjGeometry@@@Z PROC NEAR ; OMacActor::SetGeometry, COMDAT
; _this$ = ecx

; 361  : 	mGeometry = inGeometry;

	mov	eax, DWORD PTR _inGeometry$[esp-4]

; 362  : 	if (!mGeometry)

	test	eax, eax
	mov	DWORD PTR [ecx+140], eax
	jne	SHORT $L12321

; 363  : 		return(0);

	xor	al, al

; 366  : }

	ret	4
$L12321:

; 364  : 	mGeometry->CacheIn();

	mov	ecx, eax
	call	?CacheIn@OCpjChunk@@QAE_NXZ		; OCpjChunk::CacheIn

; 365  : 	return(1);

	mov	al, 1

; 366  : }

	ret	4
?SetGeometry@OMacActor@@QAE_NPAVOCpjGeometry@@@Z ENDP	; OMacActor::SetGeometry
_TEXT	ENDS
PUBLIC	?Add@?$TCorArray@VCMacBone@@@@QAEKK@Z		; TCorArray<CMacBone>::Add
PUBLIC	?Remove@?$TCorArray@VCMacBone@@@@QAEXKK@Z	; TCorArray<CMacBone>::Remove
; Function compile flags: /Ogty
;	COMDAT ?SetSkeleton@OMacActor@@QAE_NPAVOCpjSkeleton@@@Z
_TEXT	SEGMENT
_inSkeleton$ = 8
_i$ = 8
?SetSkeleton@OMacActor@@QAE_NPAVOCpjSkeleton@@@Z PROC NEAR ; OMacActor::SetSkeleton, COMDAT
; _this$ = ecx

; 368  : {

	push	ecx

; 369  : 	// clear out old bones
; 370  : 	mSkeleton = inSkeleton;

	mov	eax, DWORD PTR _inSkeleton$[esp]
	push	ebx
	push	esi
	mov	esi, ecx
	push	edi

; 371  : 	mActorBones.Purge(); mActorBones.Shrink();

	xor	ebx, ebx
	lea	edi, DWORD PTR [esi+272]
	mov	DWORD PTR [esi+144], eax
	mov	ecx, DWORD PTR [edi+4]
	push	ecx
	push	ebx
	mov	ecx, edi
	call	?Remove@?$TCorArray@VCMacBone@@@@QAEXKK@Z ; TCorArray<CMacBone>::Remove
	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi+8]
	cmp	ecx, eax
	je	SHORT $L20728
	push	140					; 0000008cH
	mov	ecx, edi
	mov	DWORD PTR [edi+8], eax
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
$L20728:

; 372  : 	if (!mSkeleton)

	mov	ecx, DWORD PTR [esi+144]
	cmp	ecx, ebx
	jne	SHORT $L12326
	pop	edi
	pop	esi

; 373  : 		return(0);

	xor	al, al
	pop	ebx

; 407  : }

	pop	ecx
	ret	4
$L12326:
	push	ebp

; 374  : 	mSkeleton->CacheIn();

	call	?CacheIn@OCpjChunk@@QAE_NXZ		; OCpjChunk::CacheIn

; 375  : 
; 376  : 	// add the same number of bones as the skeleton
; 377  : 	mActorBones.Add(mSkeleton->m_Bones.GetCount());

	mov	edx, DWORD PTR [esi+144]
	mov	ecx, edi
	mov	eax, DWORD PTR [edx+76]
	push	eax
	call	?Add@?$TCorArray@VCMacBone@@@@QAEKK@Z	; TCorArray<CMacBone>::Add

; 378  : 	
; 379  : 	// set up parents
; 380  : 	for (NDword i=0;i<mActorBones.GetCount();i++)

	mov	eax, DWORD PTR [esi+276]
	mov	DWORD PTR _i$[esp+16], ebx
	cmp	eax, ebx
	jbe	$L12330

; 374  : 	mSkeleton->CacheIn();

	xor	ebp, ebp
$L12328:

; 381  : 	{
; 382  : 		CMacBone* bone = &mActorBones[i];		
; 383  : 		bone->mSklBone = &mSkeleton->m_Bones[i];

	mov	edx, DWORD PTR [esi+144]
	mov	ecx, DWORD PTR [edi]
	add	ecx, ebx
	mov	eax, DWORD PTR [edx+72]

; 384  : 		bone->mParent = NULL;

	xor	edx, edx
	add	eax, ebp
	mov	DWORD PTR [ecx+128], edx
	mov	DWORD PTR [ecx+124], eax

; 385  : 		if (bone->mSklBone->parentBone)

	mov	eax, DWORD PTR [eax+8]
	cmp	eax, edx
	je	SHORT $L12332

; 386  : 			bone->mParent = &mActorBones[bone->mSklBone->parentBone - &mSkeleton->m_Bones[0]];

	mov	edx, DWORD PTR [esi+144]
	sub	eax, DWORD PTR [edx+72]
	mov	edx, eax
	mov	eax, 1808407283				; 6bca1af3H
	imul	edx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	edx, eax
	lea	eax, DWORD PTR [edx*8]
	sub	eax, edx
	lea	edx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR [edi]
	lea	edx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR [ecx+128], edx
	xor	edx, edx
$L12332:
	mov	eax, DWORD PTR _i$[esp+16]

; 387  : 		bone->mFirstChild = bone->mNextSibling = NULL;

	mov	DWORD PTR [ecx+136], edx
	mov	DWORD PTR [ecx+132], edx
	mov	ecx, DWORD PTR [esi+276]
	inc	eax
	add	ebx, 140				; 0000008cH
	add	ebp, 76					; 0000004cH
	cmp	eax, ecx
	mov	DWORD PTR _i$[esp+16], eax
	jb	SHORT $L12328
$L12330:

; 388  : 	}
; 389  : 	// determine children
; 390  : 	for (i=0;i<mActorBones.GetCount();i++)

	mov	eax, DWORD PTR [esi+276]
	xor	ecx, ecx
	cmp	eax, ecx
	mov	DWORD PTR _i$[esp+16], ecx
	jbe	SHORT $L12335
	mov	DWORD PTR -4+[esp+20], ecx
$L12333:

; 391  : 	{
; 392  : 		CMacBone* bA = &mActorBones[i];

	mov	ecx, DWORD PTR [edi]
	mov	ebx, DWORD PTR -4+[esp+20]
	add	ecx, ebx

; 393  : 		for (NDword j=0;j<mActorBones.GetCount();j++)

	xor	ebx, ebx
	test	eax, eax
	jbe	SHORT $L12334

; 391  : 	{
; 392  : 		CMacBone* bA = &mActorBones[i];

	xor	edx, edx
$L12338:

; 394  : 		{
; 395  : 			CMacBone* bB = &mActorBones[j];

	mov	eax, DWORD PTR [edi]
	add	eax, edx

; 396  : 			if (bB->mParent == bA)

	cmp	DWORD PTR [eax+128], ecx
	jne	SHORT $L12339

; 397  : 			{
; 398  : 				bB->mNextSibling = bA->mFirstChild;

	mov	ebp, DWORD PTR [ecx+132]
	mov	DWORD PTR [eax+136], ebp

; 399  : 				bA->mFirstChild = bB;

	mov	DWORD PTR [ecx+132], eax
$L12339:
	mov	eax, DWORD PTR [esi+276]
	inc	ebx
	add	edx, 140				; 0000008cH
	cmp	ebx, eax
	jb	SHORT $L12338
$L12334:

; 388  : 	}
; 389  : 	// determine children
; 390  : 	for (i=0;i<mActorBones.GetCount();i++)

	mov	ecx, DWORD PTR _i$[esp+16]
	mov	ebx, DWORD PTR -4+[esp+20]
	mov	eax, DWORD PTR [esi+276]
	inc	ecx
	add	ebx, 140				; 0000008cH
	cmp	ecx, eax
	mov	DWORD PTR _i$[esp+16], ecx
	mov	DWORD PTR -4+[esp+20], ebx
	jb	SHORT $L12333
$L12335:

; 400  : 			}
; 401  : 		}
; 402  : 	}
; 403  : 	// reset all the transforms
; 404  : 	for (i=0;i<mActorBones.GetCount();i++)

	mov	eax, DWORD PTR [esi+276]
	xor	ebx, ebx
	test	eax, eax
	jbe	SHORT $L12345
	xor	ebp, ebp
$L12343:

; 405  : 		mActorBones[i].ResetCoords();

	mov	ecx, DWORD PTR [edi]
	push	0
	add	ecx, ebp
	mov	eax, DWORD PTR [ecx+124]
	add	eax, 12					; 0000000cH
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], edx
	mov	edx, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+16], edx
	mov	edx, DWORD PTR [eax+20]
	mov	DWORD PTR [ecx+20], edx
	mov	edx, DWORD PTR [eax+24]
	mov	DWORD PTR [ecx+24], edx
	mov	edx, DWORD PTR [eax+28]
	mov	DWORD PTR [ecx+28], edx
	mov	edx, DWORD PTR [eax+32]
	mov	DWORD PTR [ecx+32], edx
	mov	edx, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx+36], edx
	mov	edx, DWORD PTR [eax+40]
	mov	DWORD PTR [ecx+40], edx
	mov	edx, DWORD PTR [eax+44]
	mov	DWORD PTR [ecx+44], edx
	mov	edx, DWORD PTR [eax+48]
	mov	DWORD PTR [ecx+48], edx
	mov	edx, DWORD PTR [eax+52]
	mov	DWORD PTR [ecx+52], edx
	mov	eax, DWORD PTR [eax+56]
	mov	DWORD PTR [ecx+56], eax
	call	?ValidateAbs@CMacBone@@IAEX_N@Z		; CMacBone::ValidateAbs
	mov	eax, DWORD PTR [esi+276]
	inc	ebx
	add	ebp, 140				; 0000008cH
	cmp	ebx, eax
	jb	SHORT $L12343
$L12345:
	pop	ebp
	pop	edi
	pop	esi

; 406  : 	return(1);

	mov	al, 1
	pop	ebx

; 407  : }

	pop	ecx
	ret	4
?SetSkeleton@OMacActor@@QAE_NPAVOCpjSkeleton@@@Z ENDP	; OMacActor::SetSkeleton
_TEXT	ENDS
PUBLIC	?SetLodData@OMacActor@@QAE_NPAVOCpjLodData@@@Z	; OMacActor::SetLodData
; Function compile flags: /Ogty
;	COMDAT ?SetLodData@OMacActor@@QAE_NPAVOCpjLodData@@@Z
_TEXT	SEGMENT
_inLodData$ = 8
?SetLodData@OMacActor@@QAE_NPAVOCpjLodData@@@Z PROC NEAR ; OMacActor::SetLodData, COMDAT
; _this$ = ecx

; 410  : 	mLodData = inLodData;

	mov	eax, DWORD PTR _inLodData$[esp-4]

; 411  : 	if (!mLodData)

	test	eax, eax
	mov	DWORD PTR [ecx+148], eax
	jne	SHORT $L12350

; 412  : 		return(0);

	xor	al, al

; 415  : }

	ret	4
$L12350:

; 413  : 	mLodData->CacheIn();

	mov	ecx, eax
	call	?CacheIn@OCpjChunk@@QAE_NXZ		; OCpjChunk::CacheIn

; 414  : 	return(1);

	mov	al, 1

; 415  : }

	ret	4
?SetLodData@OMacActor@@QAE_NPAVOCpjLodData@@@Z ENDP	; OMacActor::SetLodData
_TEXT	ENDS
PUBLIC	?SetSurface@OMacActor@@QAE_NKPAVOCpjSurface@@@Z	; OMacActor::SetSurface
; Function compile flags: /Ogty
;	COMDAT ?SetSurface@OMacActor@@QAE_NKPAVOCpjSurface@@@Z
_TEXT	SEGMENT
_inIndex$ = 8
_inSurface$ = 12
?SetSurface@OMacActor@@QAE_NKPAVOCpjSurface@@@Z PROC NEAR ; OMacActor::SetSurface, COMDAT
; _this$ = ecx

; 418  : 	if (mSurfaces.GetCount() <= inIndex)

	mov	edx, DWORD PTR _inIndex$[esp-4]
	push	ebp
	mov	ebp, ecx
	mov	eax, DWORD PTR [ebp+156]
	cmp	eax, edx
	ja	SHORT $L21937
	push	ebx

; 419  : 		mSurfaces.AddZeroed((inIndex - mSurfaces.GetCount()) + 1);

	mov	ebx, DWORD PTR [ebp+156]
	push	esi
	mov	ecx, DWORD PTR [ebp+160]
	push	edi
	mov	esi, edx
	lea	edi, DWORD PTR [ebp+152]
	sub	esi, eax
	inc	esi
	lea	eax, DWORD PTR [ebx+esi]
	cmp	eax, ecx
	mov	DWORD PTR [edi+4], eax
	jbe	SHORT $L21943
	mov	ecx, eax
	push	4
	shr	ecx, 2
	lea	edx, DWORD PTR [ecx+eax+32]
	mov	ecx, edi
	mov	DWORD PTR [edi+8], edx
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
	mov	edx, DWORD PTR _inIndex$[esp+12]
$L21943:
	mov	ecx, esi
	mov	esi, DWORD PTR [edi]
	xor	eax, eax
	lea	edi, DWORD PTR [esi+ebx*4]
	rep stosd
	pop	edi
	pop	esi
	pop	ebx
$L21937:

; 420  : 	mSurfaces[inIndex] = inSurface;

	mov	eax, DWORD PTR [ebp+152]
	mov	ecx, DWORD PTR _inSurface$[esp]

; 421  : 	if (!inSurface)

	test	ecx, ecx
	mov	DWORD PTR [eax+edx*4], ecx
	pop	ebp
	jne	SHORT $L12357

; 422  : 		return(0);

	xor	al, al

; 425  : }

	ret	8
$L12357:

; 423  : 	inSurface->CacheIn();

	call	?CacheIn@OCpjChunk@@QAE_NXZ		; OCpjChunk::CacheIn

; 424  : 	return(1);

	mov	al, 1

; 425  : }

	ret	8
?SetSurface@OMacActor@@QAE_NKPAVOCpjSurface@@@Z ENDP	; OMacActor::SetSurface
_TEXT	ENDS
PUBLIC	?AddFrames@OMacActor@@QAE_NPAVOCpjProject@@@Z	; OMacActor::AddFrames
PUBLIC	?Reset@CObjIter@@QAEXPAVOObject@@_N@Z		; CObjIter::Reset
EXTRN	?staticObjClass@OCpjFrames@@0PAVCObjClass@@A:DWORD ; OCpjFrames::staticObjClass
; Function compile flags: /Ogty
;	COMDAT ?AddFrames@OMacActor@@QAE_NPAVOCpjProject@@@Z
_TEXT	SEGMENT
_inProject$ = 8
_this$ = -16
_it$ = -12
?AddFrames@OMacActor@@QAE_NPAVOCpjProject@@@Z PROC NEAR	; OMacActor::AddFrames, COMDAT
; _this$ = ecx

; 427  : {

	sub	esp, 16					; 00000010H
	push	esi

; 428  : 	if (!inProject)

	mov	esi, DWORD PTR _inProject$[esp+16]
	test	esi, esi
	mov	DWORD PTR _this$[esp+20], ecx
	jne	SHORT $L12362

; 429  : 		return(0);

	xor	al, al
	pop	esi

; 433  : }

	add	esp, 16					; 00000010H
	ret	4
$L12362:
	push	ebp
	push	edi

; 430  : 	for (TObjIter<OCpjFrames> it(inProject); it; it++)

	push	0
	push	esi
	lea	ecx, DWORD PTR _it$[esp+36]
	call	?Reset@CObjIter@@QAEXPAVOObject@@_N@Z	; CObjIter::Reset
	add	esi, 24					; 00000018H
	lea	ecx, DWORD PTR _it$[esp+28]
	mov	DWORD PTR _it$[esp+32], 0
	mov	DWORD PTR _it$[esp+28], esi
	mov	BYTE PTR _it$[esp+36], 0
	call	?GetNext@CObjIter@@IAEXXZ		; CObjIter::GetNext
	mov	eax, DWORD PTR _it$[esp+32]
	lea	ecx, DWORD PTR _it$[esp+28]
	mov	DWORD PTR _it$[esp+28], eax
	call	?GetNext@CObjIter@@IAEXXZ		; CObjIter::GetNext
	lea	ecx, DWORD PTR _it$[esp+28]
	call	?AdvanceToType@?$TObjIter@VOCpjFrames@@@@IAEXXZ ; TObjIter<OCpjFrames>::AdvanceToType
$L22174:
	mov	eax, DWORD PTR _it$[esp+28]
$L22047:
	test	eax, eax
	je	$L22171
	mov	ebp, DWORD PTR [eax]
	test	ebp, ebp
	je	$L22171

; 431  : 		mFrames.AddItem(*it);

	mov	ecx, DWORD PTR _this$[esp+28]
	mov	edi, DWORD PTR [ecx+172]
	lea	esi, DWORD PTR [ecx+168]
	mov	ecx, DWORD PTR [ecx+176]
	lea	eax, DWORD PTR [edi+1]
	cmp	eax, ecx
	mov	DWORD PTR [esi+4], eax
	jbe	SHORT $L22151
	mov	edx, eax
	push	4
	shr	edx, 2
	mov	ecx, esi
	lea	eax, DWORD PTR [edx+eax+32]
	mov	DWORD PTR [esi+8], eax
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
$L22151:
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [ecx+edi*4], ebp
	mov	cl, BYTE PTR _it$[esp+36]
	mov	eax, DWORD PTR _it$[esp+32]
	test	cl, cl
	mov	DWORD PTR _it$[esp+28], eax
	je	SHORT $L22056
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR _it$[esp+32], edx
	jmp	SHORT $L22070

; 430  : 	for (TObjIter<OCpjFrames> it(inProject); it; it++)

$L22056:
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _it$[esp+32], ecx
$L22070:
	test	eax, eax
	je	SHORT $L22171
	cmp	DWORD PTR [eax], 0
	je	SHORT $L22047
	lea	ecx, DWORD PTR _it$[esp+28]
	call	?GetObject@CObjIter@@IAEPAVOObject@@XZ	; CObjIter::GetObject
	mov	ecx, DWORD PTR ?staticObjClass@OCpjFrames@@0PAVCObjClass@@A ; OCpjFrames::staticObjClass
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+44]
	test	al, al
	jne	$L22174
	mov	edx, DWORD PTR _it$[esp+32]
	lea	ecx, DWORD PTR _it$[esp+28]
	mov	DWORD PTR _it$[esp+28], edx
	call	?GetNext@CObjIter@@IAEXXZ		; CObjIter::GetNext
	mov	eax, DWORD PTR _it$[esp+28]
	jmp	SHORT $L22070
$L22171:
	pop	edi
	pop	ebp

; 432  : 	return(1);

	mov	al, 1
	pop	esi

; 433  : }

	add	esp, 16					; 00000010H
	ret	4
?AddFrames@OMacActor@@QAE_NPAVOCpjProject@@@Z ENDP	; OMacActor::AddFrames
_TEXT	ENDS
PUBLIC	?AddSequences@OMacActor@@QAE_NPAVOCpjProject@@@Z ; OMacActor::AddSequences
EXTRN	?staticObjClass@OCpjSequence@@0PAVCObjClass@@A:DWORD ; OCpjSequence::staticObjClass
; Function compile flags: /Ogty
;	COMDAT ?AddSequences@OMacActor@@QAE_NPAVOCpjProject@@@Z
_TEXT	SEGMENT
_inProject$ = 8
_this$ = -16
_it$ = -12
?AddSequences@OMacActor@@QAE_NPAVOCpjProject@@@Z PROC NEAR ; OMacActor::AddSequences, COMDAT
; _this$ = ecx

; 435  : {

	sub	esp, 16					; 00000010H
	push	esi

; 436  : 	if (!inProject)

	mov	esi, DWORD PTR _inProject$[esp+16]
	test	esi, esi
	mov	DWORD PTR _this$[esp+20], ecx
	jne	SHORT $L12393

; 437  : 		return(0);

	xor	al, al
	pop	esi

; 441  : }

	add	esp, 16					; 00000010H
	ret	4
$L12393:
	push	ebp
	push	edi

; 438  : 	for (TObjIter<OCpjSequence> it(inProject); it; it++)

	push	0
	push	esi
	lea	ecx, DWORD PTR _it$[esp+36]
	call	?Reset@CObjIter@@QAEXPAVOObject@@_N@Z	; CObjIter::Reset
	add	esi, 24					; 00000018H
	lea	ecx, DWORD PTR _it$[esp+28]
	mov	DWORD PTR _it$[esp+32], 0
	mov	DWORD PTR _it$[esp+28], esi
	mov	BYTE PTR _it$[esp+36], 0
	call	?GetNext@CObjIter@@IAEXXZ		; CObjIter::GetNext
	mov	eax, DWORD PTR _it$[esp+32]
	lea	ecx, DWORD PTR _it$[esp+28]
	mov	DWORD PTR _it$[esp+28], eax
	call	?GetNext@CObjIter@@IAEXXZ		; CObjIter::GetNext
	lea	ecx, DWORD PTR _it$[esp+28]
	call	?AdvanceToType@?$TObjIter@VOCpjSequence@@@@IAEXXZ ; TObjIter<OCpjSequence>::AdvanceToType
$L22402:
	mov	eax, DWORD PTR _it$[esp+28]
$L22275:
	test	eax, eax
	je	$L22399
	mov	ebp, DWORD PTR [eax]
	test	ebp, ebp
	je	$L22399

; 439  : 		mSequences.AddItem(*it);

	mov	ecx, DWORD PTR _this$[esp+28]
	mov	edi, DWORD PTR [ecx+188]
	lea	esi, DWORD PTR [ecx+184]
	mov	ecx, DWORD PTR [ecx+192]
	lea	eax, DWORD PTR [edi+1]
	cmp	eax, ecx
	mov	DWORD PTR [esi+4], eax
	jbe	SHORT $L22381
	mov	edx, eax
	push	4
	shr	edx, 2
	mov	ecx, esi
	lea	eax, DWORD PTR [edx+eax+32]
	mov	DWORD PTR [esi+8], eax
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
$L22381:
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [ecx+edi*4], ebp
	mov	cl, BYTE PTR _it$[esp+36]
	mov	eax, DWORD PTR _it$[esp+32]
	test	cl, cl
	mov	DWORD PTR _it$[esp+28], eax
	je	SHORT $L22280
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR _it$[esp+32], edx
	jmp	SHORT $L22288

; 438  : 	for (TObjIter<OCpjSequence> it(inProject); it; it++)

$L22280:
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _it$[esp+32], ecx
$L22288:
	test	eax, eax
	je	SHORT $L22399
	cmp	DWORD PTR [eax], 0
	je	SHORT $L22275
	lea	ecx, DWORD PTR _it$[esp+28]
	call	?GetObject@CObjIter@@IAEPAVOObject@@XZ	; CObjIter::GetObject
	mov	ecx, DWORD PTR ?staticObjClass@OCpjSequence@@0PAVCObjClass@@A ; OCpjSequence::staticObjClass
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+44]
	test	al, al
	jne	$L22402
	mov	edx, DWORD PTR _it$[esp+32]
	lea	ecx, DWORD PTR _it$[esp+28]
	mov	DWORD PTR _it$[esp+28], edx
	call	?GetNext@CObjIter@@IAEXXZ		; CObjIter::GetNext
	mov	eax, DWORD PTR _it$[esp+28]
	jmp	SHORT $L22288
$L22399:
	pop	edi
	pop	ebp

; 440  : 	return(1);

	mov	al, 1
	pop	esi

; 441  : }

	add	esp, 16					; 00000010H
	ret	4
?AddSequences@OMacActor@@QAE_NPAVOCpjProject@@@Z ENDP	; OMacActor::AddSequences
_TEXT	ENDS
PUBLIC	??_C@_08PDKO@autoexec?$AA@			; `string'
PUBLIC	?Remove@?$TCorArray@PAVOCpjSurface@@@@QAEXKK@Z	; TCorArray<OCpjSurface *>::Remove
PUBLIC	?Remove@?$TCorArray@PAVOCpjFrames@@@@QAEXKK@Z	; TCorArray<OCpjFrames *>::Remove
PUBLIC	?Remove@?$TCorArray@PAVOCpjSequence@@@@QAEXKK@Z	; TCorArray<OCpjSequence *>::Remove
PUBLIC	?Remove@?$TCorArray@VCCorString@@@@QAEXKK@Z	; TCorArray<CCorString>::Remove
EXTRN	?staticObjClass@OCpjProject@@0PAVCObjClass@@A:DWORD ; OCpjProject::staticObjClass
EXTRN	?Msgf@IMsgTarget@@QAA_NPADZZ:NEAR		; IMsgTarget::Msgf
;	COMDAT ??_C@_08PDKO@autoexec?$AA@
; File C:\duke4\Cannibal\CorMain.h
_DATA	SEGMENT
??_C@_08PDKO@autoexec?$AA@ DB 'autoexec', 00H		; `string'
; Function compile flags: /Ogty
; File C:\duke4\Cannibal\MacMain.cpp
_DATA	ENDS
;	COMDAT ?LoadConfig@OMacActor@@QAE_NPAVOCpjConfig@@@Z
_TEXT	SEGMENT
_inConfig$ = 8
?LoadConfig@OMacActor@@QAE_NPAVOCpjConfig@@@Z PROC NEAR	; OMacActor::LoadConfig, COMDAT
; _this$ = ecx

; 444  : {

	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, ecx

; 445  : 	NDword i;
; 446  : 
; 447  : 	mLoadProject = NULL;

	xor	ebx, ebx

; 448  : 	
; 449  : 	mGeometry = NULL;
; 450  : 	mSkeleton = NULL;
; 451  : 	mLodData = NULL;
; 452  : 	mSurfaces.Purge(); mSurfaces.Shrink();

	lea	esi, DWORD PTR [edi+152]
	mov	DWORD PTR [edi+68], ebx
	mov	DWORD PTR [edi+140], ebx
	mov	DWORD PTR [edi+144], ebx
	mov	DWORD PTR [edi+148], ebx
	mov	eax, DWORD PTR [esi+4]
	push	eax
	push	ebx
	mov	ecx, esi
	call	?Remove@?$TCorArray@PAVOCpjSurface@@@@QAEXKK@Z ; TCorArray<OCpjSurface *>::Remove
	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	cmp	ecx, eax
	je	SHORT $L22416
	push	4
	mov	ecx, esi
	mov	DWORD PTR [esi+8], eax
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
$L22416:

; 453  : 	mFrames.Purge(); mFrames.Shrink();

	mov	ecx, DWORD PTR [edi+172]
	lea	esi, DWORD PTR [edi+168]
	push	ecx
	push	ebx
	mov	ecx, esi
	call	?Remove@?$TCorArray@PAVOCpjFrames@@@@QAEXKK@Z ; TCorArray<OCpjFrames *>::Remove
	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	cmp	ecx, eax
	je	SHORT $L22425
	push	4
	mov	ecx, esi
	mov	DWORD PTR [esi+8], eax
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
$L22425:

; 454  : 	mSequences.Purge(); mSequences.Shrink();

	mov	edx, DWORD PTR [edi+188]
	lea	esi, DWORD PTR [edi+184]
	push	edx
	push	ebx
	mov	ecx, esi
	call	?Remove@?$TCorArray@PAVOCpjSequence@@@@QAEXKK@Z ; TCorArray<OCpjSequence *>::Remove
	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	cmp	ecx, eax
	je	SHORT $L22434
	push	4
	mov	ecx, esi
	mov	DWORD PTR [esi+8], eax
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
$L22434:

; 455  : 	mFramesFiles.Purge(); mFramesFiles.Shrink();

	mov	eax, DWORD PTR [edi+204]
	lea	esi, DWORD PTR [edi+200]
	push	eax
	push	ebx
	mov	ecx, esi
	call	?Remove@?$TCorArray@VCCorString@@@@QAEXKK@Z ; TCorArray<CCorString>::Remove
	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	cmp	ecx, eax
	je	SHORT $L22442
	push	4
	mov	ecx, esi
	mov	DWORD PTR [esi+8], eax
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
$L22442:

; 456  : 	mFramesStarFiles.Purge(); mFramesStarFiles.Shrink();

	mov	ecx, DWORD PTR [edi+220]
	lea	esi, DWORD PTR [edi+216]
	push	ecx
	push	ebx
	mov	ecx, esi
	call	?Remove@?$TCorArray@VCCorString@@@@QAEXKK@Z ; TCorArray<CCorString>::Remove
	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	cmp	ecx, eax
	je	SHORT $L22451
	push	4
	mov	ecx, esi
	mov	DWORD PTR [esi+8], eax
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
$L22451:

; 457  : 	mSequencesFiles.Purge(); mSequencesFiles.Shrink();

	mov	edx, DWORD PTR [edi+236]
	lea	esi, DWORD PTR [edi+232]
	push	edx
	push	ebx
	mov	ecx, esi
	call	?Remove@?$TCorArray@VCCorString@@@@QAEXKK@Z ; TCorArray<CCorString>::Remove
	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	cmp	ecx, eax
	je	SHORT $L22460
	push	4
	mov	ecx, esi
	mov	DWORD PTR [esi+8], eax
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
$L22460:

; 458  : 	mSequencesStarFiles.Purge(); mSequencesStarFiles.Shrink();

	mov	eax, DWORD PTR [edi+252]
	lea	esi, DWORD PTR [edi+248]
	push	eax
	push	ebx
	mov	ecx, esi
	call	?Remove@?$TCorArray@VCCorString@@@@QAEXKK@Z ; TCorArray<CCorString>::Remove
	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	cmp	ecx, eax
	je	SHORT $L22469
	push	4
	mov	ecx, esi
	mov	DWORD PTR [esi+8], eax
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
$L22469:

; 459  : 
; 460  : 	mTraceInfo = NULL;
; 461  : 	
; 462  : 	if (!inConfig)

	mov	esi, DWORD PTR _inConfig$[esp+12]
	mov	DWORD PTR [edi+304], ebx
	cmp	esi, ebx
	jne	SHORT $L12425
	pop	edi
	pop	esi
	pop	ebp

; 463  : 		return(0);

	xor	al, al
	pop	ebx

; 487  : }

	ret	4
$L12425:

; 464  : 	inConfig->CacheIn();

	mov	ecx, esi
	call	?CacheIn@OCpjChunk@@QAE_NXZ		; OCpjChunk::CacheIn

; 465  : 
; 466  : 	// find autoexec section for processing
; 467  : 	CCpjMacSection* section = NULL;
; 468  : 	for (i=0;i<inConfig->m_Sections.GetCount();i++)

	cmp	DWORD PTR [esi+76], ebx
	jbe	SHORT $L22522

; 464  : 	inConfig->CacheIn();

	xor	ebp, ebp
$L12427:

; 469  : 	{
; 470  : 		if (!stricmp(*inConfig->m_Sections[i].name, "autoexec"))

	mov	eax, DWORD PTR [esi+72]
	add	eax, ebp
	mov	eax, DWORD PTR [eax]
	test	eax, eax
	jne	SHORT $L22488
	mov	eax, OFFSET FLAT:??_C@_00A@?$AA@	; `string'
$L22488:
	push	OFFSET FLAT:??_C@_08PDKO@autoexec?$AA@	; `string'
	push	eax
	call	DWORD PTR __imp__stricmp
	add	esp, 8
	test	eax, eax
	je	SHORT $L22519
	mov	eax, DWORD PTR [esi+76]
	inc	ebx
	add	ebp, 20					; 00000014H
	cmp	ebx, eax
	jb	SHORT $L12427
	pop	edi
	pop	esi
	pop	ebp

; 477  : 		return(0);

	xor	al, al
	pop	ebx

; 487  : }

	ret	4
$L22519:

; 471  : 		{
; 472  : 			section = &inConfig->m_Sections[i];

	mov	edx, DWORD PTR [esi+72]
	lea	ecx, DWORD PTR [ebx+ebx*4]
	lea	ebx, DWORD PTR [edx+ecx*4]

; 473  : 			break;
; 474  : 		}
; 475  : 	}
; 476  : 	if (!section)

	test	ebx, ebx
	jne	SHORT $L12432
$L22522:
	pop	edi
	pop	esi
	pop	ebp

; 477  : 		return(0);

	xor	al, al
	pop	ebx

; 487  : }

	ret	4
$L12432:

; 478  : 
; 479  : 	// we have our section, run the commands	
; 480  : 	if (inConfig->GetParent() && inConfig->GetParent()->IsA(OCpjProject::GetStaticClass()))

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+32]
	test	eax, eax
	je	SHORT $L12433
	mov	edx, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [edx+32]
	mov	ecx, DWORD PTR ?staticObjClass@OCpjProject@@0PAVCObjClass@@A ; OCpjProject::staticObjClass
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+44]
	test	al, al
	je	SHORT $L12433

; 481  : 		mLoadProject = (OCpjProject*)inConfig->GetParent();

	mov	edx, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [edx+32]
	mov	DWORD PTR [edi+68], eax
$L12433:

; 482  : 	for (i=0;i<section->commands.GetCount();i++)

	mov	eax, DWORD PTR [ebx+8]
	xor	esi, esi
	test	eax, eax
	jbe	SHORT $L12437
$L12435:
	mov	eax, DWORD PTR [ebx+4]
	lea	eax, DWORD PTR [eax+esi*4]

; 483  : 		Msgf(*section->commands[i]);

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	jne	SHORT $L22513
	mov	eax, OFFSET FLAT:??_C@_00A@?$AA@	; `string'
$L22513:
	push	eax
	push	edi
	call	?Msgf@IMsgTarget@@QAA_NPADZZ		; IMsgTarget::Msgf
	mov	eax, DWORD PTR [ebx+8]
	add	esp, 8
	inc	esi
	cmp	esi, eax
	jb	SHORT $L12435
$L12437:

; 484  : 	mLoadProject = NULL;

	mov	DWORD PTR [edi+68], 0
	pop	edi
	pop	esi
	pop	ebp

; 485  : 
; 486  : 	return(1);

	mov	al, 1
	pop	ebx

; 487  : }

	ret	4
?LoadConfig@OMacActor@@QAE_NPAVOCpjConfig@@@Z ENDP	; OMacActor::LoadConfig
_TEXT	ENDS
PUBLIC	??_C@_0P@HLNL@SetAuthor?5?$CC?$CFs?$CC?$AA@	; `string'
PUBLIC	??_C@_0BE@JMPP@SetDescription?5?$CC?$CFs?$CC?$AA@ ; `string'
PUBLIC	??_C@_0BD@GKMM@SetOrigin?5?$CFf?5?$CFf?5?$CFf?$AA@ ; `string'
PUBLIC	??_C@_0BC@NICM@SetScale?5?$CFf?5?$CFf?5?$CFf?$AA@ ; `string'
PUBLIC	??_C@_0BF@LOLC@SetRotation?5?$CFf?5?$CFf?5?$CFf?$AA@ ; `string'
PUBLIC	??_C@_0BG@BKJK@SetBoundsMin?5?$CFf?5?$CFf?5?$CFf?$AA@ ; `string'
PUBLIC	??_C@_0BG@JCEN@SetBoundsMax?5?$CFf?5?$CFf?5?$CFf?$AA@ ; `string'
PUBLIC	??_C@_0BB@PBDG@SetGeometry?5?$CC?$CFs?$CC?$AA@	; `string'
PUBLIC	??_C@_0BB@BEIB@SetSkeleton?5?$CC?$CFs?$CC?$AA@	; `string'
PUBLIC	??_C@_0BA@FMNO@SetLodData?5?$CC?$CFs?$CC?$AA@	; `string'
PUBLIC	??_C@_0BD@DNEA@SetSurface?5?$CFd?5?$CC?$CFs?$CC?$AA@ ; `string'
PUBLIC	??_C@_0BB@PHGO@AddFrames?5?$CCNULL?$CC?$AA@	; `string'
PUBLIC	??1?$TCorArray@PAVOCpjProject@@@@QAE@XZ		; TCorArray<OCpjProject *>::~TCorArray<OCpjProject *>
PUBLIC	?AddItem@?$TCorArray@PAVOCpjProject@@@@QAEKABQAVOCpjProject@@@Z ; TCorArray<OCpjProject *>::AddItem
PUBLIC	?Add@?$TCorArray@PAVOCpjProject@@@@QAEKK@Z	; TCorArray<OCpjProject *>::Add
PUBLIC	?FindItem@?$TCorArray@PAVOCpjProject@@@@QBE_NABQAVOCpjProject@@PAK@Z ; TCorArray<OCpjProject *>::FindItem
PUBLIC	??_C@_0P@LABC@AddFrames?5?$CC?$CFs?$CC?$AA@	; `string'
PUBLIC	??_C@_0BE@HFDO@AddSequences?5?$CCNULL?$CC?$AA@	; `string'
PUBLIC	??_C@_0BC@FMMO@AddSequences?5?$CC?$CFs?$CC?$AA@	; `string'
PUBLIC	__real@43340000
PUBLIC	__real@3ea2f983
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	??1CCorString@@QAE@XZ				; CCorString::~CCorString
PUBLIC	?AddNoConstruct@?$TCorArray@VCCorString@@@@QAEKK@Z ; TCorArray<CCorString>::AddNoConstruct
PUBLIC	??0CCpjMacSection@@QAE@XZ			; CCpjMacSection::CCpjMacSection
PUBLIC	?SaveConfig@OMacActor@@QAE_NPAVOCpjConfig@@@Z	; OMacActor::SaveConfig
PUBLIC	?AddNoConstruct@?$TCorArray@VCCpjMacSection@@@@QAEKK@Z ; TCorArray<CCpjMacSection>::AddNoConstruct
PUBLIC	??0CCorArray@@IAE@KK@Z				; CCorArray::CCorArray
EXTRN	__imp__memmove:NEAR
EXTRN	?STR_FilePath@@YAPADPAD@Z:NEAR			; STR_FilePath
EXTRN	__imp__sprintf:NEAR
EXTRN	__except_list:DWORD
EXTRN	___CxxFrameHandler:NEAR
EXTRN	?CPJ_GetProjectPath@@YAPBDPAVOCpjProject@@@Z:NEAR ; CPJ_GetProjectPath
EXTRN	?CPJ_GetChunkPath@@YAPBDPAVOCpjProject@@PAVOCpjChunk@@@Z:NEAR ; CPJ_GetChunkPath
;	COMDAT xdata$x
; File C:\duke4\Cannibal\CorMain.h
xdata$x	SEGMENT
$T23911	DD	0ffffffffH
	DD	FLAT:$L22605
	DD	0ffffffffH
	DD	FLAT:$L22553
	DD	0ffffffffH
	DD	FLAT:$L22554
	DD	0ffffffffH
	DD	FLAT:$L22555
	DD	0ffffffffH
	DD	FLAT:$L22556
	DD	0ffffffffH
	DD	FLAT:$L22557
	DD	0ffffffffH
	DD	FLAT:$L22558
	DD	0ffffffffH
	DD	FLAT:$L22559
	DD	0ffffffffH
	DD	FLAT:$L22560
	DD	0ffffffffH
	DD	FLAT:$L22561
	DD	0ffffffffH
	DD	FLAT:$L22562
	DD	0ffffffffH
	DD	FLAT:$L22563
	DD	0ffffffffH
	DD	FLAT:$L22564
	DD	0ffffffffH
	DD	FLAT:$L22565
	DD	0dH
	DD	FLAT:$L22566
	DD	0dH
	DD	FLAT:$L22567
	DD	0dH
	DD	FLAT:$L22568
	DD	0dH
	DD	FLAT:$L22569
	DD	0dH
	DD	FLAT:$L22570
	DD	012H
	DD	FLAT:$L22571
	DD	012H
	DD	FLAT:$L22572
	DD	012H
	DD	FLAT:$L22573
$T23816	DD	019930520H
	DD	016H
	DD	FLAT:$T23911
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_0P@HLNL@SetAuthor?5?$CC?$CFs?$CC?$AA@
_DATA	SEGMENT
??_C@_0P@HLNL@SetAuthor?5?$CC?$CFs?$CC?$AA@ DB 'SetAuthor "%s"', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BE@JMPP@SetDescription?5?$CC?$CFs?$CC?$AA@
_DATA	SEGMENT
??_C@_0BE@JMPP@SetDescription?5?$CC?$CFs?$CC?$AA@ DB 'SetDescription "%s"'
	DB	00H						; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BD@GKMM@SetOrigin?5?$CFf?5?$CFf?5?$CFf?$AA@
_DATA	SEGMENT
??_C@_0BD@GKMM@SetOrigin?5?$CFf?5?$CFf?5?$CFf?$AA@ DB 'SetOrigin %f %f %f'
	DB	00H						; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BC@NICM@SetScale?5?$CFf?5?$CFf?5?$CFf?$AA@
_DATA	SEGMENT
??_C@_0BC@NICM@SetScale?5?$CFf?5?$CFf?5?$CFf?$AA@ DB 'SetScale %f %f %f', 00H ; `string'
_DATA	ENDS
;	COMDAT __real@43340000
CONST	SEGMENT
__real@43340000 DD 043340000r			; 180
CONST	ENDS
;	COMDAT __real@3ea2f983
CONST	SEGMENT
__real@3ea2f983 DD 03ea2f983r			; 0.31831
CONST	ENDS
;	COMDAT ??_C@_0BF@LOLC@SetRotation?5?$CFf?5?$CFf?5?$CFf?$AA@
_DATA	SEGMENT
??_C@_0BF@LOLC@SetRotation?5?$CFf?5?$CFf?5?$CFf?$AA@ DB 'SetRotation %f %'
	DB	'f %f', 00H					; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BG@BKJK@SetBoundsMin?5?$CFf?5?$CFf?5?$CFf?$AA@
_DATA	SEGMENT
??_C@_0BG@BKJK@SetBoundsMin?5?$CFf?5?$CFf?5?$CFf?$AA@ DB 'SetBoundsMin %f'
	DB	' %f %f', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BG@JCEN@SetBoundsMax?5?$CFf?5?$CFf?5?$CFf?$AA@
_DATA	SEGMENT
??_C@_0BG@JCEN@SetBoundsMax?5?$CFf?5?$CFf?5?$CFf?$AA@ DB 'SetBoundsMax %f'
	DB	' %f %f', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BB@PBDG@SetGeometry?5?$CC?$CFs?$CC?$AA@
_DATA	SEGMENT
??_C@_0BB@PBDG@SetGeometry?5?$CC?$CFs?$CC?$AA@ DB 'SetGeometry "%s"', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BB@BEIB@SetSkeleton?5?$CC?$CFs?$CC?$AA@
_DATA	SEGMENT
??_C@_0BB@BEIB@SetSkeleton?5?$CC?$CFs?$CC?$AA@ DB 'SetSkeleton "%s"', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BA@FMNO@SetLodData?5?$CC?$CFs?$CC?$AA@
_DATA	SEGMENT
??_C@_0BA@FMNO@SetLodData?5?$CC?$CFs?$CC?$AA@ DB 'SetLodData "%s"', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BD@DNEA@SetSurface?5?$CFd?5?$CC?$CFs?$CC?$AA@
_DATA	SEGMENT
??_C@_0BD@DNEA@SetSurface?5?$CFd?5?$CC?$CFs?$CC?$AA@ DB 'SetSurface %d "%'
	DB	's"', 00H					; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BB@PHGO@AddFrames?5?$CCNULL?$CC?$AA@
_DATA	SEGMENT
??_C@_0BB@PHGO@AddFrames?5?$CCNULL?$CC?$AA@ DB 'AddFrames "NULL"', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0P@LABC@AddFrames?5?$CC?$CFs?$CC?$AA@
_DATA	SEGMENT
??_C@_0P@LABC@AddFrames?5?$CC?$CFs?$CC?$AA@ DB 'AddFrames "%s"', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BE@HFDO@AddSequences?5?$CCNULL?$CC?$AA@
_DATA	SEGMENT
??_C@_0BE@HFDO@AddSequences?5?$CCNULL?$CC?$AA@ DB 'AddSequences "NULL"', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BC@FMMO@AddSequences?5?$CC?$CFs?$CC?$AA@
_DATA	SEGMENT
??_C@_0BC@FMMO@AddSequences?5?$CC?$CFs?$CC?$AA@ DB 'AddSequences "%s"', 00H ; `string'
; Function compile flags: /Ogty
; File C:\duke4\Cannibal\MacMain.cpp
_DATA	ENDS
;	COMDAT ?SaveConfig@OMacActor@@QAE_NPAVOCpjConfig@@@Z
_TEXT	SEGMENT
$T22527 = -828
$T22528 = -828
$T22529 = -828
$T22530 = -828
$T22531 = -828
$T22532 = -828
$T22533 = -828
$T22534 = -828
$T22535 = -828
$T22536 = -828
$T22537 = -828
$T22538 = -828
$T22539 = -828
$T22542 = -828
$T22543 = -828
$T22544 = -828
$T22545 = -828
$T22546 = -828
$T22549 = -816
$T22550 = -828
$T22551 = -824
_inConfig$ = 8
_configProject$ = -824
_i$ = -820
_buf$ = -780
$T22620 = -820
$T22621 = -816
$T23643 = -828
_path$ = -828
$T22649 = -816
$T22689 = -816
_frmProjects$ = -796
_b1$12552 = -268
_b2$12557 = -524
_seqProjects$ = -812
_b1$12593 = -524
_b2$12598 = -268
__$EHRec$ = -12
_i$22989 = -816
$T23297 = -828
?SaveConfig@OMacActor@@QAE_NPAVOCpjConfig@@@Z PROC NEAR	; OMacActor::SaveConfig, COMDAT
; _this$ = ecx

; 490  : {

	mov	eax, DWORD PTR fs:__except_list
	push	-1
	push	$L23909
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 816				; 00000330H
	push	ebx
	push	esi
	push	edi

; 491  : 	if (!inConfig)

	mov	edi, DWORD PTR _inConfig$[esp+836]
	xor	ebx, ebx
	mov	esi, ecx
	cmp	edi, ebx
	jne	SHORT $L12442

; 492  : 		return(0);

	xor	al, al
	jmp	$L12441
$L12442:

; 493  : 	inConfig->CacheIn();

	mov	ecx, edi
	call	?CacheIn@OCpjChunk@@QAE_NXZ		; OCpjChunk::CacheIn

; 494  : 
; 495  : 	OCpjProject* configProject = NULL;
; 496  : 	if (inConfig->GetParent() && inConfig->GetParent()->IsA(OCpjProject::GetStaticClass()))

	mov	eax, DWORD PTR [edi]
	mov	ecx, edi
	mov	DWORD PTR _configProject$[esp+840], ebx
	call	DWORD PTR [eax+32]
	test	eax, eax
	je	SHORT $L12444
	mov	edx, DWORD PTR [edi]
	mov	ecx, edi
	call	DWORD PTR [edx+32]
	mov	ecx, DWORD PTR ?staticObjClass@OCpjProject@@0PAVCObjClass@@A ; OCpjProject::staticObjClass
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+44]
	test	al, al
	je	SHORT $L12444

; 497  : 		configProject = (OCpjProject*)inConfig->GetParent();

	mov	edx, DWORD PTR [edi]
	mov	ecx, edi
	call	DWORD PTR [edx+32]
	mov	DWORD PTR _configProject$[esp+840], eax
$L12444:

; 498  : 
; 499  : 	// find autoexec section for processing
; 500  : 	CCpjMacSection* section = NULL;
; 501  : 	for (NDword i=0;i<inConfig->m_Sections.GetCount();i++)

	mov	eax, DWORD PTR [edi+76]
	push	ebp
	xor	ebp, ebp
	cmp	eax, ebx
	jbe	SHORT $L23876
$L12448:

; 502  : 	{
; 503  : 		if (!stricmp(*inConfig->m_Sections[i].name, "autoexec"))

	mov	eax, DWORD PTR [edi+72]
	add	eax, ebx
	mov	eax, DWORD PTR [eax]
	test	eax, eax
	jne	SHORT $L22592
	mov	eax, OFFSET FLAT:??_C@_00A@?$AA@	; `string'
$L22592:
	push	OFFSET FLAT:??_C@_08PDKO@autoexec?$AA@	; `string'
	push	eax
	call	DWORD PTR __imp__stricmp
	add	esp, 8
	test	eax, eax
	je	SHORT $L23849
	mov	eax, DWORD PTR [edi+76]
	inc	ebp
	add	ebx, 20					; 00000014H
	cmp	ebp, eax
	jb	SHORT $L12448

; 629  : 				if (!stricmp(b1, b2))

	jmp	SHORT $L23876
$L23849:

; 504  : 		{
; 505  : 			section = &inConfig->m_Sections[i];

	mov	ecx, DWORD PTR [edi+72]
	lea	eax, DWORD PTR [ebp+ebp*4]
	lea	ebp, DWORD PTR [ecx+eax*4]

; 506  : 			break;
; 507  : 		}
; 508  : 	}
; 509  : 	if (!section)

	test	ebp, ebp
	jne	SHORT $L22634
$L23876:

; 510  : 	{
; 511  : 		section = &inConfig->m_Sections[inConfig->m_Sections.Add()];

	lea	ebx, DWORD PTR [edi+72]
	push	1
	mov	ecx, ebx
	call	?AddNoConstruct@?$TCorArray@VCCpjMacSection@@@@QAEKK@Z ; TCorArray<CCpjMacSection>::AddNoConstruct
	mov	edi, eax
	lea	eax, DWORD PTR [edi+1]
	cmp	edi, eax
	jae	SHORT $L22617
	lea	ebp, DWORD PTR [edi+edi*4]
	shl	ebp, 2
	sub	eax, edi
	mov	DWORD PTR -828+[esp+844], eax
$L22615:
	mov	ecx, DWORD PTR [ebx]
	add	ecx, ebp
	mov	DWORD PTR $T22621[esp+844], ecx
	mov	DWORD PTR $T22620[esp+844], ecx
	mov	DWORD PTR __$EHRec$[esp+852], 0
	je	SHORT $L22622
	call	??0CCpjMacSection@@QAE@XZ		; CCpjMacSection::CCpjMacSection
$L22622:
	mov	eax, DWORD PTR -828+[esp+844]
	add	ebp, 20					; 00000014H
	dec	eax
	mov	DWORD PTR __$EHRec$[esp+852], -1
	mov	DWORD PTR -828+[esp+844], eax
	jne	SHORT $L22615
$L22617:
	mov	eax, DWORD PTR [ebx]
	lea	edx, DWORD PTR [edi+edi*4]

; 512  : 		section->name = "autoexec";

	push	OFFSET FLAT:??_C@_08PDKO@autoexec?$AA@	; `string'
	lea	ebp, DWORD PTR [eax+edx*4]
	mov	ecx, ebp
	call	?Set@CCorString@@QAEXPAD@Z		; CCorString::Set
$L22634:

; 513  : 	}
; 514  : 
; 515  : 	// nuke the contents of the section
; 516  : 	section->commands.Purge(); section->commands.Shrink();

	mov	ecx, DWORD PTR [ebp+8]
	add	ebp, 4
	push	ecx
	push	0
	mov	ecx, ebp
	call	?Remove@?$TCorArray@VCCorString@@@@QAEXKK@Z ; TCorArray<CCorString>::Remove
	mov	eax, DWORD PTR [ebp+4]
	mov	ecx, DWORD PTR [ebp+8]
	cmp	ecx, eax
	je	SHORT $L22640
	push	4
	mov	ecx, ebp
	mov	DWORD PTR [ebp+8], eax
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
$L22640:

; 517  : 
; 518  : 	// add commands for regular properties
; 519  : 	char buf[256];
; 520  : 	if (mAuthor.Len()) { sprintf(buf, "SetAuthor \"%s\"", *mAuthor); section->commands.AddItem(buf); }

	mov	edi, DWORD PTR [esi+72]
	mov	ebx, DWORD PTR __imp__sprintf
	test	edi, edi
	je	SHORT $L22683
	or	ecx, -1
	xor	eax, eax
	repne scasb
	not	ecx
	dec	ecx
	mov	DWORD PTR $T22649[esp+844], ecx
	je	SHORT $L22683
	mov	eax, DWORD PTR [esi+72]
	test	eax, eax
	jne	SHORT $L22658
	mov	eax, OFFSET FLAT:??_C@_00A@?$AA@	; `string'
$L22658:
	push	eax
	lea	edx, DWORD PTR _buf$[esp+848]
	push	OFFSET FLAT:??_C@_0P@HLNL@SetAuthor?5?$CC?$CFs?$CC?$AA@ ; `string'
	push	edx
	call	ebx
	add	esp, 12					; 0000000cH
	lea	eax, DWORD PTR _buf$[esp+844]
	lea	ecx, DWORD PTR $T22527[esp+844]
	mov	DWORD PTR $T22527[esp+844], 0
	push	eax
	call	?Set@CCorString@@QAEXPAD@Z		; CCorString::Set
	push	1
	mov	ecx, ebp
	mov	DWORD PTR __$EHRec$[esp+856], 1
	call	?Add@?$TCorArray@VCCorString@@@@QAEKK@Z	; TCorArray<CCorString>::Add
	mov	ecx, DWORD PTR [ebp]
	mov	edx, DWORD PTR $T22527[esp+844]
	push	edx
	lea	ecx, DWORD PTR [ecx+eax*4]
	call	?Set@CCorString@@QAEXPAD@Z		; CCorString::Set
	push	0
	lea	ecx, DWORD PTR $T22527[esp+848]
	mov	DWORD PTR __$EHRec$[esp+856], -1
	call	?Set@CCorString@@QAEXPAD@Z		; CCorString::Set
$L22683:

; 521  : 	if (mDescription.Len()) { sprintf(buf, "SetDescription \"%s\"", *mDescription); section->commands.AddItem(buf); }

	mov	edi, DWORD PTR [esi+76]
	test	edi, edi
	je	SHORT $L22723
	or	ecx, -1
	xor	eax, eax
	repne scasb
	not	ecx
	dec	ecx
	mov	DWORD PTR $T22689[esp+844], ecx
	je	SHORT $L22723
	mov	eax, DWORD PTR [esi+76]
	test	eax, eax
	jne	SHORT $L22698
	mov	eax, OFFSET FLAT:??_C@_00A@?$AA@	; `string'
$L22698:
	push	eax
	lea	eax, DWORD PTR _buf$[esp+848]
	push	OFFSET FLAT:??_C@_0BE@JMPP@SetDescription?5?$CC?$CFs?$CC?$AA@ ; `string'
	push	eax
	call	ebx
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR _buf$[esp+844]
	mov	DWORD PTR $T22528[esp+844], 0
	push	ecx
	lea	ecx, DWORD PTR $T22528[esp+848]
	call	?Set@CCorString@@QAEXPAD@Z		; CCorString::Set
	push	1
	mov	ecx, ebp
	mov	DWORD PTR __$EHRec$[esp+856], 2
	call	?Add@?$TCorArray@VCCorString@@@@QAEKK@Z	; TCorArray<CCorString>::Add
	mov	edx, DWORD PTR [ebp]
	lea	ecx, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR $T22528[esp+844]
	push	eax
	call	?Set@CCorString@@QAEXPAD@Z		; CCorString::Set
	push	0
	lea	ecx, DWORD PTR $T22528[esp+848]
	mov	DWORD PTR __$EHRec$[esp+856], -1
	call	?Set@CCorString@@QAEXPAD@Z		; CCorString::Set
$L22723:

; 522  : 	sprintf(buf, "SetOrigin %f %f %f", mOrigin.x, mOrigin.y, mOrigin.z); section->commands.AddItem(buf);

	fld	DWORD PTR [esi+88]
	sub	esp, 24					; 00000018H
	lea	ecx, DWORD PTR _buf$[esp+868]
	fstp	QWORD PTR [esp+16]
	fld	DWORD PTR [esi+84]
	fstp	QWORD PTR [esp+8]
	fld	DWORD PTR [esi+80]
	fstp	QWORD PTR [esp]
	push	OFFSET FLAT:??_C@_0BD@GKMM@SetOrigin?5?$CFf?5?$CFf?5?$CFf?$AA@ ; `string'
	push	ecx
	call	ebx
	add	esp, 32					; 00000020H
	lea	edx, DWORD PTR _buf$[esp+844]
	xor	edi, edi
	lea	ecx, DWORD PTR $T22529[esp+844]
	push	edx
	mov	DWORD PTR $T22529[esp+848], edi
	call	?Set@CCorString@@QAEXPAD@Z		; CCorString::Set
	push	1
	mov	ecx, ebp
	mov	DWORD PTR __$EHRec$[esp+856], 3
	call	?Add@?$TCorArray@VCCorString@@@@QAEKK@Z	; TCorArray<CCorString>::Add
	mov	ecx, DWORD PTR [ebp]
	mov	edx, DWORD PTR $T22529[esp+844]
	push	edx
	lea	ecx, DWORD PTR [ecx+eax*4]
	call	?Set@CCorString@@QAEXPAD@Z		; CCorString::Set
	push	edi
	lea	ecx, DWORD PTR $T22529[esp+848]
	mov	DWORD PTR __$EHRec$[esp+856], -1
	call	?Set@CCorString@@QAEXPAD@Z		; CCorString::Set

; 523  : 	sprintf(buf, "SetScale %f %f %f", mScale.x, mScale.y, mScale.z); section->commands.AddItem(buf);

	fld	DWORD PTR [esi+100]
	sub	esp, 24					; 00000018H
	lea	eax, DWORD PTR _buf$[esp+868]
	fstp	QWORD PTR [esp+16]
	fld	DWORD PTR [esi+96]
	fstp	QWORD PTR [esp+8]
	fld	DWORD PTR [esi+92]
	fstp	QWORD PTR [esp]
	push	OFFSET FLAT:??_C@_0BC@NICM@SetScale?5?$CFf?5?$CFf?5?$CFf?$AA@ ; `string'
	push	eax
	call	ebx
	add	esp, 32					; 00000020H
	lea	ecx, DWORD PTR _buf$[esp+844]
	mov	DWORD PTR $T22530[esp+844], edi
	push	ecx
	lea	ecx, DWORD PTR $T22530[esp+848]
	call	?Set@CCorString@@QAEXPAD@Z		; CCorString::Set
	push	1
	mov	ecx, ebp
	mov	DWORD PTR __$EHRec$[esp+856], 4
	call	?Add@?$TCorArray@VCCorString@@@@QAEKK@Z	; TCorArray<CCorString>::Add
	mov	edx, DWORD PTR [ebp]
	lea	ecx, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR $T22530[esp+844]
	push	eax
	call	?Set@CCorString@@QAEXPAD@Z		; CCorString::Set
	push	edi
	lea	ecx, DWORD PTR $T22530[esp+848]
	mov	DWORD PTR __$EHRec$[esp+856], -1
	call	?Set@CCorString@@QAEXPAD@Z		; CCorString::Set

; 524  : 	sprintf(buf, "SetRotation %f %f %f", M_RADTODEG(mRotation.r), M_RADTODEG(mRotation.p), M_RADTODEG(mRotation.y)); section->commands.AddItem(buf);

	fld	DWORD PTR [esi+112]
	fmul	DWORD PTR __real@43340000
	sub	esp, 24					; 00000018H
	fmul	DWORD PTR __real@3ea2f983
	fstp	QWORD PTR [esp+16]
	fld	DWORD PTR [esi+108]
	fmul	DWORD PTR __real@43340000
	fmul	DWORD PTR __real@3ea2f983
	fstp	QWORD PTR [esp+8]
	fld	DWORD PTR [esi+104]
	fmul	DWORD PTR __real@43340000
	fmul	DWORD PTR __real@3ea2f983
	lea	ecx, DWORD PTR _buf$[esp+868]
	fstp	QWORD PTR [esp]
	push	OFFSET FLAT:??_C@_0BF@LOLC@SetRotation?5?$CFf?5?$CFf?5?$CFf?$AA@ ; `string'
	push	ecx
	call	ebx
	add	esp, 32					; 00000020H
	lea	edx, DWORD PTR _buf$[esp+844]
	lea	ecx, DWORD PTR $T22531[esp+844]
	mov	DWORD PTR $T22531[esp+844], edi
	push	edx
	call	?Set@CCorString@@QAEXPAD@Z		; CCorString::Set
	push	1
	mov	ecx, ebp
	mov	DWORD PTR __$EHRec$[esp+856], 5
	call	?Add@?$TCorArray@VCCorString@@@@QAEKK@Z	; TCorArray<CCorString>::Add
	mov	ecx, DWORD PTR [ebp]
	mov	edx, DWORD PTR $T22531[esp+844]
	push	edx
	lea	ecx, DWORD PTR [ecx+eax*4]
	call	?Set@CCorString@@QAEXPAD@Z		; CCorString::Set
	push	edi
	lea	ecx, DWORD PTR $T22531[esp+848]
	mov	DWORD PTR __$EHRec$[esp+856], -1
	call	?Set@CCorString@@QAEXPAD@Z		; CCorString::Set

; 525  : 	sprintf(buf, "SetBoundsMin %f %f %f", mBounds[0].x, mBounds[0].y, mBounds[0].z); section->commands.AddItem(buf);

	fld	DWORD PTR [esi+124]
	sub	esp, 24					; 00000018H
	lea	eax, DWORD PTR _buf$[esp+868]
	fstp	QWORD PTR [esp+16]
	fld	DWORD PTR [esi+120]
	fstp	QWORD PTR [esp+8]
	fld	DWORD PTR [esi+116]
	fstp	QWORD PTR [esp]
	push	OFFSET FLAT:??_C@_0BG@BKJK@SetBoundsMin?5?$CFf?5?$CFf?5?$CFf?$AA@ ; `string'
	push	eax
	call	ebx
	add	esp, 32					; 00000020H
	lea	ecx, DWORD PTR _buf$[esp+844]
	mov	DWORD PTR $T22532[esp+844], edi
	push	ecx
	lea	ecx, DWORD PTR $T22532[esp+848]
	call	?Set@CCorString@@QAEXPAD@Z		; CCorString::Set
	push	1
	mov	ecx, ebp
	mov	DWORD PTR __$EHRec$[esp+856], 6
	call	?Add@?$TCorArray@VCCorString@@@@QAEKK@Z	; TCorArray<CCorString>::Add
	mov	edx, DWORD PTR [ebp]
	lea	ecx, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR $T22532[esp+844]
	push	eax
	call	?Set@CCorString@@QAEXPAD@Z		; CCorString::Set
	push	edi
	lea	ecx, DWORD PTR $T22532[esp+848]
	mov	DWORD PTR __$EHRec$[esp+856], -1
	call	?Set@CCorString@@QAEXPAD@Z		; CCorString::Set

; 526  : 	sprintf(buf, "SetBoundsMax %f %f %f", mBounds[1].x, mBounds[1].y, mBounds[1].z); section->commands.AddItem(buf);

	fld	DWORD PTR [esi+136]
	sub	esp, 24					; 00000018H
	lea	ecx, DWORD PTR _buf$[esp+868]
	fstp	QWORD PTR [esp+16]
	fld	DWORD PTR [esi+132]
	fstp	QWORD PTR [esp+8]
	fld	DWORD PTR [esi+128]
	fstp	QWORD PTR [esp]
	push	OFFSET FLAT:??_C@_0BG@JCEN@SetBoundsMax?5?$CFf?5?$CFf?5?$CFf?$AA@ ; `string'
	push	ecx
	call	ebx
	add	esp, 32					; 00000020H
	lea	edx, DWORD PTR _buf$[esp+844]
	lea	ecx, DWORD PTR $T22533[esp+844]
	mov	DWORD PTR $T22533[esp+844], edi
	push	edx
	call	?Set@CCorString@@QAEXPAD@Z		; CCorString::Set
	push	1
	mov	ecx, ebp
	mov	DWORD PTR __$EHRec$[esp+856], 7
	call	?Add@?$TCorArray@VCCorString@@@@QAEKK@Z	; TCorArray<CCorString>::Add
	mov	ecx, DWORD PTR [ebp]
	mov	edx, DWORD PTR $T22533[esp+844]
	push	edx
	lea	ecx, DWORD PTR [ecx+eax*4]
	call	?Set@CCorString@@QAEXPAD@Z		; CCorString::Set
	push	edi
	lea	ecx, DWORD PTR $T22533[esp+848]
	mov	DWORD PTR __$EHRec$[esp+856], -1
	call	?Set@CCorString@@QAEXPAD@Z		; CCorString::Set

; 527  : 
; 528  : 	// add commands for used resources
; 529  : 	const NChar* path;
; 530  : 	if (mGeometry && (path = CPJ_GetChunkPath(configProject, mGeometry))) { sprintf(buf, "SetGeometry \"%s\"", path); section->commands.AddItem(buf); }

	mov	eax, DWORD PTR [esi+140]
	cmp	eax, edi
	je	SHORT $L22855
	push	eax
	mov	eax, DWORD PTR _configProject$[esp+848]
	push	eax
	call	?CPJ_GetChunkPath@@YAPBDPAVOCpjProject@@PAVOCpjChunk@@@Z ; CPJ_GetChunkPath
	add	esp, 8
	cmp	eax, edi
	je	SHORT $L22855
	push	eax
	lea	ecx, DWORD PTR _buf$[esp+848]
	push	OFFSET FLAT:??_C@_0BB@PBDG@SetGeometry?5?$CC?$CFs?$CC?$AA@ ; `string'
	push	ecx
	call	ebx
	add	esp, 12					; 0000000cH
	lea	edx, DWORD PTR _buf$[esp+844]
	lea	ecx, DWORD PTR $T22534[esp+844]
	mov	DWORD PTR $T22534[esp+844], edi
	push	edx
	call	?Set@CCorString@@QAEXPAD@Z		; CCorString::Set
	push	1
	mov	ecx, ebp
	mov	DWORD PTR __$EHRec$[esp+856], 8
	call	?Add@?$TCorArray@VCCorString@@@@QAEKK@Z	; TCorArray<CCorString>::Add
	mov	ecx, DWORD PTR [ebp]
	mov	edx, DWORD PTR $T22534[esp+844]
	push	edx
	lea	ecx, DWORD PTR [ecx+eax*4]
	call	?Set@CCorString@@QAEXPAD@Z		; CCorString::Set
	push	edi
	lea	ecx, DWORD PTR $T22534[esp+848]
	mov	DWORD PTR __$EHRec$[esp+856], -1
	call	?Set@CCorString@@QAEXPAD@Z		; CCorString::Set
$L22855:

; 531  : 	if (mSkeleton && (path = CPJ_GetChunkPath(configProject, mSkeleton))) { sprintf(buf, "SetSkeleton \"%s\"", path); section->commands.AddItem(buf); }

	mov	eax, DWORD PTR [esi+144]
	cmp	eax, edi
	je	SHORT $L22877
	push	eax
	mov	eax, DWORD PTR _configProject$[esp+848]
	push	eax
	call	?CPJ_GetChunkPath@@YAPBDPAVOCpjProject@@PAVOCpjChunk@@@Z ; CPJ_GetChunkPath
	add	esp, 8
	cmp	eax, edi
	je	SHORT $L22877
	push	eax
	lea	ecx, DWORD PTR _buf$[esp+848]
	push	OFFSET FLAT:??_C@_0BB@BEIB@SetSkeleton?5?$CC?$CFs?$CC?$AA@ ; `string'
	push	ecx
	call	ebx
	add	esp, 12					; 0000000cH
	lea	edx, DWORD PTR _buf$[esp+844]
	lea	ecx, DWORD PTR $T22535[esp+844]
	mov	DWORD PTR $T22535[esp+844], edi
	push	edx
	call	?Set@CCorString@@QAEXPAD@Z		; CCorString::Set
	push	1
	mov	ecx, ebp
	mov	DWORD PTR __$EHRec$[esp+856], 9
	call	?Add@?$TCorArray@VCCorString@@@@QAEKK@Z	; TCorArray<CCorString>::Add
	mov	ecx, DWORD PTR [ebp]
	mov	edx, DWORD PTR $T22535[esp+844]
	push	edx
	lea	ecx, DWORD PTR [ecx+eax*4]
	call	?Set@CCorString@@QAEXPAD@Z		; CCorString::Set
	push	edi
	lea	ecx, DWORD PTR $T22535[esp+848]
	mov	DWORD PTR __$EHRec$[esp+856], -1
	call	?Set@CCorString@@QAEXPAD@Z		; CCorString::Set
$L22877:

; 532  : 	if (mLodData && (path = CPJ_GetChunkPath(configProject, mLodData))) { sprintf(buf, "SetLodData \"%s\"", path); section->commands.AddItem(buf); }

	mov	eax, DWORD PTR [esi+148]
	cmp	eax, edi
	je	SHORT $L22899
	push	eax
	mov	eax, DWORD PTR _configProject$[esp+848]
	push	eax
	call	?CPJ_GetChunkPath@@YAPBDPAVOCpjProject@@PAVOCpjChunk@@@Z ; CPJ_GetChunkPath
	add	esp, 8
	cmp	eax, edi
	je	SHORT $L22899
	push	eax
	lea	ecx, DWORD PTR _buf$[esp+848]
	push	OFFSET FLAT:??_C@_0BA@FMNO@SetLodData?5?$CC?$CFs?$CC?$AA@ ; `string'
	push	ecx
	call	ebx
	add	esp, 12					; 0000000cH
	lea	edx, DWORD PTR _buf$[esp+844]
	lea	ecx, DWORD PTR $T22536[esp+844]
	mov	DWORD PTR $T22536[esp+844], edi
	push	edx
	call	?Set@CCorString@@QAEXPAD@Z		; CCorString::Set
	push	1
	mov	ecx, ebp
	mov	DWORD PTR __$EHRec$[esp+856], 10	; 0000000aH
	call	?Add@?$TCorArray@VCCorString@@@@QAEKK@Z	; TCorArray<CCorString>::Add
	mov	ecx, DWORD PTR [ebp]
	mov	edx, DWORD PTR $T22536[esp+844]
	push	edx
	lea	ecx, DWORD PTR [ecx+eax*4]
	call	?Set@CCorString@@QAEXPAD@Z		; CCorString::Set
	push	edi
	lea	ecx, DWORD PTR $T22536[esp+848]
	mov	DWORD PTR __$EHRec$[esp+856], -1
	call	?Set@CCorString@@QAEXPAD@Z		; CCorString::Set
$L22899:

; 533  : 	for (i=0;i<mSurfaces.GetCount();i++)

	mov	eax, DWORD PTR [esi+156]
	xor	edi, edi
	test	eax, eax
	jbe	$L12482
$L12480:

; 534  : 	{
; 535  : 		if (mSurfaces[i] && (path = CPJ_GetChunkPath(configProject, mSurfaces[i]))) { sprintf(buf, "SetSurface %d \"%s\"", i, path); section->commands.AddItem(buf); }

	mov	eax, DWORD PTR [esi+152]
	mov	eax, DWORD PTR [eax+edi*4]
	test	eax, eax
	je	SHORT $L12481
	mov	ecx, DWORD PTR _configProject$[esp+844]
	push	eax
	push	ecx
	call	?CPJ_GetChunkPath@@YAPBDPAVOCpjProject@@PAVOCpjChunk@@@Z ; CPJ_GetChunkPath
	add	esp, 8
	test	eax, eax
	je	SHORT $L12481
	push	eax
	push	edi
	lea	edx, DWORD PTR _buf$[esp+852]
	push	OFFSET FLAT:??_C@_0BD@DNEA@SetSurface?5?$CFd?5?$CC?$CFs?$CC?$AA@ ; `string'
	push	edx
	call	ebx
	add	esp, 16					; 00000010H
	lea	eax, DWORD PTR _buf$[esp+844]
	lea	ecx, DWORD PTR $T22537[esp+844]
	mov	DWORD PTR $T22537[esp+844], 0
	push	eax
	call	?Set@CCorString@@QAEXPAD@Z		; CCorString::Set
	push	1
	mov	ecx, ebp
	mov	DWORD PTR __$EHRec$[esp+856], 11	; 0000000bH
	call	?Add@?$TCorArray@VCCorString@@@@QAEKK@Z	; TCorArray<CCorString>::Add
	mov	ecx, DWORD PTR [ebp]
	mov	edx, DWORD PTR $T22537[esp+844]
	push	edx
	lea	ecx, DWORD PTR [ecx+eax*4]
	call	?Set@CCorString@@QAEXPAD@Z		; CCorString::Set
	push	0
	lea	ecx, DWORD PTR $T22537[esp+848]
	mov	DWORD PTR __$EHRec$[esp+856], -1
	call	?Set@CCorString@@QAEXPAD@Z		; CCorString::Set
$L12481:
	mov	eax, DWORD PTR [esi+156]
	inc	edi
	cmp	edi, eax
	jb	$L12480
$L12482:

; 536  : 	}
; 537  : 
; 538  : 	// add commands for resources taken from search paths
; 539  : 	section->commands.AddItem(CCorString("AddFrames \"NULL\""));

	xor	edi, edi
	push	OFFSET FLAT:??_C@_0BB@PHGO@AddFrames?5?$CCNULL?$CC?$AA@ ; `string'
	lea	ecx, DWORD PTR $T22538[esp+848]
	mov	DWORD PTR $T22538[esp+848], edi
	call	?Set@CCorString@@QAEXPAD@Z		; CCorString::Set
	push	1
	mov	ecx, ebp
	mov	DWORD PTR __$EHRec$[esp+856], 12	; 0000000cH
	call	?Add@?$TCorArray@VCCorString@@@@QAEKK@Z	; TCorArray<CCorString>::Add
	mov	ecx, DWORD PTR [ebp]
	mov	edx, DWORD PTR $T22538[esp+844]
	push	edx
	lea	ecx, DWORD PTR [ecx+eax*4]
	call	?Set@CCorString@@QAEXPAD@Z		; CCorString::Set
	push	edi
	lea	ecx, DWORD PTR $T22538[esp+848]
	mov	DWORD PTR __$EHRec$[esp+856], -1
	call	?Set@CCorString@@QAEXPAD@Z		; CCorString::Set

; 540  : 	TCorArray<OCpjProject*> frmProjects;

	push	4
	push	edi
	lea	ecx, DWORD PTR _frmProjects$[esp+852]
	call	??0CCorArray@@IAE@KK@Z			; CCorArray::CCorArray

; 541  : 	for (i=0;i<mFrames.GetCount();i++)

	mov	eax, DWORD PTR [esi+172]
	mov	DWORD PTR __$EHRec$[esp+852], 13	; 0000000dH
	test	eax, eax
	jbe	$L12537
$L12535:

; 542  : 	{
; 543  : 		if (mFrames[i] && mFrames[i]->GetParent() && mFrames[i]->GetParent()->IsA(OCpjProject::GetStaticClass()))

	mov	eax, DWORD PTR [esi+168]
	mov	ecx, DWORD PTR [eax+edi*4]
	test	ecx, ecx
	je	SHORT $L12536
	mov	edx, DWORD PTR [ecx]
	call	DWORD PTR [edx+32]
	test	eax, eax
	je	SHORT $L12536
	mov	eax, DWORD PTR [esi+168]
	mov	ecx, DWORD PTR [eax+edi*4]
	mov	edx, DWORD PTR [ecx]
	call	DWORD PTR [edx+32]
	mov	ecx, DWORD PTR ?staticObjClass@OCpjProject@@0PAVCObjClass@@A ; OCpjProject::staticObjClass
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+44]
	test	al, al
	je	SHORT $L23894

; 544  : 			frmProjects.AddUnique((OCpjProject*)mFrames[i]->GetParent());

	mov	edx, DWORD PTR [esi+168]
	mov	ecx, DWORD PTR [edx+edi*4]
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+32]
	lea	ecx, DWORD PTR _i$22989[esp+844]
	lea	edx, DWORD PTR $T22539[esp+844]
	push	ecx
	push	edx
	lea	ecx, DWORD PTR _frmProjects$[esp+852]
	mov	DWORD PTR $T22539[esp+852], eax
	call	?FindItem@?$TCorArray@PAVOCpjProject@@@@QBE_NABQAVOCpjProject@@PAK@Z ; TCorArray<OCpjProject *>::FindItem
	test	al, al
	jne	SHORT $L23894
	push	1
	lea	ecx, DWORD PTR _frmProjects$[esp+848]
	call	?Add@?$TCorArray@PAVOCpjProject@@@@QAEKK@Z ; TCorArray<OCpjProject *>::Add
	mov	ecx, DWORD PTR _frmProjects$[esp+844]
	mov	edx, DWORD PTR $T22539[esp+844]
	mov	DWORD PTR [ecx+eax*4], edx
$L23894:
	mov	ebx, DWORD PTR __imp__sprintf
$L12536:

; 541  : 	for (i=0;i<mFrames.GetCount();i++)

	mov	eax, DWORD PTR [esi+172]
	inc	edi
	cmp	edi, eax
	jb	$L12535
$L12537:

; 545  : 	}
; 546  : 	for (i=0;i<frmProjects.GetCount();i++)

	mov	eax, DWORD PTR _frmProjects$[esp+848]
	mov	DWORD PTR _i$[esp+844], 0
	test	eax, eax
	jbe	$L12543
$L12541:

; 547  : 	{
; 548  : 		if (frmProjects[i] == configProject)

	mov	eax, DWORD PTR _frmProjects$[esp+844]
	mov	ecx, DWORD PTR _i$[esp+844]
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	ecx, DWORD PTR _configProject$[esp+844]
	cmp	eax, ecx
	je	$L12542

; 549  : 			continue; // already have null in the search path
; 550  : 		if (path = CPJ_GetProjectPath(frmProjects[i]))

	push	eax
	call	?CPJ_GetProjectPath@@YAPBDPAVOCpjProject@@@Z ; CPJ_GetProjectPath
	add	esp, 4
	mov	DWORD PTR _path$[esp+844], eax
	test	eax, eax
	je	$L12542

; 551  : 		{			
; 552  : 			for (NDword j=0;j<mFramesFiles.GetCount();j++)

	mov	eax, DWORD PTR [esi+204]
	xor	edi, edi
	test	eax, eax
	jbe	SHORT $L12549
$L12547:
	mov	edx, DWORD PTR [esi+200]
	lea	eax, DWORD PTR [edx+edi*4]

; 553  : 			{
; 554  : 				if (!stricmp(*mFramesFiles[j], path))

	mov	eax, DWORD PTR [edx+edi*4]
	test	eax, eax
	jne	SHORT $L23022
	mov	eax, OFFSET FLAT:??_C@_00A@?$AA@	; `string'
$L23022:
	mov	ecx, DWORD PTR _path$[esp+844]
	push	ecx
	push	eax
	call	DWORD PTR __imp__stricmp
	add	esp, 8
	test	eax, eax
	je	$L12542
	mov	eax, DWORD PTR [esi+204]
	inc	edi
	cmp	edi, eax
	jb	SHORT $L12547
$L12549:

; 555  : 				{
; 556  : 					path = NULL; // project is a known file, no need to add it
; 557  : 					break;
; 558  : 				}
; 559  : 			}
; 560  : 			if (!path)
; 561  : 				continue;
; 562  : 
; 563  : 			char b1[256];
; 564  : 			strcpy(b1, STR_FilePath((NChar*)path));

	mov	edx, DWORD PTR _path$[esp+844]
	push	edx
	call	?STR_FilePath@@YAPADPAD@Z		; STR_FilePath
	add	esp, 4
	lea	edx, DWORD PTR _b1$12552[esp+844]
$L22540:
	mov	cl, BYTE PTR [eax]
	inc	eax
	mov	BYTE PTR [edx], cl
	inc	edx
	test	cl, cl
	jne	SHORT $L22540

; 565  : 			for (j=0;j<mFramesStarFiles.GetCount();j++)

	mov	eax, DWORD PTR [esi+220]
	xor	edi, edi
	test	eax, eax
	jbe	SHORT $L12556
$L12554:
	mov	eax, DWORD PTR [esi+216]
	lea	eax, DWORD PTR [eax+edi*4]

; 566  : 			{
; 567  : 				char b2[256];
; 568  : 				strcpy(b2, STR_FilePath(*mFramesStarFiles[j]));

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	jne	SHORT $L23041
	mov	eax, OFFSET FLAT:??_C@_00A@?$AA@	; `string'
$L23041:
	push	eax
	call	?STR_FilePath@@YAPADPAD@Z		; STR_FilePath
	add	esp, 4
	lea	edx, DWORD PTR _b2$12557[esp+844]
$L22541:
	mov	cl, BYTE PTR [eax]
	inc	eax
	mov	BYTE PTR [edx], cl
	inc	edx
	test	cl, cl
	jne	SHORT $L22541

; 569  : 				if (!stricmp(b1, b2))

	lea	ecx, DWORD PTR _b2$12557[esp+844]
	lea	edx, DWORD PTR _b1$12552[esp+844]
	push	ecx
	push	edx
	call	DWORD PTR __imp__stricmp
	add	esp, 8
	test	eax, eax
	je	SHORT $L12542
	mov	eax, DWORD PTR [esi+220]
	inc	edi
	cmp	edi, eax
	jb	SHORT $L12554
$L12556:

; 570  : 				{
; 571  : 					path = NULL; // project is part of a star path, no need to add it
; 572  : 					break;
; 573  : 				}
; 574  : 			}
; 575  : 			if (path)
; 576  : 			{
; 577  : 				sprintf(buf, "AddFrames \"%s\"", path);

	mov	eax, DWORD PTR _path$[esp+844]
	lea	ecx, DWORD PTR _buf$[esp+844]
	push	eax
	push	OFFSET FLAT:??_C@_0P@LABC@AddFrames?5?$CC?$CFs?$CC?$AA@ ; `string'
	push	ecx
	call	ebx
	add	esp, 12					; 0000000cH

; 578  : 				section->commands.AddItem(buf);

	lea	edx, DWORD PTR _buf$[esp+844]
	lea	ecx, DWORD PTR $T22542[esp+844]
	mov	DWORD PTR $T22542[esp+844], 0
	push	edx
	call	?Set@CCorString@@QAEXPAD@Z		; CCorString::Set
	push	1
	mov	ecx, ebp
	mov	BYTE PTR __$EHRec$[esp+856], 14		; 0000000eH
	call	?Add@?$TCorArray@VCCorString@@@@QAEKK@Z	; TCorArray<CCorString>::Add
	mov	ecx, DWORD PTR [ebp]
	mov	edx, DWORD PTR $T22542[esp+844]
	push	edx
	lea	ecx, DWORD PTR [ecx+eax*4]
	call	?Set@CCorString@@QAEXPAD@Z		; CCorString::Set
	push	0
	lea	ecx, DWORD PTR $T22542[esp+848]
	mov	BYTE PTR __$EHRec$[esp+856], 13		; 0000000dH
	call	?Set@CCorString@@QAEXPAD@Z		; CCorString::Set
$L12542:
	mov	eax, DWORD PTR _i$[esp+844]
	mov	ecx, DWORD PTR _frmProjects$[esp+848]
	inc	eax
	cmp	eax, ecx
	mov	DWORD PTR _i$[esp+844], eax
	jb	$L12541
$L12543:

; 579  : 			}
; 580  : 		}
; 581  : 	}
; 582  : 	for (i=0;i<mFramesFiles.GetCount();i++)

	mov	eax, DWORD PTR [esi+204]
	xor	edi, edi
	test	eax, eax
	jbe	$L12564
$L12562:

; 583  : 	{
; 584  : 		if (configProject)

	mov	eax, DWORD PTR _configProject$[esp+844]
	test	eax, eax
	je	SHORT $L12567

; 585  : 		{
; 586  : 			const NChar* path = CPJ_GetProjectPath(configProject);

	push	eax
	call	?CPJ_GetProjectPath@@YAPBDPAVOCpjProject@@@Z ; CPJ_GetProjectPath
	mov	ecx, DWORD PTR [esi+200]
	add	esp, 4
	lea	ecx, DWORD PTR [ecx+edi*4]

; 587  : 			if (!stricmp(*mFramesFiles[i], path))

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	jne	SHORT $L23082
	mov	ecx, OFFSET FLAT:??_C@_00A@?$AA@	; `string'
$L23082:
	push	eax
	push	ecx
	call	DWORD PTR __imp__stricmp
	add	esp, 8
	test	eax, eax
	je	SHORT $L12563
$L12567:

; 579  : 			}
; 580  : 		}
; 581  : 	}
; 582  : 	for (i=0;i<mFramesFiles.GetCount();i++)

	mov	edx, DWORD PTR [esi+200]
	lea	eax, DWORD PTR [edx+edi*4]

; 588  : 				continue;
; 589  : 		}
; 590  : 		sprintf(buf, "AddFrames \"%s\"", *mFramesFiles[i]);

	mov	eax, DWORD PTR [edx+edi*4]
	test	eax, eax
	jne	SHORT $L23097
	mov	eax, OFFSET FLAT:??_C@_00A@?$AA@	; `string'
$L23097:
	push	eax
	lea	eax, DWORD PTR _buf$[esp+848]
	push	OFFSET FLAT:??_C@_0P@LABC@AddFrames?5?$CC?$CFs?$CC?$AA@ ; `string'
	push	eax
	call	ebx
	add	esp, 12					; 0000000cH

; 591  : 		section->commands.AddItem(buf);

	lea	ecx, DWORD PTR _buf$[esp+844]
	mov	DWORD PTR $T22543[esp+844], 0
	push	ecx
	lea	ecx, DWORD PTR $T22543[esp+848]
	call	?Set@CCorString@@QAEXPAD@Z		; CCorString::Set
	push	1
	mov	ecx, ebp
	mov	BYTE PTR __$EHRec$[esp+856], 15		; 0000000fH
	call	?Add@?$TCorArray@VCCorString@@@@QAEKK@Z	; TCorArray<CCorString>::Add
	mov	edx, DWORD PTR [ebp]
	lea	ecx, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR $T22543[esp+844]
	push	eax
	call	?Set@CCorString@@QAEXPAD@Z		; CCorString::Set
	push	0
	lea	ecx, DWORD PTR $T22543[esp+848]
	mov	BYTE PTR __$EHRec$[esp+856], 13		; 0000000dH
	call	?Set@CCorString@@QAEXPAD@Z		; CCorString::Set
$L12563:
	mov	eax, DWORD PTR [esi+204]
	inc	edi
	cmp	edi, eax
	jb	$L12562
$L12564:

; 592  : 	}
; 593  : 	for (i=0;i<mFramesStarFiles.GetCount();i++)

	mov	eax, DWORD PTR [esi+220]
	xor	edi, edi
	test	eax, eax
	jbe	SHORT $L12571
$L12569:
	mov	ecx, DWORD PTR [esi+216]
	lea	eax, DWORD PTR [ecx+edi*4]

; 594  : 	{
; 595  : 		sprintf(buf, "AddFrames \"%s\"", *mFramesStarFiles[i]);

	mov	eax, DWORD PTR [ecx+edi*4]
	test	eax, eax
	jne	SHORT $L23138
	mov	eax, OFFSET FLAT:??_C@_00A@?$AA@	; `string'
$L23138:
	push	eax
	lea	edx, DWORD PTR _buf$[esp+848]
	push	OFFSET FLAT:??_C@_0P@LABC@AddFrames?5?$CC?$CFs?$CC?$AA@ ; `string'
	push	edx
	call	ebx
	add	esp, 12					; 0000000cH

; 596  : 		section->commands.AddItem(buf);

	lea	eax, DWORD PTR _buf$[esp+844]
	lea	ecx, DWORD PTR $T22544[esp+844]
	mov	DWORD PTR $T22544[esp+844], 0
	push	eax
	call	?Set@CCorString@@QAEXPAD@Z		; CCorString::Set
	push	1
	mov	ecx, ebp
	mov	BYTE PTR __$EHRec$[esp+856], 16		; 00000010H
	call	?Add@?$TCorArray@VCCorString@@@@QAEKK@Z	; TCorArray<CCorString>::Add
	mov	ecx, DWORD PTR [ebp]
	mov	edx, DWORD PTR $T22544[esp+844]
	push	edx
	lea	ecx, DWORD PTR [ecx+eax*4]
	call	?Set@CCorString@@QAEXPAD@Z		; CCorString::Set
	push	0
	lea	ecx, DWORD PTR $T22544[esp+848]
	mov	BYTE PTR __$EHRec$[esp+856], 13		; 0000000dH
	call	?Set@CCorString@@QAEXPAD@Z		; CCorString::Set
	mov	eax, DWORD PTR [esi+220]
	inc	edi
	cmp	edi, eax
	jb	SHORT $L12569
$L12571:

; 597  : 	}
; 598  : 
; 599  : 	section->commands.AddItem(CCorString("AddSequences \"NULL\""));

	xor	edi, edi
	push	OFFSET FLAT:??_C@_0BE@HFDO@AddSequences?5?$CCNULL?$CC?$AA@ ; `string'
	lea	ecx, DWORD PTR $T22545[esp+848]
	mov	DWORD PTR $T22545[esp+848], edi
	call	?Set@CCorString@@QAEXPAD@Z		; CCorString::Set
	push	1
	mov	ecx, ebp
	mov	BYTE PTR __$EHRec$[esp+856], 17		; 00000011H
	call	?Add@?$TCorArray@VCCorString@@@@QAEKK@Z	; TCorArray<CCorString>::Add
	mov	ecx, DWORD PTR [ebp]
	mov	edx, DWORD PTR $T22545[esp+844]
	push	edx
	lea	ecx, DWORD PTR [ecx+eax*4]
	call	?Set@CCorString@@QAEXPAD@Z		; CCorString::Set
	push	edi
	lea	ecx, DWORD PTR $T22545[esp+848]
	mov	BYTE PTR __$EHRec$[esp+856], 13		; 0000000dH
	call	?Set@CCorString@@QAEXPAD@Z		; CCorString::Set

; 600  : 	TCorArray<OCpjProject*> seqProjects;

	push	4
	lea	ecx, DWORD PTR _seqProjects$[esp+848]
	mov	DWORD PTR _seqProjects$[esp+848], edi
	mov	DWORD PTR _seqProjects$[esp+852], edi
	mov	DWORD PTR _seqProjects$[esp+856], edi
	mov	DWORD PTR _seqProjects$[esp+860], 4
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc

; 601  : 	for (i=0;i<mSequences.GetCount();i++)

	mov	eax, DWORD PTR [esi+188]
	mov	BYTE PTR __$EHRec$[esp+852], 18		; 00000012H
	cmp	eax, edi
	jbe	SHORT $L12578
$L12576:

; 602  : 	{
; 603  : 		if (mSequences[i] && mSequences[i]->GetParent() && mSequences[i]->GetParent()->IsA(OCpjProject::GetStaticClass()))

	mov	eax, DWORD PTR [esi+184]
	mov	ecx, DWORD PTR [eax+edi*4]
	test	ecx, ecx
	je	SHORT $L12577
	mov	edx, DWORD PTR [ecx]
	call	DWORD PTR [edx+32]
	test	eax, eax
	je	SHORT $L12577
	mov	eax, DWORD PTR [esi+184]
	mov	ecx, DWORD PTR [eax+edi*4]
	mov	edx, DWORD PTR [ecx]
	call	DWORD PTR [edx+32]
	mov	ecx, DWORD PTR ?staticObjClass@OCpjProject@@0PAVCObjClass@@A ; OCpjProject::staticObjClass
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+44]
	test	al, al
	je	SHORT $L12577

; 604  : 			seqProjects.AddUnique((OCpjProject*)mSequences[i]->GetParent());

	mov	edx, DWORD PTR [esi+184]
	mov	ecx, DWORD PTR [edx+edi*4]
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+32]
	mov	edx, DWORD PTR _seqProjects$[esp+848]
	xor	ecx, ecx
	test	edx, edx
	mov	DWORD PTR $T22546[esp+844], eax
	jbe	SHORT $L23235
	mov	ebx, DWORD PTR _seqProjects$[esp+844]
$L23233:
	cmp	DWORD PTR [ebx+ecx*4], eax
	je	SHORT $L12577
	inc	ecx
	cmp	ecx, edx
	jb	SHORT $L23233
$L23235:
	lea	ecx, DWORD PTR $T22546[esp+844]
	push	ecx
	lea	ecx, DWORD PTR _seqProjects$[esp+848]
	call	?AddItem@?$TCorArray@PAVOCpjProject@@@@QAEKABQAVOCpjProject@@@Z ; TCorArray<OCpjProject *>::AddItem
$L12577:
	mov	eax, DWORD PTR [esi+188]
	inc	edi
	cmp	edi, eax
	jb	SHORT $L12576

; 601  : 	for (i=0;i<mSequences.GetCount();i++)

	xor	edi, edi
$L12578:

; 605  : 	}
; 606  : 	for (i=0;i<seqProjects.GetCount();i++)

	mov	ecx, DWORD PTR _seqProjects$[esp+848]
	xor	eax, eax
	cmp	ecx, edi
	mov	DWORD PTR _i$[esp+844], eax
	jbe	$L12584
$L12582:

; 607  : 	{
; 608  : 		if (seqProjects[i] == configProject)

	mov	edx, DWORD PTR _seqProjects$[esp+844]
	mov	ecx, DWORD PTR _configProject$[esp+844]
	mov	eax, DWORD PTR [edx+eax*4]
	cmp	eax, ecx
	je	$L12583

; 609  : 			continue; // already have null in the search path
; 610  : 		if (path = CPJ_GetProjectPath(seqProjects[i]))

	push	eax
	call	?CPJ_GetProjectPath@@YAPBDPAVOCpjProject@@@Z ; CPJ_GetProjectPath
	mov	ebx, eax
	add	esp, 4
	test	ebx, ebx
	je	$L12583

; 611  : 		{
; 612  : 			for (NDword j=0;j<mSequencesFiles.GetCount();j++)

	mov	eax, DWORD PTR [esi+236]
	xor	edi, edi
	test	eax, eax
	jbe	SHORT $L12590
$L12588:
	mov	eax, DWORD PTR [esi+232]
	lea	eax, DWORD PTR [eax+edi*4]

; 613  : 			{
; 614  : 				if (!stricmp(*mSequencesFiles[j], path))

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	jne	SHORT $L23263
	mov	eax, OFFSET FLAT:??_C@_00A@?$AA@	; `string'
$L23263:
	push	ebx
	push	eax
	call	DWORD PTR __imp__stricmp
	add	esp, 8
	test	eax, eax
	je	$L12583
	mov	eax, DWORD PTR [esi+236]
	inc	edi
	cmp	edi, eax
	jb	SHORT $L12588
$L12590:

; 615  : 				{
; 616  : 					path = NULL; // project is a known file, no need to add it
; 617  : 					break;
; 618  : 				}
; 619  : 			}
; 620  : 			if (!path)
; 621  : 				continue;
; 622  : 
; 623  : 			char b1[256];
; 624  : 			strcpy(b1, STR_FilePath((NChar*)path));

	push	ebx
	call	?STR_FilePath@@YAPADPAD@Z		; STR_FilePath
	add	esp, 4
	lea	edx, DWORD PTR _b1$12593[esp+844]
$L22547:
	mov	cl, BYTE PTR [eax]
	inc	eax
	mov	BYTE PTR [edx], cl
	inc	edx
	test	cl, cl
	jne	SHORT $L22547

; 625  : 			for (j=0;j<mSequencesStarFiles.GetCount();j++)

	mov	eax, DWORD PTR [esi+252]
	xor	edi, edi
	test	eax, eax
	jbe	SHORT $L12597
$L12595:
	mov	ecx, DWORD PTR [esi+248]
	lea	eax, DWORD PTR [ecx+edi*4]

; 626  : 			{
; 627  : 				char b2[256];
; 628  : 				strcpy(b2, STR_FilePath(*mSequencesStarFiles[j]));

	mov	eax, DWORD PTR [ecx+edi*4]
	test	eax, eax
	jne	SHORT $L23282
	mov	eax, OFFSET FLAT:??_C@_00A@?$AA@	; `string'
$L23282:
	push	eax
	call	?STR_FilePath@@YAPADPAD@Z		; STR_FilePath
	add	esp, 4
	lea	edx, DWORD PTR _b2$12598[esp+844]
$L22548:
	mov	cl, BYTE PTR [eax]
	inc	eax
	mov	BYTE PTR [edx], cl
	inc	edx
	test	cl, cl
	jne	SHORT $L22548

; 629  : 				if (!stricmp(b1, b2))

	lea	edx, DWORD PTR _b2$12598[esp+844]
	lea	eax, DWORD PTR _b1$12593[esp+844]
	push	edx
	push	eax
	call	DWORD PTR __imp__stricmp
	add	esp, 8
	test	eax, eax
	je	$L12583
	mov	eax, DWORD PTR [esi+252]
	inc	edi
	cmp	edi, eax
	jb	SHORT $L12595
$L12597:

; 630  : 				{
; 631  : 					path = NULL; // project is part of a star path, no need to add it
; 632  : 					break;
; 633  : 				}
; 634  : 			}
; 635  : 			if (path)
; 636  : 			{
; 637  : 				sprintf(buf, "AddSequences \"%s\"", path);

	push	ebx
	lea	ecx, DWORD PTR _buf$[esp+848]
	push	OFFSET FLAT:??_C@_0BC@FMMO@AddSequences?5?$CC?$CFs?$CC?$AA@ ; `string'
	push	ecx
	call	DWORD PTR __imp__sprintf

; 638  : 				section->commands.AddItem(buf);

	mov	al, BYTE PTR _buf$[esp+856]
	add	esp, 12					; 0000000cH
	lea	edx, DWORD PTR _buf$[esp+844]
	test	al, al
	mov	DWORD PTR $T23297[esp+844], edx
	jne	SHORT $L23302
	mov	DWORD PTR $T23297[esp+844], 0
$L23302:
	mov	eax, DWORD PTR $T23297[esp+844]
	xor	ebx, ebx
	test	eax, eax
	mov	DWORD PTR $T22549[esp+844], ebx
	je	SHORT $L23305
	mov	edi, eax
	or	ecx, -1
	xor	eax, eax
	repne scasb
	not	ecx
	dec	ecx
	mov	edi, ecx
	inc	edi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	edi
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	ebx, eax
	test	ebx, ebx
	mov	DWORD PTR $T22549[esp+844], ebx
	je	SHORT $L23305
	mov	eax, DWORD PTR $T23297[esp+844]
	mov	edx, ebx
	sub	edx, eax
$L23307:
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx+eax], cl
	inc	eax
	test	cl, cl
	jne	SHORT $L23307
	add	DWORD PTR ?sMemTotal@CCorString@@0KA, edi ; CCorString::sMemTotal
$L23305:
	push	1
	mov	ecx, ebp
	mov	BYTE PTR __$EHRec$[esp+856], 19		; 00000013H
	call	?AddNoConstruct@?$TCorArray@VCCorString@@@@QAEKK@Z ; TCorArray<CCorString>::AddNoConstruct
	lea	edi, DWORD PTR [eax+1]
	mov	ecx, eax
	cmp	eax, edi
	jae	SHORT $L23358
$L23356:
	mov	edx, DWORD PTR [ebp]
	lea	edx, DWORD PTR [edx+ecx*4]
	test	edx, edx
	je	SHORT $L23363
	mov	DWORD PTR [edx], 0
$L23363:
	inc	ecx
	cmp	ecx, edi
	jb	SHORT $L23356
$L23358:
	mov	ecx, DWORD PTR [ebp]
	push	ebx
	lea	ecx, DWORD PTR [ecx+eax*4]
	call	?Set@CCorString@@QAEXPAD@Z		; CCorString::Set
	test	ebx, ebx
	mov	BYTE PTR __$EHRec$[esp+852], 18		; 00000012H
	je	SHORT $L12583
	mov	edi, ebx
	or	ecx, -1
	xor	eax, eax
	or	edx, -1
	repne scasb
	mov	edi, DWORD PTR ?sMemTotal@CCorString@@0KA ; CCorString::sMemTotal
	not	ecx
	dec	ecx
	sub	edx, ecx
	add	edi, edx
	mov	DWORD PTR ?sMemTotal@CCorString@@0KA, edi ; CCorString::sMemTotal
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	ebx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L12583:
	mov	eax, DWORD PTR _i$[esp+844]
	mov	ecx, DWORD PTR _seqProjects$[esp+848]
	inc	eax
	cmp	eax, ecx
	mov	DWORD PTR _i$[esp+844], eax
	jb	$L12582
$L12584:

; 639  : 			}
; 640  : 		}
; 641  : 	}
; 642  : 	for (i=0;i<mSequencesFiles.GetCount();i++)

	mov	eax, DWORD PTR [esi+236]
	xor	edi, edi
	test	eax, eax
	mov	DWORD PTR _i$[esp+844], edi
	jbe	$L12605
$L12603:

; 643  : 	{
; 644  : 		if (configProject)

	mov	eax, DWORD PTR _configProject$[esp+844]
	test	eax, eax
	je	SHORT $L12608

; 645  : 		{
; 646  : 			const NChar* path = CPJ_GetProjectPath(configProject);

	push	eax
	call	?CPJ_GetProjectPath@@YAPBDPAVOCpjProject@@@Z ; CPJ_GetProjectPath
	mov	ecx, DWORD PTR [esi+232]
	add	esp, 4
	lea	ecx, DWORD PTR [ecx+edi*4]

; 647  : 			if (!stricmp(*mSequencesFiles[i], path))

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	jne	SHORT $L23413
	mov	ecx, OFFSET FLAT:??_C@_00A@?$AA@	; `string'
$L23413:
	push	eax
	push	ecx
	call	DWORD PTR __imp__stricmp
	add	esp, 8
	test	eax, eax
	je	$L12604
$L12608:

; 639  : 			}
; 640  : 		}
; 641  : 	}
; 642  : 	for (i=0;i<mSequencesFiles.GetCount();i++)

	mov	edx, DWORD PTR [esi+232]

; 648  : 				continue;
; 649  : 		}
; 650  : 		sprintf(buf, "AddSequences \"%s\"", *mSequencesFiles[i]);

	mov	eax, DWORD PTR [edx+edi*4]
	lea	edi, DWORD PTR [edx+edi*4]
	test	eax, eax
	jne	SHORT $L23428
	mov	eax, OFFSET FLAT:??_C@_00A@?$AA@	; `string'
$L23428:
	push	eax
	lea	eax, DWORD PTR _buf$[esp+848]
	push	OFFSET FLAT:??_C@_0BC@FMMO@AddSequences?5?$CC?$CFs?$CC?$AA@ ; `string'
	push	eax
	call	DWORD PTR __imp__sprintf

; 651  : 		section->commands.AddItem(buf);

	mov	al, BYTE PTR _buf$[esp+856]
	add	esp, 12					; 0000000cH
	test	al, al
	lea	ebx, DWORD PTR _buf$[esp+844]
	jne	SHORT $L23449
	xor	ebx, ebx
$L23449:
	test	ebx, ebx
	mov	DWORD PTR $T22550[esp+844], 0
	je	SHORT $L23452
	mov	edi, ebx
	or	ecx, -1
	xor	eax, eax
	repne scasb
	not	ecx
	dec	ecx
	mov	edi, ecx
	inc	edi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	edi
	mov	ecx, eax
	call	DWORD PTR [edx]
	test	eax, eax
	mov	DWORD PTR $T22550[esp+844], eax
	je	SHORT $L23452
	mov	edx, DWORD PTR $T22550[esp+844]
	mov	eax, ebx
	sub	edx, ebx
$L23446:
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx+eax], cl
	inc	eax
	test	cl, cl
	jne	SHORT $L23446
	add	DWORD PTR ?sMemTotal@CCorString@@0KA, edi ; CCorString::sMemTotal
$L23452:
	push	1
	mov	ecx, ebp
	mov	BYTE PTR __$EHRec$[esp+856], 20		; 00000014H
	call	?AddNoConstruct@?$TCorArray@VCCorString@@@@QAEKK@Z ; TCorArray<CCorString>::AddNoConstruct
	lea	edi, DWORD PTR [eax+1]
	mov	ecx, eax
	cmp	eax, edi
	jae	SHORT $L23516
$L23514:
	mov	edx, DWORD PTR [ebp]
	lea	edx, DWORD PTR [edx+ecx*4]
	test	edx, edx
	je	SHORT $L23503
	mov	DWORD PTR [edx], 0
$L23503:
	inc	ecx
	cmp	ecx, edi
	jb	SHORT $L23514
$L23516:
	mov	ecx, DWORD PTR [ebp]
	mov	edi, DWORD PTR $T22550[esp+844]
	push	edi
	lea	ecx, DWORD PTR [ecx+eax*4]
	call	?Set@CCorString@@QAEXPAD@Z		; CCorString::Set
	test	edi, edi
	mov	BYTE PTR __$EHRec$[esp+852], 18		; 00000012H
	je	SHORT $L23900
	or	ecx, -1
	xor	eax, eax
	mov	ebx, edi
	or	edx, -1
	repne scasb
	mov	edi, DWORD PTR ?sMemTotal@CCorString@@0KA ; CCorString::sMemTotal
	not	ecx
	dec	ecx
	sub	edx, ecx
	add	edi, edx
	mov	DWORD PTR ?sMemTotal@CCorString@@0KA, edi ; CCorString::sMemTotal
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	ebx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L23900:
	mov	edi, DWORD PTR _i$[esp+844]
$L12604:

; 639  : 			}
; 640  : 		}
; 641  : 	}
; 642  : 	for (i=0;i<mSequencesFiles.GetCount();i++)

	mov	eax, DWORD PTR [esi+236]
	inc	edi
	cmp	edi, eax
	mov	DWORD PTR _i$[esp+844], edi
	jb	$L12603
$L12605:

; 652  : 	}
; 653  : 	for (i=0;i<mSequencesStarFiles.GetCount();i++)

	mov	eax, DWORD PTR [esi+252]
	mov	DWORD PTR _i$[esp+844], 0
	test	eax, eax
	jbe	$L12612
$L12610:
	mov	eax, DWORD PTR [esi+248]
	mov	ecx, DWORD PTR _i$[esp+844]
	lea	eax, DWORD PTR [eax+ecx*4]

; 654  : 	{
; 655  : 		sprintf(buf, "AddSequences \"%s\"", *mSequencesStarFiles[i]);

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	jne	SHORT $L23559
	mov	eax, OFFSET FLAT:??_C@_00A@?$AA@	; `string'
$L23559:
	push	eax
	lea	edx, DWORD PTR _buf$[esp+848]
	push	OFFSET FLAT:??_C@_0BC@FMMO@AddSequences?5?$CC?$CFs?$CC?$AA@ ; `string'
	push	edx
	call	DWORD PTR __imp__sprintf

; 656  : 		section->commands.AddItem(buf);

	mov	al, BYTE PTR _buf$[esp+856]
	add	esp, 12					; 0000000cH
	test	al, al
	lea	ebx, DWORD PTR _buf$[esp+844]
	jne	SHORT $L23580
	xor	ebx, ebx
$L23580:
	test	ebx, ebx
	mov	DWORD PTR $T22551[esp+844], 0
	je	SHORT $L23583
	mov	edi, ebx
	or	ecx, -1
	xor	eax, eax
	repne scasb
	not	ecx
	dec	ecx
	mov	edi, ecx
	inc	edi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	edi
	mov	ecx, eax
	call	DWORD PTR [edx]
	test	eax, eax
	mov	DWORD PTR $T22551[esp+844], eax
	je	SHORT $L23583
	mov	edx, DWORD PTR $T22551[esp+844]
	mov	eax, ebx
	sub	edx, ebx
$L23577:
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [eax+edx], cl
	inc	eax
	test	cl, cl
	jne	SHORT $L23577
	add	DWORD PTR ?sMemTotal@CCorString@@0KA, edi ; CCorString::sMemTotal
$L23583:
	mov	edi, DWORD PTR [ebp+4]
	mov	eax, DWORD PTR [ebp+8]
	mov	BYTE PTR __$EHRec$[esp+852], 21		; 00000015H
	lea	ebx, DWORD PTR [edi+1]
	cmp	ebx, eax
	mov	DWORD PTR [ebp+4], ebx
	jbe	SHORT $L23667
	mov	eax, ebx
	push	4
	shr	eax, 2
	lea	ecx, DWORD PTR [eax+ebx+32]
	mov	DWORD PTR [ebp+8], ecx
	mov	ecx, ebp
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
$L23667:
	cmp	edi, ebx
	mov	ecx, edi
	jae	SHORT $L23679
$L23677:
	mov	edx, DWORD PTR [ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	test	eax, eax
	je	SHORT $L23662
	mov	DWORD PTR [eax], 0
$L23662:
	inc	ecx
	cmp	ecx, ebx
	jb	SHORT $L23677
$L23679:
	mov	eax, DWORD PTR [ebp]
	lea	ebx, DWORD PTR [eax+edi*4]
	mov	eax, DWORD PTR $T22551[esp+844]
	test	eax, eax
	mov	DWORD PTR $T23643[esp+844], eax
	je	SHORT $L23686
	cmp	BYTE PTR [eax], 0
	jne	SHORT $L23686
	mov	DWORD PTR $T23643[esp+844], 0
$L23686:
	mov	edi, DWORD PTR [ebx]
	test	edi, edi
	je	SHORT $L23687
	or	ecx, -1
	xor	eax, eax
	repne scasb
	mov	eax, DWORD PTR ?sMemTotal@CCorString@@0KA ; CCorString::sMemTotal
	or	edx, -1
	not	ecx
	dec	ecx
	sub	edx, ecx
	add	eax, edx
	mov	DWORD PTR ?sMemTotal@CCorString@@0KA, eax ; CCorString::sMemTotal
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [ebx]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L23687:
	mov	edi, DWORD PTR $T23643[esp+844]
	mov	DWORD PTR [ebx], 0
	test	edi, edi
	je	SHORT $L23690
	or	ecx, -1
	xor	eax, eax
	repne scasb
	not	ecx
	dec	ecx
	mov	edi, ecx
	inc	edi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	edi
	mov	ecx, eax
	call	DWORD PTR [edx]
	test	eax, eax
	mov	DWORD PTR [ebx], eax
	je	SHORT $L23690
	mov	edx, DWORD PTR $T23643[esp+844]
$L23684:
	mov	cl, BYTE PTR [edx]
	inc	edx
	mov	BYTE PTR [eax], cl
	inc	eax
	test	cl, cl
	jne	SHORT $L23684
	add	DWORD PTR ?sMemTotal@CCorString@@0KA, edi ; CCorString::sMemTotal
$L23690:
	mov	eax, DWORD PTR $T22551[esp+844]
	mov	BYTE PTR __$EHRec$[esp+852], 18		; 00000012H
	test	eax, eax
	je	SHORT $L12611
	mov	ebx, eax
	or	ecx, -1
	mov	edi, ebx
	xor	eax, eax
	repne scasb
	mov	edx, DWORD PTR ?sMemTotal@CCorString@@0KA ; CCorString::sMemTotal
	or	eax, -1
	not	ecx
	dec	ecx
	sub	eax, ecx
	add	edx, eax
	mov	DWORD PTR ?sMemTotal@CCorString@@0KA, edx ; CCorString::sMemTotal
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	ebx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L12611:
	mov	eax, DWORD PTR _i$[esp+844]
	mov	ecx, DWORD PTR [esi+252]
	inc	eax
	cmp	eax, ecx
	mov	DWORD PTR _i$[esp+844], eax
	jb	$L12610
$L12612:

; 657  : 	}
; 658  : 
; 659  : 	return(1);

	mov	esi, DWORD PTR _seqProjects$[esp+848]
	mov	edi, DWORD PTR __imp__memmove
	test	esi, esi
	mov	BYTE PTR __$EHRec$[esp+852], 13		; 0000000dH
	pop	ebp
	je	SHORT $L23757
	mov	eax, DWORD PTR _seqProjects$[esp+840]
	push	0
	lea	ecx, DWORD PTR [eax+esi*4]
	push	ecx
	push	eax
	call	edi
	mov	eax, DWORD PTR _seqProjects$[esp+856]
	add	esp, 12					; 0000000cH
	sub	eax, esi
	mov	DWORD PTR _seqProjects$[esp+844], eax
$L23757:
	mov	eax, DWORD PTR _seqProjects$[esp+840]
	test	eax, eax
	je	SHORT $L23762
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR _seqProjects$[esp+840]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L23762:
	mov	eax, DWORD PTR _frmProjects$[esp+844]
	mov	DWORD PTR __$EHRec$[esp+848], -1
	test	eax, eax
	mov	esi, eax
	je	SHORT $L23806
	mov	ecx, DWORD PTR _frmProjects$[esp+840]
	push	0
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	push	ecx
	call	edi
	mov	eax, DWORD PTR _frmProjects$[esp+856]
	add	esp, 12					; 0000000cH
	sub	eax, esi
	mov	DWORD PTR _frmProjects$[esp+844], eax
$L23806:
	mov	eax, DWORD PTR _frmProjects$[esp+840]
	test	eax, eax
	je	SHORT $L23811
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR _frmProjects$[esp+840]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L23811:
	mov	al, 1
$L12441:

; 660  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+840]
	pop	edi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 828				; 0000033cH
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L22605:
	mov	eax, DWORD PTR $T22621[ebp]
	push	eax
	mov	ecx, DWORD PTR $T22620[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
$L22553:
	lea	ecx, DWORD PTR $T22527[ebp]
	jmp	??1CCorString@@QAE@XZ			; CCorString::~CCorString
$L22554:
	lea	ecx, DWORD PTR $T22528[ebp]
	jmp	??1CCorString@@QAE@XZ			; CCorString::~CCorString
$L22555:
	lea	ecx, DWORD PTR $T22529[ebp]
	jmp	??1CCorString@@QAE@XZ			; CCorString::~CCorString
$L22556:
	lea	ecx, DWORD PTR $T22530[ebp]
	jmp	??1CCorString@@QAE@XZ			; CCorString::~CCorString
$L22557:
	lea	ecx, DWORD PTR $T22531[ebp]
	jmp	??1CCorString@@QAE@XZ			; CCorString::~CCorString
$L22558:
	lea	ecx, DWORD PTR $T22532[ebp]
	jmp	??1CCorString@@QAE@XZ			; CCorString::~CCorString
$L22559:
	lea	ecx, DWORD PTR $T22533[ebp]
	jmp	??1CCorString@@QAE@XZ			; CCorString::~CCorString
$L22560:
	lea	ecx, DWORD PTR $T22534[ebp]
	jmp	??1CCorString@@QAE@XZ			; CCorString::~CCorString
$L22561:
	lea	ecx, DWORD PTR $T22535[ebp]
	jmp	??1CCorString@@QAE@XZ			; CCorString::~CCorString
$L22562:
	lea	ecx, DWORD PTR $T22536[ebp]
	jmp	??1CCorString@@QAE@XZ			; CCorString::~CCorString
$L22563:
	lea	ecx, DWORD PTR $T22537[ebp]
	jmp	??1CCorString@@QAE@XZ			; CCorString::~CCorString
$L22564:
	lea	ecx, DWORD PTR $T22538[ebp]
	jmp	??1CCorString@@QAE@XZ			; CCorString::~CCorString
$L22565:
	lea	ecx, DWORD PTR _frmProjects$[ebp]
	jmp	??1?$TCorArray@PAVOCpjProject@@@@QAE@XZ	; TCorArray<OCpjProject *>::~TCorArray<OCpjProject *>
$L22566:
	lea	ecx, DWORD PTR $T22542[ebp]
	jmp	??1CCorString@@QAE@XZ			; CCorString::~CCorString
$L22567:
	lea	ecx, DWORD PTR $T22543[ebp]
	jmp	??1CCorString@@QAE@XZ			; CCorString::~CCorString
$L22568:
	lea	ecx, DWORD PTR $T22544[ebp]
	jmp	??1CCorString@@QAE@XZ			; CCorString::~CCorString
$L22569:
	lea	ecx, DWORD PTR $T22545[ebp]
	jmp	??1CCorString@@QAE@XZ			; CCorString::~CCorString
$L22570:
	lea	ecx, DWORD PTR _seqProjects$[ebp]
	jmp	??1?$TCorArray@PAVOCpjProject@@@@QAE@XZ	; TCorArray<OCpjProject *>::~TCorArray<OCpjProject *>
$L22571:
	lea	ecx, DWORD PTR $T22549[ebp]
	jmp	??1CCorString@@QAE@XZ			; CCorString::~CCorString
$L22572:
	lea	ecx, DWORD PTR $T22550[ebp]
	jmp	??1CCorString@@QAE@XZ			; CCorString::~CCorString
$L22573:
	lea	ecx, DWORD PTR $T22551[ebp]
	jmp	??1CCorString@@QAE@XZ			; CCorString::~CCorString
$L23909:
	mov	eax, OFFSET FLAT:$T23816
	jmp	___CxxFrameHandler
text$x	ENDS
?SaveConfig@OMacActor@@QAE_NPAVOCpjConfig@@@Z ENDP	; OMacActor::SaveConfig
PUBLIC	__real@00000000
PUBLIC	__real@3f8ccccd
PUBLIC	?GetLodInfo@OMacActor@@QAEPAVCCpjLodLevel@@M@Z	; OMacActor::GetLodInfo
;	COMDAT __real@00000000
; File C:\duke4\Cannibal\CorMain.h
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT __real@3f8ccccd
CONST	SEGMENT
__real@3f8ccccd DD 03f8ccccdr			; 1.1
; Function compile flags: /Ogty
; File C:\duke4\Cannibal\MacMain.cpp
CONST	ENDS
;	COMDAT ?GetLodInfo@OMacActor@@QAEPAVCCpjLodLevel@@M@Z
_TEXT	SEGMENT
_inLodLevel$ = 8
?GetLodInfo@OMacActor@@QAEPAVCCpjLodLevel@@M@Z PROC NEAR ; OMacActor::GetLodInfo, COMDAT
; _this$ = ecx

; 664  : 	CCpjLodLevel* lodLevel = NULL;
; 665  : 	if (inLodLevel > 1.f) inLodLevel = 1.f;

	fld	DWORD PTR _inLodLevel$[esp-4]
	fcomp	DWORD PTR __real@3f800000
	push	esi
	xor	esi, esi
	fnstsw	ax
	and	eax, 16640				; 00004100H
	jne	SHORT $L12620
	mov	DWORD PTR _inLodLevel$[esp], 1065353216	; 3f800000H

; 666  : 	if (inLodLevel < 0.f) inLodLevel = 0.f;

	jmp	SHORT $L12621
$L12620:
	fld	DWORD PTR _inLodLevel$[esp]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L12621
	mov	DWORD PTR _inLodLevel$[esp], 0
$L12621:

; 667  : 	if (mLodData && (inLodLevel < 1.f))

	mov	ecx, DWORD PTR [ecx+148]
	test	ecx, ecx
	je	SHORT $L23931
	fld	DWORD PTR _inLodLevel$[esp]
	fcomp	DWORD PTR __real@3f800000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L23931

; 670  : 		for (NDword i=0;i<mLodData->m_Levels.GetCount();i++)

	mov	eax, DWORD PTR [ecx+76]
	fld	DWORD PTR __real@3f8ccccd
	test	eax, eax
	jbe	SHORT $L23929
	mov	ecx, DWORD PTR [ecx+72]
	mov	edx, eax
$L12625:

; 671  : 		{
; 672  : 			CCpjLodLevel* lev = &mLodData->m_Levels[i];
; 673  : 			if ((lev->detail >= inLodLevel) && (lev->detail < lowestLevelValue))

	fld	DWORD PTR [ecx]
	fcomp	DWORD PTR _inLodLevel$[esp]
	fnstsw	ax
	and	eax, 256				; 00000100H
	jne	SHORT $L12626
	fcom	DWORD PTR [ecx]
	fnstsw	ax
	and	eax, 16640				; 00004100H
	jne	SHORT $L12626
	fstp	ST(0)

; 674  : 			{
; 675  : 				lodLevel = lev;
; 676  : 				lowestLevelValue = lev->detail;

	fld	DWORD PTR [ecx]
	mov	esi, ecx
$L12626:
	add	ecx, 36					; 00000024H
	dec	edx
	jne	SHORT $L12625
$L23929:

; 668  : 	{
; 669  : 		NFloat lowestLevelValue = 1.1f;

	fstp	ST(0)
$L23931:

; 677  : 			}
; 678  : 		}
; 679  : 	}
; 680  : 	return(lodLevel);

	mov	eax, esi
	pop	esi

; 681  : }

	ret	4
?GetLodInfo@OMacActor@@QAEPAVCCpjLodLevel@@M@Z ENDP	; OMacActor::GetLodInfo
_TEXT	ENDS
PUBLIC	?EvaluateTris@OMacActor@@QAEKMPAUSMacTri@@@Z	; OMacActor::EvaluateTris
; Function compile flags: /Ogty
;	COMDAT ?EvaluateTris@OMacActor@@QAEKMPAUSMacTri@@@Z
_TEXT	SEGMENT
_inLodLevel$ = 8
_outTriList$ = 12
_this$ = -4
_outTriCount$ = 12
_lodLevel$ = -16
_iSurf$ = -20
_surfUV$12651 = -12
_surfTexs$12652 = 8
$T23960 = -20
?EvaluateTris@OMacActor@@QAEKMPAUSMacTri@@@Z PROC NEAR	; OMacActor::EvaluateTris, COMDAT
; _this$ = ecx

; 684  : {

	sub	esp, 20					; 00000014H

; 685  : 	static int rot1[3] = {1,2,0};
; 686  : 	static int rot2[3] = {2,0,1};
; 687  : 	
; 688  : 	SMacTri* oT = outTriList;
; 689  : 	NDword outTriCount = 0;
; 690  : 
; 691  : 	CCpjLodLevel* lodLevel = GetLodInfo(inLodLevel);

	fld	DWORD PTR _inLodLevel$[esp+16]
	fcomp	DWORD PTR __real@3f800000
	mov	eax, DWORD PTR _inLodLevel$[esp+16]
	push	ebx
	mov	DWORD PTR $T23960[esp+24], eax
	push	ebp
	mov	ebp, ecx
	push	esi
	mov	esi, DWORD PTR _outTriList$[esp+28]
	xor	ecx, ecx
	fnstsw	ax
	xor	ebx, ebx
	push	edi
	and	eax, 16640				; 00004100H
	mov	DWORD PTR _this$[esp+36], ebp
	mov	DWORD PTR _outTriCount$[esp+32], ecx
	jne	SHORT $L23945
	mov	DWORD PTR $T23960[esp+36], 1065353216	; 3f800000H
	jmp	SHORT $L23946
$L23945:
	fld	DWORD PTR _inLodLevel$[esp+32]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L23946
	mov	DWORD PTR $T23960[esp+36], 0
$L23946:
	mov	edx, DWORD PTR [ebp+148]
	cmp	edx, ecx
	je	SHORT $L23952
	fld	DWORD PTR $T23960[esp+36]
	fcomp	DWORD PTR __real@3f800000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L23952
	mov	eax, DWORD PTR [edx+76]
	fld	DWORD PTR __real@3f8ccccd
	cmp	eax, ecx
	jbe	SHORT $L24016
	mov	edx, DWORD PTR [edx+72]
	mov	edi, eax
$L23950:
	fld	DWORD PTR [edx]
	fcomp	DWORD PTR $T23960[esp+36]
	fnstsw	ax
	and	eax, 256				; 00000100H
	jne	SHORT $L23951
	fcom	DWORD PTR [edx]
	fnstsw	ax
	and	eax, 16640				; 00004100H
	jne	SHORT $L23951
	fstp	ST(0)
	fld	DWORD PTR [edx]
	mov	ebx, edx
$L23951:
	add	edx, 36					; 00000024H
	dec	edi
	jne	SHORT $L23950
$L24016:
	fstp	ST(0)
$L23952:

; 692  : 
; 693  : 	for (NDword iSurf=0; iSurf<mSurfaces.GetCount(); iSurf++)

	mov	eax, DWORD PTR [ebp+156]
	mov	DWORD PTR _lodLevel$[esp+36], ebx
	xor	ebx, ebx
	cmp	eax, ecx
	mov	DWORD PTR _iSurf$[esp+36], ebx
	jbe	$L24015
$L12643:

; 694  : 	{	
; 695  : 		OCpjSurface* surf = mSurfaces[iSurf];

	mov	edx, DWORD PTR [ebp+152]
	mov	edi, DWORD PTR [edx+ebx*4]

; 696  : 		OCpjGeometry* geom = mGeometry;

	mov	edx, DWORD PTR [ebp+140]

; 697  : 
; 698  : 		if (!geom || !surf || (surf->m_Tris.GetCount() != geom->m_Tris.GetCount()))

	cmp	edx, ecx
	je	$L12644
	cmp	edi, ecx
	je	$L12644
	mov	eax, DWORD PTR [edi+92]
	mov	ebp, DWORD PTR [edx+108]
	cmp	eax, ebp
	mov	DWORD PTR -8+[esp+36], eax
	jne	$L12644

; 699  : 			continue; // geometry and surface are mismatched
; 700  : 
; 701  : 		// once past the primary surface, ignore any LOD data we may have had
; 702  : 		if (iSurf)

	cmp	ebx, ecx
	je	SHORT $L12650

; 703  : 			lodLevel = NULL;

	mov	DWORD PTR _lodLevel$[esp+36], ecx
$L12650:

; 704  : 
; 705  : 		VVec2* surfUV = &surf->m_UV[0];

	mov	ebx, DWORD PTR [edi+104]

; 706  : 		CCpjSrfTex* surfTexs = NULL;

	mov	DWORD PTR _surfTexs$12652[esp+32], ecx
	mov	DWORD PTR _surfUV$12651[esp+36], ebx

; 707  : 		if (surf->m_Textures.GetCount())

	mov	ebx, DWORD PTR [edi+76]
	cmp	ebx, ecx
	je	SHORT $L12653

; 708  : 			surfTexs = &surf->m_Textures[0];

	mov	ebx, DWORD PTR [edi+72]
	mov	DWORD PTR _surfTexs$12652[esp+32], ebx
$L12653:

; 709  : 
; 710  : 		if (!lodLevel)

	mov	ebp, DWORD PTR _lodLevel$[esp+36]
	cmp	ebp, ecx
	jne	$L12654

; 711  : 		{
; 712  : 			CCpjSrfTri* iTS = &surf->m_Tris[0];
; 713  : 			CCpjGeoTri* iTG = &geom->m_Tris[0];

	mov	ebx, DWORD PTR [edx+104]

; 714  : 			CCpjGeoVert* gVZero = &geom->m_Verts[0];

	mov	ebp, DWORD PTR [edx+72]

; 715  : 			NDword triCount = surf->m_Tris.GetCount();
; 716  : 			outTriCount += triCount;

	mov	edx, DWORD PTR _outTriCount$[esp+32]
	mov	edi, DWORD PTR [edi+88]
	add	edx, eax

; 717  : 			if (!oT)

	cmp	esi, ecx
	mov	DWORD PTR _outTriCount$[esp+32], edx
	je	$L12644

; 718  : 				continue;
; 719  : 			for (NDword i=0; i<triCount; i++,iTS++,iTG++,oT++)

	test	eax, eax
	jbe	$L24017
$L12661:

; 720  : 			{
; 721  : 				oT->triIndex = i;

	mov	DWORD PTR [esi], ecx

; 722  : 				oT->vertIndex[0] = iTG->edgeRing[0]->tailVertex - gVZero;

	mov	eax, DWORD PTR [ebx]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, 715827883				; 2aaaaaabH
	sub	edx, ebp
	imul	edx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	edx, eax

; 723  : 				oT->vertIndex[1] = iTG->edgeRing[1]->tailVertex - gVZero;

	mov	eax, 715827883				; 2aaaaaabH
	mov	DWORD PTR [esi+4], edx
	mov	edx, DWORD PTR [ebx+4]
	mov	edx, DWORD PTR [edx+4]
	sub	edx, ebp
	imul	edx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	edx, eax

; 724  : 				oT->vertIndex[2] = iTG->edgeRing[2]->tailVertex - gVZero;

	mov	eax, 715827883				; 2aaaaaabH
	mov	DWORD PTR [esi+8], edx
	mov	edx, DWORD PTR [ebx+8]
	mov	edx, DWORD PTR [edx+4]
	sub	edx, ebp
	imul	edx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	edx, eax

; 725  : 				oT->texture = NULL;

	xor	eax, eax
	mov	DWORD PTR [esi+12], edx
	mov	DWORD PTR [esi+16], eax

; 726  : 				oT->glazeTexture = NULL;

	mov	DWORD PTR [esi+20], eax

; 727  : 				if (!(iTS->flags & SRFTF_INACTIVE))

	mov	al, BYTE PTR [edi+8]
	test	al, 1
	jne	SHORT $L12665

; 728  : 				{
; 729  : 					oT->texture = &surfTexs[iTS->texIndex];

	xor	eax, eax
	mov	al, BYTE PTR [edi+6]
	mov	edx, eax
	shl	edx, 6
	add	edx, eax
	mov	eax, DWORD PTR _surfTexs$12652[esp+32]
	lea	edx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR [esi+16], edx

; 730  : 					if (iTS->glazeFunc != SRFGLAZE_NONE)

	mov	al, BYTE PTR [edi+15]
	test	al, al
	je	SHORT $L12665

; 731  : 						oT->glazeTexture = &surfTexs[iTS->glazeTexIndex];

	xor	eax, eax
	mov	al, BYTE PTR [edi+14]
	mov	edx, eax
	shl	edx, 6
	add	edx, eax
	mov	eax, DWORD PTR _surfTexs$12652[esp+32]
	lea	edx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR [esi+20], edx
$L12665:

; 732  : 				}
; 733  : 				oT->texUV[0] = &surfUV[iTS->uvIndex[0]];

	xor	eax, eax
	add	ebx, 12					; 0000000cH
	mov	ax, WORD PTR [edi]
	add	edi, 16					; 00000010H
	mov	edx, eax
	mov	eax, DWORD PTR _surfUV$12651[esp+36]
	add	esi, 44					; 0000002cH
	lea	edx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR [esi-20], edx

; 734  : 				oT->texUV[1] = &surfUV[iTS->uvIndex[1]];

	xor	edx, edx
	mov	dx, WORD PTR [edi-14]
	lea	edx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR [esi-16], edx

; 735  : 				oT->texUV[2] = &surfUV[iTS->uvIndex[2]];

	xor	edx, edx
	mov	dx, WORD PTR [edi-12]
	inc	ecx
	lea	eax, DWORD PTR [eax+edx*8]
	mov	DWORD PTR [esi-12], eax

; 736  : 				oT->surfaceFlags = iTS->flags;

	mov	edx, DWORD PTR [edi-8]
	mov	DWORD PTR [esi-8], edx

; 737  : 				oT->smoothGroup = iTS->smoothGroup;

	mov	al, BYTE PTR [edi-4]
	mov	BYTE PTR [esi-4], al

; 738  : 				oT->alphaLevel = iTS->alphaLevel;

	mov	dl, BYTE PTR [edi-3]
	mov	BYTE PTR [esi-3], dl

; 739  : 				oT->glazeFunc = iTS->glazeFunc;

	mov	al, BYTE PTR [edi-1]

; 740  : 				oT->surfaceIndex = (NByte)iSurf;

	mov	dl, BYTE PTR _iSurf$[esp+36]
	mov	BYTE PTR [esi-2], al
	mov	eax, DWORD PTR -8+[esp+36]
	mov	BYTE PTR [esi-1], dl
	cmp	ecx, eax
	jb	$L12661

; 741  : 			}
; 742  : 		}
; 743  : 		else

	jmp	$L24017
$L12654:

; 744  : 		{
; 745  : 			CCpjLodTri* iTL = &lodLevel->triangles[0];
; 746  : 			CCpjSrfTri* iTSZero = &surf->m_Tris[0];

	mov	ebx, DWORD PTR [edi+88]
	mov	edx, DWORD PTR [ebp+20]

; 747  : 			CCpjSrfTri* iTS;
; 748  : 			NDword triCount = lodLevel->triangles.GetCount();

	mov	edi, DWORD PTR [ebp+24]

; 749  : 			outTriCount += triCount;

	mov	ebp, DWORD PTR _outTriCount$[esp+32]
	add	ebp, edi

; 750  : 			if (!oT)

	cmp	esi, ecx
	mov	DWORD PTR _outTriCount$[esp+32], ebp
	je	$L12644

; 751  : 				continue;
; 752  : 			for (NDword i=0; i<triCount; i++,iTL++,oT++)

	cmp	edi, ecx
	jbe	$L12644
	mov	DWORD PTR -8+[esp+36], edi
	jmp	SHORT $L12674
$L24018:
	xor	ecx, ecx
$L12674:

; 753  : 			{
; 754  : 				iTS = &iTSZero[iTL->srfTriIndex];

	mov	edi, DWORD PTR [edx]
	mov	eax, edi

; 755  : 
; 756  : 				oT->triIndex = iTL->srfTriIndex;

	mov	DWORD PTR [esi], edi

; 757  : 				oT->vertIndex[0] = iTL->vertIndex[0];

	xor	edi, edi
	mov	di, WORD PTR [edx+4]
	mov	DWORD PTR [esi+4], edi

; 758  : 				oT->vertIndex[1] = iTL->vertIndex[1];

	xor	edi, edi
	mov	di, WORD PTR [edx+6]
	mov	DWORD PTR [esi+8], edi

; 759  : 				oT->vertIndex[2] = iTL->vertIndex[2];				

	xor	edi, edi
	mov	di, WORD PTR [edx+8]

; 760  : 				oT->texture = NULL;

	mov	DWORD PTR [esi+16], ecx
	shl	eax, 4
	add	eax, ebx
	mov	DWORD PTR [esi+12], edi

; 761  : 				oT->glazeTexture = NULL;

	mov	DWORD PTR [esi+20], ecx

; 762  : 				if (!(iTS->flags & SRFTF_INACTIVE))

	test	BYTE PTR [eax+8], 1
	jne	SHORT $L12678

; 763  : 				{
; 764  : 					oT->texture = &surfTexs[iTS->texIndex];

	mov	ebp, DWORD PTR _surfTexs$12652[esp+32]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+6]
	mov	edi, ecx
	shl	ecx, 6
	add	ecx, edi
	lea	ecx, DWORD PTR [ebp+ecx*4]
	mov	DWORD PTR [esi+16], ecx

; 765  : 					if (iTS->glazeFunc != SRFGLAZE_NONE)

	mov	cl, BYTE PTR [eax+15]
	test	cl, cl
	je	SHORT $L12678

; 766  : 						oT->glazeTexture = &surfTexs[iTS->glazeTexIndex];

	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+14]
	mov	edi, ecx
	shl	ecx, 6
	add	ecx, edi
	lea	ecx, DWORD PTR [ebp+ecx*4]
	mov	DWORD PTR [esi+20], ecx
$L12678:

; 767  : 				}
; 768  : 				oT->texUV[0] = &surfUV[iTL->uvIndex[0]];

	mov	edi, DWORD PTR _surfUV$12651[esp+36]
	xor	ecx, ecx
	mov	cx, WORD PTR [edx+10]
	add	edx, 16					; 00000010H
	add	esi, 44					; 0000002cH
	lea	ecx, DWORD PTR [edi+ecx*8]
	mov	DWORD PTR [esi-20], ecx

; 769  : 				oT->texUV[1] = &surfUV[iTL->uvIndex[1]];

	xor	ecx, ecx
	mov	cx, WORD PTR [edx-4]
	lea	ecx, DWORD PTR [edi+ecx*8]
	mov	DWORD PTR [esi-16], ecx

; 770  : 				oT->texUV[2] = &surfUV[iTL->uvIndex[2]];

	xor	ecx, ecx
	mov	cx, WORD PTR [edx-2]
	lea	ecx, DWORD PTR [edi+ecx*8]
	mov	DWORD PTR [esi-12], ecx

; 771  : 				oT->surfaceFlags = iTS->flags;

	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [esi-8], ecx

; 772  : 				oT->smoothGroup = iTS->smoothGroup;

	mov	cl, BYTE PTR [eax+12]
	mov	BYTE PTR [esi-4], cl

; 773  : 				oT->alphaLevel = iTS->alphaLevel;

	mov	cl, BYTE PTR [eax+13]
	mov	BYTE PTR [esi-3], cl

; 774  : 				oT->glazeFunc = iTS->glazeFunc;

	mov	al, BYTE PTR [eax+15]

; 775  : 				oT->surfaceIndex = (NByte)iSurf;

	mov	cl, BYTE PTR _iSurf$[esp+36]
	mov	BYTE PTR [esi-2], al
	mov	eax, DWORD PTR -8+[esp+36]
	mov	BYTE PTR [esi-1], cl
	dec	eax
	mov	DWORD PTR -8+[esp+36], eax
	jne	$L24018
$L24017:

; 741  : 			}
; 742  : 		}
; 743  : 		else

	xor	ecx, ecx
$L12644:

; 692  : 
; 693  : 	for (NDword iSurf=0; iSurf<mSurfaces.GetCount(); iSurf++)

	mov	ebp, DWORD PTR _this$[esp+36]
	mov	ebx, DWORD PTR _iSurf$[esp+36]
	inc	ebx
	mov	eax, DWORD PTR [ebp+156]
	mov	DWORD PTR _iSurf$[esp+36], ebx
	cmp	ebx, eax
	jb	$L12643
$L24015:

; 776  : 			}
; 777  : 		}
; 778  : 	}
; 779  : 	return(outTriCount);

	mov	eax, DWORD PTR _outTriCount$[esp+32]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 780  : }

	add	esp, 20					; 00000014H
	ret	8
?EvaluateTris@OMacActor@@QAEKMPAUSMacTri@@@Z ENDP	; OMacActor::EvaluateTris
_TEXT	ENDS
PUBLIC	__real@3f7fbe77
PUBLIC	?EvaluateVerts@OMacActor@@QAEKMMPAVVVec3@@@Z	; OMacActor::EvaluateVerts
PUBLIC	??0VCoords3@@QAE@ABV0@@Z			; VCoords3::VCoords3
_BSS	SEGMENT
	ALIGN	4

_mac_tempVerts DB 0c000H DUP (?)
_BSS	ENDS
;	COMDAT __real@3f7fbe77
; File C:\duke4\Cannibal\VecMain.h
CONST	SEGMENT
__real@3f7fbe77 DD 03f7fbe77r			; 0.999
; Function compile flags: /Ogty
; File C:\duke4\Cannibal\MacMain.cpp
CONST	ENDS
;	COMDAT ?EvaluateVerts@OMacActor@@QAEKMMPAVVVec3@@@Z
_TEXT	SEGMENT
$T24411 = -228
$T24428 = -392
$T24608 = -300
$T24633 = -404
_inLodLevel$ = 8
_inVertAlpha$ = 12
_outVerts$ = 16
_lodRelay$ = -400
_numVerts$ = -396
_evalVerts$ = -408
_w$12707 = -416
_b$12708 = -416
_iv$12712 = -412
_boneZero$12713 = -384
_i$12717 = -388
$T24025 = -380
$T24026 = -300
$T24027 = -320
$T24028 = -216
$T24029 = -252
$T24030 = -156
$T24031 = -264
$T24032 = -36
$T24033 = -96
$T24034 = -276
$T24035 = -24
$T24038 = -380
$T24039 = -288
$T24040 = -12
$T24041 = -276
$T24042 = -320
$T24043 = -252
$T24069 = -412
$T24169 = -288
$T24194 = -404
$T24256 = -320
$T24325 = -240
$T24350 = -388
?EvaluateVerts@OMacActor@@QAEKMMPAVVVec3@@@Z PROC NEAR	; OMacActor::EvaluateVerts, COMDAT
; _this$ = ecx

; 783  : {

	sub	esp, 416				; 000001a0H
	push	ebx
	push	ebp
	push	esi
	push	edi

; 784  : 	if (!outVerts || !mGeometry)

	mov	edi, DWORD PTR _outVerts$[esp+428]
	mov	ebx, ecx
	test	edi, edi
	je	$L12687
	mov	ebp, DWORD PTR [ebx+140]
	test	ebp, ebp
	je	$L12687

; 786  : 
; 787  : 	// compute lod level info
; 788  : 	CCpjLodLevel* lodLevel = GetLodInfo(inLodLevel);

	fld	DWORD PTR _inLodLevel$[esp+428]
	fcomp	DWORD PTR __real@3f800000
	mov	eax, DWORD PTR _inLodLevel$[esp+428]
	xor	edx, edx
	mov	DWORD PTR $T24069[esp+432], eax
	fnstsw	ax
	and	eax, 16640				; 00004100H
	jne	SHORT $L24054
	mov	DWORD PTR $T24069[esp+432], 1065353216	; 3f800000H
	jmp	SHORT $L24055
$L24054:
	fld	DWORD PTR _inLodLevel$[esp+428]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L24055
	mov	DWORD PTR $T24069[esp+432], 0
$L24055:
	mov	ecx, DWORD PTR [ebx+148]
	test	ecx, ecx
	je	SHORT $L24061
	fld	DWORD PTR $T24069[esp+432]
	fcomp	DWORD PTR __real@3f800000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L24061
	mov	eax, DWORD PTR [ecx+76]
	fld	DWORD PTR __real@3f8ccccd
	test	eax, eax
	jbe	SHORT $L24721
	mov	ecx, DWORD PTR [ecx+72]
	mov	esi, eax
$L24059:
	fld	DWORD PTR [ecx]
	fcomp	DWORD PTR $T24069[esp+432]
	fnstsw	ax
	and	eax, 256				; 00000100H
	jne	SHORT $L24060
	fcom	DWORD PTR [ecx]
	fnstsw	ax
	and	eax, 16640				; 00004100H
	jne	SHORT $L24060
	fstp	ST(0)
	fld	DWORD PTR [ecx]
	mov	edx, ecx
$L24060:
	add	ecx, 36					; 00000024H
	dec	esi
	jne	SHORT $L24059
$L24721:
	fstp	ST(0)
$L24061:

; 789  : 	NWord* lodRelay = NULL;
; 790  : 	NDword numVerts = mGeometry->m_Verts.GetCount();

	mov	esi, DWORD PTR [ebp+76]
	mov	DWORD PTR _lodRelay$[esp+432], 0

; 791  : 	if (lodLevel)

	test	edx, edx
	mov	DWORD PTR _numVerts$[esp+432], esi
	je	SHORT $L24081

; 792  : 	{
; 793  : 		if (!lodLevel->vertRelay.GetCount())

	mov	eax, DWORD PTR [edx+8]
	test	eax, eax

; 794  : 			return(0);

	je	$L12687

; 795  : 		lodRelay = &lodLevel->vertRelay[0];

	mov	ecx, DWORD PTR [edx+4]

; 796  : 		numVerts = lodLevel->vertRelay.GetCount();

	mov	DWORD PTR _numVerts$[esp+432], eax
	mov	DWORD PTR _lodRelay$[esp+432], ecx
	mov	esi, eax
$L24081:

; 797  : 	}
; 798  : 
; 799  : 	// clamp the vertex alpha
; 800  : 	if (inVertAlpha < 0.f) inVertAlpha = 0.f;

	fld	DWORD PTR _inVertAlpha$[esp+428]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L12693
	mov	DWORD PTR _inVertAlpha$[esp+428], 0

; 801  : 	if (inVertAlpha > 1.f) inVertAlpha = 1.f;

	jmp	SHORT $L12694
$L12693:
	fld	DWORD PTR _inVertAlpha$[esp+428]
	fcomp	DWORD PTR __real@3f800000
	fnstsw	ax
	and	eax, 16640				; 00004100H
	jne	SHORT $L12694
	mov	DWORD PTR _inVertAlpha$[esp+428], 1065353216 ; 3f800000H
$L12694:

; 802  : 
; 803  : 	// set our working vertices as our temporary buffer, unless no alpha is involved
; 804  : 	VVec3* evalVerts = mac_tempVerts;
; 805  : 	if (inVertAlpha >= (1.f - M_EPSILON))

	fld	DWORD PTR _inVertAlpha$[esp+428]
	fcomp	DWORD PTR __real@3f7fbe77
	mov	ebp, OFFSET FLAT:_mac_tempVerts
	mov	DWORD PTR _evalVerts$[esp+432], ebp
	fnstsw	ax
	and	eax, 256				; 00000100H
	jne	SHORT $L12696

; 806  : 		evalVerts = outVerts;

	mov	DWORD PTR _evalVerts$[esp+432], edi
	mov	ebp, edi
$L12696:

; 807  : 
; 808  : 	// the first sequence is the only one that's allowed to be frame-based
; 809  : 	NBool frameBased = 0;
; 810  : 	if (!mActorChannels[0] || !mActorChannels[0]->EvalVerts(this, numVerts, lodRelay, evalVerts))

	mov	edx, DWORD PTR [ebx+288]
	mov	ecx, DWORD PTR [edx]
	test	ecx, ecx
	je	SHORT $L12699
	mov	edx, DWORD PTR _lodRelay$[esp+432]
	mov	eax, DWORD PTR [ecx]
	push	ebp
	push	edx
	push	esi
	push	ebx
	call	DWORD PTR [eax+52]
	test	al, al
	jne	$L12776
$L12699:

; 811  : 	{
; 812  : 		if (mSkeleton)

	mov	eax, DWORD PTR [ebx+144]
	test	eax, eax
	je	$L12700

; 813  : 		{
; 814  : 			if (bBonesDirty)		// JEP Added dirty bone optimization

	mov	al, BYTE PTR [ebx+268]
	test	al, al
	je	SHORT $L12701

; 815  : 			{
; 816  : 				// if we have a skeleton and verts weren't modified by the primary channel
; 817  : 				// (i.e. if a frame-based sequence wasn't used), then we can process all the channels
; 818  : 				// for bone-based animation / alteration
; 819  : 				for (NDword i=0;i<mActorChannels.GetCount();i++)

	mov	eax, DWORD PTR [ebx+292]
	xor	edi, edi
	test	eax, eax
	jbe	SHORT $L12705
$L12703:

; 820  : 				{
; 821  : 					if (mActorChannels[i])

	mov	eax, DWORD PTR [ebx+288]
	mov	ecx, DWORD PTR [eax+edi*4]
	test	ecx, ecx
	je	SHORT $L12704

; 822  : 						mActorChannels[i]->EvalBones(this);

	mov	edx, DWORD PTR [ecx]
	push	ebx
	call	DWORD PTR [edx+48]
$L12704:
	mov	eax, DWORD PTR [ebx+292]
	inc	edi
	cmp	edi, eax
	jb	SHORT $L12703
$L12705:

; 823  : 				}
; 824  : 			
; 825  : 				bBonesDirty = false;

	mov	BYTE PTR [ebx+268], 0
$L12701:

; 826  : 			}
; 827  : 
; 828  : 			// and after all that's done, we evaluate our vertex positions
; 829  : 			CCpjSklWeight* w;
; 830  : 			CMacBone* b;
; 831  : 			VVec3 nv;
; 832  : 			NDword wcount;
; 833  : 			VVec3* ov = evalVerts;
; 834  : 			CCpjSklVert* iv = &mSkeleton->m_Verts[0];

	mov	ecx, DWORD PTR [ebx+144]

; 835  : 			CCpjSklBone* boneZero = &mSkeleton->m_Bones[0];
; 836  : 
; 837  : 			if (lodRelay)

	mov	edx, DWORD PTR _lodRelay$[esp+432]
	test	edx, edx
	mov	eax, DWORD PTR [ecx+88]
	mov	ebp, DWORD PTR [ecx+72]
	mov	DWORD PTR _iv$12712[esp+432], eax
	mov	DWORD PTR _boneZero$12713[esp+432], ebp
	je	$L12714

; 838  : 			{
; 839  : 				CCpjSklVert* xv;
; 840  : 				NDword count = numVerts;
; 841  : 				for (NDword i=0; i<count; i++,ov++)

	xor	edi, edi
	test	esi, esi
	mov	DWORD PTR _i$12717[esp+432], edi
	jbe	$L24725
	mov	ecx, DWORD PTR _evalVerts$[esp+432]
	lea	esi, DWORD PTR [ecx+8]
$L12718:

; 844  : 					xv = &iv[lodRelay[i]];

	mov	edx, DWORD PTR _lodRelay$[esp+432]
	xor	ecx, ecx
	mov	DWORD PTR [esi-8], ecx
	mov	DWORD PTR [esi-4], ecx
	mov	DWORD PTR [esi], ecx
	mov	cx, WORD PTR [edx+edi*2]
	shl	ecx, 4
	add	ecx, eax

; 845  : 					wcount = xv->weights.GetCount();

	mov	edx, DWORD PTR [ecx+4]

; 846  : 					w = &xv->weights[0];

	mov	ecx, DWORD PTR [ecx]

; 847  : 					for (NDword j=0;j<wcount;j++,w++)

	test	edx, edx
	mov	DWORD PTR _w$12707[esp+432], ecx
	jbe	$L12719
	lea	edi, DWORD PTR [ecx+16]
	mov	DWORD PTR -392+[esp+432], edx
	jmp	SHORT $L12723
$L24723:

; 842  : 				{
; 843  : 					*ov = VVec3(0,0,0);

	mov	ecx, DWORD PTR _w$12707[esp+432]
$L12723:

; 848  : 					{
; 849  : 						b = &mActorBones[w->bone - boneZero];

	mov	ecx, DWORD PTR [ecx]
	mov	eax, 1808407283				; 6bca1af3H
	sub	ecx, ebp

; 850  : 						*ov += (w->offsetPos << b->GetCoords(true)) * w->factor;

	push	1
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	edx, eax
	lea	eax, DWORD PTR [edx*8]
	sub	eax, edx
	mov	edx, DWORD PTR [ebx+272]
	lea	ecx, DWORD PTR [eax+eax*4]
	lea	ebp, DWORD PTR [edx+ecx*4]
	mov	ecx, ebp
	call	?ValidateAbs@CMacBone@@IAEX_N@Z		; CMacBone::ValidateAbs
	add	ebp, 60					; 0000003cH
	lea	ecx, DWORD PTR $T24025[esp+432]
	push	ebp
	call	??0VCoords3@@QAE@ABV0@@Z		; VCoords3::VCoords3
	fld	DWORD PTR $T24025[esp+480]
	fmul	DWORD PTR [edi-8]
	fld	DWORD PTR $T24025[esp+484]
	fmul	DWORD PTR [edi-4]
	fld	DWORD PTR $T24025[esp+488]
	fmul	DWORD PTR [edi]
	fld	ST(1)
	fmul	DWORD PTR $T24025[esp+444]
	fld	ST(1)
	fmul	DWORD PTR $T24025[esp+456]
	mov	eax, DWORD PTR [edi-12]
	mov	DWORD PTR $T24194[esp+432], eax
	faddp	ST(1), ST(0)
	fld	ST(3)
	fmul	DWORD PTR $T24025[esp+432]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR $T24169[esp+432]
	fld	ST(1)
	fmul	DWORD PTR $T24025[esp+448]
	fld	ST(1)
	fmul	DWORD PTR $T24025[esp+460]
	faddp	ST(1), ST(0)
	fld	ST(3)
	fmul	DWORD PTR $T24025[esp+436]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR $T24169[esp+436]
	fxch	ST(1)
	fmul	DWORD PTR $T24025[esp+452]
	fxch	ST(1)
	fmul	DWORD PTR $T24025[esp+464]
	faddp	ST(1), ST(0)
	fxch	ST(1)
	fmul	DWORD PTR $T24025[esp+440]
	faddp	ST(1), ST(0)
	fld	DWORD PTR $T24169[esp+432]
	fadd	DWORD PTR $T24025[esp+468]
	fld	DWORD PTR $T24169[esp+436]
	fadd	DWORD PTR $T24025[esp+472]
	fstp	DWORD PTR $T24026[esp+436]
	fxch	ST(1)
	fadd	DWORD PTR $T24025[esp+476]
	fstp	DWORD PTR $T24026[esp+440]
	fmul	DWORD PTR $T24194[esp+432]
	fld	DWORD PTR $T24026[esp+436]
	fmul	DWORD PTR $T24194[esp+432]
	fld	DWORD PTR $T24026[esp+440]
	fmul	DWORD PTR $T24194[esp+432]
	fstp	DWORD PTR $T24027[esp+440]
	fxch	ST(1)
	fadd	DWORD PTR [esi-8]
	mov	edx, DWORD PTR _w$12707[esp+432]
	mov	eax, DWORD PTR -392+[esp+432]
	mov	ebp, DWORD PTR _boneZero$12713[esp+432]
	add	edx, 20					; 00000014H
	add	edi, 20					; 00000014H
	dec	eax
	fstp	DWORD PTR [esi-8]
	mov	DWORD PTR _w$12707[esp+432], edx
	mov	DWORD PTR -392+[esp+432], eax
	fadd	DWORD PTR [esi-4]
	fstp	DWORD PTR [esi-4]
	fld	DWORD PTR $T24027[esp+440]
	fadd	DWORD PTR [esi]
	fstp	DWORD PTR [esi]
	jne	$L24723
	mov	edi, DWORD PTR _i$12717[esp+432]
	mov	eax, DWORD PTR _iv$12712[esp+432]
$L12719:
	mov	ecx, DWORD PTR _numVerts$[esp+432]
	inc	edi
	add	esi, 12					; 0000000cH
	cmp	edi, ecx
	mov	DWORD PTR _i$12717[esp+432], edi
	jb	$L12718

; 851  : 					}
; 852  : 				}
; 853  : 			}
; 854  : 			else

	mov	esi, ecx
$L24725:

; 887  : 					}
; 888  : 				}
; 889  : 			}
; 890  : 		}
; 891  : 		else

	mov	ebp, DWORD PTR _evalVerts$[esp+432]
$L12776:

; 912  : 			}
; 913  : 		}
; 914  : 	}
; 915  : 
; 916  : 	// process remaining channels for vertex modification
; 917  : 	for (NDword i=1;i<mActorChannels.GetCount();i++)

	mov	eax, DWORD PTR [ebx+292]
	mov	edi, 1
	cmp	eax, edi
	jbe	SHORT $L12780
$L12778:

; 918  : 	{
; 919  : 		if (mActorChannels[i])

	mov	edx, DWORD PTR [ebx+288]
	mov	ecx, DWORD PTR [edx+edi*4]
	test	ecx, ecx
	je	SHORT $L12779

; 920  : 			mActorChannels[i]->EvalVerts(this, numVerts, lodRelay, evalVerts);

	mov	edx, DWORD PTR _lodRelay$[esp+432]
	mov	eax, DWORD PTR [ecx]
	push	ebp
	push	edx
	push	esi
	push	ebx
	call	DWORD PTR [eax+52]
$L12779:
	mov	eax, DWORD PTR [ebx+292]
	inc	edi
	cmp	edi, eax
	jb	SHORT $L12778
$L12780:

; 921  : 	}
; 922  : 
; 923  : 	// build the output vertices from the final work vertices and the alpha, if required
; 924  : 	if (evalVerts != outVerts)

	mov	ecx, DWORD PTR _outVerts$[esp+428]
	cmp	ebp, ecx
	je	$L12789

; 925  : 	{
; 926  : 		NDword i;
; 927  : 		VVec3* ov, *iv;
; 928  : 		NDword count = numVerts;
; 929  : 		for (i=0,ov=outVerts,iv=evalVerts; i<count; i++,ov++,iv++)

	test	esi, esi
	jbe	$L12789
	fld	DWORD PTR __real@3f800000
	fsub	DWORD PTR _inVertAlpha$[esp+428]
	mov	edx, ecx
	lea	eax, DWORD PTR [ebp+8]
	sub	edx, ebp
	mov	edi, esi
$L12787:

; 930  : 			*ov = (*iv * inVertAlpha) + (*ov * (1.f-inVertAlpha));

	fld	ST(0)
	fmul	DWORD PTR [ecx]
	fld	ST(1)
	fmul	DWORD PTR [ecx+4]
	add	ecx, 12					; 0000000cH
	add	eax, 12					; 0000000cH
	dec	edi
	fstp	DWORD PTR $T24041[esp+436]
	fld	ST(1)
	fmul	DWORD PTR [edx+eax-12]
	fstp	DWORD PTR $T24041[esp+440]
	fld	DWORD PTR _inVertAlpha$[esp+428]
	fmul	DWORD PTR [eax-20]
	fld	DWORD PTR _inVertAlpha$[esp+428]
	fmul	DWORD PTR [eax-16]
	fstp	DWORD PTR $T24042[esp+436]
	fld	DWORD PTR _inVertAlpha$[esp+428]
	fmul	DWORD PTR [eax-12]
	fstp	DWORD PTR $T24042[esp+440]
	faddp	ST(1), ST(0)
	fld	DWORD PTR $T24042[esp+436]
	fadd	DWORD PTR $T24041[esp+436]
	fld	DWORD PTR $T24042[esp+440]
	fadd	DWORD PTR $T24041[esp+440]
	fstp	DWORD PTR $T24043[esp+440]
	fxch	ST(1)
	fstp	DWORD PTR [ecx-12]
	fstp	DWORD PTR [ecx-8]
	fld	DWORD PTR $T24043[esp+440]
	fstp	DWORD PTR [edx+eax-12]
	jne	SHORT $L12787
	fstp	ST(0)
$L12789:

; 931  : 	}
; 932  : 	
; 933  : 	return(numVerts);

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 934  : }

	add	esp, 416				; 000001a0H
	ret	12					; 0000000cH
$L12714:

; 855  : 			{
; 856  : 				NDword count = mSkeleton->m_Verts.GetCount();

	mov	ecx, DWORD PTR [ecx+92]

; 857  : 				for (NDword i=0; i<count; i++,ov++,iv++)

	test	ecx, ecx
	jbe	$L24725
	mov	edx, DWORD PTR _evalVerts$[esp+432]
	mov	DWORD PTR -304+[esp+432], ecx
	lea	edi, DWORD PTR [edx+8]
$L12732:

; 858  : 				{					
; 859  : 					wcount = iv->weights.GetCount();

	mov	edx, DWORD PTR [eax+4]

; 860  : 					switch(wcount)
; 861  : 					{

	mov	ecx, edx
	sub	ecx, 0
	je	$L12749
	dec	ecx
	je	$L12739
	dec	ecx
	je	$L12742

; 877  : 						break;
; 878  : 					default:
; 879  : 						*ov = VVec3(0,0,0);

	xor	ecx, ecx
	mov	DWORD PTR [edi-8], ecx
	mov	DWORD PTR [edi-4], ecx
	mov	DWORD PTR [edi], ecx

; 880  : 						w = &iv->weights[0];

	mov	ecx, DWORD PTR [eax]

; 881  : 						for (NDword j=0;j<wcount;j++,w++)

	test	edx, edx
	mov	DWORD PTR _w$12707[esp+432], ecx
	jbe	$L12733
	lea	ebp, DWORD PTR [ecx+16]
	mov	DWORD PTR -308+[esp+432], edx
	jmp	SHORT $L12754
$L24722:

; 877  : 						break;
; 878  : 					default:
; 879  : 						*ov = VVec3(0,0,0);

	mov	ecx, DWORD PTR _w$12707[esp+432]
$L12754:

; 882  : 						{
; 883  : 							b = &mActorBones[w->bone - boneZero];

	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _boneZero$12713[esp+432]
	sub	ecx, eax
	mov	eax, 1808407283				; 6bca1af3H
	imul	ecx
	sar	edx, 5
	mov	eax, edx

; 884  : 							*ov += (w->offsetPos << b->GetCoords(true)) * w->factor;

	push	1
	shr	eax, 31					; 0000001fH
	add	edx, eax
	lea	eax, DWORD PTR [edx*8]
	sub	eax, edx
	mov	edx, DWORD PTR [ebx+272]
	lea	ecx, DWORD PTR [eax+eax*4]
	lea	esi, DWORD PTR [edx+ecx*4]
	mov	ecx, esi
	call	?ValidateAbs@CMacBone@@IAEX_N@Z		; CMacBone::ValidateAbs
	mov	DWORD PTR $T24038[esp+432], 1065353216	; 3f800000H
	mov	DWORD PTR $T24038[esp+436], 0
	mov	DWORD PTR $T24038[esp+440], 0
	mov	DWORD PTR $T24038[esp+444], 0
	mov	DWORD PTR $T24038[esp+448], 1065353216	; 3f800000H
	mov	DWORD PTR $T24038[esp+452], 0
	mov	DWORD PTR $T24038[esp+456], 0
	mov	DWORD PTR $T24038[esp+460], 0
	mov	DWORD PTR $T24038[esp+464], 1065353216	; 3f800000H
	mov	eax, DWORD PTR [esi+60]
	mov	DWORD PTR $T24038[esp+432], eax
	mov	ecx, DWORD PTR [esi+64]
	mov	DWORD PTR $T24038[esp+436], ecx
	mov	edx, DWORD PTR [esi+68]
	mov	DWORD PTR $T24038[esp+440], edx
	mov	eax, DWORD PTR [esi+72]
	mov	DWORD PTR $T24038[esp+444], eax
	mov	ecx, DWORD PTR [esi+76]
	mov	DWORD PTR $T24038[esp+448], ecx
	mov	edx, DWORD PTR [esi+80]
	mov	DWORD PTR $T24038[esp+452], edx
	mov	eax, DWORD PTR [esi+84]
	mov	DWORD PTR $T24038[esp+456], eax
	mov	ecx, DWORD PTR [esi+88]
	mov	DWORD PTR $T24038[esp+460], ecx
	mov	edx, DWORD PTR [esi+92]
	mov	DWORD PTR $T24038[esp+464], edx
	mov	eax, DWORD PTR [esi+96]
	mov	DWORD PTR $T24038[esp+468], eax
	mov	ecx, DWORD PTR [esi+100]
	mov	DWORD PTR $T24038[esp+472], ecx
	mov	edx, DWORD PTR [esi+104]
	mov	DWORD PTR $T24038[esp+476], edx
	mov	eax, DWORD PTR [esi+108]
	mov	DWORD PTR $T24038[esp+480], eax
	mov	ecx, DWORD PTR [esi+112]
	fld	DWORD PTR $T24038[esp+480]
	mov	DWORD PTR $T24038[esp+484], ecx
	mov	edx, DWORD PTR [esi+116]
	mov	DWORD PTR $T24038[esp+488], edx
	fmul	DWORD PTR [ebp-8]
	fld	DWORD PTR $T24038[esp+484]
	fmul	DWORD PTR [ebp-4]
	fld	DWORD PTR $T24038[esp+488]
	fmul	DWORD PTR [ebp]
	fld	DWORD PTR $T24038[esp+456]
	fmul	ST(0), ST(1)
	fld	ST(2)
	fmul	DWORD PTR $T24038[esp+444]
	faddp	ST(1), ST(0)
	fld	ST(3)
	fmul	DWORD PTR $T24038[esp+432]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR $T24608[esp+432]
	fld	ST(1)
	fmul	DWORD PTR $T24038[esp+448]
	fld	DWORD PTR $T24038[esp+436]
	fmul	ST(0), ST(4)
	faddp	ST(1), ST(0)
	fld	ST(1)
	fmul	DWORD PTR $T24038[esp+460]
	mov	eax, DWORD PTR [ebp-12]
	mov	edx, DWORD PTR _w$12707[esp+432]
	mov	DWORD PTR $T24633[esp+432], eax
	mov	eax, DWORD PTR -308+[esp+432]
	faddp	ST(1), ST(0)
	add	edx, 20					; 00000014H
	add	ebp, 20					; 00000014H
	dec	eax
	mov	DWORD PTR _w$12707[esp+432], edx
	fstp	DWORD PTR $T24608[esp+436]
	fxch	ST(1)
	fmul	DWORD PTR $T24038[esp+452]
	fld	DWORD PTR $T24038[esp+440]
	fmul	ST(0), ST(3)
	mov	DWORD PTR -308+[esp+432], eax
	faddp	ST(1), ST(0)
	fxch	ST(1)
	fmul	DWORD PTR $T24038[esp+464]
	faddp	ST(1), ST(0)
	fstp	ST(1)
	fld	DWORD PTR $T24608[esp+432]
	fadd	DWORD PTR $T24038[esp+468]
	fld	DWORD PTR $T24608[esp+436]
	fadd	DWORD PTR $T24038[esp+472]
	fstp	DWORD PTR $T24039[esp+436]
	fxch	ST(1)
	fadd	DWORD PTR $T24038[esp+476]
	fstp	DWORD PTR $T24039[esp+440]
	fmul	DWORD PTR $T24633[esp+432]
	fld	DWORD PTR $T24039[esp+436]
	fmul	DWORD PTR $T24633[esp+432]
	fld	DWORD PTR $T24039[esp+440]
	fmul	DWORD PTR $T24633[esp+432]
	fstp	DWORD PTR $T24040[esp+440]
	fxch	ST(1)
	fadd	DWORD PTR [edi-8]
	fstp	DWORD PTR [edi-8]
	fadd	DWORD PTR [edi-4]
	fstp	DWORD PTR [edi-4]
	fld	DWORD PTR $T24040[esp+440]
	fadd	DWORD PTR [edi]
	fstp	DWORD PTR [edi]
	jne	$L24722

; 885  : 						}
; 886  : 						break;

	mov	ebp, DWORD PTR _boneZero$12713[esp+432]
	mov	eax, DWORD PTR _iv$12712[esp+432]
	mov	esi, DWORD PTR _numVerts$[esp+432]
	jmp	$L12733
$L12742:

; 867  : 					case 2:
; 868  : 						w = &iv->weights[0];

	mov	esi, DWORD PTR [eax]

; 869  : 						b = &mActorBones[w->bone - boneZero];

	mov	eax, 1808407283				; 6bca1af3H

; 870  : 						*ov = (w->offsetPos << b->GetCoords(true)) * w->factor;

	push	1
	mov	ecx, DWORD PTR [esi]
	sub	ecx, ebp
	imul	ecx
	sar	edx, 5
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	edx, ecx
	lea	eax, DWORD PTR [edx*8]
	sub	eax, edx
	lea	edx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR [ebx+272]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _b$12708[esp+436], ecx
	call	?ValidateAbs@CMacBone@@IAEX_N@Z		; CMacBone::ValidateAbs
	mov	ecx, DWORD PTR _b$12708[esp+432]
	add	ecx, 60					; 0000003cH
	push	ecx
	lea	ecx, DWORD PTR $T24030[esp+436]
	call	??0VCoords3@@QAE@ABV0@@Z		; VCoords3::VCoords3
	fld	DWORD PTR $T24030[esp+480]
	fmul	DWORD PTR [esi+8]
	fld	DWORD PTR $T24030[esp+484]
	fmul	DWORD PTR [esi+12]
	fld	DWORD PTR $T24030[esp+488]
	fmul	DWORD PTR [esi+16]
	fld	ST(2)
	fmul	DWORD PTR $T24030[esp+432]
	fld	ST(2)
	fmul	DWORD PTR $T24030[esp+444]
	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR $T24350[esp+432], edx
	faddp	ST(1), ST(0)
	fld	ST(1)
	fmul	DWORD PTR $T24030[esp+456]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR $T24325[esp+432]
	fld	ST(2)
	fmul	DWORD PTR $T24030[esp+436]
	fld	ST(2)
	fmul	DWORD PTR $T24030[esp+448]
	faddp	ST(1), ST(0)
	fld	ST(1)
	fmul	DWORD PTR $T24030[esp+460]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR $T24325[esp+436]
	fxch	ST(2)
	fmul	DWORD PTR $T24030[esp+440]
	fxch	ST(1)
	fmul	DWORD PTR $T24030[esp+452]
	faddp	ST(1), ST(0)
	fld	ST(1)
	fmul	DWORD PTR $T24030[esp+464]
	faddp	ST(1), ST(0)
	fxch	ST(1)
	fstp	ST(0)
	fld	DWORD PTR $T24030[esp+468]
	fadd	DWORD PTR $T24325[esp+432]
	fstp	DWORD PTR $T24031[esp+432]
	fld	DWORD PTR $T24325[esp+436]
	fadd	DWORD PTR $T24030[esp+472]
	fstp	DWORD PTR $T24031[esp+436]
	fadd	DWORD PTR $T24030[esp+476]
	fld	DWORD PTR $T24031[esp+432]
	fmul	DWORD PTR $T24350[esp+432]
	fld	DWORD PTR $T24031[esp+436]
	fmul	DWORD PTR $T24350[esp+432]
	fxch	ST(2)
	fmul	DWORD PTR $T24350[esp+432]

; 871  : 						w++;

	add	esi, 20					; 00000014H

; 872  : 						b = &mActorBones[w->bone - boneZero];
; 873  : 						*ov += (w->offsetPos << b->GetCoords(true)) * w->factor;

	push	1
	fstp	DWORD PTR $T24032[esp+444]
	mov	eax, DWORD PTR $T24032[esp+444]
	fstp	DWORD PTR [edi-8]
	mov	DWORD PTR [edi], eax
	mov	eax, 1808407283				; 6bca1af3H
	fstp	DWORD PTR [edi-4]
	mov	ecx, DWORD PTR [esi]
	sub	ecx, ebp
	imul	ecx
	sar	edx, 5
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	edx, ecx
	lea	eax, DWORD PTR [edx*8]
	sub	eax, edx
	lea	edx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR [ebx+272]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _b$12708[esp+436], ecx
	call	?ValidateAbs@CMacBone@@IAEX_N@Z		; CMacBone::ValidateAbs
	mov	ecx, DWORD PTR _b$12708[esp+432]
	add	ecx, 60					; 0000003cH
	push	ecx
	lea	ecx, DWORD PTR $T24033[esp+436]
	call	??0VCoords3@@QAE@ABV0@@Z		; VCoords3::VCoords3
	fld	DWORD PTR $T24033[esp+480]
	fmul	DWORD PTR [esi+8]
	fld	DWORD PTR $T24033[esp+484]
	fmul	DWORD PTR [esi+12]
	fld	DWORD PTR $T24033[esp+488]
	fmul	DWORD PTR [esi+16]
	fld	ST(1)
	fmul	DWORD PTR $T24033[esp+444]
	fld	ST(1)
	fmul	DWORD PTR $T24033[esp+456]
	faddp	ST(1), ST(0)
	fld	ST(3)
	fmul	DWORD PTR $T24033[esp+432]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR $T24411[esp+432]
	fld	ST(1)
	fmul	DWORD PTR $T24033[esp+448]
	fld	ST(1)
	fmul	DWORD PTR $T24033[esp+460]
	faddp	ST(1), ST(0)
	fld	ST(3)
	fmul	DWORD PTR $T24033[esp+436]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR $T24411[esp+436]
	fxch	ST(1)
	fmul	DWORD PTR $T24033[esp+452]
	fxch	ST(1)
	fmul	DWORD PTR $T24033[esp+464]
	faddp	ST(1), ST(0)
	fld	DWORD PTR $T24033[esp+440]
	fmul	ST(0), ST(2)
	faddp	ST(1), ST(0)
	fstp	ST(1)
	fld	DWORD PTR $T24033[esp+468]
	fadd	DWORD PTR $T24411[esp+432]
	fld	DWORD PTR $T24411[esp+436]
	fadd	DWORD PTR $T24033[esp+472]
	fstp	DWORD PTR $T24034[esp+436]
	mov	edx, DWORD PTR [esi+4]

; 874  : 						break;

	mov	eax, DWORD PTR _iv$12712[esp+432]
	fxch	ST(1)
	fadd	DWORD PTR $T24033[esp+476]
	mov	DWORD PTR $T24428[esp+432], edx
	mov	esi, DWORD PTR _numVerts$[esp+432]
	fstp	DWORD PTR $T24034[esp+440]
	fmul	DWORD PTR $T24428[esp+432]
	fld	DWORD PTR $T24034[esp+436]
	fmul	DWORD PTR $T24428[esp+432]
	fld	DWORD PTR $T24034[esp+440]
	fmul	DWORD PTR $T24428[esp+432]
	fstp	DWORD PTR $T24035[esp+440]
	fxch	ST(1)
	fadd	DWORD PTR [edi-8]
	fstp	DWORD PTR [edi-8]
	fadd	DWORD PTR [edi-4]
	fstp	DWORD PTR [edi-4]
	fld	DWORD PTR $T24035[esp+440]
	fadd	DWORD PTR [edi]
	fstp	DWORD PTR [edi]
	jmp	$L12733
$L12739:

; 862  : 					case 1:
; 863  : 						w = &iv->weights[0];

	mov	esi, DWORD PTR [eax]

; 864  : 						b = &mActorBones[w->bone - boneZero];

	mov	eax, 1808407283				; 6bca1af3H

; 865  : 						*ov = (w->offsetPos << b->GetCoords(true));// * w->factor;

	push	1
	mov	ecx, DWORD PTR [esi]
	sub	ecx, ebp
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	edx, eax
	lea	eax, DWORD PTR [edx*8]
	sub	eax, edx
	mov	edx, DWORD PTR [ebx+272]
	lea	ecx, DWORD PTR [eax+eax*4]
	lea	ecx, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR _b$12708[esp+436], ecx
	call	?ValidateAbs@CMacBone@@IAEX_N@Z		; CMacBone::ValidateAbs
	mov	eax, DWORD PTR _b$12708[esp+432]
	lea	ecx, DWORD PTR $T24028[esp+432]
	add	eax, 60					; 0000003cH
	push	eax
	call	??0VCoords3@@QAE@ABV0@@Z		; VCoords3::VCoords3
	fld	DWORD PTR $T24028[esp+480]
	fmul	DWORD PTR [esi+8]
	fld	DWORD PTR $T24028[esp+484]
	fmul	DWORD PTR [esi+12]
	fld	DWORD PTR $T24028[esp+488]
	fmul	DWORD PTR [esi+16]
	fld	ST(1)
	fmul	DWORD PTR $T24028[esp+444]
	fld	ST(1)
	fmul	DWORD PTR $T24028[esp+456]

; 866  : 						break;

	mov	eax, DWORD PTR _iv$12712[esp+432]
	mov	esi, DWORD PTR _numVerts$[esp+432]
	faddp	ST(1), ST(0)
	fld	DWORD PTR $T24028[esp+432]
	fmul	ST(0), ST(4)
	faddp	ST(1), ST(0)
	fstp	DWORD PTR $T24256[esp+432]
	fld	ST(1)
	fmul	DWORD PTR $T24028[esp+448]
	fld	ST(1)
	fmul	DWORD PTR $T24028[esp+460]
	faddp	ST(1), ST(0)
	fld	DWORD PTR $T24028[esp+436]
	fmul	ST(0), ST(4)
	faddp	ST(1), ST(0)
	fstp	DWORD PTR $T24256[esp+436]
	fxch	ST(1)
	fmul	DWORD PTR $T24028[esp+452]
	fxch	ST(1)
	fmul	DWORD PTR $T24028[esp+464]
	faddp	ST(1), ST(0)
	fld	DWORD PTR $T24028[esp+440]
	fmul	ST(0), ST(2)
	faddp	ST(1), ST(0)
	fstp	ST(1)
	fld	DWORD PTR $T24028[esp+468]
	fadd	DWORD PTR $T24256[esp+432]
	fld	DWORD PTR $T24256[esp+436]
	fadd	DWORD PTR $T24028[esp+472]
	fxch	ST(2)
	fadd	DWORD PTR $T24028[esp+476]
	fstp	DWORD PTR $T24029[esp+440]
	mov	ecx, DWORD PTR $T24029[esp+440]
	fstp	DWORD PTR [edi-8]
	fstp	DWORD PTR [edi-4]
	jmp	SHORT $L24729
$L12749:

; 875  : 					case 0:
; 876  : 						*ov = VVec3(0,0,0);

	xor	ecx, ecx
	mov	DWORD PTR [edi-8], ecx
	mov	DWORD PTR [edi-4], ecx
$L24729:
	mov	DWORD PTR [edi], ecx
$L12733:

; 857  : 				for (NDword i=0; i<count; i++,ov++,iv++)

	mov	ecx, DWORD PTR -304+[esp+432]
	add	edi, 12					; 0000000cH
	add	eax, 16					; 00000010H
	dec	ecx
	mov	DWORD PTR _iv$12712[esp+432], eax
	mov	DWORD PTR -304+[esp+432], ecx
	jne	$L12732

; 887  : 					}
; 888  : 				}
; 889  : 			}
; 890  : 		}
; 891  : 		else

	jmp	$L24725
$L12700:

; 892  : 		{
; 893  : 			// if we don't have a skeleton at all, and we didn't have vertex modification,
; 894  : 			// then we'll need some kind of data in here, so use the reference positions
; 895  : 			if (lodRelay)

	mov	eax, DWORD PTR _lodRelay$[esp+432]
	test	eax, eax
	je	SHORT $L12761

; 896  : 			{
; 897  : 				NDword i;
; 898  : 				VVec3* ov;
; 899  : 				CCpjGeoVert* iv;
; 900  : 				NDword count = numVerts;
; 901  : 				for (i=0,ov=evalVerts,iv=&mGeometry->m_Verts[0]; i<count; i++,ov++)

	mov	eax, DWORD PTR [ebx+140]
	xor	edx, edx
	test	esi, esi
	mov	edi, DWORD PTR [eax+72]
	jbe	$L12776
	lea	ecx, DWORD PTR [ebp+8]
$L12766:

; 902  : 					*ov = iv[lodRelay[i]].refPosition;

	mov	ebp, DWORD PTR _lodRelay$[esp+432]
	xor	eax, eax
	add	ecx, 12					; 0000000cH
	mov	ax, WORD PTR [ebp+edx*2]
	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 4
	inc	edx
	mov	ebp, DWORD PTR [eax+edi+4]
	lea	eax, DWORD PTR [eax+edi+4]
	mov	DWORD PTR [ecx-20], ebp
	cmp	edx, esi
	mov	ebp, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx-16], ebp
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx-12], eax
	jb	SHORT $L12766

; 903  : 			}
; 904  : 			else

	jmp	$L24725
$L12761:

; 905  : 			{
; 906  : 				NDword i;
; 907  : 				VVec3* ov;
; 908  : 				CCpjGeoVert* iv;
; 909  : 				NDword count = numVerts;
; 910  : 				for (i=0,ov=evalVerts,iv=&mGeometry->m_Verts[0]; i<count; i++,ov++,iv++)

	mov	ecx, DWORD PTR [ebx+140]
	test	esi, esi
	mov	ecx, DWORD PTR [ecx+72]
	jbe	$L12776
	lea	eax, DWORD PTR [ebp+8]
	add	ecx, 12					; 0000000cH
	mov	edx, esi
$L12774:

; 911  : 					*ov = iv->refPosition;

	mov	edi, DWORD PTR [ecx-8]
	add	ecx, 48					; 00000030H
	mov	DWORD PTR [eax-8], edi
	mov	edi, DWORD PTR [ecx-52]
	mov	DWORD PTR [eax-4], edi
	mov	edi, DWORD PTR [ecx-48]
	mov	DWORD PTR [eax], edi
	add	eax, 12					; 0000000cH
	dec	edx
	jne	SHORT $L12774

; 905  : 			{
; 906  : 				NDword i;
; 907  : 				VVec3* ov;
; 908  : 				CCpjGeoVert* iv;
; 909  : 				NDword count = numVerts;
; 910  : 				for (i=0,ov=evalVerts,iv=&mGeometry->m_Verts[0]; i<count; i++,ov++,iv++)

	jmp	$L12776
$L12687:
	pop	edi
	pop	esi
	pop	ebp

; 785  : 		return(0); // kinda pointless if we have no verts to evaluate to

	xor	eax, eax
	pop	ebx

; 934  : }

	add	esp, 416				; 000001a0H
	ret	12					; 0000000cH
?EvaluateVerts@OMacActor@@QAEKMMPAVVVec3@@@Z ENDP	; OMacActor::EvaluateVerts
; Function compile flags: /Ogty
; File C:\duke4\Cannibal\CorMain.h
_TEXT	ENDS
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
??3@YAXPAX0@Z PROC NEAR					; operator delete, COMDAT

; 25   : inline void operator delete (void* inPtr, void*) {}

	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?Set@CCorString@@QAEXPAD@Z
_TEXT	SEGMENT
_inStr$ = 8
?Set@CCorString@@QAEXPAD@Z PROC NEAR			; CCorString::Set, COMDAT
; _this$ = ecx

; 44   : 	{

	push	ebx
	push	ebp

; 45   : 		if (inStr && !inStr[0])

	mov	ebp, DWORD PTR _inStr$[esp+4]
	push	esi
	test	ebp, ebp
	push	edi
	mov	ebx, ecx
	je	SHORT $L4690
	cmp	BYTE PTR [ebp], 0
	jne	SHORT $L4690

; 46   : 			inStr=NULL;

	xor	ebp, ebp
$L4690:

; 47   : 		if (mStr)

	mov	edi, DWORD PTR [ebx]
	test	edi, edi
	je	SHORT $L4691

; 48   : 		{
; 49   : 			sMemTotal -= strlen(mStr)+1;

	or	ecx, -1
	xor	eax, eax
	repne scasb
	mov	edi, DWORD PTR ?sMemTotal@CCorString@@0KA ; CCorString::sMemTotal
	or	eax, -1
	not	ecx
	dec	ecx
	sub	eax, ecx
	add	edi, eax
	mov	DWORD PTR ?sMemTotal@CCorString@@0KA, edi ; CCorString::sMemTotal

; 50   : 			MEM_Free(mStr);

	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [ebx]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L4691:

; 51   : 		}
; 52   : 		mStr = NULL;
; 53   : 		if (inStr)

	test	ebp, ebp
	mov	DWORD PTR [ebx], 0
	je	SHORT $L4696

; 54   : 		{
; 55   : 			unsigned long size = strlen(inStr)+1;

	mov	edi, ebp
	or	ecx, -1
	xor	eax, eax
	repne scasb
	not	ecx
	dec	ecx
	mov	esi, ecx
	inc	esi

; 56   : 			mStr = MEM_Malloc(char, size);

	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	ecx, eax
	call	DWORD PTR [edx]

; 57   : 			if (mStr)

	test	eax, eax
	mov	DWORD PTR [ebx], eax
	je	SHORT $L4696

; 58   : 			{
; 59   : 				strcpy(mStr, inStr);

	mov	edx, ebp
$L24736:
	mov	cl, BYTE PTR [edx]
	inc	edx
	mov	BYTE PTR [eax], cl
	inc	eax
	test	cl, cl
	jne	SHORT $L24736

; 60   : 				sMemTotal += size;

	add	DWORD PTR ?sMemTotal@CCorString@@0KA, esi ; CCorString::sMemTotal
$L4696:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 61   : 			}
; 62   : 		}
; 63   : 	}

	ret	4
?Set@CCorString@@QAEXPAD@Z ENDP				; CCorString::Set
_TEXT	ENDS
PUBLIC	?Cat@CCorString@@QAEXPAD@Z			; CCorString::Cat
; Function compile flags: /Ogty
;	COMDAT ?Cat@CCorString@@QAEXPAD@Z
_TEXT	SEGMENT
_inStr$ = 8
_size$ = 8
?Cat@CCorString@@QAEXPAD@Z PROC NEAR			; CCorString::Cat, COMDAT
; _this$ = ecx

; 65   : 	{

	push	ebx
	push	ebp
	push	esi

; 66   : 		if (inStr && !inStr[0])

	mov	esi, DWORD PTR _inStr$[esp+8]
	test	esi, esi
	push	edi
	mov	ebp, ecx
	je	SHORT $L4699
	cmp	BYTE PTR [esi], 0
	jne	SHORT $L4699

; 67   : 			inStr=NULL;

	xor	esi, esi
$L4699:

; 68   : 		if (!mStr)

	mov	edi, DWORD PTR [ebp]
	test	edi, edi
	jne	SHORT $L4700

; 69   : 		{
; 70   : 			Set(inStr);

	test	esi, esi
	mov	ebx, esi
	je	SHORT $L24747
	cmp	BYTE PTR [esi], 0
	jne	SHORT $L24747
	xor	ebx, ebx
$L24747:
	test	ebx, ebx
	mov	DWORD PTR [ebp], 0
	je	$L4698
	mov	edi, ebx
	or	ecx, -1
	xor	eax, eax
	repne scasb
	not	ecx
	dec	ecx
	mov	esi, ecx
	inc	esi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	ecx, eax
	call	DWORD PTR [edx]
	test	eax, eax
	mov	DWORD PTR [ebp], eax
	je	$L4698
	mov	ecx, ebx
	mov	edx, eax
$L24745:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	mov	BYTE PTR [edx], al
	inc	edx
	test	al, al
	jne	SHORT $L24745
	mov	eax, DWORD PTR ?sMemTotal@CCorString@@0KA ; CCorString::sMemTotal
	pop	edi
	add	eax, esi
	pop	esi
	pop	ebp
	mov	DWORD PTR ?sMemTotal@CCorString@@0KA, eax ; CCorString::sMemTotal
	pop	ebx

; 86   : 	}

	ret	4
$L4700:

; 71   : 			return;
; 72   : 		}
; 73   : 		if (!inStr)

	test	esi, esi
	je	$L4698

; 74   : 			return;
; 75   : 		unsigned long size = strlen(mStr)+strlen(inStr)+1;		

	or	ecx, -1
	xor	eax, eax
	repne scasb
	not	ecx
	dec	ecx
	mov	edi, esi
	mov	edx, ecx
	or	ecx, -1
	repne scasb
	not	ecx
	dec	ecx
	lea	edi, DWORD PTR [edx+ecx+1]
	mov	DWORD PTR _size$[esp+12], edi

; 76   : 		char* nstr = MEM_Malloc(char, size);

	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	edi
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	ebx, eax

; 77   : 		if (nstr)

	test	ebx, ebx
	je	SHORT $L4706

; 78   : 		{
; 79   : 			strcpy(nstr, mStr);

	mov	ecx, DWORD PTR [ebp]
	mov	edx, ebx
$L24741:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	mov	BYTE PTR [edx], al
	inc	edx
	test	al, al
	jne	SHORT $L24741

; 80   : 			strcat(nstr, inStr);

	mov	edi, esi
	or	ecx, -1
	xor	eax, eax
	repne scasb
	not	ecx
	sub	edi, ecx
	mov	esi, edi
	mov	edx, ecx
	mov	edi, ebx
	or	ecx, -1
	repne scasb
	mov	ecx, edx
	dec	edi
	shr	ecx, 2
	rep movsd

; 81   : 			sMemTotal += size;

	mov	eax, DWORD PTR _size$[esp+12]
	mov	ecx, edx
	and	ecx, 3
	rep movsb
	add	DWORD PTR ?sMemTotal@CCorString@@0KA, eax ; CCorString::sMemTotal
$L4706:

; 82   : 		}
; 83   : 		sMemTotal -= strlen(mStr)+1;

	mov	edi, DWORD PTR [ebp]
	or	ecx, -1
	xor	eax, eax
	or	edx, -1
	repne scasb
	mov	edi, DWORD PTR ?sMemTotal@CCorString@@0KA ; CCorString::sMemTotal
	not	ecx
	dec	ecx
	sub	edx, ecx
	add	edi, edx
	mov	DWORD PTR ?sMemTotal@CCorString@@0KA, edi ; CCorString::sMemTotal

; 84   : 		MEM_Free(mStr);

	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [ebp]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]

; 85   : 		mStr = nstr;

	mov	DWORD PTR [ebp], ebx
$L4698:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 86   : 	}

	ret	4
?Cat@CCorString@@QAEXPAD@Z ENDP				; CCorString::Cat
_TEXT	ENDS
PUBLIC	?Setf@CCorString@@QAAXPADZZ			; CCorString::Setf
EXTRN	?STR_Va@@YAPADAAPAD@Z:NEAR			; STR_Va
; Function compile flags: /Ogty
;	COMDAT ?Setf@CCorString@@QAAXPADZZ
_TEXT	SEGMENT
_inStr$ = 12
_this$ = 8
?Setf@CCorString@@QAAXPADZZ PROC NEAR			; CCorString::Setf, COMDAT

; 87   : 	inline void Setf(char* inStr, ... ) { Set(STR_Va(inStr)); }

	push	ebx
	push	ebp
	push	esi
	lea	eax, DWORD PTR _inStr$[esp+8]
	push	edi
	push	eax
	call	?STR_Va@@YAPADAAPAD@Z			; STR_Va
	mov	ebp, eax
	add	esp, 4
	test	ebp, ebp
	je	SHORT $L24764
	cmp	BYTE PTR [ebp], 0
	jne	SHORT $L24764
	xor	ebp, ebp
$L24764:
	mov	ebx, DWORD PTR _this$[esp+12]
	mov	edi, DWORD PTR [ebx]
	test	edi, edi
	je	SHORT $L24765
	or	ecx, -1
	xor	eax, eax
	repne scasb
	mov	edi, DWORD PTR ?sMemTotal@CCorString@@0KA ; CCorString::sMemTotal
	or	edx, -1
	not	ecx
	dec	ecx
	sub	edx, ecx
	add	edi, edx
	mov	DWORD PTR ?sMemTotal@CCorString@@0KA, edi ; CCorString::sMemTotal
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [ebx]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L24765:
	test	ebp, ebp
	mov	DWORD PTR [ebx], 0
	je	SHORT $L24768
	mov	edi, ebp
	or	ecx, -1
	xor	eax, eax
	repne scasb
	not	ecx
	dec	ecx
	mov	esi, ecx
	inc	esi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	ecx, eax
	call	DWORD PTR [edx]
	test	eax, eax
	mov	DWORD PTR [ebx], eax
	je	SHORT $L24768
	mov	edx, ebp
$L24762:
	mov	cl, BYTE PTR [edx]
	inc	edx
	mov	BYTE PTR [eax], cl
	inc	eax
	test	cl, cl
	jne	SHORT $L24762
	add	DWORD PTR ?sMemTotal@CCorString@@0KA, esi ; CCorString::sMemTotal
$L24768:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	0
?Setf@CCorString@@QAAXPADZZ ENDP			; CCorString::Setf
_TEXT	ENDS
PUBLIC	?Catf@CCorString@@QAAXPADZZ			; CCorString::Catf
; Function compile flags: /Ogty
;	COMDAT ?Catf@CCorString@@QAAXPADZZ
_TEXT	SEGMENT
_size$24801 = 8
_inStr$ = 12
_this$ = 8
?Catf@CCorString@@QAAXPADZZ PROC NEAR			; CCorString::Catf, COMDAT

; 88   : 	inline void Catf(char* inStr, ... ) { Cat(STR_Va(inStr)); }

	push	ebx
	push	ebp
	push	esi
	lea	eax, DWORD PTR _inStr$[esp+8]
	push	edi
	push	eax
	call	?STR_Va@@YAPADAAPAD@Z			; STR_Va
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	je	SHORT $L24798
	cmp	BYTE PTR [esi], 0
	jne	SHORT $L24798
	xor	esi, esi
$L24798:
	mov	ebp, DWORD PTR _this$[esp+12]
	mov	edi, DWORD PTR [ebp]
	test	edi, edi
	jne	SHORT $L24799
	test	esi, esi
	mov	ebx, esi
	je	SHORT $L24792
	cmp	BYTE PTR [esi], 0
	jne	SHORT $L24792
	xor	ebx, ebx
$L24792:
	test	ebx, ebx
	mov	DWORD PTR [ebp], 0
	je	$L24797
	mov	edi, ebx
	or	ecx, -1
	xor	eax, eax
	repne scasb
	not	ecx
	dec	ecx
	mov	esi, ecx
	inc	esi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	ecx, eax
	call	DWORD PTR [edx]
	test	eax, eax
	mov	DWORD PTR [ebp], eax
	je	$L24797
	mov	ecx, ebx
	mov	edx, eax
$L24790:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	mov	BYTE PTR [edx], al
	inc	edx
	test	al, al
	jne	SHORT $L24790
	mov	eax, DWORD PTR ?sMemTotal@CCorString@@0KA ; CCorString::sMemTotal
	pop	edi
	add	eax, esi
	pop	esi
	pop	ebp
	mov	DWORD PTR ?sMemTotal@CCorString@@0KA, eax ; CCorString::sMemTotal
	pop	ebx
	ret	0
$L24799:
	test	esi, esi
	je	$L24797
	or	ecx, -1
	xor	eax, eax
	repne scasb
	not	ecx
	dec	ecx
	mov	edi, esi
	mov	edx, ecx
	or	ecx, -1
	repne scasb
	not	ecx
	dec	ecx
	lea	edi, DWORD PTR [edx+ecx+1]
	mov	DWORD PTR _size$24801[esp+12], edi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	edi
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	ebx, eax
	test	ebx, ebx
	je	SHORT $L24803
	mov	ecx, DWORD PTR [ebp]
	mov	edx, ebx
$L24788:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	mov	BYTE PTR [edx], al
	inc	edx
	test	al, al
	jne	SHORT $L24788
	mov	edi, esi
	or	ecx, -1
	xor	eax, eax
	repne scasb
	not	ecx
	sub	edi, ecx
	mov	esi, edi
	mov	edx, ecx
	mov	edi, ebx
	or	ecx, -1
	repne scasb
	mov	ecx, edx
	dec	edi
	shr	ecx, 2
	rep movsd
	mov	eax, DWORD PTR _size$24801[esp+12]
	mov	ecx, edx
	and	ecx, 3
	rep movsb
	add	DWORD PTR ?sMemTotal@CCorString@@0KA, eax ; CCorString::sMemTotal
$L24803:
	mov	edi, DWORD PTR [ebp]
	or	ecx, -1
	xor	eax, eax
	or	edx, -1
	repne scasb
	mov	edi, DWORD PTR ?sMemTotal@CCorString@@0KA ; CCorString::sMemTotal
	not	ecx
	dec	ecx
	sub	edx, ecx
	add	edi, edx
	mov	DWORD PTR ?sMemTotal@CCorString@@0KA, edi ; CCorString::sMemTotal
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [ebp]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
	mov	DWORD PTR [ebp], ebx
$L24797:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	0
?Catf@CCorString@@QAAXPADZZ ENDP			; CCorString::Catf
_TEXT	ENDS
PUBLIC	??0CCorString@@QAE@XZ				; CCorString::CCorString
; Function compile flags: /Ogty
;	COMDAT ??0CCorString@@QAE@XZ
_TEXT	SEGMENT
??0CCorString@@QAE@XZ PROC NEAR				; CCorString::CCorString, COMDAT
; _this$ = ecx

; 90   : 	inline CCorString() { mStr = NULL; }

	mov	eax, ecx
	mov	DWORD PTR [eax], 0
	ret	0
??0CCorString@@QAE@XZ ENDP				; CCorString::CCorString
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??1CCorString@@QAE@XZ
_TEXT	SEGMENT
??1CCorString@@QAE@XZ PROC NEAR				; CCorString::~CCorString, COMDAT
; _this$ = ecx

; 91   : 	inline ~CCorString() { Set(NULL); }

	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR [esi]
	test	edi, edi
	je	SHORT $L24826
	or	ecx, -1
	xor	eax, eax
	repne scasb
	not	ecx
	dec	ecx
	or	eax, -1
	sub	eax, ecx
	mov	ecx, DWORD PTR ?sMemTotal@CCorString@@0KA ; CCorString::sMemTotal
	add	ecx, eax
	mov	DWORD PTR ?sMemTotal@CCorString@@0KA, ecx ; CCorString::sMemTotal
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L24826:
	mov	DWORD PTR [esi], 0
	pop	edi
	pop	esi
	ret	0
??1CCorString@@QAE@XZ ENDP				; CCorString::~CCorString
_TEXT	ENDS
PUBLIC	??0CCorString@@QAE@ABV0@@Z			; CCorString::CCorString
; Function compile flags: /Ogty
;	COMDAT ??0CCorString@@QAE@ABV0@@Z
_TEXT	SEGMENT
_inStr$ = 8
??0CCorString@@QAE@ABV0@@Z PROC NEAR			; CCorString::CCorString, COMDAT
; _this$ = ecx

; 92   : 	inline CCorString(const CCorString& inStr) { mStr = NULL; Set(inStr.mStr); }

	mov	eax, DWORD PTR _inStr$[esp-4]
	push	ebx
	mov	ebx, ecx
	push	esi
	push	edi
	mov	DWORD PTR [ebx], 0
	mov	esi, DWORD PTR [eax]
	test	esi, esi
	je	SHORT $L24836
	cmp	BYTE PTR [esi], 0
	jne	SHORT $L24836
	xor	esi, esi
$L24836:
	test	esi, esi
	mov	DWORD PTR [ebx], 0
	je	SHORT $L24843
	mov	edi, esi
	or	ecx, -1
	xor	eax, eax
	repne scasb
	not	ecx
	dec	ecx
	mov	edi, ecx
	inc	edi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	edi
	mov	ecx, eax
	call	DWORD PTR [edx]
	test	eax, eax
	mov	DWORD PTR [ebx], eax
	je	SHORT $L24843
	mov	ecx, eax
$L24833:
	mov	al, BYTE PTR [esi]
	inc	esi
	mov	BYTE PTR [ecx], al
	inc	ecx
	test	al, al
	jne	SHORT $L24833
	add	DWORD PTR ?sMemTotal@CCorString@@0KA, edi ; CCorString::sMemTotal
$L24843:
	pop	edi
	mov	eax, ebx
	pop	esi
	pop	ebx
	ret	4
??0CCorString@@QAE@ABV0@@Z ENDP				; CCorString::CCorString
_TEXT	ENDS
PUBLIC	??0CCorString@@QAE@PBD@Z			; CCorString::CCorString
; Function compile flags: /Ogty
;	COMDAT ??0CCorString@@QAE@PBD@Z
_TEXT	SEGMENT
_inStr$ = 8
??0CCorString@@QAE@PBD@Z PROC NEAR			; CCorString::CCorString, COMDAT
; _this$ = ecx

; 93   : 	inline CCorString(const char* inStr) { mStr = NULL; Set((char*)inStr); }

	push	ebx
	mov	ebx, DWORD PTR _inStr$[esp]
	push	ebp
	mov	ebp, ecx
	test	ebx, ebx
	push	esi
	mov	DWORD PTR [ebp], 0
	je	SHORT $L24853
	cmp	BYTE PTR [ebx], 0
	jne	SHORT $L24853
	xor	ebx, ebx
$L24853:
	test	ebx, ebx
	mov	DWORD PTR [ebp], 0
	je	SHORT $L24860
	push	edi
	mov	edi, ebx
	or	ecx, -1
	xor	eax, eax
	repne scasb
	not	ecx
	dec	ecx
	mov	esi, ecx
	inc	esi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	ecx, eax
	call	DWORD PTR [edx]
	test	eax, eax
	mov	DWORD PTR [ebp], eax
	pop	edi
	je	SHORT $L24860
	mov	ecx, ebx
	mov	edx, eax
$L24850:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	mov	BYTE PTR [edx], al
	inc	edx
	test	al, al
	jne	SHORT $L24850
	add	DWORD PTR ?sMemTotal@CCorString@@0KA, esi ; CCorString::sMemTotal
$L24860:
	mov	eax, ebp
	pop	esi
	pop	ebp
	pop	ebx
	ret	4
??0CCorString@@QAE@PBD@Z ENDP				; CCorString::CCorString
_TEXT	ENDS
PUBLIC	??4CCorString@@QAEAAV0@ABV0@@Z			; CCorString::operator=
; Function compile flags: /Ogty
;	COMDAT ??4CCorString@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
_inStr$ = 8
??4CCorString@@QAEAAV0@ABV0@@Z PROC NEAR		; CCorString::operator=, COMDAT
; _this$ = ecx

; 95   : 	inline CCorString& operator = (const CCorString& inStr) { Set(inStr.mStr); return(*this); }

	mov	eax, DWORD PTR _inStr$[esp-4]
	push	ebx
	push	ebp
	push	esi
	mov	ebx, DWORD PTR [eax]
	push	edi
	test	ebx, ebx
	mov	ebp, ecx
	je	SHORT $L24869
	cmp	BYTE PTR [ebx], 0
	jne	SHORT $L24869
	xor	ebx, ebx
$L24869:
	mov	edi, DWORD PTR [ebp]
	test	edi, edi
	je	SHORT $L24870
	or	ecx, -1
	xor	eax, eax
	repne scasb
	mov	edi, DWORD PTR ?sMemTotal@CCorString@@0KA ; CCorString::sMemTotal
	or	edx, -1
	not	ecx
	dec	ecx
	sub	edx, ecx
	add	edi, edx
	mov	DWORD PTR ?sMemTotal@CCorString@@0KA, edi ; CCorString::sMemTotal
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [ebp]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L24870:
	test	ebx, ebx
	mov	DWORD PTR [ebp], 0
	je	SHORT $L24877
	mov	edi, ebx
	or	ecx, -1
	xor	eax, eax
	repne scasb
	not	ecx
	dec	ecx
	mov	esi, ecx
	inc	esi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	ecx, eax
	call	DWORD PTR [edx]
	test	eax, eax
	mov	DWORD PTR [ebp], eax
	je	SHORT $L24877
	mov	edx, ebx
$L24867:
	mov	cl, BYTE PTR [edx]
	inc	edx
	mov	BYTE PTR [eax], cl
	inc	eax
	test	cl, cl
	jne	SHORT $L24867
	add	DWORD PTR ?sMemTotal@CCorString@@0KA, esi ; CCorString::sMemTotal
$L24877:
	pop	edi
	mov	eax, ebp
	pop	esi
	pop	ebp
	pop	ebx
	ret	4
??4CCorString@@QAEAAV0@ABV0@@Z ENDP			; CCorString::operator=
_TEXT	ENDS
PUBLIC	??4CCorString@@QAEAAV0@PBD@Z			; CCorString::operator=
; Function compile flags: /Ogty
;	COMDAT ??4CCorString@@QAEAAV0@PBD@Z
_TEXT	SEGMENT
_inStr$ = 8
??4CCorString@@QAEAAV0@PBD@Z PROC NEAR			; CCorString::operator=, COMDAT
; _this$ = ecx

; 96   : 	inline CCorString& operator = (const char* inStr) { Set((char*)inStr); return(*this); }

	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _inStr$[esp+4]
	push	esi
	test	ebp, ebp
	push	edi
	mov	ebx, ecx
	je	SHORT $L24886
	cmp	BYTE PTR [ebp], 0
	jne	SHORT $L24886
	xor	ebp, ebp
$L24886:
	mov	edi, DWORD PTR [ebx]
	test	edi, edi
	je	SHORT $L24887
	or	ecx, -1
	xor	eax, eax
	repne scasb
	mov	edi, DWORD PTR ?sMemTotal@CCorString@@0KA ; CCorString::sMemTotal
	or	eax, -1
	not	ecx
	dec	ecx
	sub	eax, ecx
	add	edi, eax
	mov	DWORD PTR ?sMemTotal@CCorString@@0KA, edi ; CCorString::sMemTotal
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [ebx]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L24887:
	test	ebp, ebp
	mov	DWORD PTR [ebx], 0
	je	SHORT $L24894
	mov	edi, ebp
	or	ecx, -1
	xor	eax, eax
	repne scasb
	not	ecx
	dec	ecx
	mov	esi, ecx
	inc	esi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	ecx, eax
	call	DWORD PTR [edx]
	test	eax, eax
	mov	DWORD PTR [ebx], eax
	je	SHORT $L24894
	mov	edx, ebp
$L24884:
	mov	cl, BYTE PTR [edx]
	inc	edx
	mov	BYTE PTR [eax], cl
	inc	eax
	test	cl, cl
	jne	SHORT $L24884
	add	DWORD PTR ?sMemTotal@CCorString@@0KA, esi ; CCorString::sMemTotal
$L24894:
	pop	edi
	pop	esi
	mov	eax, ebx
	pop	ebp
	pop	ebx
	ret	4
??4CCorString@@QAEAAV0@PBD@Z ENDP			; CCorString::operator=
_TEXT	ENDS
PUBLIC	??YCCorString@@QAEAAV0@ABV0@@Z			; CCorString::operator+=
; Function compile flags: /Ogty
;	COMDAT ??YCCorString@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
_size$24925 = 8
_inStr$ = 8
??YCCorString@@QAEAAV0@ABV0@@Z PROC NEAR		; CCorString::operator+=, COMDAT
; _this$ = ecx

; 97   : 	inline CCorString& operator += (const CCorString& inStr) { Cat(inStr.mStr); return(*this); }

	mov	eax, DWORD PTR _inStr$[esp-4]
	push	ebp
	push	esi
	push	edi
	mov	esi, DWORD PTR [eax]
	mov	ebp, ecx
	test	esi, esi
	je	SHORT $L24922
	cmp	BYTE PTR [esi], 0
	jne	SHORT $L24922
	xor	esi, esi
$L24922:
	mov	edi, DWORD PTR [ebp]
	test	edi, edi
	jne	SHORT $L24923
	test	esi, esi
	je	SHORT $L24916
	cmp	BYTE PTR [esi], 0
	jne	SHORT $L24916
	xor	esi, esi
$L24916:
	test	esi, esi
	mov	DWORD PTR [ebp], 0
	je	$L24933
	mov	edi, esi
	or	ecx, -1
	xor	eax, eax
	repne scasb
	not	ecx
	dec	ecx
	mov	edi, ecx
	inc	edi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	edi
	mov	ecx, eax
	call	DWORD PTR [edx]
	test	eax, eax
	mov	DWORD PTR [ebp], eax
	je	$L24933
	mov	ecx, esi
	mov	edx, eax
$L24914:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	mov	BYTE PTR [edx], al
	inc	edx
	test	al, al
	jne	SHORT $L24914
	mov	eax, DWORD PTR ?sMemTotal@CCorString@@0KA ; CCorString::sMemTotal
	add	eax, edi
	pop	edi
	mov	DWORD PTR ?sMemTotal@CCorString@@0KA, eax ; CCorString::sMemTotal
	mov	eax, ebp
	pop	esi
	pop	ebp
	ret	4
$L24923:
	test	esi, esi
	je	$L24933
	or	ecx, -1
	xor	eax, eax
	repne scasb
	not	ecx
	dec	ecx
	mov	edi, esi
	mov	edx, ecx
	or	ecx, -1
	repne scasb
	not	ecx
	dec	ecx
	push	ebx
	lea	edi, DWORD PTR [edx+ecx+1]
	mov	DWORD PTR _size$24925[esp+12], edi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	edi
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	ebx, eax
	test	ebx, ebx
	je	SHORT $L24927
	mov	ecx, DWORD PTR [ebp]
	mov	edx, ebx
$L24912:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	mov	BYTE PTR [edx], al
	inc	edx
	test	al, al
	jne	SHORT $L24912
	mov	edi, esi
	or	ecx, -1
	xor	eax, eax
	repne scasb
	not	ecx
	sub	edi, ecx
	mov	esi, edi
	mov	edx, ecx
	mov	edi, ebx
	or	ecx, -1
	repne scasb
	mov	ecx, edx
	dec	edi
	shr	ecx, 2
	rep movsd
	mov	eax, DWORD PTR _size$24925[esp+12]
	mov	ecx, edx
	and	ecx, 3
	rep movsb
	add	DWORD PTR ?sMemTotal@CCorString@@0KA, eax ; CCorString::sMemTotal
$L24927:
	mov	edi, DWORD PTR [ebp]
	or	ecx, -1
	xor	eax, eax
	or	edx, -1
	repne scasb
	mov	edi, DWORD PTR ?sMemTotal@CCorString@@0KA ; CCorString::sMemTotal
	not	ecx
	dec	ecx
	sub	edx, ecx
	add	edi, edx
	mov	DWORD PTR ?sMemTotal@CCorString@@0KA, edi ; CCorString::sMemTotal
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [ebp]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
	mov	DWORD PTR [ebp], ebx
	pop	ebx
$L24933:
	pop	edi
	mov	eax, ebp
	pop	esi
	pop	ebp
	ret	4
??YCCorString@@QAEAAV0@ABV0@@Z ENDP			; CCorString::operator+=
_TEXT	ENDS
PUBLIC	??YCCorString@@QAEAAV0@PBD@Z			; CCorString::operator+=
; Function compile flags: /Ogty
;	COMDAT ??YCCorString@@QAEAAV0@PBD@Z
_TEXT	SEGMENT
_size$24965 = 8
_inStr$ = 8
??YCCorString@@QAEAAV0@PBD@Z PROC NEAR			; CCorString::operator+=, COMDAT
; _this$ = ecx

; 98   : 	inline CCorString& operator += (const char* inStr) { Cat((char*)inStr); return(*this); }

	push	ebx
	push	ebp
	push	esi
	mov	esi, DWORD PTR _inStr$[esp+8]
	test	esi, esi
	push	edi
	mov	ebp, ecx
	je	SHORT $L24962
	cmp	BYTE PTR [esi], 0
	jne	SHORT $L24962
	xor	esi, esi
$L24962:
	mov	edi, DWORD PTR [ebp]
	test	edi, edi
	jne	SHORT $L24963
	test	esi, esi
	mov	ebx, esi
	je	SHORT $L24956
	cmp	BYTE PTR [esi], 0
	jne	SHORT $L24956
	xor	ebx, ebx
$L24956:
	test	ebx, ebx
	mov	DWORD PTR [ebp], 0
	je	$L24973
	mov	edi, ebx
	or	ecx, -1
	xor	eax, eax
	repne scasb
	not	ecx
	dec	ecx
	mov	esi, ecx
	inc	esi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	ecx, eax
	call	DWORD PTR [edx]
	test	eax, eax
	mov	DWORD PTR [ebp], eax
	je	$L24973
	mov	ecx, ebx
	mov	edx, eax
$L24954:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	mov	BYTE PTR [edx], al
	inc	edx
	test	al, al
	jne	SHORT $L24954
	mov	eax, DWORD PTR ?sMemTotal@CCorString@@0KA ; CCorString::sMemTotal
	pop	edi
	add	eax, esi
	pop	esi
	mov	DWORD PTR ?sMemTotal@CCorString@@0KA, eax ; CCorString::sMemTotal
	mov	eax, ebp
	pop	ebp
	pop	ebx
	ret	4
$L24963:
	test	esi, esi
	je	$L24973
	or	ecx, -1
	xor	eax, eax
	repne scasb
	not	ecx
	dec	ecx
	mov	edi, esi
	mov	edx, ecx
	or	ecx, -1
	repne scasb
	not	ecx
	dec	ecx
	lea	edi, DWORD PTR [edx+ecx+1]
	mov	DWORD PTR _size$24965[esp+12], edi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	edi
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	ebx, eax
	test	ebx, ebx
	je	SHORT $L24967
	mov	ecx, DWORD PTR [ebp]
	mov	edx, ebx
$L24952:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	mov	BYTE PTR [edx], al
	inc	edx
	test	al, al
	jne	SHORT $L24952
	mov	edi, esi
	or	ecx, -1
	xor	eax, eax
	repne scasb
	not	ecx
	sub	edi, ecx
	mov	esi, edi
	mov	edx, ecx
	mov	edi, ebx
	or	ecx, -1
	repne scasb
	mov	ecx, edx
	dec	edi
	shr	ecx, 2
	rep movsd
	mov	eax, DWORD PTR _size$24965[esp+12]
	mov	ecx, edx
	and	ecx, 3
	rep movsb
	add	DWORD PTR ?sMemTotal@CCorString@@0KA, eax ; CCorString::sMemTotal
$L24967:
	mov	edi, DWORD PTR [ebp]
	or	ecx, -1
	xor	eax, eax
	or	edx, -1
	repne scasb
	mov	edi, DWORD PTR ?sMemTotal@CCorString@@0KA ; CCorString::sMemTotal
	not	ecx
	dec	ecx
	sub	edx, ecx
	add	edi, edx
	mov	DWORD PTR ?sMemTotal@CCorString@@0KA, edi ; CCorString::sMemTotal
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [ebp]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
	mov	DWORD PTR [ebp], ebx
$L24973:
	pop	edi
	mov	eax, ebp
	pop	esi
	pop	ebp
	pop	ebx
	ret	4
??YCCorString@@QAEAAV0@PBD@Z ENDP			; CCorString::operator+=
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
$T25084	DD	0ffffffffH
	DD	FLAT:$L24979
	DD	00H
	DD	FLAT:$L24978
$T25073	DD	019930520H
	DD	02H
	DD	FLAT:$T25084
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ??H@YA?AVCCorString@@ABV0@PBD@Z
_TEXT	SEGMENT
_inS1$ = 12
_inS2$ = 16
$T24980 = -16
_size$25024 = 16
___$ReturnUdt$ = 8
_r$ = 12
__$EHRec$ = -12
??H@YA?AVCCorString@@ABV0@PBD@Z PROC NEAR		; operator+, COMDAT

; 101  : 	inline friend CCorString operator + (const CCorString& inS1, const char* inS2) { CCorString r(inS1); r += inS2; return(r); }

	push	-1
	push	$L25083
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	mov	DWORD PTR $T24980[esp+16], 0
	mov	eax, DWORD PTR _inS1$[esp+12]
	push	ebp
	push	esi
	mov	esi, DWORD PTR [eax]
	push	edi
	test	esi, esi
	je	SHORT $L24999
	cmp	BYTE PTR [esi], 0
	jne	SHORT $L24999
	xor	esi, esi
$L24999:
	xor	ebp, ebp
	test	esi, esi
	mov	DWORD PTR _r$[esp+24], ebp
	je	SHORT $L25002
	mov	edi, esi
	or	ecx, -1
	xor	eax, eax
	repne scasb
	not	ecx
	dec	ecx
	mov	edi, ecx
	inc	edi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	edi
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	ebp, eax
	test	ebp, ebp
	mov	DWORD PTR _r$[esp+24], ebp
	je	SHORT $L25002
	mov	edx, ebp
	mov	eax, esi
	sub	edx, esi
$L24996:
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx+eax], cl
	inc	eax
	test	cl, cl
	jne	SHORT $L24996
	add	DWORD PTR ?sMemTotal@CCorString@@0KA, edi ; CCorString::sMemTotal
$L25002:
	mov	esi, DWORD PTR _inS2$[esp+24]
	mov	DWORD PTR __$EHRec$[esp+36], 1
	test	esi, esi
	je	SHORT $L25021
	cmp	BYTE PTR [esi], 0
	jne	SHORT $L25021
	xor	esi, esi
$L25021:
	test	ebp, ebp
	push	ebx
	jne	SHORT $L25022
	push	esi
	lea	ecx, DWORD PTR _r$[esp+32]
	call	?Set@CCorString@@QAEXPAD@Z		; CCorString::Set
	mov	ebp, DWORD PTR _r$[esp+28]
	jmp	$L25020
$L25022:
	test	esi, esi
	je	$L25020
	mov	edi, esi
	or	ecx, -1
	xor	eax, eax
	repne scasb
	not	ecx
	dec	ecx
	mov	edi, ebp
	mov	edx, ecx
	or	ecx, -1
	repne scasb
	not	ecx
	dec	ecx
	lea	edi, DWORD PTR [edx+ecx+1]
	mov	DWORD PTR _size$25024[esp+28], edi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	edi
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	ebx, eax
	test	ebx, ebx
	je	SHORT $L25026
	mov	edx, ebx
	mov	eax, ebp
	sub	edx, ebp
$L25019:
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx+eax], cl
	inc	eax
	test	cl, cl
	jne	SHORT $L25019
	mov	edi, esi
	or	ecx, -1
	xor	eax, eax
	repne scasb
	not	ecx
	sub	edi, ecx
	mov	esi, edi
	mov	edx, ecx
	mov	edi, ebx
	or	ecx, -1
	repne scasb
	mov	ecx, edx
	dec	edi
	shr	ecx, 2
	rep movsd
	mov	eax, DWORD PTR _size$25024[esp+28]
	mov	ecx, edx
	and	ecx, 3
	rep movsb
	add	DWORD PTR ?sMemTotal@CCorString@@0KA, eax ; CCorString::sMemTotal
$L25026:
	mov	edi, ebp
	or	ecx, -1
	xor	eax, eax
	mov	esi, DWORD PTR ?sMemTotal@CCorString@@0KA ; CCorString::sMemTotal
	repne scasb
	not	ecx
	dec	ecx
	or	edx, -1
	sub	edx, ecx
	add	esi, edx
	mov	DWORD PTR ?sMemTotal@CCorString@@0KA, esi ; CCorString::sMemTotal
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	ebp
	mov	ecx, eax
	call	DWORD PTR [edx+8]
	mov	ebp, ebx
	mov	DWORD PTR _r$[esp+28], ebp
$L25020:
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+28]
	mov	ebx, ebp
	test	ebp, ebp
	mov	DWORD PTR [esi], 0
	je	SHORT $L25043
	cmp	BYTE PTR [ebp], 0
	jne	SHORT $L25043
	xor	ebx, ebx
$L25043:
	test	ebx, ebx
	mov	DWORD PTR [esi], 0
	je	SHORT $L25046
	mov	edi, ebx
	or	ecx, -1
	xor	eax, eax
	repne scasb
	not	ecx
	dec	ecx
	mov	esi, ecx
	inc	esi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	ecx, DWORD PTR ___$ReturnUdt$[esp+28]
	test	eax, eax
	mov	DWORD PTR [ecx], eax
	je	SHORT $L25082
	mov	edx, ebx
$L25049:
	mov	cl, BYTE PTR [edx]
	inc	edx
	mov	BYTE PTR [eax], cl
	inc	eax
	test	cl, cl
	jne	SHORT $L25049
	add	DWORD PTR ?sMemTotal@CCorString@@0KA, esi ; CCorString::sMemTotal
$L25082:
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+28]
$L25046:
	mov	DWORD PTR $T24980[esp+32], 1
	test	ebp, ebp
	mov	BYTE PTR __$EHRec$[esp+40], 0
	pop	ebx
	je	SHORT $L25078
	mov	edi, ebp
	or	ecx, -1
	xor	eax, eax
	or	edx, -1
	repne scasb
	mov	edi, DWORD PTR ?sMemTotal@CCorString@@0KA ; CCorString::sMemTotal
	not	ecx
	dec	ecx
	sub	edx, ecx
	add	edi, edx
	mov	DWORD PTR ?sMemTotal@CCorString@@0KA, edi ; CCorString::sMemTotal
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	ebp
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L25078:
	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L24978:
	lea	ecx, DWORD PTR _r$[ebp-4]
	jmp	??1CCorString@@QAE@XZ			; CCorString::~CCorString
$L24979:
	mov	eax, DWORD PTR $T24980[ebp]
	and	eax, 1
	test	eax, eax
	je	$L24981
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1CCorString@@QAE@XZ			; CCorString::~CCorString
$L24981:
	ret	0
$L25083:
	mov	eax, OFFSET FLAT:$T25073
	jmp	___CxxFrameHandler
text$x	ENDS
??H@YA?AVCCorString@@ABV0@PBD@Z ENDP			; operator+
PUBLIC	??8CCorString@@QAE_NABV0@@Z			; CCorString::operator==
; Function compile flags: /Ogty
;	COMDAT ??8CCorString@@QAE_NABV0@@Z
_TEXT	SEGMENT
_inS$ = 8
??8CCorString@@QAE_NABV0@@Z PROC NEAR			; CCorString::operator==, COMDAT
; _this$ = ecx

; 104  : 	inline bool operator == (const CCorString& inS) { return(strcmp(Str(), inS.Str())==0); }

	mov	eax, DWORD PTR _inS$[esp-4]
	push	ebx
	push	esi
	mov	eax, DWORD PTR [eax]
	test	eax, eax
	mov	esi, eax
	jne	SHORT $L25091
	mov	esi, OFFSET FLAT:??_C@_00A@?$AA@	; `string'
$L25091:
	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	jne	SHORT $L25100
	mov	eax, OFFSET FLAT:??_C@_00A@?$AA@	; `string'
$L25100:
	mov	dl, BYTE PTR [eax]
	mov	bl, BYTE PTR [esi]
	mov	cl, dl
	cmp	dl, bl
	jne	SHORT $L25101
	test	cl, cl
	je	SHORT $L25102
	mov	dl, BYTE PTR [eax+1]
	mov	bl, BYTE PTR [esi+1]
	mov	cl, dl
	cmp	dl, bl
	jne	SHORT $L25101
	add	eax, 2
	add	esi, 2
	test	cl, cl
	jne	SHORT $L25100
$L25102:
	xor	eax, eax
	xor	ecx, ecx
	test	eax, eax
	sete	cl
	pop	esi
	mov	al, cl
	pop	ebx
	ret	4
$L25101:
	sbb	eax, eax
	pop	esi
	sbb	eax, -1
	xor	ecx, ecx
	test	eax, eax
	sete	cl
	mov	al, cl
	pop	ebx
	ret	4
??8CCorString@@QAE_NABV0@@Z ENDP			; CCorString::operator==
_TEXT	ENDS
PUBLIC	??9CCorString@@QAE_NABV0@@Z			; CCorString::operator!=
; Function compile flags: /Ogty
;	COMDAT ??9CCorString@@QAE_NABV0@@Z
_TEXT	SEGMENT
_inS$ = 8
??9CCorString@@QAE_NABV0@@Z PROC NEAR			; CCorString::operator!=, COMDAT
; _this$ = ecx

; 105  : 	inline bool operator != (const CCorString& inS) { return(strcmp(Str(), inS.Str())!=0); }

	mov	eax, DWORD PTR _inS$[esp-4]
	push	ebx
	push	esi
	mov	eax, DWORD PTR [eax]
	test	eax, eax
	mov	esi, eax
	jne	SHORT $L25108
	mov	esi, OFFSET FLAT:??_C@_00A@?$AA@	; `string'
$L25108:
	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	jne	SHORT $L25117
	mov	eax, OFFSET FLAT:??_C@_00A@?$AA@	; `string'
$L25117:
	mov	dl, BYTE PTR [eax]
	mov	bl, BYTE PTR [esi]
	mov	cl, dl
	cmp	dl, bl
	jne	SHORT $L25118
	test	cl, cl
	je	SHORT $L25119
	mov	dl, BYTE PTR [eax+1]
	mov	bl, BYTE PTR [esi+1]
	mov	cl, dl
	cmp	dl, bl
	jne	SHORT $L25118
	add	eax, 2
	add	esi, 2
	test	cl, cl
	jne	SHORT $L25117
$L25119:
	xor	eax, eax
	xor	ecx, ecx
	test	eax, eax
	setne	cl
	pop	esi
	mov	al, cl
	pop	ebx
	ret	4
$L25118:
	sbb	eax, eax
	pop	esi
	sbb	eax, -1
	xor	ecx, ecx
	test	eax, eax
	setne	cl
	mov	al, cl
	pop	ebx
	ret	4
??9CCorString@@QAE_NABV0@@Z ENDP			; CCorString::operator!=
_TEXT	ENDS
PUBLIC	??ECCorString@@QAEXXZ				; CCorString::operator++
EXTRN	__imp___strupr:NEAR
; Function compile flags: /Ogty
;	COMDAT ??ECCorString@@QAEXXZ
_TEXT	SEGMENT
??ECCorString@@QAEXXZ PROC NEAR				; CCorString::operator++, COMDAT
; _this$ = ecx

; 107  : 	inline void operator ++ () { if (mStr) _strupr(mStr); }

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $L4745
	push	eax
	call	DWORD PTR __imp___strupr
	pop	ecx
$L4745:
	ret	0
??ECCorString@@QAEXXZ ENDP				; CCorString::operator++
_TEXT	ENDS
PUBLIC	??ECCorString@@QAEXH@Z				; CCorString::operator++
; Function compile flags: /Ogty
;	COMDAT ??ECCorString@@QAEXH@Z
_TEXT	SEGMENT
??ECCorString@@QAEXH@Z PROC NEAR			; CCorString::operator++, COMDAT
; _this$ = ecx

; 108  : 	inline void operator ++ (int) { if (mStr) _strupr(mStr); }

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $L4748
	push	eax
	call	DWORD PTR __imp___strupr
	pop	ecx
$L4748:
	ret	4
??ECCorString@@QAEXH@Z ENDP				; CCorString::operator++
_TEXT	ENDS
PUBLIC	??FCCorString@@QAEXXZ				; CCorString::operator--
EXTRN	__imp___strlwr:NEAR
; Function compile flags: /Ogty
;	COMDAT ??FCCorString@@QAEXXZ
_TEXT	SEGMENT
??FCCorString@@QAEXXZ PROC NEAR				; CCorString::operator--, COMDAT
; _this$ = ecx

; 109  : 	inline void operator -- () { if (mStr) _strlwr(mStr); }

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $L4751
	push	eax
	call	DWORD PTR __imp___strlwr
	pop	ecx
$L4751:
	ret	0
??FCCorString@@QAEXXZ ENDP				; CCorString::operator--
_TEXT	ENDS
PUBLIC	??FCCorString@@QAEXH@Z				; CCorString::operator--
; Function compile flags: /Ogty
;	COMDAT ??FCCorString@@QAEXH@Z
_TEXT	SEGMENT
??FCCorString@@QAEXH@Z PROC NEAR			; CCorString::operator--, COMDAT
; _this$ = ecx

; 110  : 	inline void operator -- (int) { if (mStr) _strlwr(mStr); }

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $L4754
	push	eax
	call	DWORD PTR __imp___strlwr
	pop	ecx
$L4754:
	ret	4
??FCCorString@@QAEXH@Z ENDP				; CCorString::operator--
_TEXT	ENDS
PUBLIC	??HCCorString@@QAE?AV0@XZ			; CCorString::operator+
;	COMDAT xdata$x
xdata$x	SEGMENT
$T25219	DD	0ffffffffH
	DD	FLAT:$L25137
	DD	00H
	DD	FLAT:$L25136
$T25211	DD	019930520H
	DD	02H
	DD	FLAT:$T25219
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ??HCCorString@@QAE?AV0@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8
_r$ = -20
$T25138 = -16
__$EHRec$ = -12
??HCCorString@@QAE?AV0@XZ PROC NEAR			; CCorString::operator+, COMDAT
; _this$ = ecx

; 111  : 	inline CCorString operator + () { CCorString r(*this); ++r; return(r); }

	push	-1
	push	$L25218
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 8
	push	ebx
	push	ebp
	mov	DWORD PTR $T25138[esp+28], 0
	mov	ebp, DWORD PTR [ecx]
	push	esi
	push	edi
	test	ebp, ebp
	je	SHORT $L25156
	cmp	BYTE PTR [ebp], 0
	jne	SHORT $L25156
	xor	ebp, ebp
$L25156:
	xor	esi, esi
	test	ebp, ebp
	mov	DWORD PTR _r$[esp+36], esi
	je	SHORT $L25159
	mov	edi, ebp
	or	ecx, -1
	xor	eax, eax
	repne scasb
	not	ecx
	dec	ecx
	mov	edi, ecx
	inc	edi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	edi
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	esi, eax
	test	esi, esi
	mov	DWORD PTR _r$[esp+36], esi
	je	SHORT $L25159
	mov	edx, esi
	mov	eax, ebp
	sub	edx, ebp
$L25161:
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx+eax], cl
	inc	eax
	test	cl, cl
	jne	SHORT $L25161
	add	DWORD PTR ?sMemTotal@CCorString@@0KA, edi ; CCorString::sMemTotal
$L25159:
	test	esi, esi
	mov	DWORD PTR __$EHRec$[esp+44], 1
	je	SHORT $L25164
	push	esi
	call	DWORD PTR __imp___strupr
	add	esp, 4
$L25164:
	mov	ebx, DWORD PTR ___$ReturnUdt$[esp+32]
	mov	ebp, esi
	test	esi, esi
	mov	DWORD PTR [ebx], 0
	je	SHORT $L25182
	cmp	BYTE PTR [esi], 0
	jne	SHORT $L25182
	xor	ebp, ebp
$L25182:
	test	ebp, ebp
	mov	DWORD PTR [ebx], 0
	je	SHORT $L25185
	mov	edi, ebp
	or	ecx, -1
	xor	eax, eax
	repne scasb
	not	ecx
	dec	ecx
	mov	edi, ecx
	inc	edi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	edi
	mov	ecx, eax
	call	DWORD PTR [edx]
	test	eax, eax
	mov	DWORD PTR [ebx], eax
	je	SHORT $L25185
	mov	edx, ebp
$L25187:
	mov	cl, BYTE PTR [edx]
	inc	edx
	mov	BYTE PTR [eax], cl
	inc	eax
	test	cl, cl
	jne	SHORT $L25187
	add	DWORD PTR ?sMemTotal@CCorString@@0KA, edi ; CCorString::sMemTotal
$L25185:
	mov	DWORD PTR $T25138[esp+36], 1
	test	esi, esi
	mov	BYTE PTR __$EHRec$[esp+44], 0
	je	SHORT $L25215
	mov	edi, esi
	or	ecx, -1
	xor	eax, eax
	mov	edx, DWORD PTR ?sMemTotal@CCorString@@0KA ; CCorString::sMemTotal
	repne scasb
	not	ecx
	dec	ecx
	or	eax, -1
	sub	eax, ecx
	add	edx, eax
	mov	DWORD PTR ?sMemTotal@CCorString@@0KA, edx ; CCorString::sMemTotal
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L25215:
	mov	ecx, DWORD PTR __$EHRec$[esp+36]
	pop	edi
	pop	esi
	mov	eax, ebx
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 20					; 00000014H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L25136:
	lea	ecx, DWORD PTR _r$[ebp]
	jmp	??1CCorString@@QAE@XZ			; CCorString::~CCorString
$L25137:
	mov	eax, DWORD PTR $T25138[ebp]
	and	eax, 1
	test	eax, eax
	je	$L25139
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1CCorString@@QAE@XZ			; CCorString::~CCorString
$L25139:
	ret	0
$L25218:
	mov	eax, OFFSET FLAT:$T25211
	jmp	___CxxFrameHandler
text$x	ENDS
??HCCorString@@QAE?AV0@XZ ENDP				; CCorString::operator+
PUBLIC	??GCCorString@@QAE?AV0@XZ			; CCorString::operator-
;	COMDAT xdata$x
xdata$x	SEGMENT
$T25308	DD	0ffffffffH
	DD	FLAT:$L25226
	DD	00H
	DD	FLAT:$L25225
$T25300	DD	019930520H
	DD	02H
	DD	FLAT:$T25308
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ??GCCorString@@QAE?AV0@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8
_r$ = -20
$T25227 = -16
__$EHRec$ = -12
??GCCorString@@QAE?AV0@XZ PROC NEAR			; CCorString::operator-, COMDAT
; _this$ = ecx

; 112  : 	inline CCorString operator - () { CCorString r(*this); --r; return(r); }

	push	-1
	push	$L25307
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 8
	push	ebx
	push	ebp
	mov	DWORD PTR $T25227[esp+28], 0
	mov	ebp, DWORD PTR [ecx]
	push	esi
	push	edi
	test	ebp, ebp
	je	SHORT $L25245
	cmp	BYTE PTR [ebp], 0
	jne	SHORT $L25245
	xor	ebp, ebp
$L25245:
	xor	esi, esi
	test	ebp, ebp
	mov	DWORD PTR _r$[esp+36], esi
	je	SHORT $L25248
	mov	edi, ebp
	or	ecx, -1
	xor	eax, eax
	repne scasb
	not	ecx
	dec	ecx
	mov	edi, ecx
	inc	edi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	edi
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	esi, eax
	test	esi, esi
	mov	DWORD PTR _r$[esp+36], esi
	je	SHORT $L25248
	mov	edx, esi
	mov	eax, ebp
	sub	edx, ebp
$L25250:
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx+eax], cl
	inc	eax
	test	cl, cl
	jne	SHORT $L25250
	add	DWORD PTR ?sMemTotal@CCorString@@0KA, edi ; CCorString::sMemTotal
$L25248:
	test	esi, esi
	mov	DWORD PTR __$EHRec$[esp+44], 1
	je	SHORT $L25253
	push	esi
	call	DWORD PTR __imp___strlwr
	add	esp, 4
$L25253:
	mov	ebx, DWORD PTR ___$ReturnUdt$[esp+32]
	mov	ebp, esi
	test	esi, esi
	mov	DWORD PTR [ebx], 0
	je	SHORT $L25271
	cmp	BYTE PTR [esi], 0
	jne	SHORT $L25271
	xor	ebp, ebp
$L25271:
	test	ebp, ebp
	mov	DWORD PTR [ebx], 0
	je	SHORT $L25274
	mov	edi, ebp
	or	ecx, -1
	xor	eax, eax
	repne scasb
	not	ecx
	dec	ecx
	mov	edi, ecx
	inc	edi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	edi
	mov	ecx, eax
	call	DWORD PTR [edx]
	test	eax, eax
	mov	DWORD PTR [ebx], eax
	je	SHORT $L25274
	mov	edx, ebp
$L25276:
	mov	cl, BYTE PTR [edx]
	inc	edx
	mov	BYTE PTR [eax], cl
	inc	eax
	test	cl, cl
	jne	SHORT $L25276
	add	DWORD PTR ?sMemTotal@CCorString@@0KA, edi ; CCorString::sMemTotal
$L25274:
	mov	DWORD PTR $T25227[esp+36], 1
	test	esi, esi
	mov	BYTE PTR __$EHRec$[esp+44], 0
	je	SHORT $L25304
	mov	edi, esi
	or	ecx, -1
	xor	eax, eax
	mov	edx, DWORD PTR ?sMemTotal@CCorString@@0KA ; CCorString::sMemTotal
	repne scasb
	not	ecx
	dec	ecx
	or	eax, -1
	sub	eax, ecx
	add	edx, eax
	mov	DWORD PTR ?sMemTotal@CCorString@@0KA, edx ; CCorString::sMemTotal
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L25304:
	mov	ecx, DWORD PTR __$EHRec$[esp+36]
	pop	edi
	pop	esi
	mov	eax, ebx
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 20					; 00000014H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L25225:
	lea	ecx, DWORD PTR _r$[ebp]
	jmp	??1CCorString@@QAE@XZ			; CCorString::~CCorString
$L25226:
	mov	eax, DWORD PTR $T25227[ebp]
	and	eax, 1
	test	eax, eax
	je	$L25228
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1CCorString@@QAE@XZ			; CCorString::~CCorString
$L25228:
	ret	0
$L25307:
	mov	eax, OFFSET FLAT:$T25300
	jmp	___CxxFrameHandler
text$x	ENDS
??GCCorString@@QAE?AV0@XZ ENDP				; CCorString::operator-
PUBLIC	??DCCorString@@QBEPADXZ				; CCorString::operator*
; Function compile flags: /Ogty
;	COMDAT ??DCCorString@@QBEPADXZ
_TEXT	SEGMENT
??DCCorString@@QBEPADXZ PROC NEAR			; CCorString::operator*, COMDAT
; _this$ = ecx

; 114  : 	inline char* operator * () const { return(Str()); }

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	jne	SHORT $L25315
	mov	eax, OFFSET FLAT:??_C@_00A@?$AA@	; `string'
$L25315:
	ret	0
??DCCorString@@QBEPADXZ ENDP				; CCorString::operator*
_TEXT	ENDS
PUBLIC	?Len@CCorString@@QBEKXZ				; CCorString::Len
; Function compile flags: /Ogty
;	COMDAT ?Len@CCorString@@QBEKXZ
_TEXT	SEGMENT
?Len@CCorString@@QBEKXZ PROC NEAR			; CCorString::Len, COMDAT
; _this$ = ecx

; 116  : 	inline unsigned long Len() const { if (!mStr) return(0); return(strlen(mStr)); }

	push	edi
	mov	edi, DWORD PTR [ecx]
	xor	eax, eax
	test	edi, edi
	je	SHORT $L4766
	or	ecx, -1
	repne scasb
	not	ecx
	dec	ecx
	mov	eax, ecx
$L4766:
	pop	edi
	ret	0
?Len@CCorString@@QBEKXZ ENDP				; CCorString::Len
_TEXT	ENDS
PUBLIC	?Str@CCorString@@QBEPADXZ			; CCorString::Str
; Function compile flags: /Ogty
;	COMDAT ?Str@CCorString@@QBEPADXZ
_TEXT	SEGMENT
?Str@CCorString@@QBEPADXZ PROC NEAR			; CCorString::Str, COMDAT
; _this$ = ecx

; 117  : 	inline char* Str() const { if (mStr) return(mStr); return(""); }

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	jne	SHORT $L4769
	mov	eax, OFFSET FLAT:??_C@_00A@?$AA@	; `string'
$L4769:
	ret	0
?Str@CCorString@@QBEPADXZ ENDP				; CCorString::Str
_TEXT	ENDS
PUBLIC	?GetStaticMemSize@CCorString@@SAKXZ		; CCorString::GetStaticMemSize
; Function compile flags: /Ogty
;	COMDAT ?GetStaticMemSize@CCorString@@SAKXZ
_TEXT	SEGMENT
?GetStaticMemSize@CCorString@@SAKXZ PROC NEAR		; CCorString::GetStaticMemSize, COMDAT

; 118  : 	inline static unsigned long GetStaticMemSize() { return(sMemTotal); }

	mov	eax, DWORD PTR ?sMemTotal@CCorString@@0KA ; CCorString::sMemTotal
	ret	0
?GetStaticMemSize@CCorString@@SAKXZ ENDP		; CCorString::GetStaticMemSize
_TEXT	ENDS
PUBLIC	?EvaluateTriVerts@OMacActor@@QAE_NKMPAVVVec3@@@Z ; OMacActor::EvaluateTriVerts
; Function compile flags: /Ogty
; File C:\duke4\Cannibal\MacMain.cpp
;	COMDAT ?EvaluateTriVerts@OMacActor@@QAE_NKMPAVVVec3@@@Z
_TEXT	SEGMENT
$T25546 = -92
$T25571 = -124
_inTriIndex$ = 8
_inVertAlpha$ = 12
_outVerts$ = 16
_this$ = -112
_triRelay$ = -120
_gVZero$ = -132
_evalVerts$ = -128
_iv$12828 = -80
_boneZero$12829 = -16
_i$12832 = -132
$T25332 = -76
$T25333 = -104
$T25334 = -12
$T25335 = -92
$T25336 = -104
$T25337 = -12
?EvaluateTriVerts@OMacActor@@QAE_NKMPAVVVec3@@@Z PROC NEAR ; OMacActor::EvaluateTriVerts, COMDAT
; _this$ = ecx

; 937  : {

	sub	esp, 132				; 00000084H

; 938  : 	if (!outVerts || !mGeometry)

	mov	eax, DWORD PTR _outVerts$[esp+128]
	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx
	test	eax, eax
	mov	DWORD PTR _this$[esp+144], esi
	je	$L12800
	mov	ebp, DWORD PTR [esi+140]
	test	ebp, ebp
	je	$L12800

; 940  : 	if (inTriIndex > mGeometry->m_Tris.GetCount())

	mov	ebx, DWORD PTR _inTriIndex$[esp+140]
	mov	eax, DWORD PTR [ebp+108]
	cmp	ebx, eax

; 941  : 		return(0);

	ja	$L12800

; 942  : 
; 943  : 	// build up a relay along the same lines as the LOD does, but specifically for the triangle
; 944  : 	NDword numVerts = 3;
; 945  : 	NWord triRelay[3];
; 946  : 	CCpjGeoVert* gVZero = &mGeometry->m_Verts[0];

	mov	eax, DWORD PTR [ebp+72]
	push	edi
	lea	ebx, DWORD PTR [ebx+ebx*2]

; 947  : 	for (NDword iRelay=0;iRelay<3;iRelay++)

	xor	edi, edi
	mov	DWORD PTR _gVZero$[esp+148], eax
	shl	ebx, 2
$L12806:

; 948  : 		triRelay[iRelay] = mGeometry->m_Tris[inTriIndex].edgeRing[iRelay]->tailVertex - gVZero;

	mov	ecx, DWORD PTR [ebp+104]
	mov	eax, 715827883				; 2aaaaaabH
	mov	edx, DWORD PTR [ebx+ecx]
	add	ebx, 4
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR _gVZero$[esp+148]
	sub	ecx, edx
	imul	ecx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	edx, eax
	mov	WORD PTR _triRelay$[esp+edi*2+148], dx
	inc	edi
	cmp	edi, 3
	jb	SHORT $L12806

; 949  : 	
; 950  : 	// clamp the vertex alpha
; 951  : 	if (inVertAlpha < 0.f) inVertAlpha = 0.f;

	fld	DWORD PTR _inVertAlpha$[esp+144]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L12809
	mov	DWORD PTR _inVertAlpha$[esp+144], 0

; 952  : 	if (inVertAlpha > 1.f) inVertAlpha = 1.f;

	jmp	SHORT $L12810
$L12809:
	fld	DWORD PTR _inVertAlpha$[esp+144]
	fcomp	DWORD PTR __real@3f800000
	fnstsw	ax
	and	eax, 16640				; 00004100H
	jne	SHORT $L12810
	mov	DWORD PTR _inVertAlpha$[esp+144], 1065353216 ; 3f800000H
$L12810:

; 953  : 
; 954  : 	// set our working vertices as our temporary buffer, unless no alpha is involved
; 955  : 	VVec3* evalVerts = mac_tempVerts;
; 956  : 	if (inVertAlpha >= (1.f - M_EPSILON))

	fld	DWORD PTR _inVertAlpha$[esp+144]
	fcomp	DWORD PTR __real@3f7fbe77
	mov	ebp, OFFSET FLAT:_mac_tempVerts
	mov	DWORD PTR _evalVerts$[esp+148], ebp
	fnstsw	ax
	and	eax, 256				; 00000100H
	jne	SHORT $L12812

; 957  : 		evalVerts = outVerts;

	mov	ecx, DWORD PTR _outVerts$[esp+144]
	mov	DWORD PTR _evalVerts$[esp+148], ecx
	mov	ebp, ecx
$L12812:

; 958  : 
; 959  : 	// the first sequence is the only one that's allowed to be frame-based
; 960  : 	NBool frameBased = 0;
; 961  : 	if (!mActorChannels[0] || !mActorChannels[0]->EvalVerts(this, numVerts, triRelay, evalVerts))

	mov	edx, DWORD PTR [esi+288]
	mov	ecx, DWORD PTR [edx]
	test	ecx, ecx
	je	SHORT $L12815
	mov	eax, DWORD PTR [ecx]
	lea	edx, DWORD PTR _triRelay$[esp+148]
	push	ebp
	push	edx
	push	3
	push	esi
	call	DWORD PTR [eax+52]
	test	al, al
	jne	$L12851
$L12815:

; 962  : 	{
; 963  : 		if (mSkeleton)

	mov	eax, DWORD PTR [esi+144]
	test	eax, eax
	je	$L12816

; 964  : 		{
; 965  : 			if (bBonesDirty)		// JEP Added dirty bone optimization

	mov	al, BYTE PTR [esi+268]
	test	al, al
	je	SHORT $L12817

; 966  : 			{
; 967  : 				// if we have a skeleton and verts weren't modified by the primary channel
; 968  : 				// (i.e. if a frame-based sequence wasn't used), then we can process all the channels
; 969  : 				// for bone-based animation / alteration			
; 970  : 				for (NDword i=0;i<mActorChannels.GetCount();i++)

	mov	eax, DWORD PTR [esi+292]
	xor	edi, edi
	test	eax, eax
	jbe	SHORT $L12821
$L12819:

; 971  : 				{
; 972  : 					if (mActorChannels[i])

	mov	eax, DWORD PTR [esi+288]
	mov	ecx, DWORD PTR [eax+edi*4]
	test	ecx, ecx
	je	SHORT $L12820

; 973  : 						mActorChannels[i]->EvalBones(this);

	mov	edx, DWORD PTR [ecx]
	push	esi
	call	DWORD PTR [edx+48]
$L12820:
	mov	eax, DWORD PTR [esi+292]
	inc	edi
	cmp	edi, eax
	jb	SHORT $L12819
$L12821:

; 974  : 				}
; 975  : 
; 976  : 				bBonesDirty = false;

	mov	BYTE PTR [esi+268], 0
$L12817:

; 977  : 			}
; 978  : 
; 979  : 			// and after all that's done, we evaluate our vertex positions
; 980  : 			CCpjSklWeight* w;
; 981  : 			CMacBone* b;
; 982  : 			VVec3 nv;
; 983  : 			NDword wcount;
; 984  : 			VVec3* ov = evalVerts;
; 985  : 			CCpjSklVert* iv = &mSkeleton->m_Verts[0];

	mov	eax, DWORD PTR [esi+144]
	lea	edi, DWORD PTR [ebp+8]

; 986  : 			CCpjSklBone* boneZero = &mSkeleton->m_Bones[0];

	mov	edx, DWORD PTR [eax+72]
	mov	ecx, DWORD PTR [eax+88]
	mov	DWORD PTR _boneZero$12829[esp+148], edx

; 987  : 
; 988  : 			CCpjSklVert* xv;
; 989  : 			NDword count = numVerts;
; 990  : 			for (NDword i=0; i<count; i++,ov++)

	xor	edx, edx
	mov	DWORD PTR _iv$12828[esp+148], ecx
	mov	DWORD PTR _i$12832[esp+148], edx
$L12833:

; 991  : 			{
; 992  : 				*ov = VVec3(0,0,0);
; 993  : 				xv = &iv[triRelay[i]];

	mov	ecx, DWORD PTR _iv$12828[esp+148]
	xor	eax, eax
	mov	DWORD PTR [edi-8], eax
	mov	DWORD PTR [edi-4], eax
	mov	DWORD PTR [edi], eax
	mov	ax, WORD PTR _triRelay$[esp+edx*2+148]
	shl	eax, 4
	add	eax, ecx

; 994  : 				wcount = xv->weights.GetCount();

	mov	ecx, DWORD PTR [eax+4]

; 995  : 				w = &xv->weights[0];

	mov	ebx, DWORD PTR [eax]

; 996  : 				for (NDword j=0;j<wcount;j++,w++)

	test	ecx, ecx
	jbe	$L12834
	lea	ebp, DWORD PTR [ebx+16]
	mov	DWORD PTR -108+[esp+148], ecx
$L25645:

; 997  : 				{
; 998  : 					b = &mActorBones[w->bone - boneZero];

	mov	ecx, DWORD PTR [ebx]
	mov	edx, DWORD PTR _boneZero$12829[esp+148]
	sub	ecx, edx
	mov	eax, 1808407283				; 6bca1af3H
	imul	ecx
	sar	edx, 5
	mov	eax, edx

; 999  : 					*ov += (w->offsetPos << b->GetCoords(true)) * w->factor;

	push	1
	shr	eax, 31					; 0000001fH
	add	edx, eax
	lea	eax, DWORD PTR [edx*8]
	sub	eax, edx
	mov	edx, DWORD PTR [esi+272]
	lea	ecx, DWORD PTR [eax+eax*4]
	lea	esi, DWORD PTR [edx+ecx*4]
	mov	ecx, esi
	call	?ValidateAbs@CMacBone@@IAEX_N@Z		; CMacBone::ValidateAbs
	mov	eax, DWORD PTR [esi+60]
	mov	ecx, DWORD PTR [esi+64]
	mov	edx, DWORD PTR [esi+68]
	mov	DWORD PTR $T25332[esp+148], eax
	mov	eax, DWORD PTR [esi+72]
	mov	DWORD PTR $T25332[esp+152], ecx
	mov	ecx, DWORD PTR [esi+76]
	mov	DWORD PTR $T25332[esp+160], eax
	mov	eax, DWORD PTR [esi+84]
	mov	DWORD PTR $T25332[esp+156], edx
	mov	edx, DWORD PTR [esi+80]
	mov	DWORD PTR $T25332[esp+164], ecx
	mov	ecx, DWORD PTR [esi+88]
	mov	DWORD PTR $T25332[esp+172], eax
	mov	eax, DWORD PTR [esi+96]
	mov	DWORD PTR $T25332[esp+168], edx
	mov	edx, DWORD PTR [esi+92]
	mov	DWORD PTR $T25332[esp+176], ecx
	mov	ecx, DWORD PTR [esi+100]
	mov	DWORD PTR $T25332[esp+184], eax
	mov	eax, DWORD PTR [esi+108]
	mov	DWORD PTR $T25332[esp+180], edx
	mov	edx, DWORD PTR [esi+104]
	mov	DWORD PTR $T25332[esp+188], ecx
	mov	ecx, DWORD PTR [esi+112]
	mov	DWORD PTR $T25332[esp+196], eax
	fld	DWORD PTR $T25332[esp+196]
	fmul	DWORD PTR [ebp-8]
	mov	DWORD PTR $T25332[esp+192], edx
	mov	edx, DWORD PTR [esi+116]
	mov	DWORD PTR $T25332[esp+200], ecx
	mov	DWORD PTR $T25332[esp+204], edx
	fld	DWORD PTR $T25332[esp+200]
	fmul	DWORD PTR [ebp-4]
	fld	DWORD PTR $T25332[esp+204]
	fmul	DWORD PTR [ebp]
	fld	DWORD PTR $T25332[esp+172]
	fmul	ST(0), ST(1)
	fld	DWORD PTR $T25332[esp+160]
	fmul	ST(0), ST(3)
	faddp	ST(1), ST(0)
	fld	ST(3)
	fmul	DWORD PTR $T25332[esp+148]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR $T25546[esp+148]
	fld	DWORD PTR $T25332[esp+176]
	fmul	ST(0), ST(1)
	fld	DWORD PTR $T25332[esp+164]
	fmul	ST(0), ST(3)
	faddp	ST(1), ST(0)
	fld	DWORD PTR $T25332[esp+152]
	fmul	ST(0), ST(4)
	faddp	ST(1), ST(0)
	fstp	DWORD PTR $T25546[esp+152]
	fld	DWORD PTR $T25332[esp+180]
	fmul	ST(0), ST(1)
	fld	DWORD PTR $T25332[esp+168]
	fmul	ST(0), ST(3)
	mov	eax, DWORD PTR [ebp-12]
	mov	esi, DWORD PTR _this$[esp+148]
	mov	DWORD PTR $T25571[esp+148], eax
	mov	eax, DWORD PTR -108+[esp+148]
	faddp	ST(1), ST(0)
	fld	DWORD PTR $T25332[esp+156]
	fmul	ST(0), ST(4)
	add	ebx, 20					; 00000014H
	add	ebp, 20					; 00000014H
	dec	eax
	faddp	ST(1), ST(0)
	mov	DWORD PTR -108+[esp+148], eax
	fstp	ST(3)
	fstp	ST(0)
	fstp	ST(0)
	fld	DWORD PTR $T25332[esp+184]
	fadd	DWORD PTR $T25546[esp+148]
	fld	DWORD PTR $T25332[esp+188]
	fadd	DWORD PTR $T25546[esp+152]
	fstp	DWORD PTR $T25333[esp+152]
	fld	DWORD PTR $T25332[esp+192]
	fadd	ST(0), ST(2)
	fstp	DWORD PTR $T25333[esp+156]
	fmul	DWORD PTR $T25571[esp+148]
	fstp	ST(1)
	fld	DWORD PTR $T25333[esp+152]
	fmul	DWORD PTR $T25571[esp+148]
	fld	DWORD PTR $T25333[esp+156]
	fmul	DWORD PTR $T25571[esp+148]
	fstp	DWORD PTR $T25334[esp+156]
	fxch	ST(1)
	fadd	DWORD PTR [edi-8]
	fstp	DWORD PTR [edi-8]
	fadd	DWORD PTR [edi-4]
	fstp	DWORD PTR [edi-4]
	fld	DWORD PTR $T25334[esp+156]
	fadd	DWORD PTR [edi]
	fstp	DWORD PTR [edi]
	jne	$L25645
	mov	edx, DWORD PTR _i$12832[esp+148]
	mov	ebp, DWORD PTR _evalVerts$[esp+148]
$L12834:
	inc	edx
	add	edi, 12					; 0000000cH
	cmp	edx, 3
	mov	DWORD PTR _i$12832[esp+148], edx
	jb	$L12833

; 1000 : 				}
; 1001 : 			}
; 1002 : 		}
; 1003 : 		else

	jmp	SHORT $L12851
$L12816:

; 1004 : 		{
; 1005 : 			// if we don't have a skeleton at all, and we didn't have vertex modification,
; 1006 : 			// then we'll need some kind of data in here, so use the reference positions
; 1007 : 			NDword i;
; 1008 : 			VVec3* ov;
; 1009 : 			CCpjGeoVert* iv;
; 1010 : 			NDword count = numVerts;
; 1011 : 			for (i=0,ov=evalVerts,iv=&mGeometry->m_Verts[0]; i<count; i++,ov++)

	mov	ecx, DWORD PTR [esi+140]
	xor	edx, edx
	mov	edi, DWORD PTR [ecx+72]
	lea	ecx, DWORD PTR [ebp+8]
$L12849:

; 1012 : 				*ov = iv[triRelay[i]].refPosition;

	xor	eax, eax
	add	ecx, 12					; 0000000cH
	mov	ax, WORD PTR _triRelay$[esp+edx*2+148]
	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 4
	inc	edx
	mov	ebx, DWORD PTR [eax+edi+4]
	lea	eax, DWORD PTR [eax+edi+4]
	mov	DWORD PTR [ecx-20], ebx
	cmp	edx, 3
	mov	ebx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx-16], ebx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx-12], eax
	jb	SHORT $L12849
$L12851:

; 1013 : 		}
; 1014 : 	}
; 1015 : 
; 1016 : 	// process remaining channels for vertex modification
; 1017 : 	for (NDword i=1;i<mActorChannels.GetCount();i++)

	mov	eax, DWORD PTR [esi+292]
	mov	edi, 1
	cmp	eax, edi
	jbe	SHORT $L12855
$L12853:

; 1018 : 	{
; 1019 : 		if (mActorChannels[i])

	mov	ecx, DWORD PTR [esi+288]
	mov	ecx, DWORD PTR [ecx+edi*4]
	test	ecx, ecx
	je	SHORT $L12854

; 1020 : 			mActorChannels[i]->EvalVerts(this, numVerts, triRelay, evalVerts);

	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR _triRelay$[esp+148]
	push	ebp
	push	eax
	push	3
	push	esi
	call	DWORD PTR [edx+52]
$L12854:
	mov	eax, DWORD PTR [esi+292]
	inc	edi
	cmp	edi, eax
	jb	SHORT $L12853
$L12855:

; 1021 : 	}
; 1022 : 
; 1023 : 	// build the output vertices from the final work vertices and the alpha, if required
; 1024 : 	if (evalVerts != outVerts)

	mov	ecx, DWORD PTR _outVerts$[esp+144]
	pop	edi
	cmp	ebp, ecx
	je	$L12864

; 1025 : 	{
; 1026 : 		NDword i;
; 1027 : 		VVec3* ov, *iv;
; 1028 : 		NDword count = numVerts;
; 1029 : 		for (i=0,ov=outVerts,iv=evalVerts; i<count; i++,ov++,iv++)

	fld	DWORD PTR __real@3f800000
	fsub	DWORD PTR _inVertAlpha$[esp+140]
	mov	edx, ecx
	lea	eax, DWORD PTR [ebp+8]
	sub	edx, ebp
	mov	esi, 3
$L12862:

; 1030 : 			*ov = (*iv * inVertAlpha) + (*ov * (1.f-inVertAlpha));

	fld	ST(0)
	fmul	DWORD PTR [ecx]
	fld	ST(1)
	fmul	DWORD PTR [ecx+4]
	add	ecx, 12					; 0000000cH
	add	eax, 12					; 0000000cH
	dec	esi
	fstp	DWORD PTR $T25335[esp+148]
	fld	ST(1)
	fmul	DWORD PTR [edx+eax-12]
	fstp	DWORD PTR $T25335[esp+152]
	fld	DWORD PTR _inVertAlpha$[esp+140]
	fmul	DWORD PTR [eax-20]
	fld	DWORD PTR _inVertAlpha$[esp+140]
	fmul	DWORD PTR [eax-16]
	fstp	DWORD PTR $T25336[esp+148]
	fld	DWORD PTR _inVertAlpha$[esp+140]
	fmul	DWORD PTR [eax-12]
	fstp	DWORD PTR $T25336[esp+152]
	faddp	ST(1), ST(0)
	fld	DWORD PTR $T25336[esp+148]
	fadd	DWORD PTR $T25335[esp+148]
	fld	DWORD PTR $T25336[esp+152]
	fadd	DWORD PTR $T25335[esp+152]
	fstp	DWORD PTR $T25337[esp+152]
	fxch	ST(1)
	fstp	DWORD PTR [ecx-12]
	fstp	DWORD PTR [ecx-8]
	fld	DWORD PTR $T25337[esp+152]
	fstp	DWORD PTR [edx+eax-12]
	jne	SHORT $L12862
	fstp	ST(0)
$L12864:
	pop	esi
	pop	ebp

; 1031 : 	}
; 1032 : 
; 1033 : 	return(1);

	mov	al, 1
	pop	ebx

; 1034 : }

	add	esp, 132				; 00000084H
	ret	12					; 0000000cH
$L12800:
	pop	esi
	pop	ebp

; 939  : 		return(0); // kinda pointless if we have no verts to evaluate to

	xor	al, al
	pop	ebx

; 1034 : }

	add	esp, 132				; 00000084H
	ret	12					; 0000000cH
?EvaluateTriVerts@OMacActor@@QAE_NKMPAVVVec3@@@Z ENDP	; OMacActor::EvaluateTriVerts
; Function compile flags: /Ogty
; File C:\duke4\Cannibal\CorMain.h
_TEXT	ENDS
;	COMDAT ?Realloc@CCorArray@@IAEXK@Z
_TEXT	SEGMENT
_inElemSize$ = 8
?Realloc@CCorArray@@IAEXK@Z PROC NEAR			; CCorArray::Realloc, COMDAT
; _this$ = ecx

; 184  : 		m_ElemSize = inElemSize;

	mov	eax, DWORD PTR _inElemSize$[esp-4]
	push	esi
	mov	esi, ecx

; 185  : 		if (m_Data)

	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [esi+12], eax
	test	ecx, ecx
	je	SHORT $L4944

; 186  : 		{
; 187  : 			if (!m_ElemSize || !m_Limit)

	test	eax, eax
	je	SHORT $L4946
	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $L4946

; 190  : 				m_Data = NULL;
; 191  : 			}
; 192  : 			else
; 193  : 			{
; 194  : 				m_Data = MEM_Realloc(NByte, m_Data, m_Limit*m_ElemSize);

	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+8]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [esi+12]
	push	ecx
	mov	ecx, DWORD PTR [esi]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+4]
	mov	DWORD PTR [esi], eax
	pop	esi

; 206  : 			}
; 207  : 		}
; 208  : 	}

	ret	4
$L4946:

; 188  : 			{
; 189  : 				MEM_Free(m_Data);

	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L4952:

; 200  : 			{
; 201  : 				m_Data = NULL;

	mov	DWORD PTR [esi], 0
	pop	esi

; 206  : 			}
; 207  : 		}
; 208  : 	}

	ret	4
$L4944:

; 195  : 			}
; 196  : 		}
; 197  : 		else
; 198  : 		{
; 199  : 			if (!m_ElemSize || !m_Limit)

	test	eax, eax
	je	SHORT $L4952
	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $L4952

; 202  : 			}
; 203  : 			else
; 204  : 			{
; 205  : 				m_Data = MEM_Malloc(NByte, m_Limit*m_ElemSize);

	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+8]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [esi+12]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	DWORD PTR [esi], eax
	pop	esi

; 206  : 			}
; 207  : 		}
; 208  : 	}

	ret	4
?Realloc@CCorArray@@IAEXK@Z ENDP			; CCorArray::Realloc
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??0CCorArray@@IAE@KK@Z
_TEXT	SEGMENT
_inCount$ = 8
_inElemSize$ = 12
??0CCorArray@@IAE@KK@Z PROC NEAR			; CCorArray::CCorArray, COMDAT
; _this$ = ecx

; 211  : 	{

	mov	eax, DWORD PTR _inCount$[esp-4]
	push	esi
	mov	esi, ecx

; 212  : 		Realloc(inElemSize);

	mov	ecx, DWORD PTR _inElemSize$[esp]
	test	ecx, ecx
	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], ecx
	je	SHORT $L25665
	test	eax, eax
	je	SHORT $L25665
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+8]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [esi+12]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	DWORD PTR [esi], eax

; 213  : 	}

	mov	eax, esi
	pop	esi
	ret	8

; 212  : 		Realloc(inElemSize);

$L25665:
	mov	DWORD PTR [esi], 0

; 213  : 	}

	mov	eax, esi
	pop	esi
	ret	8
??0CCorArray@@IAE@KK@Z ENDP				; CCorArray::CCorArray
_TEXT	ENDS
PUBLIC	??5@YA?AVVVec3@@ABV0@ABVVCoords3@@@Z		; operator>>
PUBLIC	??6@YA?AVVCoords3@@ABV0@0@Z			; operator<<
PUBLIC	?Add@?$TCorArray@VCMacTraceInfo@@@@QAEKK@Z	; TCorArray<CMacTraceInfo>::Add
PUBLIC	?Construct@CMacTraceInfo@@QAEXPAVOMacActor@@@Z	; CMacTraceInfo::Construct
PUBLIC	?TraceRay@OMacActor@@QAE_NKPAUSMacTri@@KPAVVVec3@@ABVVLine3@@PAKPAM1PAPAVCCpjSklBone@@@Z ; OMacActor::TraceRay
PUBLIC	__real@3a83126f
PUBLIC	??0VLine3@@QAE@XZ				; VLine3::VLine3
PUBLIC	?TwoPoint@VLine3@@QAEXABVVVec3@@0@Z		; VLine3::TwoPoint
_BSS	SEGMENT
?boneFilter@?8??TraceRay@OMacActor@@QAE_NKPAUSMacTri@@KPAVVVec3@@ABVVLine3@@PAKPAM1PAPAVCCpjSklBone@@@Z@4PA_NA DB 0100H DUP (?) ; boneFilter
_BSS	ENDS
;	COMDAT __real@3a83126f
CONST	SEGMENT
__real@3a83126f DD 03a83126fr			; 0.001
; Function compile flags: /Ogty
; File C:\duke4\Cannibal\MacMain.cpp
CONST	ENDS
;	COMDAT ?TraceRay@OMacActor@@QAE_NKPAUSMacTri@@KPAVVVec3@@ABVVLine3@@PAKPAM1PAPAVCCpjSklBone@@@Z
_TEXT	SEGMENT
$T25671 = -120
$T25898 = -60
$T25940 = -188
_l$26065 = -168
_tn$26066 = -284
_tf$26067 = -288
$T26093 = -264
$T26094 = -180
$T26095 = -132
_inNumTris$ = 8
_inTris$ = 12
_fi$26107 = -192
_inVerts$ = 20
_inRay$ = 24
_outTri$ = 28
_outDist$ = 32
_outBarys$ = 36
_outBone$ = 40
_this$ = -272
_result$ = -289
_minDist$ = -268
_minTri$ = -288
_minBarys$ = -264
_count$12920 = -184
_box$12921 = -252
_i$12922 = -276
_v$12934 = -168
_t$12940 = -280
_barys$12941 = -180
?TraceRay@OMacActor@@QAE_NKPAUSMacTri@@KPAVVVec3@@ABVVLine3@@PAKPAM1PAPAVCCpjSklBone@@@Z PROC NEAR ; OMacActor::TraceRay, COMDAT
; _this$ = ecx

; 1064 : {

	sub	esp, 292				; 00000124H

; 1065 : 	if (!inTris || !inVerts)

	mov	eax, DWORD PTR _inTris$[esp+288]
	push	ebp
	mov	ebp, ecx
	test	eax, eax
	mov	DWORD PTR _this$[esp+296], ebp
	je	$L12909
	mov	eax, DWORD PTR _inVerts$[esp+292]
	test	eax, eax
	je	$L12909
	push	ebx
	push	esi
	push	edi

; 1067 : 	if (mGeometry && mSkeleton)

	mov	edi, DWORD PTR [ebp+140]
	test	edi, edi
	je	SHORT $L12911
	mov	ebx, DWORD PTR [ebp+144]
	test	ebx, ebx
	je	SHORT $L12911

; 1068 : 	{
; 1069 : 		if ((!mTraceInfo) || (mTraceInfo->mTraceGeometry!=mGeometry) || (mTraceInfo->mTraceSkeleton!=mSkeleton))

	mov	eax, DWORD PTR [ebp+304]
	test	eax, eax
	je	SHORT $L12912
	cmp	DWORD PTR [eax], edi
	jne	SHORT $L12912
	cmp	DWORD PTR [eax+4], ebx
	je	SHORT $L12911
$L12912:

; 1070 : 			mTraceInfo = CMacTraceInfo::StaticFindInfo(this, mGeometry, mSkeleton);

	test	edi, edi
	je	SHORT $L25686
	test	ebx, ebx
	je	SHORT $L25686
	mov	edx, DWORD PTR ?sTraceInfoList@CMacTraceInfo@@2V?$TCorArray@VCMacTraceInfo@@@@A+4
	xor	ecx, ecx
	test	edx, edx
	jbe	SHORT $L25691
	mov	eax, DWORD PTR ?sTraceInfoList@CMacTraceInfo@@2V?$TCorArray@VCMacTraceInfo@@@@A
$L25689:
	cmp	edi, DWORD PTR [eax]
	jne	SHORT $L25690
	cmp	ebx, DWORD PTR [eax+4]
	je	SHORT $L25684
$L25690:
	inc	ecx
	add	eax, 40					; 00000028H
	cmp	ecx, edx
	jb	SHORT $L25689
$L25691:
	push	1
	mov	ecx, OFFSET FLAT:?sTraceInfoList@CMacTraceInfo@@2V?$TCorArray@VCMacTraceInfo@@@@A
	call	?Add@?$TCorArray@VCMacTraceInfo@@@@QAEKK@Z ; TCorArray<CMacTraceInfo>::Add
	mov	ecx, DWORD PTR ?sTraceInfoList@CMacTraceInfo@@2V?$TCorArray@VCMacTraceInfo@@@@A
	lea	eax, DWORD PTR [eax+eax*4]
	push	ebp
	lea	esi, DWORD PTR [ecx+eax*8]
	mov	ecx, esi
	mov	DWORD PTR [esi], edi
	mov	DWORD PTR [esi+4], ebx
	call	?Construct@CMacTraceInfo@@QAEXPAVOMacActor@@@Z ; CMacTraceInfo::Construct
	mov	eax, esi
	jmp	SHORT $L25684
$L25686:
	xor	eax, eax
$L25684:
	mov	DWORD PTR [ebp+304], eax
$L12911:

; 1071 : 	}
; 1072 : 	NBool result = 0;	
; 1073 : 	NFloat minDist = FLT_MAX;
; 1074 : 	NDword minTri;
; 1075 : 	VVec3 minBarys;
; 1076 : 
; 1077 : 	static NBool boneFilter[256];
; 1078 : 	if (mTraceInfo)

	mov	eax, DWORD PTR [ebp+304]
	mov	edi, DWORD PTR _inRay$[esp+304]
	xor	ebx, ebx
	mov	BYTE PTR _result$[esp+308], 0
	cmp	eax, ebx
	mov	DWORD PTR _minDist$[esp+308], 2139095039 ; 7f7fffffH
	je	$L12925

; 1079 : 	{
; 1080 : 		NDword count = mTraceInfo->mBoneBounds.GetCount();

	mov	eax, DWORD PTR [eax+28]

; 1081 : 		VBox3 box;

	mov	DWORD PTR _box$12921[esp+308], 1065353216 ; 3f800000H

; 1082 : 		for (NDword i=0;i<count;i++)

	cmp	eax, ebx
	mov	DWORD PTR _count$12920[esp+308], eax
	mov	DWORD PTR _box$12921[esp+312], ebx
	mov	DWORD PTR _box$12921[esp+316], ebx
	mov	DWORD PTR _box$12921[esp+320], ebx
	mov	DWORD PTR _box$12921[esp+324], 1065353216 ; 3f800000H
	mov	DWORD PTR _box$12921[esp+328], ebx
	mov	DWORD PTR _box$12921[esp+332], ebx
	mov	DWORD PTR _box$12921[esp+336], ebx
	mov	DWORD PTR _box$12921[esp+340], 1065353216 ; 3f800000H
	mov	DWORD PTR _box$12921[esp+344], ebx
	mov	DWORD PTR _box$12921[esp+348], ebx
	mov	DWORD PTR _box$12921[esp+352], ebx
	mov	DWORD PTR _box$12921[esp+356], 1065353216 ; 3f800000H
	mov	DWORD PTR _box$12921[esp+360], 1065353216 ; 3f800000H
	mov	DWORD PTR _box$12921[esp+364], 1065353216 ; 3f800000H
	mov	DWORD PTR _i$12922[esp+308], ebx
	jbe	$L12925

; 1079 : 	{
; 1080 : 		NDword count = mTraceInfo->mBoneBounds.GetCount();

	mov	DWORD PTR -280+[esp+308], ebx
$L12923:

; 1083 : 		{
; 1084 : 			box = mTraceInfo->mBoneBounds[i];

	mov	edx, DWORD PTR [ebp+304]

; 1085 : 			box.c <<= mActorBones[i].GetCoords(true);

	mov	esi, DWORD PTR [ebp+272]
	push	1
	mov	eax, DWORD PTR [edx+24]
	add	eax, ebx
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _box$12921[esp+312], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _box$12921[esp+316], edx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _box$12921[esp+320], ecx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR _box$12921[esp+324], edx
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _box$12921[esp+328], ecx
	mov	edx, DWORD PTR [eax+20]
	mov	DWORD PTR _box$12921[esp+332], edx
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _box$12921[esp+336], ecx
	mov	edx, DWORD PTR [eax+28]
	mov	DWORD PTR _box$12921[esp+340], edx
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR _box$12921[esp+344], ecx
	mov	edx, DWORD PTR [eax+36]
	mov	DWORD PTR _box$12921[esp+348], edx
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR _box$12921[esp+352], ecx
	mov	edx, DWORD PTR [eax+44]
	mov	DWORD PTR _box$12921[esp+356], edx
	mov	ecx, DWORD PTR [eax+48]
	mov	DWORD PTR _box$12921[esp+360], ecx
	mov	edx, DWORD PTR [eax+52]
	mov	DWORD PTR _box$12921[esp+364], edx
	mov	eax, DWORD PTR [eax+56]
	mov	DWORD PTR _box$12921[esp+368], eax
	mov	eax, DWORD PTR -280+[esp+312]
	add	esi, eax
	mov	ecx, esi
	call	?ValidateAbs@CMacBone@@IAEX_N@Z		; CMacBone::ValidateAbs
	add	esi, 60					; 0000003cH
	lea	ecx, DWORD PTR $T25671[esp+308]
	push	esi
	call	??0VCoords3@@QAE@ABV0@@Z		; VCoords3::VCoords3
	lea	ecx, DWORD PTR $T25671[esp+308]
	lea	edx, DWORD PTR _box$12921[esp+308]
	push	ecx
	lea	eax, DWORD PTR $T25898[esp+312]
	push	edx
	push	eax
	call	??6@YA?AVVCoords3@@ABV0@0@Z		; operator<<
	mov	ecx, DWORD PTR [eax]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _box$12921[esp+308], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _box$12921[esp+312], edx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _box$12921[esp+316], ecx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR _box$12921[esp+320], edx
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _box$12921[esp+324], ecx
	mov	edx, DWORD PTR [eax+20]
	mov	DWORD PTR _box$12921[esp+328], edx
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _box$12921[esp+332], ecx
	mov	edx, DWORD PTR [eax+28]
	mov	DWORD PTR _box$12921[esp+336], edx
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR _box$12921[esp+340], ecx
	mov	edx, DWORD PTR [eax+36]
	mov	DWORD PTR _box$12921[esp+344], edx
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR _box$12921[esp+348], ecx
	mov	edx, DWORD PTR [eax+44]
	mov	DWORD PTR _box$12921[esp+352], edx
	mov	ecx, DWORD PTR [eax+48]
	mov	DWORD PTR _box$12921[esp+356], ecx
	mov	edx, DWORD PTR [eax+52]
	mov	DWORD PTR _box$12921[esp+360], edx
	mov	eax, DWORD PTR [eax+56]
	mov	DWORD PTR _box$12921[esp+364], eax

; 1086 : 			boneFilter[i] = box.Intersects(inRay, NULL, NULL);

	lea	ecx, DWORD PTR _l$26065[esp+308]
	call	??0VLine3@@QAE@XZ			; VLine3::VLine3
	fld	DWORD PTR [edi]
	fadd	DWORD PTR [edi+12]
	lea	ecx, DWORD PTR _box$12921[esp+308]
	lea	edx, DWORD PTR $T26093[esp+308]
	push	ecx
	lea	eax, DWORD PTR $T26094[esp+312]
	fstp	DWORD PTR $T26093[esp+312]
	fld	DWORD PTR [edi+16]
	fadd	DWORD PTR [edi+4]
	push	edx
	push	eax
	fstp	DWORD PTR $T26093[esp+324]
	fld	DWORD PTR [edi+20]
	fadd	DWORD PTR [edi+8]
	fstp	DWORD PTR $T26093[esp+328]
	call	??5@YA?AVVVec3@@ABV0@ABVVCoords3@@@Z	; operator>>
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR _box$12921[esp+308]
	lea	edx, DWORD PTR $T26095[esp+308]
	push	eax
	push	ecx
	push	edi
	push	edx
	call	??5@YA?AVVVec3@@ABV0@ABVVCoords3@@@Z	; operator>>
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR _l$26065[esp+312]
	push	eax
	call	?TwoPoint@VLine3@@QAEXABVVVec3@@0@Z	; VLine3::TwoPoint
	mov	DWORD PTR _tn$26066[esp+308], -8388609	; ff7fffffH
	mov	DWORD PTR _tf$26067[esp+308], 2139095039 ; 7f7fffffH
	xor	ecx, ecx
$L26070:
	mov	eax, DWORD PTR _l$26065[esp+ecx*4+320]
	mov	edx, eax
	mov	DWORD PTR $T25940[esp+308], eax
	and	edx, 2147483647				; 7fffffffH
	mov	DWORD PTR _fi$26107[esp+308], edx
	fld	DWORD PTR _fi$26107[esp+308]
	fcomp	DWORD PTR __real@3a83126f
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L26073
	fld	DWORD PTR _l$26065[esp+ecx*4+308]
	fsub	DWORD PTR __real@3f800000
	fcomp	DWORD PTR __real@3a83126f
	fnstsw	ax
	and	eax, 16640				; 00004100H
	je	$L26220
	fld	DWORD PTR _l$26065[esp+ecx*4+308]
	fcomp	DWORD PTR __real@3a83126f
	fnstsw	ax
	test	ah, 5
	jnp	$L26220
	jmp	$L26071
$L26073:
	fld	DWORD PTR __real@3f800000
	fdiv	DWORD PTR _l$26065[esp+ecx*4+320]
	fld	DWORD PTR _l$26065[esp+ecx*4+308]
	fsub	DWORD PTR __real@3f800000
	fmul	ST(0), ST(1)
	fchs
	fld	DWORD PTR _l$26065[esp+ecx*4+320]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	and	eax, 16640				; 00004100H
	jne	SHORT $L26076
	fcom	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 5
	jnp	$L26215
	fcom	DWORD PTR _tf$26067[esp+308]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L26237
	fstp	DWORD PTR _tf$26067[esp+308]
	jmp	SHORT $L26078
$L26237:
	fstp	ST(0)
$L26078:
	fld	DWORD PTR _tn$26066[esp+308]
	fcomp	DWORD PTR _tf$26067[esp+308]
	fnstsw	ax
	and	eax, 16640				; 00004100H
	je	$L26219
	fmul	DWORD PTR _l$26065[esp+ecx*4+308]
	fchs
	fcom	DWORD PTR _tn$26066[esp+308]
	fnstsw	ax
	and	eax, 16640				; 00004100H
	jne	SHORT $L26236
	fstp	DWORD PTR _tn$26066[esp+308]
	jmp	SHORT $L26086
$L26076:
	fcom	DWORD PTR _tn$26066[esp+308]
	fnstsw	ax
	and	eax, 16640				; 00004100H
	jne	SHORT $L26238
	fstp	DWORD PTR _tn$26066[esp+308]
	jmp	SHORT $L26083
$L26238:
	fstp	ST(0)
$L26083:
	fld	DWORD PTR _tn$26066[esp+308]
	fcomp	DWORD PTR _tf$26067[esp+308]
	fnstsw	ax
	and	eax, 16640				; 00004100H
	je	$L26219
	fmul	DWORD PTR _l$26065[esp+ecx*4+308]
	fchs
	fcom	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 5
	jnp	$L26219
	fcom	DWORD PTR _tf$26067[esp+308]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L26236
	fstp	DWORD PTR _tf$26067[esp+308]
	jmp	SHORT $L26086
$L26236:
	fstp	ST(0)
$L26086:
	fld	DWORD PTR _tn$26066[esp+308]
	fcomp	DWORD PTR _tf$26067[esp+308]
	fnstsw	ax
	and	eax, 16640				; 00004100H
	je	$L26220
$L26071:
	inc	ecx
	cmp	ecx, 3
	jl	$L26070
	mov	al, 1
$L26064:
	mov	ecx, DWORD PTR _i$12922[esp+308]
	mov	edx, DWORD PTR -280+[esp+308]
	add	ebx, 60					; 0000003cH
	add	edx, 140				; 0000008cH
	mov	BYTE PTR ?boneFilter@?8??TraceRay@OMacActor@@QAE_NKPAUSMacTri@@KPAVVVec3@@ABVVLine3@@PAKPAM1PAPAVCCpjSklBone@@@Z@4PA_NA[ecx], al
	mov	eax, DWORD PTR _count$12920[esp+308]
	inc	ecx
	mov	DWORD PTR -280+[esp+308], edx
	cmp	ecx, eax
	mov	DWORD PTR _i$12922[esp+308], ecx
	jb	$L12923
$L12925:

; 1087 : 		}
; 1088 : 	}
; 1089 : 
; 1090 : 	for (NDword i=0;i<inNumTris;i++)

	mov	eax, DWORD PTR _inNumTris$[esp+304]
	xor	ebx, ebx
	test	eax, eax
	jbe	$L12949
	mov	eax, DWORD PTR _inTris$[esp+304]
	lea	edx, DWORD PTR [eax+4]
	mov	DWORD PTR -276+[esp+308], edx
$L12928:

; 1091 : 	{
; 1092 : 		if (mTraceInfo && !boneFilter[mTraceInfo->mTriBones[i]])

	mov	eax, DWORD PTR [ebp+304]
	test	eax, eax
	je	SHORT $L12931
	mov	ecx, DWORD PTR [eax+8]
	xor	eax, eax
	mov	al, BYTE PTR [ecx+ebx]
	mov	cl, BYTE PTR ?boneFilter@?8??TraceRay@OMacActor@@QAE_NKPAUSMacTri@@KPAVVVec3@@ABVVLine3@@PAKPAM1PAPAVCCpjSklBone@@@Z@4PA_NA[eax]
	test	cl, cl
	je	$L12929
$L12931:

; 1093 : 			continue; // bone wasn't collided with, so skip this tri
; 1094 : 		
; 1095 : 		SMacTri* tri = &inTris[i];
; 1096 : 		if (tri->surfaceFlags & SRFTF_NONCOLLIDE) // !BR Trace through this tri.

	mov	eax, DWORD PTR [edx+32]
	test	ah, 4
	jne	$L12929

; 1097 : 			continue;
; 1098 : 		VVec3 v[3];
; 1099 : 		for (NDword j=0;j<3;j++)

	lea	eax, DWORD PTR _v$12934[esp+316]
	mov	esi, 3
$L12937:

; 1100 : 			v[j] = inVerts[tri->vertIndex[j]];

	mov	ecx, DWORD PTR [edx]
	mov	ebp, DWORD PTR _inVerts$[esp+304]
	add	edx, 4
	add	eax, 12					; 0000000cH
	lea	ecx, DWORD PTR [ecx+ecx*2]
	dec	esi
	lea	ecx, DWORD PTR [ebp+ecx*4]
	mov	ebp, DWORD PTR [ecx]
	mov	DWORD PTR [eax-20], ebp
	mov	ebp, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax-16], ebp
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax-12], ecx
	jne	SHORT $L12937

; 1101 : 		NFloat t;
; 1102 : 		VVec3 barys;
; 1103 : 		if (RayTriIntersect(inRay, v[0], v[1], v[2], t, barys))

	lea	edx, DWORD PTR _barys$12941[esp+308]
	lea	eax, DWORD PTR _t$12940[esp+308]
	push	edx
	lea	ecx, DWORD PTR _v$12934[esp+336]
	push	eax
	lea	edx, DWORD PTR _v$12934[esp+328]
	push	ecx
	lea	eax, DWORD PTR _v$12934[esp+320]
	push	edx
	push	eax
	push	edi
	call	?RayTriIntersect@@YA_NABVVLine3@@ABVVVec3@@11AAMAAV2@@Z ; RayTriIntersect
	add	esp, 24					; 00000018H
	test	al, al
	je	SHORT $L26234

; 1104 : 		{
; 1105 : 			if ((t >= 0.f) && (t < minDist))

	fld	DWORD PTR _t$12940[esp+308]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	and	eax, 256				; 00000100H
	jne	SHORT $L26234
	fld	DWORD PTR _t$12940[esp+308]
	fcomp	DWORD PTR _minDist$[esp+308]

; 1106 : 			{
; 1107 : 				result = 1;
; 1108 : 				minDist = t;
; 1109 : 				minTri = i;
; 1110 : 				minBarys = barys;

	mov	ebp, DWORD PTR _this$[esp+308]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L12929
	mov	ecx, DWORD PTR _t$12940[esp+308]
	mov	edx, DWORD PTR _barys$12941[esp+308]
	mov	eax, DWORD PTR _barys$12941[esp+312]
	mov	DWORD PTR _minDist$[esp+308], ecx
	mov	ecx, DWORD PTR _barys$12941[esp+316]
	mov	BYTE PTR _result$[esp+308], 1
	mov	DWORD PTR _minTri$[esp+308], ebx
	mov	DWORD PTR _minBarys$[esp+308], edx
	mov	DWORD PTR _minBarys$[esp+312], eax
	mov	DWORD PTR _minBarys$[esp+316], ecx
	jmp	SHORT $L12929
$L26215:

; 1086 : 			boneFilter[i] = box.Intersects(inRay, NULL, NULL);

	fstp	ST(0)
$L26219:
	fstp	ST(0)
$L26220:
	xor	al, al
	jmp	$L26064
$L26234:

; 1106 : 			{
; 1107 : 				result = 1;
; 1108 : 				minDist = t;
; 1109 : 				minTri = i;
; 1110 : 				minBarys = barys;

	mov	ebp, DWORD PTR _this$[esp+308]
$L12929:

; 1087 : 		}
; 1088 : 	}
; 1089 : 
; 1090 : 	for (NDword i=0;i<inNumTris;i++)

	mov	edx, DWORD PTR -276+[esp+308]
	mov	eax, DWORD PTR _inNumTris$[esp+304]
	inc	ebx
	add	edx, 44					; 0000002cH
	cmp	ebx, eax
	mov	DWORD PTR -276+[esp+308], edx
	jb	$L12928

; 1111 : 			}
; 1112 : 		}
; 1113 : 	}
; 1114 : 	if (result)

	mov	al, BYTE PTR _result$[esp+308]
	test	al, al
	je	$L12949

; 1115 : 	{
; 1116 : 		if (outTri) *outTri = minTri;

	mov	eax, DWORD PTR _outTri$[esp+304]
	test	eax, eax
	je	SHORT $L12945
	mov	edx, DWORD PTR _minTri$[esp+308]
	mov	DWORD PTR [eax], edx
$L12945:

; 1117 : 		if (outDist) *outDist = minDist;

	mov	eax, DWORD PTR _outDist$[esp+304]
	test	eax, eax
	je	SHORT $L12946
	mov	ecx, DWORD PTR _minDist$[esp+308]
	mov	DWORD PTR [eax], ecx
$L12946:

; 1118 : 		if (outBarys) *outBarys = minBarys;

	mov	eax, DWORD PTR _outBarys$[esp+304]
	test	eax, eax
	je	SHORT $L26196
	mov	edx, DWORD PTR _minBarys$[esp+308]
	mov	ecx, DWORD PTR _minBarys$[esp+312]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR _minBarys$[esp+316]
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], edx
$L26196:

; 1119 : 		if (outBone)

	mov	ecx, DWORD PTR _outBone$[esp+304]
	test	ecx, ecx
	je	SHORT $L12949

; 1120 : 		{
; 1121 : 			*outBone = NULL;

	mov	DWORD PTR [ecx], 0

; 1122 : 			if ((mTraceInfo) && (mTraceInfo->mTriBones[minTri]!=255))

	mov	eax, DWORD PTR [ebp+304]
	test	eax, eax
	je	SHORT $L12949
	mov	eax, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _minTri$[esp+308]
	mov	al, BYTE PTR [edx+eax]
	cmp	al, 255					; 000000ffH
	je	SHORT $L12949

; 1123 : 				*outBone = &mSkeleton->m_Bones[mTraceInfo->mTriBones[minTri]];

	and	eax, 255				; 000000ffH
	lea	edx, DWORD PTR [eax+eax*8]
	lea	eax, DWORD PTR [eax+edx*2]
	mov	edx, DWORD PTR [ebp+144]
	mov	edx, DWORD PTR [edx+72]
	lea	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR [ecx], eax
$L12949:

; 1124 : 		}
; 1125 : 	}
; 1126 : 	return(result);

	mov	al, BYTE PTR _result$[esp+308]
	pop	edi
	pop	esi
	pop	ebx
	pop	ebp

; 1127 : }

	add	esp, 292				; 00000124H
	ret	36					; 00000024H
$L12909:

; 1066 : 		return(0);

	xor	al, al
	pop	ebp

; 1127 : }

	add	esp, 292				; 00000124H
	ret	36					; 00000024H
?TraceRay@OMacActor@@QAE_NKPAUSMacTri@@KPAVVVec3@@ABVVLine3@@PAKPAM1PAPAVCCpjSklBone@@@Z ENDP ; OMacActor::TraceRay
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?RayTriIntersect@@YA_NABVVLine3@@ABVVVec3@@11AAMAAV2@@Z
_TEXT	SEGMENT
_inRay$ = 8
_inV0$ = 12
_inV1$ = 16
_inV2$ = 20
_outT$ = 24
_outBarys$ = 28
_e1$ = -36
_e2$ = -24
_f$ = 12
_s$ = -48
_u$ = 16
_q$ = -12
_fi$26289 = 16
$T26291 = 16
?RayTriIntersect@@YA_NABVVLine3@@ABVVVec3@@11AAMAAV2@@Z PROC NEAR ; RayTriIntersect, COMDAT

; 1037 : {

	sub	esp, 48					; 00000030H

; 1038 : 	VVec3 e1 = inV1 - inV0;

	mov	eax, DWORD PTR _inV1$[esp+44]
	mov	edx, DWORD PTR _inV0$[esp+44]

; 1039 : 	VVec3 e2 = inV2 - inV0;
; 1040 : 	VVec3 p = inRay.v ^ e2;

	mov	ecx, DWORD PTR _inRay$[esp+44]
	fld	DWORD PTR [eax]
	fsub	DWORD PTR [edx]
	fstp	DWORD PTR _e1$[esp+48]
	fld	DWORD PTR [eax+4]
	fsub	DWORD PTR [edx+4]
	fstp	DWORD PTR _e1$[esp+52]
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR [edx+8]
	mov	eax, DWORD PTR _inV2$[esp+44]
	fstp	DWORD PTR _e1$[esp+56]
	fld	DWORD PTR [eax]
	fsub	DWORD PTR [edx]
	fstp	DWORD PTR _e2$[esp+48]
	fld	DWORD PTR [eax+4]
	fsub	DWORD PTR [edx+4]
	fstp	DWORD PTR _e2$[esp+52]
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR [edx+8]
	fstp	DWORD PTR _e2$[esp+56]
	fld	DWORD PTR _e2$[esp+56]
	fmul	DWORD PTR [ecx+16]
	fld	DWORD PTR _e2$[esp+52]
	fmul	DWORD PTR [ecx+20]
	fsubp	ST(1), ST(0)
	fld	DWORD PTR _e2$[esp+48]
	fmul	DWORD PTR [ecx+20]
	fld	DWORD PTR _e2$[esp+56]
	fmul	DWORD PTR [ecx+12]
	fsubp	ST(1), ST(0)
	fld	DWORD PTR _e2$[esp+52]
	fmul	DWORD PTR [ecx+12]
	fld	DWORD PTR _e2$[esp+48]
	fmul	DWORD PTR [ecx+16]
	fsubp	ST(1), ST(0)

; 1041 : 	NFloat a = e1 | p;

	fld	DWORD PTR _e1$[esp+56]
	fmul	ST(0), ST(1)
	fld	ST(2)
	fmul	DWORD PTR _e1$[esp+52]
	faddp	ST(1), ST(0)
	fld	ST(3)
	fmul	DWORD PTR _e1$[esp+48]
	faddp	ST(1), ST(0)

; 1042 : 	if (M_Fabs(a) < M_EPSILON)

	fst	DWORD PTR $T26291[esp+44]
	mov	eax, DWORD PTR $T26291[esp+44]
	and	eax, 2147483647				; 7fffffffH
	mov	DWORD PTR _fi$26289[esp+44], eax
	fld	DWORD PTR _fi$26289[esp+44]
	fcomp	DWORD PTR __real@3a83126f
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L12883
	fstp	ST(0)
	fstp	ST(0)
$L26324:

; 1051 : 	if ((v < 0.f) || ((u+v) > 1.f))

	fstp	ST(0)
$L26325:
	fstp	ST(0)
$L12889:

; 1048 : 		return(0);

	xor	al, al

; 1060 : }

	add	esp, 48					; 00000030H
	ret	0
$L12883:

; 1043 : 		return(0);
; 1044 : 	NFloat f = 1.f / a;

	fld	DWORD PTR __real@3f800000
	fdiv	ST(0), ST(1)
	fstp	DWORD PTR _f$[esp+44]
	fstp	ST(0)

; 1045 : 	VVec3 s = inRay.u - inV0;

	fld	DWORD PTR [ecx]
	fsub	DWORD PTR [edx]
	fstp	DWORD PTR _s$[esp+48]
	fld	DWORD PTR [ecx+4]
	fsub	DWORD PTR [edx+4]
	fstp	DWORD PTR _s$[esp+52]
	fld	DWORD PTR [ecx+8]
	fsub	DWORD PTR [edx+8]
	fst	DWORD PTR _s$[esp+56]

; 1046 : 	NFloat u = f * (s | p);

	fmul	ST(0), ST(1)
	fld	DWORD PTR _s$[esp+52]
	fmul	ST(0), ST(3)
	faddp	ST(1), ST(0)
	fld	DWORD PTR _s$[esp+48]
	fmul	ST(0), ST(4)
	faddp	ST(1), ST(0)
	fmul	DWORD PTR _f$[esp+44]
	fstp	DWORD PTR _u$[esp+44]
	fstp	ST(0)
	fstp	ST(0)
	fstp	ST(0)

; 1047 : 	if ((u < 0.f) || (u > 1.f))

	fld	DWORD PTR _u$[esp+44]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $L12889
	fld	DWORD PTR _u$[esp+44]
	fcomp	DWORD PTR __real@3f800000
	fnstsw	ax
	and	eax, 16640				; 00004100H
	je	SHORT $L12889

; 1049 : 	VVec3 q = s ^ e1;

	fld	DWORD PTR _s$[esp+52]
	fmul	DWORD PTR _e1$[esp+56]
	fld	DWORD PTR _s$[esp+56]
	fmul	DWORD PTR _e1$[esp+52]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _q$[esp+48]
	fld	DWORD PTR _s$[esp+56]
	fmul	DWORD PTR _e1$[esp+48]
	fld	DWORD PTR _e1$[esp+56]
	fmul	DWORD PTR _s$[esp+48]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _q$[esp+52]
	fld	DWORD PTR _s$[esp+48]
	fmul	DWORD PTR _e1$[esp+52]
	fld	DWORD PTR _s$[esp+52]
	fmul	DWORD PTR _e1$[esp+48]
	fsubp	ST(1), ST(0)
	fst	DWORD PTR _q$[esp+56]

; 1050 : 	NFloat v = f * (inRay.v | q);

	fmul	DWORD PTR [ecx+20]
	fld	DWORD PTR _q$[esp+52]
	fmul	DWORD PTR [ecx+16]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _q$[esp+48]
	fmul	DWORD PTR [ecx+12]
	faddp	ST(1), ST(0)
	fmul	DWORD PTR _f$[esp+44]

; 1051 : 	if ((v < 0.f) || ((u+v) > 1.f))

	fcom	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 5
	jnp	$L26325
	fld	DWORD PTR _u$[esp+44]
	fadd	ST(0), ST(1)
	fcom	DWORD PTR __real@3f800000
	fnstsw	ax
	and	eax, 16640				; 00004100H
	je	$L26324

; 1052 : 		return(0);
; 1053 : 	NFloat t = f * (e2 | q);

	fld	DWORD PTR _q$[esp+56]
	fmul	DWORD PTR _e2$[esp+56]
	fld	DWORD PTR _q$[esp+52]
	fmul	DWORD PTR _e2$[esp+52]

; 1054 : 	
; 1055 : 	outT = t;

	mov	ecx, DWORD PTR _outT$[esp+44]

; 1056 : 	outBarys.x = 1.f - (u+v);

	mov	eax, DWORD PTR _outBarys$[esp+44]

; 1057 : 	outBarys.y = u;

	mov	edx, DWORD PTR _u$[esp+44]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _q$[esp+48]
	fmul	DWORD PTR _e2$[esp+48]
	faddp	ST(1), ST(0)
	fmul	DWORD PTR _f$[esp+44]
	fstp	DWORD PTR [ecx]
	fld	DWORD PTR __real@3f800000
	fsub	ST(0), ST(1)
	mov	DWORD PTR [eax+4], edx
	fstp	DWORD PTR [eax]
	fstp	ST(0)

; 1058 : 	outBarys.z = v;

	fstp	DWORD PTR [eax+8]

; 1059 : 	return(1);

	mov	al, 1

; 1060 : }

	add	esp, 48					; 00000030H
	ret	0
?RayTriIntersect@@YA_NABVVLine3@@ABVVVec3@@11AAMAAV2@@Z ENDP ; RayTriIntersect
_TEXT	ENDS
PUBLIC	?AddNoConstruct@?$TCorArray@PAVOCpjSurface@@@@QAEKK@Z ; TCorArray<OCpjSurface *>::AddNoConstruct
PUBLIC	?RemoveReferencesTo@OMacActor@@QAE_NPAVOCpjChunk@@@Z ; OMacActor::RemoveReferencesTo
; Function compile flags: /Ogty
;	COMDAT ?RemoveReferencesTo@OMacActor@@QAE_NPAVOCpjChunk@@@Z
_TEXT	SEGMENT
_inChunk$ = 8
?RemoveReferencesTo@OMacActor@@QAE_NPAVOCpjChunk@@@Z PROC NEAR ; OMacActor::RemoveReferencesTo, COMDAT
; _this$ = ecx

; 1130 : {

	push	ebx
	push	ebp
	push	esi
	push	edi

; 1131 : 	if (!inChunk)

	mov	edi, DWORD PTR _inChunk$[esp+12]
	xor	ebx, ebx
	cmp	edi, ebx
	mov	esi, ecx

; 1132 : 		return(0);

	je	$L12979

; 1133 : 	if ((inChunk->IsA(OCpjGeometry::GetStaticClass())) && (mGeometry == (OCpjGeometry*)inChunk))

	mov	ecx, DWORD PTR ?staticObjClass@OCpjGeometry@@0PAVCObjClass@@A ; OCpjGeometry::staticObjClass
	mov	eax, DWORD PTR [edi]
	push	ecx
	mov	ecx, edi
	call	DWORD PTR [eax+44]
	test	al, al
	je	SHORT $L12956
	cmp	DWORD PTR [esi+140], edi
	jne	SHORT $L12956

; 1134 : 	{
; 1135 : 		SetGeometry(NULL);

	mov	DWORD PTR [esi+140], ebx
	pop	edi
	pop	esi
	pop	ebp

; 1136 : 		return(1);

	mov	al, 1
	pop	ebx

; 1182 : }

	ret	4
$L12956:

; 1137 : 	}
; 1138 : 	if ((inChunk->IsA(OCpjSkeleton::GetStaticClass())) && (mSkeleton == (OCpjSkeleton*)inChunk))

	mov	eax, DWORD PTR ?staticObjClass@OCpjSkeleton@@0PAVCObjClass@@A ; OCpjSkeleton::staticObjClass
	mov	edx, DWORD PTR [edi]
	push	eax
	mov	ecx, edi
	call	DWORD PTR [edx+44]
	test	al, al
	je	SHORT $L12958
	cmp	DWORD PTR [esi+144], edi
	jne	SHORT $L12958

; 1139 : 	{
; 1140 : 		SetSkeleton(NULL);

	push	ebx
	mov	ecx, esi
	call	?SetSkeleton@OMacActor@@QAE_NPAVOCpjSkeleton@@@Z ; OMacActor::SetSkeleton
	pop	edi
	pop	esi
	pop	ebp

; 1141 : 		return(1);

	mov	al, 1
	pop	ebx

; 1182 : }

	ret	4
$L12958:

; 1142 : 	}
; 1143 : 	if ((inChunk->IsA(OCpjLodData::GetStaticClass())) && (mLodData == (OCpjLodData*)inChunk))

	mov	eax, DWORD PTR ?staticObjClass@OCpjLodData@@0PAVCObjClass@@A ; OCpjLodData::staticObjClass
	mov	edx, DWORD PTR [edi]
	push	eax
	mov	ecx, edi
	call	DWORD PTR [edx+44]
	test	al, al
	je	SHORT $L12960
	cmp	DWORD PTR [esi+148], edi
	jne	SHORT $L12960

; 1144 : 	{
; 1145 : 		SetLodData(NULL);

	mov	DWORD PTR [esi+148], ebx
	pop	edi
	pop	esi
	pop	ebp

; 1146 : 		return(1);

	mov	al, 1
	pop	ebx

; 1182 : }

	ret	4
$L12960:

; 1147 : 	}
; 1148 : 	if (inChunk->IsA(OCpjSurface::GetStaticClass()))

	mov	eax, DWORD PTR ?staticObjClass@OCpjSurface@@0PAVCObjClass@@A ; OCpjSurface::staticObjClass
	mov	edx, DWORD PTR [edi]
	push	eax
	mov	ecx, edi
	call	DWORD PTR [edx+44]
	test	al, al
	je	SHORT $L12965

; 1149 : 	{
; 1150 : 		for (NDword i=0;i<mSurfaces.GetCount();i++)

	mov	eax, DWORD PTR [esi+156]
	cmp	eax, ebx
	jbe	SHORT $L12965
	mov	ecx, DWORD PTR [esi+152]
	lea	ebp, DWORD PTR [esi+152]
$L12963:

; 1151 : 		{
; 1152 : 			if (mSurfaces[i] == (OCpjSurface*)inChunk)

	cmp	DWORD PTR [ecx], edi
	je	SHORT $L26424
	inc	ebx
	add	ecx, 4
	cmp	ebx, eax
	jb	SHORT $L12963
$L12965:

; 1156 : 			}
; 1157 : 		}
; 1158 : 	}
; 1159 : 	if (inChunk->IsA(OCpjFrames::GetStaticClass()))

	mov	eax, DWORD PTR ?staticObjClass@OCpjFrames@@0PAVCObjClass@@A ; OCpjFrames::staticObjClass
	mov	edx, DWORD PTR [edi]
	push	eax
	mov	ecx, edi
	call	DWORD PTR [edx+44]
	test	al, al
	je	SHORT $L12972

; 1160 : 	{
; 1161 : 		for (NDword i=0;i<mFrames.GetCount();i++)

	mov	edx, DWORD PTR [esi+172]
	xor	eax, eax
	test	edx, edx
	jbe	SHORT $L12972
	mov	ebx, DWORD PTR [esi+168]
	mov	ecx, ebx
$L12970:

; 1162 : 		{
; 1163 : 			if (mFrames[i] == (OCpjFrames*)inChunk)

	cmp	DWORD PTR [ecx], edi
	je	SHORT $L26425
	inc	eax
	add	ecx, 4
	cmp	eax, edx
	jb	SHORT $L12970

; 1173 : 		{
; 1174 : 			if (mSequences[i] == (OCpjSequence*)inChunk)

	jmp	SHORT $L12972
$L26424:

; 1153 : 			{
; 1154 : 				SetSurface(i, NULL);

	cmp	eax, ebx
	ja	SHORT $L26387
	mov	esi, ebx
	mov	ecx, ebp
	sub	esi, eax
	inc	esi
	push	esi
	call	?AddNoConstruct@?$TCorArray@PAVOCpjSurface@@@@QAEKK@Z ; TCorArray<OCpjSurface *>::AddNoConstruct
	mov	ecx, esi
	mov	esi, DWORD PTR [ebp]
	mov	edx, eax
	xor	eax, eax
	lea	edi, DWORD PTR [esi+edx*4]
	rep stosd
$L26387:
	mov	ecx, DWORD PTR [ebp]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR [ecx+ebx*4], 0

; 1155 : 				return(1);

	mov	al, 1
	pop	ebx

; 1182 : }

	ret	4
$L26425:
	pop	edi
	pop	esi

; 1164 : 			{
; 1165 : 				mFrames[i] = NULL;

	mov	DWORD PTR [ebx+eax*4], 0
	pop	ebp

; 1166 : 				return(1);

	mov	al, 1
	pop	ebx

; 1182 : }

	ret	4
$L12972:

; 1167 : 			}
; 1168 : 		}
; 1169 : 	}
; 1170 : 	if (inChunk->IsA(OCpjSequence::GetStaticClass()))

	mov	eax, DWORD PTR ?staticObjClass@OCpjSequence@@0PAVCObjClass@@A ; OCpjSequence::staticObjClass
	mov	edx, DWORD PTR [edi]
	push	eax
	mov	ecx, edi
	call	DWORD PTR [edx+44]
	test	al, al
	je	SHORT $L12979

; 1171 : 	{
; 1172 : 		for (NDword i=0;i<mSequences.GetCount();i++)

	mov	edx, DWORD PTR [esi+188]
	xor	eax, eax
	test	edx, edx
	jbe	SHORT $L12979
	mov	esi, DWORD PTR [esi+184]
	mov	ecx, esi
$L12977:

; 1173 : 		{
; 1174 : 			if (mSequences[i] == (OCpjSequence*)inChunk)

	cmp	DWORD PTR [ecx], edi
	je	SHORT $L26426
	inc	eax
	add	ecx, 4
	cmp	eax, edx
	jb	SHORT $L12977
$L12979:
	pop	edi
	pop	esi
	pop	ebp

; 1178 : 			}
; 1179 : 		}
; 1180 : 	}
; 1181 : 	return(0);

	xor	al, al
	pop	ebx

; 1182 : }

	ret	4
$L26426:

; 1175 : 			{
; 1176 : 				mSequences[i] = NULL;

	mov	DWORD PTR [esi+eax*4], 0
	pop	edi
	pop	esi
	pop	ebp

; 1177 : 				return(1);

	mov	al, 1
	pop	ebx

; 1182 : }

	ret	4
?RemoveReferencesTo@OMacActor@@QAE_NPAVOCpjChunk@@@Z ENDP ; OMacActor::RemoveReferencesTo
_TEXT	ENDS
PUBLIC	?RemoveAllReferencesTo@OMacActor@@SA_NPAVOCpjChunk@@@Z ; OMacActor::RemoveAllReferencesTo
; Function compile flags: /Ogty
;	COMDAT ?RemoveAllReferencesTo@OMacActor@@SA_NPAVOCpjChunk@@@Z
_TEXT	SEGMENT
_inChunk$ = 8
?RemoveAllReferencesTo@OMacActor@@SA_NPAVOCpjChunk@@@Z PROC NEAR ; OMacActor::RemoveAllReferencesTo, COMDAT

; 1184 : {

	push	esi

; 1185 : 	for (CMacActorLink* link = CMacActorLink::GetFirst(); !link->IsDone(); link = link->GetNext())

	mov	esi, DWORD PTR ?sHeadLink@CMacActorLink@@0V1@A+8
	cmp	esi, OFFSET FLAT:?sHeadLink@CMacActorLink@@0V1@A ; CMacActorLink::sHeadLink
	je	SHORT $L26453
	push	edi
	mov	edi, DWORD PTR _inChunk$[esp+4]
$L26439:

; 1186 : 	{
; 1187 : 		if (link->GetActor())

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $L12987

; 1188 : 			link->GetActor()->RemoveReferencesTo(inChunk);

	push	edi
	call	?RemoveReferencesTo@OMacActor@@QAE_NPAVOCpjChunk@@@Z ; OMacActor::RemoveReferencesTo
$L12987:
	mov	esi, DWORD PTR [esi+8]
	cmp	esi, OFFSET FLAT:?sHeadLink@CMacActorLink@@0V1@A ; CMacActorLink::sHeadLink
	jne	SHORT $L26439
	pop	edi
$L26453:

; 1189 : 	}
; 1190 : 	return(1);

	mov	al, 1
	pop	esi

; 1191 : }

	ret	0
?RemoveAllReferencesTo@OMacActor@@SA_NPAVOCpjChunk@@@Z ENDP ; OMacActor::RemoveAllReferencesTo
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT _$E99
_TEXT	SEGMENT
_$E99	PROC NEAR					; COMDAT
	mov	ecx, OFFSET FLAT:?OMacChannel_objClassInstance@@3VCObjClass@@A
	call	??0CObjClass@@QAE@XZ			; CObjClass::CObjClass
	push	OFFSET FLAT:_$E97
	call	_atexit
	pop	ecx
	ret	0
_$E99	ENDP
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT _$E97
_TEXT	SEGMENT
_$E97	PROC NEAR					; COMDAT
	mov	ecx, OFFSET FLAT:?OMacChannel_objClassInstance@@3VCObjClass@@A
	jmp	??1CObjClass@@QAE@XZ			; CObjClass::~CObjClass
_$E97	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0M@BDBM@OMacChannel?$AA@			; `string'
PUBLIC	?New@OMacChannel@@SAPAV1@PAVOObject@@PAVCObjClass@@@Z ; OMacChannel::New
;	COMDAT ??_C@_0M@BDBM@OMacChannel?$AA@
_DATA	SEGMENT
??_C@_0M@BDBM@OMacChannel?$AA@ DB 'OMacChannel', 00H	; `string'
; Function compile flags: /Ogty
_DATA	ENDS
;	COMDAT _$E102
_TEXT	SEGMENT
_$E102	PROC NEAR					; COMDAT
	push	0
	push	OFFSET FLAT:?New@OMacChannel@@SAPAV1@PAVOObject@@PAVCObjClass@@@Z ; OMacChannel::New
	push	OFFSET FLAT:??_C@_07ILDF@OObject?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0M@BDBM@OMacChannel?$AA@ ; `string'
	push	OFFSET FLAT:?OMacChannel_objClassInstance@@3VCObjClass@@A ; OMacChannel_objClassInstance
	call	?OBJ_ConstructClass@@YAPAVCObjClass@@PAV1@PBD1P6APAVOObject@@PAV2@0@ZK@Z ; OBJ_ConstructClass
	add	esp, 20					; 00000014H
	mov	DWORD PTR ?staticObjClass@OMacChannel@@0PAVCObjClass@@A, eax ; OMacChannel::staticObjClass
	ret	0
_$E102	ENDP
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT _$E107
_TEXT	SEGMENT
_$E107	PROC NEAR					; COMDAT
	mov	ecx, OFFSET FLAT:?OMacSequenceChannel_objClassInstance@@3VCObjClass@@A
	call	??0CObjClass@@QAE@XZ			; CObjClass::CObjClass
	push	OFFSET FLAT:_$E105
	call	_atexit
	pop	ecx
	ret	0
_$E107	ENDP
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT _$E105
_TEXT	SEGMENT
_$E105	PROC NEAR					; COMDAT
	mov	ecx, OFFSET FLAT:?OMacSequenceChannel_objClassInstance@@3VCObjClass@@A
	jmp	??1CObjClass@@QAE@XZ			; CObjClass::~CObjClass
_$E105	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BE@NKOE@OMacSequenceChannel?$AA@		; `string'
PUBLIC	?New@OMacSequenceChannel@@SAPAV1@PAVOObject@@PAVCObjClass@@@Z ; OMacSequenceChannel::New
;	COMDAT ??_C@_0BE@NKOE@OMacSequenceChannel?$AA@
_DATA	SEGMENT
??_C@_0BE@NKOE@OMacSequenceChannel?$AA@ DB 'OMacSequenceChannel', 00H ; `string'
; Function compile flags: /Ogty
_DATA	ENDS
;	COMDAT _$E110
_TEXT	SEGMENT
_$E110	PROC NEAR					; COMDAT
	push	0
	push	OFFSET FLAT:?New@OMacSequenceChannel@@SAPAV1@PAVOObject@@PAVCObjClass@@@Z ; OMacSequenceChannel::New
	push	OFFSET FLAT:??_C@_0M@BDBM@OMacChannel?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0BE@NKOE@OMacSequenceChannel?$AA@ ; `string'
	push	OFFSET FLAT:?OMacSequenceChannel_objClassInstance@@3VCObjClass@@A ; OMacSequenceChannel_objClassInstance
	call	?OBJ_ConstructClass@@YAPAVCObjClass@@PAV1@PBD1P6APAVOObject@@PAV2@0@ZK@Z ; OBJ_ConstructClass
	add	esp, 20					; 00000014H
	mov	DWORD PTR ?staticObjClass@OMacSequenceChannel@@0PAVCObjClass@@A, eax ; OMacSequenceChannel::staticObjClass
	ret	0
_$E110	ENDP
_TEXT	ENDS
PUBLIC	?rot1@?1???0VQuat3@@QAE@ABVVAxes3@@@Z@4PAHA	; rot1
PUBLIC	__real@0000000000000000
PUBLIC	__real@3f000000
PUBLIC	?EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z ; OMacSequenceChannel::EvalBones
PUBLIC	??0VCoords3@@QAE@XZ				; VCoords3::VCoords3
PUBLIC	??4VCoords3@@QAEAAV0@ABV0@@Z			; VCoords3::operator=
EXTRN	__ftol:NEAR
EXTRN	__CIacos:NEAR
EXTRN	__imp___finite:NEAR
_BSS	SEGMENT
?frmCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A DB 07800H DUP (?) ; frmCoords
?$S112@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4EA DB 01H DUP (?) ; ?$S112@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4EA
	ALIGN	4

?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A DB 07800H DUP (?) ; frmDeltaCoords
?bonesUsed@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PA_NA DB 0100H DUP (?) ; bonesUsed
?boneMap@?O@??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAPAVCMacBone@@A DD 0100H DUP (?) ; boneMap
_BSS	ENDS
;	COMDAT __real@0000000000000000
; File C:\duke4\Cannibal\VecMain.h
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT ?rot1@?1???0VQuat3@@QAE@ABVVAxes3@@@Z@4PAHA
_DATA	SEGMENT
?rot1@?1???0VQuat3@@QAE@ABVVAxes3@@@Z@4PAHA DD 01H	; rot1
	DD	02H
	DD	00H
; Function compile flags: /Ogty
; File C:\duke4\Cannibal\MacMain.cpp
_DATA	ENDS
;	COMDAT ?EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z
_TEXT	SEGMENT
$T28450 = -116
$T27443 = -512
$T27444 = -488
$T27445 = -476
_b$28495 = -912
$T28501 = -900
$T26494 = -680
$T26497 = -680
$T26498 = -140
$T26499 = -200
$T26500 = -152
$T26501 = -104
$T26502 = -188
$T26503 = -56
$T28536 = -44
$T26504 = -696
$T28537 = -380
$T26505 = -820
$T28538 = -368
$T26507 = -680
$T26508 = -236
$T26509 = -320
$T26510 = -344
$T26511 = -212
$T26512 = -404
$T26513 = -552
$T26514 = -804
_w2$28565 = -904
_xx2$28566 = -704
_yy2$28567 = -908
_zz2$28568 = -856
_xy2$28570 = -852
_xz2$28571 = -912
$T26539 = -896
_xw2$28572 = -900
_yw2$28574 = -840
_zw2$28575 = -844
$T26545 = -896
$T27624 = -552
$T27625 = -164
$T27626 = -588
$T27633 = -512
$T27634 = -488
$T27635 = -476
_adjF$28012 = -740
_c$28014 = -788
_adjF$29035 = -588
_sq$28019 = -912
_q$28020 = -280
_c$29037 = -500
_q$29043 = -264
_b$28044 = -912
$T27065 = -904
$T29098 = -896
$T29103 = -896
$T29108 = -896
$T29113 = -896
_hash$27095 = -896
_i$27096 = -876
_adjF$28133 = -776
_c$28135 = -524
_q$28141 = -296
_b$28165 = -912
$T28197 = -896
$T28202 = -896
$T28207 = -896
$T28212 = -896
$T27197 = -896
$T27198 = -788
$T27199 = -836
_z$27221 = -876
_w2$27226 = -904
_xx2$27227 = -852
_yy2$27228 = -844
_zz2$27229 = -900
_xy2$27231 = -848
_xz2$27232 = -908
_xw2$27233 = -856
_yz2$27234 = -840
_inActor$ = 8
_this$ = -824
_i$ = -884
_frameAlpha$ = -880
_frm$ = -704
_q2temp$29299 = -620
_om$29300 = -908
_cosom$29301 = -900
$T29310 = -32
$T29311 = -356
$T29312 = -512
$T29313 = -488
$T29314 = -80
$T29315 = -476
$T29316 = -836
_fi$29321 = -896
_fi$29324 = -896
_fi$29327 = -896
_fi$29330 = -896
$T29350 = -128
_srcC$ = -464
_srcQ$ = -872
_finalQ$ = -540
_b$29396 = -912
$T29402 = -912
$T29403 = -848
_q2temp$28398 = -604
_om$28399 = -908
_cosom$28400 = -908
$T28409 = -16
$T28410 = -392
$T28411 = -176
$T28412 = -92
$T28413 = -68
$T28414 = -224
$T28415 = -248
_fi$28420 = -896
_fi$28423 = -896
_fi$28426 = -896
_z2$29444 = -904
_w2$29445 = -912
_fi$28429 = -896
_xx2$29446 = -896
_yy2$29447 = -908
_zz2$29448 = -844
_xy2$29450 = -704
_xz2$29451 = -856
_xw2$29452 = -900
_yz2$29453 = -840
_zw2$29455 = -852
$T29457 = -164
$T29458 = -332
$T29459 = -308
?EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z PROC NEAR ; OMacSequenceChannel::EvalBones, COMDAT
; _this$ = ecx

; 1204 : {

	sub	esp, 912				; 00000390H
	push	ebx
	push	ebp
	push	esi

; 1205 : 	NDword i;
; 1206 : 	
; 1207 : 	if (!mSequence || !inActor || !inActor->mSkeleton)

	mov	esi, DWORD PTR [ecx+56]
	xor	ebx, ebx
	push	edi
	cmp	esi, ebx
	mov	DWORD PTR _this$[esp+928], ecx
	je	$L13030
	mov	ebp, DWORD PTR _inActor$[esp+924]
	cmp	ebp, ebx
	je	$L13030
	cmp	DWORD PTR [ebp+144], ebx
	je	$L13030

; 1209 : 
; 1210 : 	NFloat frameF = mTime * mSequence->m_Frames.GetCount();

	mov	edi, DWORD PTR [esi+80]
	mov	DWORD PTR -896+[esp+932], ebx
	mov	DWORD PTR -896+[esp+928], edi
	fild	QWORD PTR -896+[esp+928]
	fmul	DWORD PTR [ecx+60]

; 1211 : 	NDword frameI = (NDword)frameF;

	fld	ST(0)
	call	__ftol

; 1212 : 	NFloat frameAlpha = frameF - frameI;
; 1213 : 	CCpjSeqFrame* frm[2];
; 1214 : 	frm[0] = &mSequence->m_Frames[frameI % mSequence->m_Frames.GetCount()];

	xor	edx, edx
	mov	ecx, eax
	div	edi
	mov	esi, DWORD PTR [esi+76]
	mov	DWORD PTR -896+[esp+928], ecx
	mov	DWORD PTR -896+[esp+932], ebx
	fild	QWORD PTR -896+[esp+928]
	fsubr	ST(0), ST(1)
	fstp	DWORD PTR _frameAlpha$[esp+928]
	fstp	ST(0)
	lea	eax, DWORD PTR [edx+edx*2]
	lea	edx, DWORD PTR [edx+eax*4]
	lea	eax, DWORD PTR [esi+edx*4]

; 1215 : 	frm[1] = &mSequence->m_Frames[(frameI+1) % mSequence->m_Frames.GetCount()];

	xor	edx, edx
	mov	DWORD PTR _frm$[esp+928], eax
	lea	eax, DWORD PTR [ecx+1]
	div	edi

; 1216 : 
; 1217 : 	if (frm[0]->vertFrameName.Len() || frm[1]->vertFrameName.Len())

	mov	eax, DWORD PTR _frm$[esp+928]
	mov	edi, DWORD PTR [eax]
	cmp	edi, ebx
	lea	ecx, DWORD PTR [edx+edx*2]
	lea	edx, DWORD PTR [edx+ecx*4]
	lea	esi, DWORD PTR [esi+edx*4]
	mov	DWORD PTR _frm$[esp+932], esi
	je	SHORT $L30780
	or	ecx, -1
	xor	eax, eax
	repne scasb
	not	ecx
	dec	ecx
	mov	DWORD PTR $T26539[esp+928], ecx
	jne	$L13030
$L30780:
	mov	esi, DWORD PTR [esi]
	cmp	esi, ebx
	je	SHORT $L30781
	mov	edi, esi
	or	ecx, -1
	xor	eax, eax
	repne scasb
	not	ecx
	dec	ecx
	mov	DWORD PTR $T26545[esp+928], ecx
	jne	$L13030
$L30781:

; 1218 : 		return(0); // frame-based frames, ignore
; 1219 : 
; 1220 : 	static VCoords3 frmCoords[2][256], frmDeltaCoords[2][256];

	mov	al, BYTE PTR ?$S112@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4EA
	test	al, 1
	jne	SHORT $L13042
	or	al, 1
	mov	esi, OFFSET FLAT:?frmCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A
	mov	BYTE PTR ?$S112@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4EA, al
	mov	edi, 512				; 00000200H
$L26548:
	mov	ecx, esi
	call	??0VCoords3@@QAE@XZ			; VCoords3::VCoords3
	add	esi, 60					; 0000003cH
	dec	edi
	jne	SHORT $L26548
	push	OFFSET FLAT:_$E113
	call	_atexit
	add	esp, 4
$L13042:
	mov	al, BYTE PTR ?$S112@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4EA
	test	al, 2
	jne	SHORT $L13047
	or	al, 2
	mov	esi, OFFSET FLAT:?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A
	mov	BYTE PTR ?$S112@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4EA, al
	mov	edi, 512				; 00000200H
$L26556:
	mov	ecx, esi
	call	??0VCoords3@@QAE@XZ			; VCoords3::VCoords3
	add	esi, 60					; 0000003cH
	dec	edi
	jne	SHORT $L26556
	push	OFFSET FLAT:_$E114
	call	_atexit
	add	esp, 4
$L13047:

; 1221 : 	static NBool bonesUsed[256];
; 1222 : 
; 1223 : 	// initialize all bone transforms based on blend mode
; 1224 : 	switch(mBlendMode)
; 1225 : 	{

	mov	ecx, DWORD PTR _this$[esp+928]
	mov	eax, DWORD PTR [ecx+68]
	sub	eax, ebx
	je	$L13056
	dec	eax
	jne	$L13059

; 1233 : 			}
; 1234 : 		}
; 1235 : 		break;
; 1236 : 	case MACSEQBLEND_ADD:
; 1237 : 		{
; 1238 : 			for (i=0;i<inActor->mActorBones.GetCount();i++)

	mov	eax, DWORD PTR [ebp+276]
	mov	DWORD PTR _i$[esp+928], ebx
	cmp	eax, ebx
	jbe	$L13059
	mov	DWORD PTR -904+[esp+928], ebx
	xor	esi, esi
	mov	edi, 1065353216				; 3f800000H
$L13062:

; 1239 : 			{
; 1240 : 				frmCoords[0][i] = frmCoords[1][i] = inActor->mActorBones[i].GetCoords(false); // use current transforms

	mov	edx, DWORD PTR [ebp+272]
	mov	ecx, DWORD PTR -904+[esp+928]
	add	edx, ecx
	lea	ecx, DWORD PTR $T26494[esp+928]
	push	edx
	call	??0VCoords3@@QAE@ABV0@@Z		; VCoords3::VCoords3
	mov	eax, DWORD PTR $T26494[esp+928]
	mov	ecx, DWORD PTR $T26494[esp+932]
	mov	edx, DWORD PTR $T26494[esp+936]
	mov	DWORD PTR ?frmCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[esi+15360], eax
	mov	eax, DWORD PTR $T26494[esp+940]
	mov	DWORD PTR ?frmCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[esi+15364], ecx
	mov	ecx, DWORD PTR $T26494[esp+944]
	mov	DWORD PTR ?frmCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[esi+15368], edx
	mov	edx, DWORD PTR $T26494[esp+948]
	mov	DWORD PTR ?frmCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[esi+15372], eax
	mov	eax, DWORD PTR $T26494[esp+952]
	mov	DWORD PTR ?frmCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[esi+15376], ecx
	mov	ecx, DWORD PTR $T26494[esp+956]
	mov	DWORD PTR ?frmCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[esi+15380], edx
	mov	edx, DWORD PTR $T26494[esp+960]
	mov	DWORD PTR ?frmCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[esi+15384], eax
	mov	eax, DWORD PTR $T26494[esp+964]
	mov	DWORD PTR ?frmCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[esi+15388], ecx
	mov	ecx, DWORD PTR $T26494[esp+968]
	mov	DWORD PTR ?frmCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[esi+15392], edx
	mov	edx, DWORD PTR $T26494[esp+972]
	mov	DWORD PTR ?frmCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[esi+15396], eax
	mov	eax, DWORD PTR $T26494[esp+976]
	mov	DWORD PTR ?frmCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[esi+15400], ecx
	mov	ecx, DWORD PTR $T26494[esp+980]
	mov	DWORD PTR ?frmCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[esi+15404], edx
	mov	edx, DWORD PTR $T26494[esp+984]
	mov	DWORD PTR ?frmCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[esi+15408], eax
	mov	DWORD PTR ?frmCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[esi+15412], ecx
	mov	DWORD PTR ?frmCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[esi+15416], edx
	mov	eax, DWORD PTR ?frmCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[esi+15360]

; 1241 : 				frmDeltaCoords[0][i] = frmDeltaCoords[1][i] = VCoords3();

	mov	DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[esi+15360], edi
	mov	DWORD PTR ?frmCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[esi], eax
	mov	ecx, DWORD PTR ?frmCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[esi+15364]
	mov	DWORD PTR ?frmCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[esi+4], ecx
	mov	edx, DWORD PTR ?frmCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[esi+15368]
	mov	DWORD PTR ?frmCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[esi+8], edx
	mov	eax, DWORD PTR ?frmCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[esi+15372]
	mov	DWORD PTR ?frmCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[esi+12], eax
	mov	ecx, DWORD PTR ?frmCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[esi+15376]
	mov	DWORD PTR ?frmCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[esi+16], ecx
	mov	edx, DWORD PTR ?frmCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[esi+15380]
	mov	DWORD PTR ?frmCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[esi+20], edx
	mov	eax, DWORD PTR ?frmCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[esi+15384]
	mov	DWORD PTR ?frmCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[esi+24], eax
	mov	ecx, DWORD PTR ?frmCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[esi+15388]
	mov	DWORD PTR ?frmCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[esi+28], ecx
	mov	edx, DWORD PTR ?frmCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[esi+15392]
	mov	DWORD PTR ?frmCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[esi+32], edx
	mov	eax, DWORD PTR ?frmCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[esi+15396]
	mov	DWORD PTR ?frmCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[esi+36], eax
	mov	ecx, DWORD PTR ?frmCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[esi+15400]
	mov	DWORD PTR ?frmCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[esi+40], ecx
	mov	edx, DWORD PTR ?frmCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[esi+15404]
	mov	DWORD PTR ?frmCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[esi+44], edx
	mov	eax, DWORD PTR ?frmCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[esi+15408]
	mov	DWORD PTR ?frmCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[esi+48], eax
	mov	ecx, DWORD PTR ?frmCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[esi+15412]
	mov	DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[esi+15364], ebx
	mov	DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[esi+15368], ebx
	mov	DWORD PTR ?frmCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[esi+52], ecx
	mov	edx, DWORD PTR ?frmCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[esi+15416]
	mov	DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[esi+15372], ebx
	mov	DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[esi+15376], edi
	mov	DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[esi+15380], ebx
	mov	DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[esi+15384], ebx
	mov	DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[esi+15388], ebx
	mov	DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[esi+15392], edi
	mov	DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[esi+15396], ebx
	mov	DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[esi+15400], ebx
	mov	DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[esi+15404], ebx
	mov	DWORD PTR ?frmCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[esi+56], edx
	mov	DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[esi+15408], edi
	mov	DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[esi+15412], edi
	mov	DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[esi+15416], edi
	mov	eax, DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[esi+15360]
	mov	DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[esi], eax
	mov	ecx, DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[esi+15364]
	mov	DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[esi+4], ecx
	mov	edx, DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[esi+15368]
	mov	DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[esi+8], edx
	mov	eax, DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[esi+15372]
	mov	DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[esi+12], eax
	mov	ecx, DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[esi+15376]
	mov	DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[esi+16], ecx
	mov	edx, DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[esi+15380]
	mov	DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[esi+20], edx
	mov	eax, DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[esi+15384]
	mov	DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[esi+24], eax
	mov	ecx, DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[esi+15388]
	mov	DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[esi+28], ecx
	mov	edx, DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[esi+15392]
	mov	DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[esi+32], edx
	mov	eax, DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[esi+15396]
	mov	DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[esi+36], eax
	mov	ecx, DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[esi+15400]
	mov	DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[esi+40], ecx
	mov	edx, DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[esi+15404]
	mov	DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[esi+44], edx
	mov	eax, DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[esi+15408]
	mov	DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[esi+48], eax
	mov	ecx, DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[esi+15412]

; 1242 : 				bonesUsed[i] = 0;

	mov	eax, DWORD PTR _i$[esp+928]
	mov	DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[esi+52], ecx
	mov	ecx, DWORD PTR -904+[esp+928]
	mov	edx, DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[esi+15416]
	add	ecx, 140				; 0000008cH
	mov	DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[esi+56], edx
	mov	BYTE PTR ?bonesUsed@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PA_NA[eax], 0
	mov	DWORD PTR -904+[esp+928], ecx
	mov	ecx, DWORD PTR [ebp+276]
	inc	eax
	add	esi, 60					; 0000003cH
	cmp	eax, ecx
	mov	DWORD PTR _i$[esp+928], eax
	jb	$L13062

; 1243 : 			}
; 1244 : 		}
; 1245 : 		break;

	jmp	$L13059
$L13056:

; 1226 : 	case MACSEQBLEND_SET:
; 1227 : 		{
; 1228 : 			for (i=0;i<inActor->mActorBones.GetCount();i++)

	mov	eax, DWORD PTR [ebp+276]
	xor	edx, edx
	cmp	eax, ebx
	jbe	$L13059
	mov	DWORD PTR -904+[esp+928], ebx
	xor	eax, eax
	mov	edi, 1065353216				; 3f800000H
$L13057:

; 1229 : 			{
; 1230 : 				frmCoords[0][i] = frmCoords[1][i] = inActor->mActorBones[i].mSklBone->baseCoords; // use base transforms

	mov	ecx, DWORD PTR [ebp+272]
	mov	esi, DWORD PTR -904+[esp+928]
	mov	ecx, DWORD PTR [ecx+esi+124]
	mov	esi, DWORD PTR [ecx+12]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR ?frmCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+15360], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR ?frmCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+15364], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR ?frmCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+15368], esi
	mov	esi, DWORD PTR [ecx+12]
	mov	DWORD PTR ?frmCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+15372], esi
	mov	esi, DWORD PTR [ecx+16]
	mov	DWORD PTR ?frmCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+15376], esi
	mov	esi, DWORD PTR [ecx+20]
	mov	DWORD PTR ?frmCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+15380], esi
	mov	esi, DWORD PTR [ecx+24]
	mov	DWORD PTR ?frmCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+15384], esi
	mov	esi, DWORD PTR [ecx+28]
	mov	DWORD PTR ?frmCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+15388], esi
	mov	esi, DWORD PTR [ecx+32]
	mov	DWORD PTR ?frmCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+15392], esi
	mov	esi, DWORD PTR [ecx+36]
	mov	DWORD PTR ?frmCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+15396], esi
	mov	esi, DWORD PTR [ecx+40]
	mov	DWORD PTR ?frmCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+15400], esi
	mov	esi, DWORD PTR [ecx+44]
	mov	DWORD PTR ?frmCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+15404], esi
	mov	esi, DWORD PTR [ecx+48]
	mov	DWORD PTR ?frmCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+15408], esi
	mov	esi, DWORD PTR [ecx+52]
	mov	DWORD PTR ?frmCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+15412], esi
	mov	ecx, DWORD PTR [ecx+56]
	mov	DWORD PTR ?frmCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+15416], ecx
	mov	ecx, DWORD PTR ?frmCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+15360]
	mov	DWORD PTR ?frmCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax], ecx
	mov	ecx, DWORD PTR ?frmCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+15364]
	mov	DWORD PTR ?frmCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+4], ecx
	mov	ecx, DWORD PTR ?frmCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+15368]
	mov	DWORD PTR ?frmCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+8], ecx
	mov	ecx, DWORD PTR ?frmCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+15372]
	mov	DWORD PTR ?frmCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+12], ecx
	mov	ecx, DWORD PTR ?frmCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+15376]
	mov	DWORD PTR ?frmCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+16], ecx
	mov	ecx, DWORD PTR ?frmCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+15380]
	mov	DWORD PTR ?frmCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+20], ecx
	mov	ecx, DWORD PTR ?frmCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+15384]
	mov	DWORD PTR ?frmCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+24], ecx
	mov	ecx, DWORD PTR ?frmCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+15388]
	mov	DWORD PTR ?frmCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+28], ecx
	mov	ecx, DWORD PTR ?frmCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+15392]
	mov	DWORD PTR ?frmCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+32], ecx
	mov	ecx, DWORD PTR ?frmCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+15396]
	mov	DWORD PTR ?frmCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+36], ecx
	mov	ecx, DWORD PTR ?frmCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+15400]
	mov	DWORD PTR ?frmCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+40], ecx
	mov	ecx, DWORD PTR ?frmCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+15404]
	mov	DWORD PTR ?frmCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+44], ecx
	mov	ecx, DWORD PTR ?frmCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+15408]
	mov	DWORD PTR ?frmCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+48], ecx
	mov	ecx, DWORD PTR ?frmCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+15412]

; 1231 : 				frmDeltaCoords[0][i] = frmDeltaCoords[1][i] = VCoords3();

	mov	DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+15360], edi
	mov	DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+15364], ebx
	mov	DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+15368], ebx
	mov	DWORD PTR ?frmCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+52], ecx
	mov	ecx, DWORD PTR ?frmCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+15416]
	mov	DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+15372], ebx
	mov	DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+15376], edi
	mov	DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+15380], ebx
	mov	DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+15384], ebx
	mov	DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+15388], ebx
	mov	DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+15392], edi
	mov	DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+15396], ebx
	mov	DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+15400], ebx
	mov	DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+15404], ebx
	mov	DWORD PTR ?frmCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+56], ecx
	mov	DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+15408], edi
	mov	DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+15412], edi
	mov	DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+15416], edi
	mov	ecx, DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+15360]
	mov	DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax], ecx
	mov	ecx, DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+15364]

; 1232 : 				bonesUsed[i] = 0;

	mov	BYTE PTR ?bonesUsed@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PA_NA[edx], 0
	mov	DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+4], ecx
	mov	ecx, DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+15368]
	mov	DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+8], ecx
	mov	ecx, DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+15372]
	mov	DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+12], ecx
	mov	ecx, DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+15376]
	mov	DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+16], ecx
	mov	ecx, DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+15380]
	mov	DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+20], ecx
	mov	ecx, DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+15384]
	mov	DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+24], ecx
	mov	ecx, DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+15388]
	mov	DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+28], ecx
	mov	ecx, DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+15392]
	mov	DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+32], ecx
	mov	ecx, DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+15396]
	mov	DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+36], ecx
	mov	ecx, DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+15400]
	mov	DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+40], ecx
	mov	ecx, DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+15404]
	mov	DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+44], ecx
	mov	ecx, DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+15408]
	mov	DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+48], ecx
	mov	ecx, DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+15412]
	mov	DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+52], ecx
	mov	ecx, DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+15416]
	mov	DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+56], ecx
	mov	ecx, DWORD PTR -904+[esp+928]
	add	ecx, 140				; 0000008cH
	inc	edx
	mov	DWORD PTR -904+[esp+928], ecx
	mov	ecx, DWORD PTR [ebp+276]
	add	eax, 60					; 0000003cH
	cmp	edx, ecx
	jb	$L13057
$L13059:

; 1246 : 	}
; 1247 : 	
; 1248 : 	// map bone information from sequence
; 1249 : 	static CMacBone* boneMap[256];
; 1250 : 	for (i=0;i<mSequence->m_BoneInfo.GetCount();i++)

	mov	edx, DWORD PTR _this$[esp+928]
	mov	DWORD PTR _i$[esp+928], ebx
	mov	eax, DWORD PTR [edx+56]
	cmp	DWORD PTR [eax+112], ebx
	jbe	$L13071
$L13069:
	mov	eax, DWORD PTR [eax+108]
	mov	ecx, DWORD PTR _i$[esp+928]
	lea	eax, DWORD PTR [eax+ecx*8]

; 1251 : 		boneMap[i] = inActor->FindBone(*mSequence->m_BoneInfo[i].name);

	mov	eax, DWORD PTR [eax]
	cmp	eax, ebx
	je	$L27069
	cmp	eax, ebx
	mov	DWORD PTR $T27065[esp+928], eax
	je	SHORT $L27094
$L30782:
	cmp	DWORD PTR [ebp+144], ebx
	je	SHORT $L27094
	push	eax
	call	?STR_CalcHash@@YAKPAD@Z			; STR_CalcHash
	mov	DWORD PTR _hash$27095[esp+932], eax
	mov	eax, DWORD PTR [ebp+276]
	add	esp, 4
	cmp	eax, ebx
	mov	DWORD PTR _i$27096[esp+928], ebx
	jbe	SHORT $L27094
	xor	esi, esi
$L27097:
	mov	edi, DWORD PTR [ebp+272]
	mov	ecx, DWORD PTR _hash$27095[esp+928]
	add	edi, esi
	mov	eax, DWORD PTR [edi+124]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, ecx
	jne	SHORT $L27098
	mov	eax, DWORD PTR [eax]
	cmp	eax, ebx
	jne	SHORT $L27110
	mov	eax, OFFSET FLAT:??_C@_00A@?$AA@	; `string'
$L27110:
	mov	ecx, DWORD PTR $T27065[esp+928]
	push	ecx
	push	eax
	call	DWORD PTR __imp__stricmp
	add	esp, 8
	test	eax, eax
	je	SHORT $L27092
$L27098:
	mov	eax, DWORD PTR _i$27096[esp+928]
	mov	ecx, DWORD PTR [ebp+276]
	inc	eax
	add	esi, 140				; 0000008cH
	cmp	eax, ecx
	mov	DWORD PTR _i$27096[esp+928], eax
	jb	SHORT $L27097
$L27094:
	xor	edi, edi
$L27092:
	mov	ecx, DWORD PTR _i$[esp+928]
	mov	edx, DWORD PTR _this$[esp+928]
	mov	DWORD PTR ?boneMap@?O@??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAPAVCMacBone@@A[ecx*4], edi
	mov	eax, DWORD PTR [edx+56]
	inc	ecx
	mov	edx, DWORD PTR [eax+112]
	mov	DWORD PTR _i$[esp+928], ecx
	cmp	ecx, edx
	jb	$L13069
$L13071:

; 1252 : 
; 1253 : 	// run through keyframe bone information and build up structure-relative transforms
; 1254 : 	CMacBone* bone;
; 1255 : 	NDword index;
; 1256 : 	for (NDword ifrm=0;ifrm<2;ifrm++)

	lea	eax, DWORD PTR _frm$[esp+928]
	xor	edi, edi
	mov	DWORD PTR -912+[esp+928], eax
$L13075:

; 1257 : 	{
; 1258 : 		for (i=0;i<frm[ifrm]->translates.GetCount();i++)

	mov	ecx, DWORD PTR -912+[esp+928]
	xor	ebx, ebx
	mov	DWORD PTR _i$[esp+928], ebx
	mov	ecx, DWORD PTR [ecx]
	cmp	DWORD PTR [ecx+8], ebx
	jbe	SHORT $L13080
$L13078:

; 1259 : 		{				
; 1260 : 			//bone = inActor->FindBone(*mSequence->m_BoneInfo[frm[ifrm]->translates[i].boneIndex].name);
; 1261 : 			bone = boneMap[frm[ifrm]->translates[i].boneIndex];

	mov	edx, DWORD PTR [ecx+4]
	xor	eax, eax
	mov	ax, WORD PTR [ebx+edx]
	mov	eax, DWORD PTR ?boneMap@?O@??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAPAVCMacBone@@A[eax*4]

; 1262 : 			if (!bone)

	test	eax, eax
	je	SHORT $L13079

; 1263 : 				continue;
; 1264 : 			index = bone - &inActor->mActorBones[0];

	sub	eax, DWORD PTR [ebp+272]
	mov	esi, eax
	mov	eax, -368140053				; ea0ea0ebH
	imul	esi
	add	edx, esi
	sar	edx, 7
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	edx, eax

; 1265 : 			bonesUsed[index] = 1;

	mov	BYTE PTR ?bonesUsed@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PA_NA[edx], 1

; 1266 : 			frmDeltaCoords[ifrm][index].t = frm[ifrm]->translates[i].translate;

	mov	eax, DWORD PTR [ecx+4]
	add	edx, edi
	mov	esi, DWORD PTR [ebx+eax+4]
	lea	eax, DWORD PTR [ebx+eax+4]
	lea	edx, DWORD PTR [edx+edx*2]
	lea	edx, DWORD PTR [edx+edx*4]
	lea	edx, DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[edx*4+36]
	mov	DWORD PTR [edx], esi
	mov	esi, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], esi
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax
$L13079:
	mov	eax, DWORD PTR _i$[esp+928]
	mov	edx, DWORD PTR [ecx+8]
	inc	eax
	add	ebx, 16					; 00000010H
	cmp	eax, edx
	mov	DWORD PTR _i$[esp+928], eax
	jb	SHORT $L13078
$L13080:

; 1267 : /*
; 1268 : 			NFloat desiredLength = mSequence->m_BoneInfo[frm[ifrm]->translates[i].boneIndex].srcLength;
; 1269 : 			NFloat actualLength = bone->mSklBone->length;
; 1270 : 			NFloat lengthScale = actualLength / desiredLength;
; 1271 : 			frmDeltaCoords[ifrm][index].t /= lengthScale;
; 1272 : */
; 1273 : 		}
; 1274 : 		for (i=0;i<frm[ifrm]->scales.GetCount();i++)

	mov	eax, DWORD PTR [ecx+40]
	mov	DWORD PTR _i$[esp+928], 0
	test	eax, eax
	jbe	SHORT $L13084
	xor	ebx, ebx
$L13082:

; 1275 : 		{
; 1276 : 			//bone = inActor->FindBone(*mSequence->m_BoneInfo[frm[ifrm]->scales[i].boneIndex].name);
; 1277 : 			bone = boneMap[frm[ifrm]->scales[i].boneIndex];

	mov	edx, DWORD PTR [ecx+36]
	xor	eax, eax
	mov	ax, WORD PTR [ebx+edx]
	mov	eax, DWORD PTR ?boneMap@?O@??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAPAVCMacBone@@A[eax*4]

; 1278 : 			if (!bone)

	test	eax, eax
	je	SHORT $L13083

; 1279 : 				continue;
; 1280 : 			index = bone - &inActor->mActorBones[0];

	sub	eax, DWORD PTR [ebp+272]
	mov	esi, eax
	mov	eax, -368140053				; ea0ea0ebH
	imul	esi
	add	edx, esi
	sar	edx, 7
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	edx, eax

; 1281 : 			bonesUsed[index] = 1;

	mov	BYTE PTR ?bonesUsed@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PA_NA[edx], 1

; 1282 : 			frmDeltaCoords[ifrm][index].s = frm[ifrm]->scales[i].scale;

	mov	eax, DWORD PTR [ecx+36]
	add	edx, edi
	mov	esi, DWORD PTR [ebx+eax+4]
	lea	eax, DWORD PTR [ebx+eax+4]
	lea	edx, DWORD PTR [edx+edx*2]
	lea	edx, DWORD PTR [edx+edx*4]
	lea	edx, DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[edx*4+48]
	mov	DWORD PTR [edx], esi
	mov	esi, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], esi
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax
$L13083:
	mov	eax, DWORD PTR _i$[esp+928]
	mov	edx, DWORD PTR [ecx+40]
	inc	eax
	add	ebx, 16					; 00000010H
	cmp	eax, edx
	mov	DWORD PTR _i$[esp+928], eax
	jb	SHORT $L13082
$L13084:

; 1283 : 		}
; 1284 : 		for (i=0;i<frm[ifrm]->rotates.GetCount();i++)

	mov	eax, DWORD PTR [ecx+24]
	mov	DWORD PTR _i$[esp+928], 0
	test	eax, eax
	jbe	$L13076
	xor	ebx, ebx
$L13086:

; 1285 : 		{
; 1286 : 			//bone = inActor->FindBone(*mSequence->m_BoneInfo[frm[ifrm]->rotates[i].boneIndex].name);
; 1287 : 			bone = boneMap[frm[ifrm]->rotates[i].boneIndex];

	mov	edx, DWORD PTR [ecx+20]
	xor	eax, eax
	mov	ax, WORD PTR [ebx+edx]
	mov	eax, DWORD PTR ?boneMap@?O@??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAPAVCMacBone@@A[eax*4]

; 1288 : 			if (!bone)

	test	eax, eax
	je	$L13087

; 1289 : 				continue;
; 1290 : 			index = bone - &inActor->mActorBones[0];

	sub	eax, DWORD PTR [ebp+272]
	mov	esi, eax
	mov	eax, -368140053				; ea0ea0ebH
	imul	esi
	add	edx, esi
	sar	edx, 7
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	edx, eax

; 1291 : 			bonesUsed[index] = 1;

	mov	BYTE PTR ?bonesUsed@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PA_NA[edx], 1

; 1292 : #if 0
; 1293 : 			VQuat3 q;
; 1294 : 			q.AxisAngle(VVec3(0,0,1), (float)frm[ifrm]->rotates[i].roll * M_PI / 32768.f); frmDeltaCoords[ifrm][index].r >>= q;
; 1295 : 			q.AxisAngle(VVec3(1,0,0), (float)frm[ifrm]->rotates[i].pitch * M_PI / 32768.f); frmDeltaCoords[ifrm][index].r >>= q;
; 1296 : 			q.AxisAngle(VVec3(0,1,0), (float)frm[ifrm]->rotates[i].yaw * M_PI / 32768.f); frmDeltaCoords[ifrm][index].r >>= q;
; 1297 : #else
; 1298 : #ifdef CPJ_SEQ_NOQUATOPT			
; 1299 : 			VEulers3 eulers;
; 1300 : 			eulers.r = (float)frm[ifrm]->rotates[i].roll * M_PI / 32768.f;
; 1301 : 			eulers.p = (float)frm[ifrm]->rotates[i].pitch * M_PI / 32768.f;
; 1302 : 			eulers.y = (float)frm[ifrm]->rotates[i].yaw * M_PI / 32768.f;
; 1303 : 			frmDeltaCoords[ifrm][index].r >>= (~eulers);
; 1304 : #else			
; 1305 : 			frmDeltaCoords[ifrm][index].r >>= frm[ifrm]->rotates[i].quat;

	mov	eax, DWORD PTR [ecx+20]
	fld	DWORD PTR [ebx+eax+8]
	fld	DWORD PTR [ebx+eax+12]
	mov	esi, DWORD PTR [ebx+eax+16]
	lea	eax, DWORD PTR [ebx+eax+8]
	fld	ST(0)
	fadd	ST(0), ST(1)
	mov	DWORD PTR _z$27221[esp+928], esi
	fld	DWORD PTR _z$27221[esp+928]
	fadd	ST(0), ST(0)
	fld	DWORD PTR [eax+12]
	fadd	ST(0), ST(0)
	fstp	DWORD PTR _w2$27226[esp+928]
	fld	ST(3)
	fadd	ST(0), ST(0)
	fmul	ST(0), ST(4)
	fstp	DWORD PTR _xx2$27227[esp+928]
	fld	ST(1)
	fmul	ST(0), ST(3)
	fstp	DWORD PTR _yy2$27228[esp+928]
	fld	DWORD PTR _z$27221[esp+928]
	fmul	ST(0), ST(1)
	fstp	DWORD PTR _zz2$27229[esp+928]
	fxch	ST(1)
	fmul	ST(0), ST(3)
	fstp	DWORD PTR _xy2$27231[esp+928]
	fld	ST(0)
	fmul	ST(0), ST(3)
	fstp	DWORD PTR _xz2$27232[esp+928]
	fld	DWORD PTR _w2$27226[esp+928]
	fmul	ST(0), ST(3)
	fstp	DWORD PTR _xw2$27233[esp+928]
	fmul	ST(0), ST(1)
	fstp	DWORD PTR _yz2$27234[esp+928]
	fld	DWORD PTR _w2$27226[esp+928]
	fmul	ST(0), ST(1)
	fstp	ST(2)
	fstp	ST(0)
	fld	DWORD PTR _w2$27226[esp+928]
	fmul	DWORD PTR _z$27221[esp+928]
	fld	DWORD PTR _zz2$27229[esp+928]
	fadd	DWORD PTR _yy2$27228[esp+928]
	fsubr	DWORD PTR __real@3f800000
	fstp	DWORD PTR $T27197[esp+928]
	fld	DWORD PTR _xy2$27231[esp+928]
	fadd	ST(0), ST(1)
	fstp	DWORD PTR $T27197[esp+932]
	fld	DWORD PTR _xz2$27232[esp+928]
	fsub	ST(0), ST(2)
	fstp	DWORD PTR $T27197[esp+936]
	fld	DWORD PTR _xy2$27231[esp+928]
	fsub	ST(0), ST(1)
	fstp	DWORD PTR $T27198[esp+928]
	fstp	ST(0)
	fld	DWORD PTR _zz2$27229[esp+928]
	fadd	DWORD PTR _xx2$27227[esp+928]
	fsubr	DWORD PTR __real@3f800000
	fstp	DWORD PTR $T27198[esp+932]
	fld	DWORD PTR _yz2$27234[esp+928]
	fadd	DWORD PTR _xw2$27233[esp+928]
	fstp	DWORD PTR $T27198[esp+936]
	fadd	DWORD PTR _xz2$27232[esp+928]
	fstp	DWORD PTR $T27199[esp+928]
	fld	DWORD PTR _yz2$27234[esp+928]
	fsub	DWORD PTR _xw2$27233[esp+928]
	fstp	DWORD PTR $T27199[esp+932]
	fld	DWORD PTR _yy2$27228[esp+928]
	fadd	DWORD PTR _xx2$27227[esp+928]
	lea	eax, DWORD PTR [edi+edx]
	fsubr	DWORD PTR __real@3f800000
	lea	eax, DWORD PTR [eax+eax*2]
	fstp	DWORD PTR $T27199[esp+936]
	fld	DWORD PTR $T27197[esp+936]
	lea	edx, DWORD PTR [eax+eax*4]
	fmul	DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[edx*4+32]
	fld	DWORD PTR $T27197[esp+932]
	fmul	DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[edx*4+28]
	lea	eax, DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[edx*4]
	faddp	ST(1), ST(0)
	fld	DWORD PTR $T27197[esp+928]
	fmul	DWORD PTR [eax+24]
	faddp	ST(1), ST(0)
	fld	DWORD PTR $T27198[esp+936]
	fmul	DWORD PTR [eax+32]
	fld	DWORD PTR $T27198[esp+932]
	fmul	DWORD PTR [eax+28]
	faddp	ST(1), ST(0)
	fld	DWORD PTR $T27198[esp+928]
	fmul	DWORD PTR [eax+24]
	faddp	ST(1), ST(0)
	fld	DWORD PTR $T27199[esp+936]
	fmul	DWORD PTR [eax+32]
	fld	DWORD PTR $T27199[esp+932]
	fmul	DWORD PTR [eax+28]
	faddp	ST(1), ST(0)
	fld	DWORD PTR $T27199[esp+928]
	fmul	DWORD PTR [eax+24]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR $T27443[esp+936]
	fld	DWORD PTR $T27197[esp+928]
	fmul	DWORD PTR [eax+12]
	fld	DWORD PTR $T27197[esp+936]
	fmul	DWORD PTR [eax+20]
	faddp	ST(1), ST(0)
	fld	DWORD PTR $T27197[esp+932]
	fmul	DWORD PTR [eax+16]
	faddp	ST(1), ST(0)
	fld	DWORD PTR $T27198[esp+928]
	fmul	DWORD PTR [eax+12]
	fld	DWORD PTR $T27198[esp+936]
	fmul	DWORD PTR [eax+20]
	faddp	ST(1), ST(0)
	fld	DWORD PTR $T27198[esp+932]
	fmul	DWORD PTR [eax+16]
	faddp	ST(1), ST(0)
	fld	DWORD PTR $T27199[esp+928]
	fmul	DWORD PTR [eax+12]
	fld	DWORD PTR $T27199[esp+936]
	fmul	DWORD PTR [eax+20]
	faddp	ST(1), ST(0)
	fld	DWORD PTR $T27199[esp+932]
	fmul	DWORD PTR [eax+16]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR $T27444[esp+936]
	fld	DWORD PTR $T27197[esp+928]
	fmul	DWORD PTR [eax]
	fld	DWORD PTR $T27197[esp+936]
	fmul	DWORD PTR [eax+8]
	faddp	ST(1), ST(0)
	fld	DWORD PTR $T27197[esp+932]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	fld	DWORD PTR $T27198[esp+928]
	fmul	DWORD PTR [eax]
	fld	DWORD PTR $T27198[esp+936]
	fmul	DWORD PTR [eax+8]
	faddp	ST(1), ST(0)
	fld	DWORD PTR $T27198[esp+932]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	fld	DWORD PTR $T27199[esp+928]
	fmul	DWORD PTR [eax]
	fld	DWORD PTR $T27199[esp+936]
	fmul	DWORD PTR [eax+8]
	faddp	ST(1), ST(0)
	fld	DWORD PTR $T27199[esp+932]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR $T27445[esp+936]
	mov	edx, DWORD PTR $T27445[esp+936]
	fxch	ST(1)
	fstp	DWORD PTR [eax]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR $T27444[esp+936]
	fstp	DWORD PTR [eax+4]
	fxch	ST(1)
	fstp	DWORD PTR [eax+12]
	mov	DWORD PTR [eax+20], edx
	mov	edx, DWORD PTR $T27443[esp+936]
	fstp	DWORD PTR [eax+16]
	fxch	ST(1)
	fstp	DWORD PTR [eax+24]
	mov	DWORD PTR [eax+32], edx
	fstp	DWORD PTR [eax+28]
$L13087:
	mov	eax, DWORD PTR _i$[esp+928]
	mov	edx, DWORD PTR [ecx+24]
	inc	eax
	add	ebx, 24					; 00000018H
	cmp	eax, edx
	mov	DWORD PTR _i$[esp+928], eax
	jb	$L13086
$L13076:

; 1252 : 
; 1253 : 	// run through keyframe bone information and build up structure-relative transforms
; 1254 : 	CMacBone* bone;
; 1255 : 	NDword index;
; 1256 : 	for (NDword ifrm=0;ifrm<2;ifrm++)

	mov	edx, DWORD PTR -912+[esp+928]
	add	edi, 256				; 00000100H
	add	edx, 4
	cmp	edi, 512				; 00000200H
	mov	DWORD PTR -912+[esp+928], edx
	jb	$L13075

; 1306 : #endif // CPJ_SEQ_NOQUATOPT
; 1307 : #endif // if 0
; 1308 : /*
; 1309 : 			NFloat desiredLength = mSequence->m_BoneInfo[frm[ifrm]->rotates[i].boneIndex].srcLength;
; 1310 : 			NFloat actualLength = bone->mSklBone->length;
; 1311 : 			NFloat lengthScale = actualLength / desiredLength;
; 1312 : 			q = VQuat3();
; 1313 : 			if (lengthScale < 1.f)
; 1314 : 				q.Slerp(VQuat3(VAxes3()), VQuat3(frmDeltaCoords[ifrm][index].r), 1.f-lengthScale, lengthScale, false);
; 1315 : 			else
; 1316 : 				q.Slerp(VQuat3(VAxes3()), VQuat3(frmDeltaCoords[ifrm][index].r), 0.f, lengthScale, false);
; 1317 : 			frmDeltaCoords[ifrm][index].r = q;
; 1318 : */
; 1319 : 		}
; 1320 : 	}
; 1321 : 
; 1322 : 	// extract skeleton relative transformations
; 1323 : 	for (ifrm=0;ifrm<2;ifrm++)

	xor	ebx, ebx
$L13091:

; 1324 : 	{
; 1325 : 		for (i=0;i<inActor->mActorBones.GetCount();i++)

	mov	eax, DWORD PTR [ebp+276]
	xor	edi, edi
	test	eax, eax
	jbe	$L13092
$L13094:

; 1326 : 		{
; 1327 : 			if (bonesUsed[i])

	mov	al, BYTE PTR ?bonesUsed@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PA_NA[edi]
	test	al, al
	je	$L13095

; 1328 : 				frmCoords[ifrm][i] = frmDeltaCoords[ifrm][i] << frmCoords[ifrm][i];

	lea	eax, DWORD PTR [ebx+edi]
	lea	eax, DWORD PTR [eax+eax*2]
	lea	eax, DWORD PTR [eax+eax*4]
	shl	eax, 2
	fld	DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+48]
	fmul	DWORD PTR ?frmCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+48]
	lea	esi, DWORD PTR ?frmCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax]
	fstp	DWORD PTR $T27624[esp+928]
	fld	DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+52]
	fmul	DWORD PTR [esi+52]
	fstp	DWORD PTR $T27624[esp+932]
	fld	DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+56]
	fmul	DWORD PTR [esi+56]
	fstp	DWORD PTR $T27624[esp+936]
	fld	DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+24]
	fmul	DWORD PTR [esi]
	fld	DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+32]
	fmul	DWORD PTR [esi+24]
	faddp	ST(1), ST(0)
	fld	DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+28]
	fmul	DWORD PTR [esi+12]
	faddp	ST(1), ST(0)
	fld	DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+32]
	fmul	DWORD PTR [esi+28]
	fld	DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+28]
	fmul	DWORD PTR [esi+16]
	faddp	ST(1), ST(0)
	fld	DWORD PTR [esi+4]
	fmul	DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+24]
	faddp	ST(1), ST(0)
	fld	DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+32]
	fmul	DWORD PTR [esi+32]
	fld	DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+28]
	fmul	DWORD PTR [esi+20]
	faddp	ST(1), ST(0)
	fld	DWORD PTR [esi+8]
	fmul	DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+24]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR $T27633[esp+936]
	fld	DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+20]
	fmul	DWORD PTR [esi+24]
	fld	DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+16]
	fmul	DWORD PTR [esi+12]
	faddp	ST(1), ST(0)
	fld	DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+12]
	fmul	DWORD PTR [esi]
	faddp	ST(1), ST(0)
	fld	DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+20]
	fmul	DWORD PTR [esi+28]
	fld	DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+16]
	fmul	DWORD PTR [esi+16]
	faddp	ST(1), ST(0)
	fld	DWORD PTR [esi+4]
	fmul	DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+12]
	faddp	ST(1), ST(0)
	fld	DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+20]
	fmul	DWORD PTR [esi+32]
	fld	DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+16]
	fmul	DWORD PTR [esi+20]
	faddp	ST(1), ST(0)
	fld	DWORD PTR [esi+8]
	fmul	DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+12]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR $T27634[esp+936]
	fld	DWORD PTR [esi]
	fmul	DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax]
	fld	DWORD PTR [esi+24]
	fmul	DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+8]
	mov	edx, DWORD PTR $T27634[esp+936]
	mov	DWORD PTR $T27626[esp+948], edx
	lea	edx, DWORD PTR $T27624[esp+928]
	faddp	ST(1), ST(0)
	fld	DWORD PTR [esi+12]
	fmul	DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+4]
	push	edx
	push	esi
	faddp	ST(1), ST(0)
	fld	DWORD PTR [esi+4]
	fmul	DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax]
	fld	DWORD PTR [esi+28]
	fmul	DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+8]
	faddp	ST(1), ST(0)
	fld	DWORD PTR [esi+16]
	fmul	DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+4]
	faddp	ST(1), ST(0)
	fld	DWORD PTR [esi+8]
	fmul	DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax]
	fld	DWORD PTR [esi+32]
	fmul	DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+8]
	faddp	ST(1), ST(0)
	fld	DWORD PTR [esi+20]
	fmul	DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+4]
	lea	eax, DWORD PTR ?frmDeltaCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A[eax+36]
	push	eax
	faddp	ST(1), ST(0)
	fstp	DWORD PTR $T27635[esp+948]
	fxch	ST(1)
	fstp	DWORD PTR $T27626[esp+940]
	mov	ecx, DWORD PTR $T27635[esp+948]
	fstp	DWORD PTR $T27626[esp+944]
	fxch	ST(1)
	fstp	DWORD PTR $T27626[esp+952]
	mov	DWORD PTR $T27626[esp+948], ecx
	mov	ecx, DWORD PTR $T27633[esp+948]
	fstp	DWORD PTR $T27626[esp+956]
	fxch	ST(1)
	fstp	DWORD PTR $T27626[esp+964]
	mov	DWORD PTR $T27626[esp+972], ecx
	lea	ecx, DWORD PTR $T27625[esp+940]
	fstp	DWORD PTR $T27626[esp+968]
	push	ecx
	call	??6@YA?AVVVec3@@ABV0@ABVVCoords3@@@Z	; operator<<
	add	esp, 12					; 0000000cH
	lea	edx, DWORD PTR $T27626[esp+932]
	lea	ecx, DWORD PTR $T26497[esp+932]
	push	eax
	push	edx
	call	??0VCoords3@@QAE@ABVVAxes3@@ABVVVec3@@1@Z ; VCoords3::VCoords3
	mov	eax, DWORD PTR $T26497[esp+928]
	mov	ecx, DWORD PTR $T26497[esp+932]
	mov	edx, DWORD PTR $T26497[esp+936]
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR $T26497[esp+940]
	mov	DWORD PTR [esi+4], ecx
	mov	ecx, DWORD PTR $T26497[esp+944]
	mov	DWORD PTR [esi+8], edx
	mov	edx, DWORD PTR $T26497[esp+948]
	mov	DWORD PTR [esi+12], eax
	mov	eax, DWORD PTR $T26497[esp+952]
	mov	DWORD PTR [esi+16], ecx
	mov	ecx, DWORD PTR $T26497[esp+956]
	mov	DWORD PTR [esi+20], edx
	mov	edx, DWORD PTR $T26497[esp+960]
	mov	DWORD PTR [esi+24], eax
	mov	eax, DWORD PTR $T26497[esp+964]
	mov	DWORD PTR [esi+28], ecx
	mov	ecx, DWORD PTR $T26497[esp+968]
	mov	DWORD PTR [esi+32], edx
	mov	edx, DWORD PTR $T26497[esp+972]
	mov	DWORD PTR [esi+36], eax
	mov	DWORD PTR [esi+40], ecx
	mov	eax, DWORD PTR $T26497[esp+976]
	mov	ecx, DWORD PTR $T26497[esp+980]
	mov	DWORD PTR [esi+44], edx
	mov	edx, DWORD PTR $T26497[esp+984]
	mov	DWORD PTR [esi+48], eax
	mov	DWORD PTR [esi+52], ecx
	mov	DWORD PTR [esi+56], edx
$L13095:
	mov	eax, DWORD PTR [ebp+276]
	inc	edi
	cmp	edi, eax
	jb	$L13094
$L13092:

; 1306 : #endif // CPJ_SEQ_NOQUATOPT
; 1307 : #endif // if 0
; 1308 : /*
; 1309 : 			NFloat desiredLength = mSequence->m_BoneInfo[frm[ifrm]->rotates[i].boneIndex].srcLength;
; 1310 : 			NFloat actualLength = bone->mSklBone->length;
; 1311 : 			NFloat lengthScale = actualLength / desiredLength;
; 1312 : 			q = VQuat3();
; 1313 : 			if (lengthScale < 1.f)
; 1314 : 				q.Slerp(VQuat3(VAxes3()), VQuat3(frmDeltaCoords[ifrm][index].r), 1.f-lengthScale, lengthScale, false);
; 1315 : 			else
; 1316 : 				q.Slerp(VQuat3(VAxes3()), VQuat3(frmDeltaCoords[ifrm][index].r), 0.f, lengthScale, false);
; 1317 : 			frmDeltaCoords[ifrm][index].r = q;
; 1318 : */
; 1319 : 		}
; 1320 : 	}
; 1321 : 
; 1322 : 	// extract skeleton relative transformations
; 1323 : 	for (ifrm=0;ifrm<2;ifrm++)

	add	ebx, 256				; 00000100H
	cmp	ebx, 512				; 00000200H
	jb	$L13091

; 1329 : 		}
; 1330 : 	}
; 1331 : 
; 1332 : 	// interpolate to generate new bone state
; 1333 : 	VCoords3 srcC, destC, finalC;
; 1334 : 	VQuat3 srcQ, finalQ;
; 1335 : 	for (i=0;i<inActor->mActorBones.GetCount();i++)

	mov	ecx, DWORD PTR [ebp+276]
	xor	eax, eax
	cmp	ecx, eax
	mov	DWORD PTR _srcC$[esp+928], 1065353216	; 3f800000H
	mov	DWORD PTR _srcC$[esp+932], 0
	mov	DWORD PTR _srcC$[esp+936], 0
	mov	DWORD PTR _srcC$[esp+940], 0
	mov	DWORD PTR _srcC$[esp+944], 1065353216	; 3f800000H
	mov	DWORD PTR _srcC$[esp+948], 0
	mov	DWORD PTR _srcC$[esp+952], 0
	mov	DWORD PTR _srcC$[esp+956], 0
	mov	DWORD PTR _srcC$[esp+960], 1065353216	; 3f800000H
	mov	DWORD PTR _srcC$[esp+964], 0
	mov	DWORD PTR _srcC$[esp+968], 0
	mov	DWORD PTR _srcC$[esp+972], 0
	mov	DWORD PTR _srcC$[esp+976], 1065353216	; 3f800000H
	mov	DWORD PTR _srcC$[esp+980], 1065353216	; 3f800000H
	mov	DWORD PTR _srcC$[esp+984], 1065353216	; 3f800000H
	mov	DWORD PTR _i$[esp+928], eax
	jbe	$L13106
	mov	ebx, DWORD PTR _this$[esp+928]
	mov	esi, OFFSET FLAT:?frmCoords@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PAY0BAA@VVCoords3@@A+15380
	mov	DWORD PTR -876+[esp+928], eax
	mov	DWORD PTR -904+[esp+928], esi
$L13104:

; 1336 : 	{
; 1337 : 		if (!bonesUsed[i])

	mov	cl, BYTE PTR ?bonesUsed@?5??EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z@4PA_NA[eax]
	test	cl, cl
	je	$L13105

; 1338 : 			continue;
; 1339 : 
; 1340 : 		srcC.t = frmCoords[0][i].t + (frmCoords[1][i].t - frmCoords[0][i].t)*frameAlpha;

	fld	DWORD PTR [esi+16]
	fsub	DWORD PTR [esi-15344]
	fld	DWORD PTR [esi+20]
	fsub	DWORD PTR [esi-15340]
	fld	DWORD PTR [esi+24]
	fsub	DWORD PTR [esi-15336]

; 1341 : 		srcC.s = frmCoords[0][i].s + (frmCoords[1][i].s - frmCoords[0][i].s)*frameAlpha;
; 1342 : 		srcQ.Slerp(VQuat3(frmCoords[0][i].r), VQuat3(frmCoords[1][i].r), 1.f-frameAlpha, frameAlpha, false);

	mov	edx, DWORD PTR [esi-12]
	mov	DWORD PTR _adjF$28012[esp+936], edx
	mov	edx, DWORD PTR [esi]
	fstp	DWORD PTR $T26498[esp+936]
	fxch	ST(1)
	fmul	DWORD PTR _frameAlpha$[esp+928]
	fstp	DWORD PTR $T26499[esp+928]
	mov	DWORD PTR _adjF$28012[esp+948], edx
	fmul	DWORD PTR _frameAlpha$[esp+928]
	fstp	DWORD PTR $T26499[esp+932]
	fld	DWORD PTR $T26498[esp+936]
	fmul	DWORD PTR _frameAlpha$[esp+928]
	fld	DWORD PTR $T26499[esp+928]
	fadd	DWORD PTR [esi-15344]
	fld	DWORD PTR $T26499[esp+932]
	fadd	DWORD PTR [esi-15340]
	fxch	ST(2)
	fadd	DWORD PTR [esi-15336]
	fstp	DWORD PTR $T26500[esp+936]
	mov	eax, DWORD PTR $T26500[esp+936]
	fstp	DWORD PTR _srcC$[esp+964]
	mov	DWORD PTR _srcC$[esp+972], eax
	mov	eax, DWORD PTR [esi-8]
	fstp	DWORD PTR _srcC$[esp+968]
	fld	DWORD PTR [esi+28]
	fsub	DWORD PTR [esi-15332]
	fld	DWORD PTR [esi+32]
	fsub	DWORD PTR [esi-15328]
	fld	DWORD PTR [esi+36]
	fsub	DWORD PTR [esi-15324]
	mov	DWORD PTR _adjF$28012[esp+940], eax
	mov	eax, DWORD PTR [esi+4]
	fstp	DWORD PTR $T26501[esp+936]
	fxch	ST(1)
	fmul	DWORD PTR _frameAlpha$[esp+928]
	fstp	DWORD PTR $T26502[esp+928]
	mov	DWORD PTR _adjF$28012[esp+952], eax
	fmul	DWORD PTR _frameAlpha$[esp+928]
	fstp	DWORD PTR $T26502[esp+932]
	fld	DWORD PTR $T26501[esp+936]
	fmul	DWORD PTR _frameAlpha$[esp+928]
	fld	DWORD PTR $T26502[esp+928]
	fadd	DWORD PTR [esi-15332]
	fld	DWORD PTR $T26502[esp+932]
	fadd	DWORD PTR [esi-15328]
	fxch	ST(2)
	fadd	DWORD PTR [esi-15324]
	fstp	DWORD PTR $T26503[esp+936]
	mov	ecx, DWORD PTR $T26503[esp+936]
	fstp	DWORD PTR _srcC$[esp+976]
	mov	DWORD PTR _srcC$[esp+984], ecx
	mov	ecx, DWORD PTR [esi-4]
	fstp	DWORD PTR _srcC$[esp+980]
	fld	DWORD PTR [esi-20]
	fld	DWORD PTR [esi-16]
	mov	DWORD PTR _adjF$28012[esp+944], ecx
	mov	ecx, DWORD PTR [esi+8]
	fld	ST(0)
	fmul	ST(0), ST(1)
	fld	DWORD PTR _adjF$28012[esp+936]
	fmul	DWORD PTR _adjF$28012[esp+936]
	mov	edx, DWORD PTR [esi+12]
	mov	DWORD PTR _adjF$28012[esp+956], ecx
	mov	DWORD PTR _adjF$28012[esp+960], edx
	lea	eax, DWORD PTR _adjF$28012[esp+928]
	faddp	ST(1), ST(0)
	fld	ST(2)
	fmul	ST(0), ST(3)
	mov	DWORD PTR _c$28014[esp+928], eax
	lea	ecx, DWORD PTR _adjF$28012[esp+940]
	lea	edx, DWORD PTR _adjF$28012[esp+952]
	mov	DWORD PTR _c$28014[esp+932], ecx
	faddp	ST(1), ST(0)
	mov	DWORD PTR _c$28014[esp+936], edx
	fsqrt
	fdivr	DWORD PTR __real@3f800000
	fst	DWORD PTR _b$28044[esp+928]
	fmul	ST(0), ST(2)
	fstp	DWORD PTR _adjF$28012[esp+928]
	fld	DWORD PTR _b$28044[esp+928]
	fmul	ST(0), ST(1)
	fstp	DWORD PTR _adjF$28012[esp+932]
	fstp	ST(0)
	fstp	ST(0)
	fld	DWORD PTR _b$28044[esp+928]
	fmul	DWORD PTR _adjF$28012[esp+936]
	fstp	DWORD PTR _adjF$28012[esp+936]
	fld	DWORD PTR _adjF$28012[esp+944]
	fmul	DWORD PTR _adjF$28012[esp+944]
	fld	DWORD PTR _adjF$28012[esp+948]
	fmul	DWORD PTR _adjF$28012[esp+948]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _adjF$28012[esp+940]
	fmul	DWORD PTR _adjF$28012[esp+940]
	faddp	ST(1), ST(0)
	fsqrt
	fdivr	DWORD PTR __real@3f800000
	fld	DWORD PTR _adjF$28012[esp+940]
	fmul	ST(0), ST(1)
	fstp	DWORD PTR _adjF$28012[esp+940]
	fld	DWORD PTR _adjF$28012[esp+944]
	fmul	ST(0), ST(1)
	fstp	DWORD PTR _adjF$28012[esp+944]
	fmul	DWORD PTR _adjF$28012[esp+948]
	fstp	DWORD PTR _adjF$28012[esp+948]
	fld	DWORD PTR _adjF$28012[esp+956]
	fmul	DWORD PTR _adjF$28012[esp+956]
	fld	DWORD PTR _adjF$28012[esp+960]
	fmul	DWORD PTR _adjF$28012[esp+960]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _adjF$28012[esp+952]
	fmul	DWORD PTR _adjF$28012[esp+952]
	faddp	ST(1), ST(0)
	fsqrt
	fdivr	DWORD PTR __real@3f800000
	fld	DWORD PTR _adjF$28012[esp+952]
	fmul	ST(0), ST(1)
	fstp	DWORD PTR _adjF$28012[esp+952]
	fld	DWORD PTR _adjF$28012[esp+956]
	fmul	ST(0), ST(1)
	fstp	DWORD PTR _adjF$28012[esp+956]
	fmul	DWORD PTR _adjF$28012[esp+960]
	fstp	DWORD PTR _adjF$28012[esp+960]
	fld	DWORD PTR _adjF$28012[esp+928]
	fadd	DWORD PTR _adjF$28012[esp+944]
	fadd	DWORD PTR _adjF$28012[esp+960]
	fcom	QWORD PTR __real@0000000000000000
	fnstsw	ax
	and	eax, 16640				; 00004100H
	jne	SHORT $L28021
	fadd	DWORD PTR __real@3f800000
	fsqrt
	fld	DWORD PTR __real@3f000000
	fmul	ST(0), ST(1)
	fstp	DWORD PTR $T26504[esp+940]
	fld	DWORD PTR __real@3f000000
	fdiv	ST(0), ST(1)
	fstp	DWORD PTR _sq$28019[esp+928]
	fstp	ST(0)
	fld	DWORD PTR _adjF$28012[esp+948]
	fsub	DWORD PTR _adjF$28012[esp+956]
	fmul	DWORD PTR _sq$28019[esp+928]
	fld	DWORD PTR _adjF$28012[esp+952]
	fsub	DWORD PTR _adjF$28012[esp+936]
	fmul	DWORD PTR _sq$28019[esp+928]
	fstp	DWORD PTR $T26504[esp+932]
	fld	DWORD PTR _adjF$28012[esp+932]
	fsub	DWORD PTR _adjF$28012[esp+940]
	fmul	DWORD PTR _sq$28019[esp+928]
	fstp	DWORD PTR $T26504[esp+936]
	jmp	$L28011

; 1251 : 		boneMap[i] = inActor->FindBone(*mSequence->m_BoneInfo[i].name);

$L27069:
	mov	eax, OFFSET FLAT:??_C@_00A@?$AA@	; `string'
	mov	DWORD PTR $T27065[esp+928], eax
	jmp	$L30782

; 1341 : 		srcC.s = frmCoords[0][i].s + (frmCoords[1][i].s - frmCoords[0][i].s)*frameAlpha;
; 1342 : 		srcQ.Slerp(VQuat3(frmCoords[0][i].r), VQuat3(frmCoords[1][i].r), 1.f-frameAlpha, frameAlpha, false);

$L28021:
	fstp	ST(0)
	fld	DWORD PTR _adjF$28012[esp+944]
	fcomp	DWORD PTR _adjF$28012[esp+928]
	xor	ecx, ecx
	fnstsw	ax
	and	eax, 16640				; 00004100H
	jne	SHORT $L28022
	mov	ecx, 1
$L28022:
	mov	eax, DWORD PTR _c$28014[esp+ecx*4+928]
	fld	DWORD PTR _adjF$28012[esp+960]
	fcomp	DWORD PTR [eax+ecx*4]
	fnstsw	ax
	and	eax, 16640				; 00004100H
	jne	SHORT $L28023
	mov	ecx, 2
$L28023:
	mov	edx, DWORD PTR ?rot1@?1???0VQuat3@@QAE@ABVVAxes3@@@Z@4PAHA[ecx*4]
	mov	edi, DWORD PTR _c$28014[esp+ecx*4+928]
	mov	esi, DWORD PTR ?rot1@?1???0VQuat3@@QAE@ABVVAxes3@@@Z@4PAHA[edx*4]
	mov	eax, DWORD PTR _c$28014[esp+edx*4+928]
	mov	ebx, DWORD PTR _c$28014[esp+esi*4+928]
	fld	DWORD PTR [ebx+esi*4]
	fadd	DWORD PTR [eax+edx*4]
	fsubr	DWORD PTR [edi+ecx*4]
	fadd	DWORD PTR __real@3f800000
	fsqrt
	fld	DWORD PTR __real@3f000000
	fmul	ST(0), ST(1)
	fstp	DWORD PTR _q$28020[esp+ecx*4+928]
	fcom	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	SHORT $L28024
	fdivr	DWORD PTR __real@3f000000
$L28024:
	mov	eax, DWORD PTR _c$28014[esp+edx*4+928]
	fld	DWORD PTR [eax+esi*4]
	fsub	DWORD PTR [ebx+edx*4]
	fmul	ST(0), ST(1)
	fstp	DWORD PTR $T26504[esp+940]
	fld	DWORD PTR [eax+ecx*4]
	fadd	DWORD PTR [edi+edx*4]
	fmul	ST(0), ST(1)
	fstp	DWORD PTR _q$28020[esp+edx*4+928]
	fld	DWORD PTR [edi+esi*4]
	fadd	DWORD PTR [ebx+ecx*4]
	mov	ebx, DWORD PTR _this$[esp+928]
	fmul	ST(0), ST(1)
	fstp	DWORD PTR _q$28020[esp+esi*4+928]
	mov	ecx, DWORD PTR _q$28020[esp+932]
	mov	edx, DWORD PTR _q$28020[esp+936]
	mov	esi, DWORD PTR -904+[esp+928]
	mov	DWORD PTR $T26504[esp+932], ecx
	fstp	ST(0)
	fld	DWORD PTR _q$28020[esp+928]
	mov	DWORD PTR $T26504[esp+936], edx
$L28011:
	fld	DWORD PTR [esi-15380]
	fld	DWORD PTR [esi-15376]
	fld	ST(1)
	mov	eax, DWORD PTR [esi-15372]
	mov	ecx, DWORD PTR [esi-15368]
	fmul	ST(0), ST(2)
	fld	ST(1)
	fmul	ST(0), ST(2)
	mov	DWORD PTR _adjF$28133[esp+936], eax
	mov	edx, DWORD PTR [esi-15364]
	mov	DWORD PTR _adjF$28133[esp+940], ecx
	mov	eax, DWORD PTR [esi-15360]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _adjF$28133[esp+936]
	fmul	DWORD PTR _adjF$28133[esp+936]
	mov	DWORD PTR _adjF$28133[esp+944], edx
	mov	DWORD PTR _adjF$28133[esp+948], eax
	mov	ecx, DWORD PTR [esi-15356]
	mov	edx, DWORD PTR [esi-15352]
	faddp	ST(1), ST(0)
	mov	DWORD PTR _adjF$28133[esp+952], ecx
	mov	eax, DWORD PTR [esi-15348]
	mov	DWORD PTR _adjF$28133[esp+956], edx
	mov	DWORD PTR _adjF$28133[esp+960], eax
	fsqrt
	lea	ecx, DWORD PTR _adjF$28133[esp+928]
	mov	DWORD PTR _c$28135[esp+928], ecx
	fdivr	DWORD PTR __real@3f800000
	fst	DWORD PTR _b$28165[esp+928]
	fmul	ST(0), ST(2)
	fstp	DWORD PTR _adjF$28133[esp+928]
	fld	DWORD PTR _b$28165[esp+928]
	fmul	ST(0), ST(1)
	fstp	DWORD PTR _adjF$28133[esp+932]
	fstp	ST(0)
	fstp	ST(0)
	fld	DWORD PTR _b$28165[esp+928]
	fmul	DWORD PTR _adjF$28133[esp+936]
	fstp	DWORD PTR _adjF$28133[esp+936]
	fld	DWORD PTR _adjF$28133[esp+940]
	fmul	DWORD PTR _adjF$28133[esp+940]
	fld	DWORD PTR _adjF$28133[esp+944]
	fmul	DWORD PTR _adjF$28133[esp+944]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _adjF$28133[esp+948]
	fmul	DWORD PTR _adjF$28133[esp+948]
	faddp	ST(1), ST(0)
	fsqrt
	fdivr	DWORD PTR __real@3f800000
	fld	DWORD PTR _adjF$28133[esp+940]
	fmul	ST(0), ST(1)
	fstp	DWORD PTR _adjF$28133[esp+940]
	fld	DWORD PTR _adjF$28133[esp+944]
	fmul	ST(0), ST(1)
	fstp	DWORD PTR _adjF$28133[esp+944]
	fmul	DWORD PTR _adjF$28133[esp+948]
	fstp	DWORD PTR _adjF$28133[esp+948]
	fld	DWORD PTR _adjF$28133[esp+952]
	fmul	DWORD PTR _adjF$28133[esp+952]
	fld	DWORD PTR _adjF$28133[esp+956]
	fmul	DWORD PTR _adjF$28133[esp+956]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _adjF$28133[esp+960]
	fmul	DWORD PTR _adjF$28133[esp+960]
	faddp	ST(1), ST(0)
	fsqrt
	fdivr	DWORD PTR __real@3f800000
	fld	DWORD PTR _adjF$28133[esp+952]
	fmul	ST(0), ST(1)
	fstp	DWORD PTR _adjF$28133[esp+952]
	fld	DWORD PTR _adjF$28133[esp+956]
	fmul	ST(0), ST(1)
	fstp	DWORD PTR _adjF$28133[esp+956]
	fmul	DWORD PTR _adjF$28133[esp+960]
	fstp	DWORD PTR _adjF$28133[esp+960]
	fld	DWORD PTR _adjF$28133[esp+928]
	fadd	DWORD PTR _adjF$28133[esp+944]
	lea	eax, DWORD PTR _adjF$28133[esp+952]
	lea	edx, DWORD PTR _adjF$28133[esp+940]
	mov	DWORD PTR _c$28135[esp+936], eax
	mov	DWORD PTR _c$28135[esp+932], edx
	fadd	DWORD PTR _adjF$28133[esp+960]
	fcom	QWORD PTR __real@0000000000000000
	fnstsw	ax
	and	eax, 16640				; 00004100H
	jne	SHORT $L28142
	fadd	DWORD PTR __real@3f800000
	fsqrt
	fld	DWORD PTR __real@3f000000
	fmul	ST(0), ST(1)
	fstp	DWORD PTR $T26505[esp+940]
	fdivr	DWORD PTR __real@3f000000
	fld	DWORD PTR _adjF$28133[esp+948]
	fsub	DWORD PTR _adjF$28133[esp+956]
	fmul	ST(0), ST(1)
	fstp	DWORD PTR $T26505[esp+928]
	fld	DWORD PTR _adjF$28133[esp+952]
	fsub	DWORD PTR _adjF$28133[esp+936]
	fmul	ST(0), ST(1)
	fstp	DWORD PTR $T26505[esp+932]
	fld	DWORD PTR _adjF$28133[esp+932]
	fsub	DWORD PTR _adjF$28133[esp+940]
	fmul	ST(0), ST(1)
	fstp	DWORD PTR $T26505[esp+936]
	jmp	$L30807
$L28142:
	fstp	ST(0)
	fld	DWORD PTR _adjF$28133[esp+944]
	fcomp	DWORD PTR _adjF$28133[esp+928]
	xor	ecx, ecx
	fnstsw	ax
	and	eax, 16640				; 00004100H
	jne	SHORT $L28143
	mov	ecx, 1
$L28143:
	mov	edx, DWORD PTR _c$28135[esp+ecx*4+928]
	fld	DWORD PTR _adjF$28133[esp+960]
	fcomp	DWORD PTR [edx+ecx*4]
	fnstsw	ax
	and	eax, 16640				; 00004100H
	jne	SHORT $L28144
	mov	ecx, 2
$L28144:
	mov	edx, DWORD PTR ?rot1@?1???0VQuat3@@QAE@ABVVAxes3@@@Z@4PAHA[ecx*4]
	mov	edi, DWORD PTR _c$28135[esp+ecx*4+928]
	mov	esi, DWORD PTR ?rot1@?1???0VQuat3@@QAE@ABVVAxes3@@@Z@4PAHA[edx*4]
	mov	eax, DWORD PTR _c$28135[esp+edx*4+928]
	mov	ebx, DWORD PTR _c$28135[esp+esi*4+928]
	fld	DWORD PTR [ebx+esi*4]
	fadd	DWORD PTR [eax+edx*4]
	fsubr	DWORD PTR [edi+ecx*4]
	fadd	DWORD PTR __real@3f800000
	fsqrt
	fld	DWORD PTR __real@3f000000
	fmul	ST(0), ST(1)
	fstp	DWORD PTR _q$28141[esp+ecx*4+928]
	fcom	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	SHORT $L28145
	fdivr	DWORD PTR __real@3f000000
$L28145:
	mov	eax, DWORD PTR _c$28135[esp+edx*4+928]
	fld	DWORD PTR [eax+esi*4]
	fsub	DWORD PTR [ebx+edx*4]
	fmul	ST(0), ST(1)
	fstp	DWORD PTR $T26505[esp+940]
	fld	DWORD PTR [eax+ecx*4]
	fadd	DWORD PTR [edi+edx*4]
	fmul	ST(0), ST(1)
	fstp	DWORD PTR _q$28141[esp+edx*4+928]
	fld	DWORD PTR [edi+esi*4]
	fadd	DWORD PTR [ebx+ecx*4]
	mov	ebx, DWORD PTR _this$[esp+928]
	fmul	ST(0), ST(1)
	fstp	DWORD PTR _q$28141[esp+esi*4+928]
	mov	eax, DWORD PTR _q$28141[esp+928]
	mov	ecx, DWORD PTR _q$28141[esp+932]
	mov	edx, DWORD PTR _q$28141[esp+936]
	mov	esi, DWORD PTR -904+[esp+928]
	mov	DWORD PTR $T26505[esp+928], eax
	mov	DWORD PTR $T26505[esp+932], ecx
	mov	DWORD PTR $T26505[esp+936], edx
$L30807:
	fstp	ST(0)
	fld	DWORD PTR __real@3f800000
	fsub	DWORD PTR _frameAlpha$[esp+928]
	fstp	DWORD PTR $T28501[esp+928]
	fld	DWORD PTR $T26505[esp+940]
	fsub	DWORD PTR $T26504[esp+940]
	fstp	DWORD PTR $T28197[esp+928]
	mov	eax, DWORD PTR $T28197[esp+928]
	and	eax, 2147483647				; 7fffffffH
	mov	DWORD PTR _fi$28420[esp+928], eax
	fld	DWORD PTR _fi$28420[esp+928]
	fcomp	DWORD PTR __real@3a83126f
	fnstsw	ax
	test	ah, 65					; 00000041H
	jp	$L28397
	fld	DWORD PTR $T26505[esp+928]
	fsub	ST(0), ST(1)
	fstp	DWORD PTR $T28202[esp+928]
	mov	ecx, DWORD PTR $T28202[esp+928]
	and	ecx, 2147483647				; 7fffffffH
	mov	DWORD PTR _fi$28423[esp+928], ecx
	fld	DWORD PTR _fi$28423[esp+928]
	fcomp	DWORD PTR __real@3a83126f
	fnstsw	ax
	test	ah, 65					; 00000041H
	jp	$L28397
	fld	DWORD PTR $T26505[esp+932]
	fsub	DWORD PTR $T26504[esp+932]
	fstp	DWORD PTR $T28207[esp+928]
	mov	edx, DWORD PTR $T28207[esp+928]
	and	edx, 2147483647				; 7fffffffH
	mov	DWORD PTR _fi$28426[esp+928], edx
	fld	DWORD PTR _fi$28426[esp+928]
	fcomp	DWORD PTR __real@3a83126f
	fnstsw	ax
	test	ah, 65					; 00000041H
	jp	SHORT $L28397
	fld	DWORD PTR $T26505[esp+936]
	fsub	DWORD PTR $T26504[esp+936]
	fstp	DWORD PTR $T28212[esp+928]
	mov	eax, DWORD PTR $T28212[esp+928]
	and	eax, 2147483647				; 7fffffffH
	mov	DWORD PTR _fi$28429[esp+928], eax
	fld	DWORD PTR _fi$28429[esp+928]
	fcomp	DWORD PTR __real@3a83126f
	fnstsw	ax
	test	ah, 65					; 00000041H
	jp	SHORT $L28397
	mov	ecx, DWORD PTR $T26505[esp+928]
	mov	edx, DWORD PTR $T26505[esp+932]
	mov	eax, DWORD PTR $T26505[esp+936]
	mov	DWORD PTR _srcQ$[esp+928], ecx
	mov	ecx, DWORD PTR $T26505[esp+940]
	mov	DWORD PTR _srcQ$[esp+932], edx
	fstp	ST(0)
	mov	DWORD PTR _srcQ$[esp+936], eax
	mov	DWORD PTR _srcQ$[esp+940], ecx
	jmp	$L28493
$L28397:
	fst	DWORD PTR _q2temp$28398[esp+928]
	fld	DWORD PTR $T26505[esp+928]
	fmul	ST(0), ST(1)
	fld	DWORD PTR $T26505[esp+936]
	fmul	DWORD PTR $T26504[esp+936]
	mov	eax, DWORD PTR $T26504[esp+936]
	mov	edx, DWORD PTR $T26504[esp+932]
	mov	ecx, DWORD PTR $T26504[esp+940]
	mov	DWORD PTR _q2temp$28398[esp+936], eax
	faddp	ST(1), ST(0)
	fld	DWORD PTR $T26505[esp+932]
	fmul	DWORD PTR $T26504[esp+932]
	mov	DWORD PTR _q2temp$28398[esp+932], edx
	mov	DWORD PTR _q2temp$28398[esp+940], ecx
	faddp	ST(1), ST(0)
	fld	DWORD PTR $T26505[esp+940]
	fmul	DWORD PTR $T26504[esp+940]
	faddp	ST(1), ST(0)
	fst	DWORD PTR _cosom$28400[esp+928]
	fcomp	QWORD PTR __real@0000000000000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L30798
	fld	DWORD PTR _cosom$28400[esp+928]
	fchs
	fstp	DWORD PTR _cosom$28400[esp+928]
	fchs
	fld	DWORD PTR $T26504[esp+932]
	fchs
	fld	DWORD PTR $T26504[esp+936]
	fchs
	fstp	DWORD PTR $T28450[esp+936]
	fld	DWORD PTR $T26504[esp+940]
	mov	edx, DWORD PTR $T28450[esp+936]
	fchs
	fstp	DWORD PTR $T28409[esp+940]
	mov	eax, DWORD PTR $T28409[esp+940]
	mov	DWORD PTR _q2temp$28398[esp+936], edx
	fxch	ST(1)
	fstp	DWORD PTR _q2temp$28398[esp+928]
	fstp	DWORD PTR _q2temp$28398[esp+932]
	mov	DWORD PTR _q2temp$28398[esp+940], eax
	jmp	SHORT $L28461
$L30798:
	fstp	ST(0)
$L28461:
	fld	DWORD PTR __real@3f800000
	fsub	DWORD PTR _cosom$28400[esp+928]
	fcomp	DWORD PTR __real@3a83126f
	fnstsw	ax
	and	eax, 16640				; 00004100H
	jne	$L28407
	fld	DWORD PTR _cosom$28400[esp+928]
	call	__CIacos
	fst	DWORD PTR _om$28399[esp+928]
	fcomp	DWORD PTR __real@3a83126f
	fnstsw	ax
	and	eax, 256				; 00000100H
	jne	$L28407
	fld	DWORD PTR __real@40490fdb
	fsub	DWORD PTR _om$28399[esp+928]
	fcomp	DWORD PTR __real@3a83126f
	fnstsw	ax
	and	eax, 256				; 00000100H
	jne	$L28407
	fld	DWORD PTR _om$28399[esp+928]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	DWORD PTR __imp___finite
	add	esp, 8
	test	eax, eax
	je	$L28407
	fld	DWORD PTR _om$28399[esp+928]
	fsin
	fdivr	DWORD PTR __real@3f800000
	fld	DWORD PTR _om$28399[esp+928]
	fmul	DWORD PTR $T28501[esp+928]
	fsin
	fmul	ST(0), ST(1)
	fld	DWORD PTR _om$28399[esp+928]
	fmul	DWORD PTR _frameAlpha$[esp+928]
	fsin
	fmul	ST(0), ST(2)
	fld	DWORD PTR _q2temp$28398[esp+940]
	fmul	ST(0), ST(1)
	fld	ST(2)
	fmul	DWORD PTR $T26505[esp+940]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _srcQ$[esp+940]
	fld	DWORD PTR _q2temp$28398[esp+928]
	fmul	ST(0), ST(1)
	fstp	DWORD PTR $T28410[esp+928]
	fld	DWORD PTR _q2temp$28398[esp+932]
	fmul	ST(0), ST(1)
	fstp	DWORD PTR $T28410[esp+932]
	fmul	DWORD PTR _q2temp$28398[esp+936]
	fstp	DWORD PTR $T28410[esp+936]
	fld	DWORD PTR $T26505[esp+928]
	fmul	ST(0), ST(1)
	fstp	DWORD PTR $T28411[esp+928]
	fld	DWORD PTR $T26505[esp+932]
	fmul	ST(0), ST(1)
	fstp	DWORD PTR $T28411[esp+932]
	fmul	DWORD PTR $T26505[esp+936]
	fstp	ST(1)
	fld	DWORD PTR $T28411[esp+928]
	fadd	DWORD PTR $T28410[esp+928]
	fld	DWORD PTR $T28411[esp+932]
	fadd	DWORD PTR $T28410[esp+932]
	fxch	ST(2)
	fadd	DWORD PTR $T28410[esp+936]
	fstp	DWORD PTR $T28412[esp+936]
	mov	ecx, DWORD PTR $T28412[esp+936]
	fstp	DWORD PTR _srcQ$[esp+928]
	mov	DWORD PTR _srcQ$[esp+936], ecx
	fstp	DWORD PTR _srcQ$[esp+932]
	jmp	$L28493
$L28407:
	fld	DWORD PTR $T28501[esp+928]
	fmul	DWORD PTR $T26505[esp+940]
	fld	DWORD PTR _q2temp$28398[esp+940]
	fmul	DWORD PTR _frameAlpha$[esp+928]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _q2temp$28398[esp+928]
	fmul	DWORD PTR _frameAlpha$[esp+928]
	fld	DWORD PTR _q2temp$28398[esp+932]
	fmul	DWORD PTR _frameAlpha$[esp+928]
	fld	DWORD PTR _q2temp$28398[esp+936]
	fmul	DWORD PTR _frameAlpha$[esp+928]
	fstp	DWORD PTR $T28413[esp+936]
	fld	DWORD PTR $T28501[esp+928]
	fmul	DWORD PTR $T26505[esp+928]
	fld	DWORD PTR $T28501[esp+928]
	fmul	DWORD PTR $T26505[esp+932]
	fstp	DWORD PTR $T28414[esp+932]
	fld	DWORD PTR $T28501[esp+928]
	fmul	DWORD PTR $T26505[esp+936]
	fstp	DWORD PTR $T28414[esp+936]
	fadd	ST(0), ST(2)
	fstp	DWORD PTR $T28415[esp+928]
	fld	DWORD PTR $T28414[esp+932]
	fadd	ST(0), ST(1)
	fstp	ST(2)
	fstp	ST(0)
	fld	DWORD PTR $T28414[esp+936]
	fadd	DWORD PTR $T28413[esp+936]
	fld	DWORD PTR $T28415[esp+928]
	fmul	DWORD PTR $T28415[esp+928]
	fld	ST(3)
	fmul	ST(0), ST(4)
	faddp	ST(1), ST(0)
	fld	ST(1)
	fmul	ST(0), ST(2)
	faddp	ST(1), ST(0)
	fld	ST(2)
	fmul	ST(0), ST(3)
	faddp	ST(1), ST(0)
	fsqrt
	fdivr	DWORD PTR __real@3f800000
	fstp	DWORD PTR _b$28495[esp+928]
	fld	DWORD PTR $T28415[esp+928]
	fmul	DWORD PTR _b$28495[esp+928]
	fstp	DWORD PTR _srcQ$[esp+928]
	fxch	ST(1)
	fmul	DWORD PTR _b$28495[esp+928]
	fstp	DWORD PTR _srcQ$[esp+932]
	fmul	DWORD PTR _b$28495[esp+928]
	fstp	DWORD PTR _srcQ$[esp+936]
	fmul	DWORD PTR _b$28495[esp+928]
	fstp	DWORD PTR _srcQ$[esp+940]
$L28493:

; 1343 : 
; 1344 : 		if (mBlendAlpha >= 1.f)

	fld	DWORD PTR [ebx+64]
	fcomp	DWORD PTR __real@3f800000
	fnstsw	ax
	and	eax, 256				; 00000100H
	jne	$L13116

; 1345 : 		{
; 1346 : 			srcC.r = srcQ;

	fld	DWORD PTR _srcQ$[esp+932]
	fadd	ST(0), ST(0)
	fld	DWORD PTR _srcQ$[esp+936]
	fadd	ST(0), ST(0)
	fld	DWORD PTR _srcQ$[esp+940]
	fadd	ST(0), ST(0)
	fstp	DWORD PTR _w2$28565[esp+928]
	fld	DWORD PTR _srcQ$[esp+928]
	fadd	ST(0), ST(0)
	fmul	DWORD PTR _srcQ$[esp+928]
	fstp	DWORD PTR _xx2$28566[esp+928]
	fld	DWORD PTR _srcQ$[esp+932]
	fmul	ST(0), ST(2)
	fstp	DWORD PTR _yy2$28567[esp+928]
	fld	DWORD PTR _srcQ$[esp+936]
	fmul	ST(0), ST(1)
	fstp	DWORD PTR _zz2$28568[esp+928]
	fxch	ST(1)
	fmul	DWORD PTR _srcQ$[esp+928]
	fstp	DWORD PTR _xy2$28570[esp+928]
	fld	DWORD PTR _srcQ$[esp+928]
	fmul	ST(0), ST(1)
	fstp	DWORD PTR _xz2$28571[esp+928]
	fld	DWORD PTR _w2$28565[esp+928]
	fmul	DWORD PTR _srcQ$[esp+928]
	fstp	DWORD PTR _xw2$28572[esp+928]
	fmul	DWORD PTR _srcQ$[esp+932]
	fld	DWORD PTR _w2$28565[esp+928]
	fmul	DWORD PTR _srcQ$[esp+932]
	fstp	DWORD PTR _yw2$28574[esp+928]
	fld	DWORD PTR _w2$28565[esp+928]
	fmul	DWORD PTR _srcQ$[esp+936]
	fstp	DWORD PTR _zw2$28575[esp+928]
	fld	DWORD PTR _zz2$28568[esp+928]
	fadd	DWORD PTR _yy2$28567[esp+928]
	fsubr	DWORD PTR __real@3f800000
	fld	DWORD PTR _zw2$28575[esp+928]
	fadd	DWORD PTR _xy2$28570[esp+928]
	fld	DWORD PTR _xz2$28571[esp+928]
	fsub	DWORD PTR _yw2$28574[esp+928]
	fstp	DWORD PTR $T28536[esp+936]
	fld	DWORD PTR _xy2$28570[esp+928]
	fsub	DWORD PTR _zw2$28575[esp+928]
	mov	edx, DWORD PTR $T28536[esp+936]
	mov	DWORD PTR _srcC$[esp+936], edx
	fstp	DWORD PTR $T28537[esp+928]
	fld	DWORD PTR _zz2$28568[esp+928]
	fadd	DWORD PTR _xx2$28566[esp+928]
	mov	eax, DWORD PTR $T28537[esp+928]
	mov	DWORD PTR _srcC$[esp+940], eax
	fsubr	DWORD PTR __real@3f800000
	fstp	DWORD PTR $T28537[esp+932]
	fld	ST(2)
	fadd	DWORD PTR _xw2$28572[esp+928]
	mov	ecx, DWORD PTR $T28537[esp+932]
	mov	DWORD PTR _srcC$[esp+944], ecx
	fstp	DWORD PTR $T28537[esp+936]
	fld	DWORD PTR _yw2$28574[esp+928]
	fadd	DWORD PTR _xz2$28571[esp+928]
	mov	edx, DWORD PTR $T28537[esp+936]
	mov	DWORD PTR _srcC$[esp+948], edx
	fstp	DWORD PTR $T28538[esp+928]
	fxch	ST(2)
	fsub	DWORD PTR _xw2$28572[esp+928]
	mov	eax, DWORD PTR $T28538[esp+928]
	mov	DWORD PTR _srcC$[esp+952], eax
	fstp	DWORD PTR $T28538[esp+932]
	fld	DWORD PTR _yy2$28567[esp+928]
	fadd	DWORD PTR _xx2$28566[esp+928]
	mov	ecx, DWORD PTR $T28538[esp+932]
	mov	DWORD PTR _srcC$[esp+956], ecx
	fsubr	DWORD PTR __real@3f800000
	fstp	DWORD PTR $T28538[esp+936]
	mov	edx, DWORD PTR $T28538[esp+936]
	fstp	DWORD PTR _srcC$[esp+928]
	fstp	DWORD PTR _srcC$[esp+932]

; 1347 : 			inActor->mActorBones[i].SetCoords(srcC, false);

	mov	edi, DWORD PTR [ebp+272]
	mov	DWORD PTR _srcC$[esp+960], edx
	mov	edx, DWORD PTR -876+[esp+928]
	lea	eax, DWORD PTR _srcC$[esp+928]
	add	edi, edx
	push	eax
	mov	ecx, edi
	call	??4VCoords3@@QAEAAV0@ABV0@@Z		; VCoords3::operator=
	mov	ecx, edi

; 1348 : 		}
; 1349 : 		else

	jmp	$L30808
$L13116:

; 1350 : 		{
; 1351 : 			destC = inActor->mActorBones[i].GetCoords(false);

	mov	ecx, DWORD PTR [ebp+272]
	mov	edx, DWORD PTR -876+[esp+928]
	add	ecx, edx
	push	ecx
	lea	ecx, DWORD PTR $T26507[esp+932]
	call	??0VCoords3@@QAE@ABV0@@Z		; VCoords3::VCoords3

; 1352 : 
; 1353 : 			finalC = destC;
; 1354 : 			//finalC.t = destC.t;
; 1355 : 			finalC.t = srcC.t*mBlendAlpha + destC.t*(1.f-mBlendAlpha);

	fld	DWORD PTR __real@3f800000
	fsub	DWORD PTR [ebx+64]
	fld	ST(0)
	fld	DWORD PTR $T26507[esp+964]
	fmul	ST(0), ST(1)
	fld	DWORD PTR $T26507[esp+968]
	fmul	ST(0), ST(2)
	fstp	DWORD PTR $T26508[esp+932]
	fld	DWORD PTR $T26507[esp+972]
	fmul	ST(0), ST(2)
	fstp	DWORD PTR $T26508[esp+936]
	fld	DWORD PTR [ebx+64]
	fld	DWORD PTR _srcC$[esp+964]
	fmul	ST(0), ST(1)
	fstp	DWORD PTR $T26509[esp+928]
	fld	DWORD PTR _srcC$[esp+968]
	fmul	ST(0), ST(1)
	fstp	DWORD PTR $T26509[esp+932]
	fmul	DWORD PTR _srcC$[esp+972]
	fstp	DWORD PTR $T26509[esp+936]
	fld	DWORD PTR $T26509[esp+928]
	fadd	ST(0), ST(1)
	fstp	DWORD PTR $T26510[esp+928]
	fstp	ST(0)
	fstp	ST(0)
	fld	DWORD PTR $T26509[esp+932]
	fadd	DWORD PTR $T26508[esp+932]
	fstp	DWORD PTR $T26510[esp+932]
	fld	DWORD PTR $T26509[esp+936]
	fadd	DWORD PTR $T26508[esp+936]
	fstp	DWORD PTR $T26510[esp+936]

; 1356 : 			//finalC.s = destC.s;
; 1357 : 			finalC.s = srcC.s*mBlendAlpha + destC.s*(1.f-mBlendAlpha);

	fld	ST(0)
	fld	DWORD PTR $T26507[esp+976]
	fmul	ST(0), ST(1)
	fld	DWORD PTR $T26507[esp+980]
	fmul	ST(0), ST(2)
	fstp	DWORD PTR $T26511[esp+932]
	fld	DWORD PTR $T26507[esp+984]
	fmul	ST(0), ST(2)
	fstp	DWORD PTR $T26511[esp+936]
	fld	DWORD PTR [ebx+64]
	fld	DWORD PTR _srcC$[esp+976]
	fmul	ST(0), ST(1)
	fstp	DWORD PTR $T26512[esp+928]
	fld	DWORD PTR _srcC$[esp+980]
	fmul	ST(0), ST(1)
	fstp	DWORD PTR $T26512[esp+932]
	fmul	DWORD PTR _srcC$[esp+984]
	fstp	DWORD PTR $T26512[esp+936]
	fld	DWORD PTR $T26512[esp+928]
	fadd	ST(0), ST(1)
	fstp	DWORD PTR $T26513[esp+928]
	fstp	ST(0)
	fstp	ST(0)
	fld	DWORD PTR $T26512[esp+932]
	fadd	DWORD PTR $T26511[esp+932]
	fstp	DWORD PTR $T26513[esp+932]
	fld	DWORD PTR $T26512[esp+936]
	fadd	DWORD PTR $T26511[esp+936]

; 1358 : 			finalQ.Slerp(VQuat3(destC.r), srcQ, 1.f-mBlendAlpha, mBlendAlpha, false);

	lea	eax, DWORD PTR _adjF$29035[esp+940]
	lea	edx, DWORD PTR _adjF$29035[esp+928]
	mov	DWORD PTR _c$29037[esp+932], eax
	lea	ecx, DWORD PTR _adjF$29035[esp+952]
	fstp	DWORD PTR $T26513[esp+936]
	fld	DWORD PTR $T26507[esp+928]
	fmul	DWORD PTR $T26507[esp+928]
	fld	DWORD PTR $T26507[esp+936]
	fmul	DWORD PTR $T26507[esp+936]
	mov	DWORD PTR _c$29037[esp+928], edx
	mov	DWORD PTR _c$29037[esp+936], ecx
	faddp	ST(1), ST(0)
	fld	DWORD PTR $T26507[esp+932]
	fmul	DWORD PTR $T26507[esp+932]
	faddp	ST(1), ST(0)
	fsqrt
	fdivr	DWORD PTR __real@3f800000
	fld	DWORD PTR $T26507[esp+928]
	fmul	ST(0), ST(1)
	fstp	DWORD PTR _adjF$29035[esp+928]
	fld	DWORD PTR $T26507[esp+932]
	fmul	ST(0), ST(1)
	fstp	DWORD PTR _adjF$29035[esp+932]
	fmul	DWORD PTR $T26507[esp+936]
	fstp	DWORD PTR _adjF$29035[esp+936]
	fld	DWORD PTR $T26507[esp+948]
	fmul	DWORD PTR $T26507[esp+948]
	fld	DWORD PTR $T26507[esp+944]
	fmul	DWORD PTR $T26507[esp+944]
	faddp	ST(1), ST(0)
	fld	DWORD PTR $T26507[esp+940]
	fmul	DWORD PTR $T26507[esp+940]
	faddp	ST(1), ST(0)
	fsqrt
	fdivr	DWORD PTR __real@3f800000
	fld	DWORD PTR $T26507[esp+940]
	fmul	ST(0), ST(1)
	fstp	DWORD PTR _adjF$29035[esp+940]
	fld	DWORD PTR $T26507[esp+944]
	fmul	ST(0), ST(1)
	fstp	DWORD PTR _adjF$29035[esp+944]
	fld	DWORD PTR $T26507[esp+948]
	fmul	ST(0), ST(1)
	fstp	DWORD PTR _adjF$29035[esp+948]
	fstp	ST(0)
	fld	DWORD PTR $T26507[esp+956]
	fmul	DWORD PTR $T26507[esp+956]
	fld	DWORD PTR $T26507[esp+952]
	fmul	DWORD PTR $T26507[esp+952]
	faddp	ST(1), ST(0)
	fld	DWORD PTR $T26507[esp+960]
	fmul	DWORD PTR $T26507[esp+960]
	faddp	ST(1), ST(0)
	fsqrt
	fdivr	DWORD PTR __real@3f800000
	fld	DWORD PTR $T26507[esp+952]
	fmul	ST(0), ST(1)
	fstp	DWORD PTR _adjF$29035[esp+952]
	fld	DWORD PTR $T26507[esp+956]
	fmul	ST(0), ST(1)
	fstp	DWORD PTR _adjF$29035[esp+956]
	fld	DWORD PTR $T26507[esp+960]
	fmul	ST(0), ST(1)
	fstp	DWORD PTR _adjF$29035[esp+960]
	fstp	ST(0)
	fld	DWORD PTR _adjF$29035[esp+928]
	fadd	DWORD PTR _adjF$29035[esp+944]
	fadd	DWORD PTR _adjF$29035[esp+960]
	fcom	QWORD PTR __real@0000000000000000
	fnstsw	ax
	and	eax, 16640				; 00004100H
	jne	SHORT $L29044
	fadd	DWORD PTR __real@3f800000
	fsqrt
	fld	DWORD PTR __real@3f000000
	fmul	ST(0), ST(1)
	fstp	DWORD PTR $T26514[esp+940]
	fdivr	DWORD PTR __real@3f000000
	fld	DWORD PTR _adjF$29035[esp+948]
	fsub	DWORD PTR _adjF$29035[esp+956]
	fmul	ST(0), ST(1)
	fstp	DWORD PTR $T26514[esp+928]
	fld	DWORD PTR _adjF$29035[esp+952]
	fsub	DWORD PTR _adjF$29035[esp+936]
	fmul	ST(0), ST(1)
	fstp	DWORD PTR $T26514[esp+932]
	fld	DWORD PTR _adjF$29035[esp+932]
	fsub	DWORD PTR _adjF$29035[esp+940]
	fmul	ST(0), ST(1)
	fstp	DWORD PTR $T26514[esp+936]
	jmp	$L30809
$L29044:
	fstp	ST(0)
	fld	DWORD PTR _adjF$29035[esp+944]
	fcomp	DWORD PTR _adjF$29035[esp+928]
	xor	ecx, ecx
	fnstsw	ax
	and	eax, 16640				; 00004100H
	jne	SHORT $L29045
	mov	ecx, 1
$L29045:
	mov	edx, DWORD PTR _c$29037[esp+ecx*4+928]
	fld	DWORD PTR _adjF$29035[esp+960]
	fcomp	DWORD PTR [edx+ecx*4]
	fnstsw	ax
	and	eax, 16640				; 00004100H
	jne	SHORT $L29046
	mov	ecx, 2
$L29046:
	mov	edx, DWORD PTR ?rot1@?1???0VQuat3@@QAE@ABVVAxes3@@@Z@4PAHA[ecx*4]
	mov	edi, DWORD PTR _c$29037[esp+ecx*4+928]
	mov	esi, DWORD PTR ?rot1@?1???0VQuat3@@QAE@ABVVAxes3@@@Z@4PAHA[edx*4]
	mov	eax, DWORD PTR _c$29037[esp+edx*4+928]
	mov	ebx, DWORD PTR _c$29037[esp+esi*4+928]
	fld	DWORD PTR [ebx+esi*4]
	fadd	DWORD PTR [eax+edx*4]
	fsubr	DWORD PTR [edi+ecx*4]
	fadd	DWORD PTR __real@3f800000
	fsqrt
	fld	DWORD PTR __real@3f000000
	fmul	ST(0), ST(1)
	fstp	DWORD PTR _q$29043[esp+ecx*4+928]
	fcom	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	SHORT $L29047
	fdivr	DWORD PTR __real@3f000000
$L29047:
	mov	eax, DWORD PTR _c$29037[esp+edx*4+928]
	fld	DWORD PTR [eax+esi*4]
	fsub	DWORD PTR [ebx+edx*4]
	fmul	ST(0), ST(1)
	fstp	DWORD PTR $T26514[esp+940]
	fld	DWORD PTR [eax+ecx*4]
	fadd	DWORD PTR [edi+edx*4]
	fmul	ST(0), ST(1)
	fstp	DWORD PTR _q$29043[esp+edx*4+928]
	fld	DWORD PTR [edi+esi*4]
	fadd	DWORD PTR [ebx+ecx*4]
	mov	ebx, DWORD PTR _this$[esp+928]
	fmul	ST(0), ST(1)
	fstp	DWORD PTR _q$29043[esp+esi*4+928]
	mov	eax, DWORD PTR _q$29043[esp+928]
	mov	ecx, DWORD PTR _q$29043[esp+932]
	mov	edx, DWORD PTR _q$29043[esp+936]
	mov	esi, DWORD PTR -904+[esp+928]
	mov	DWORD PTR $T26514[esp+928], eax
	mov	DWORD PTR $T26514[esp+932], ecx
	mov	DWORD PTR $T26514[esp+936], edx
$L30809:
	fstp	ST(0)
	fstp	DWORD PTR $T29402[esp+928]
	fld	DWORD PTR $T26514[esp+940]
	fsub	DWORD PTR _srcQ$[esp+940]
	mov	eax, DWORD PTR [ebx+64]
	mov	DWORD PTR $T29403[esp+928], eax
	fstp	DWORD PTR $T29098[esp+928]
	mov	ecx, DWORD PTR $T29098[esp+928]
	and	ecx, 2147483647				; 7fffffffH
	mov	DWORD PTR _fi$29321[esp+928], ecx
	fld	DWORD PTR _fi$29321[esp+928]
	fcomp	DWORD PTR __real@3a83126f
	fnstsw	ax
	test	ah, 65					; 00000041H
	jp	$L29298
	fld	DWORD PTR $T26514[esp+928]
	fsub	DWORD PTR _srcQ$[esp+928]
	fstp	DWORD PTR $T29103[esp+928]
	mov	edx, DWORD PTR $T29103[esp+928]
	and	edx, 2147483647				; 7fffffffH
	mov	DWORD PTR _fi$29324[esp+928], edx
	fld	DWORD PTR _fi$29324[esp+928]
	fcomp	DWORD PTR __real@3a83126f
	fnstsw	ax
	test	ah, 65					; 00000041H
	jp	$L29298
	fld	DWORD PTR $T26514[esp+932]
	fsub	DWORD PTR _srcQ$[esp+932]
	fstp	DWORD PTR $T29108[esp+928]
	mov	eax, DWORD PTR $T29108[esp+928]
	and	eax, 2147483647				; 7fffffffH
	mov	DWORD PTR _fi$29327[esp+928], eax
	fld	DWORD PTR _fi$29327[esp+928]
	fcomp	DWORD PTR __real@3a83126f
	fnstsw	ax
	test	ah, 65					; 00000041H
	jp	SHORT $L29298
	fld	DWORD PTR $T26514[esp+936]
	fsub	DWORD PTR _srcQ$[esp+936]
	fstp	DWORD PTR $T29113[esp+928]
	mov	ecx, DWORD PTR $T29113[esp+928]
	and	ecx, 2147483647				; 7fffffffH
	mov	DWORD PTR _fi$29330[esp+928], ecx
	fld	DWORD PTR _fi$29330[esp+928]
	fcomp	DWORD PTR __real@3a83126f
	fnstsw	ax
	test	ah, 65					; 00000041H
	jp	SHORT $L29298
	fld	DWORD PTR $T26514[esp+928]
	fld	DWORD PTR $T26514[esp+932]
	mov	edx, DWORD PTR $T26514[esp+936]
	fld	DWORD PTR $T26514[esp+940]
	mov	DWORD PTR _finalQ$[esp+936], edx
	jmp	$L29394
$L29298:
	fld	DWORD PTR $T26514[esp+928]
	fmul	DWORD PTR _srcQ$[esp+928]
	fld	DWORD PTR $T26514[esp+936]
	fmul	DWORD PTR _srcQ$[esp+936]
	mov	eax, DWORD PTR _srcQ$[esp+928]
	mov	ecx, DWORD PTR _srcQ$[esp+932]
	mov	edx, DWORD PTR _srcQ$[esp+936]
	mov	DWORD PTR _q2temp$29299[esp+928], eax
	faddp	ST(1), ST(0)
	fld	DWORD PTR $T26514[esp+932]
	fmul	DWORD PTR _srcQ$[esp+932]
	mov	eax, DWORD PTR _srcQ$[esp+940]
	mov	DWORD PTR _q2temp$29299[esp+932], ecx
	mov	DWORD PTR _q2temp$29299[esp+940], eax
	mov	DWORD PTR _q2temp$29299[esp+936], edx
	faddp	ST(1), ST(0)
	fld	DWORD PTR $T26514[esp+940]
	fmul	DWORD PTR _srcQ$[esp+940]
	faddp	ST(1), ST(0)
	fst	DWORD PTR _cosom$29301[esp+928]
	fcomp	QWORD PTR __real@0000000000000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L29362
	fld	DWORD PTR _cosom$29301[esp+928]
	fchs
	fstp	DWORD PTR _cosom$29301[esp+928]
	fld	DWORD PTR _srcQ$[esp+928]
	fchs
	fld	DWORD PTR _srcQ$[esp+932]
	fchs
	fld	DWORD PTR _srcQ$[esp+936]
	fchs
	fstp	DWORD PTR $T29350[esp+936]
	fld	DWORD PTR _srcQ$[esp+940]
	mov	ecx, DWORD PTR $T29350[esp+936]
	fchs
	fstp	DWORD PTR $T29310[esp+940]
	mov	edx, DWORD PTR $T29310[esp+940]
	mov	DWORD PTR _q2temp$29299[esp+936], ecx
	fxch	ST(1)
	fstp	DWORD PTR _q2temp$29299[esp+928]
	fstp	DWORD PTR _q2temp$29299[esp+932]
	mov	DWORD PTR _q2temp$29299[esp+940], edx
$L29362:
	fld	DWORD PTR __real@3f800000
	fsub	DWORD PTR _cosom$29301[esp+928]
	fcomp	DWORD PTR __real@3a83126f
	fnstsw	ax
	and	eax, 16640				; 00004100H
	jne	$L29308
	fld	DWORD PTR _cosom$29301[esp+928]
	call	__CIacos
	fst	DWORD PTR _om$29300[esp+928]
	fcomp	DWORD PTR __real@3a83126f
	fnstsw	ax
	and	eax, 256				; 00000100H
	jne	$L29308
	fld	DWORD PTR __real@40490fdb
	fsub	DWORD PTR _om$29300[esp+928]
	fcomp	DWORD PTR __real@3a83126f
	fnstsw	ax
	and	eax, 256				; 00000100H
	jne	$L29308
	fld	DWORD PTR _om$29300[esp+928]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	DWORD PTR __imp___finite
	add	esp, 8
	test	eax, eax
	je	$L29308
	fld	DWORD PTR _om$29300[esp+928]
	fsin
	fdivr	DWORD PTR __real@3f800000
	fld	DWORD PTR _om$29300[esp+928]
	fmul	DWORD PTR $T29402[esp+928]
	fsin
	fmul	ST(0), ST(1)
	fld	DWORD PTR _om$29300[esp+928]
	fmul	DWORD PTR $T29403[esp+928]
	fsin
	fmul	ST(0), ST(2)
	fld	ST(1)
	fmul	DWORD PTR $T26514[esp+940]
	fld	DWORD PTR _q2temp$29299[esp+940]
	fmul	ST(0), ST(2)
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _finalQ$[esp+940]
	fld	DWORD PTR _q2temp$29299[esp+928]
	fmul	ST(0), ST(1)
	fstp	DWORD PTR $T29311[esp+928]
	fld	DWORD PTR _q2temp$29299[esp+932]
	fmul	ST(0), ST(1)
	fstp	DWORD PTR $T29311[esp+932]
	fmul	DWORD PTR _q2temp$29299[esp+936]
	fstp	DWORD PTR $T29311[esp+936]
	fld	DWORD PTR $T26514[esp+928]
	fmul	ST(0), ST(1)
	fstp	DWORD PTR $T29312[esp+928]
	fld	DWORD PTR $T26514[esp+932]
	fmul	ST(0), ST(1)
	fstp	DWORD PTR $T29312[esp+932]
	fmul	DWORD PTR $T26514[esp+936]
	fstp	ST(1)
	fld	DWORD PTR $T29312[esp+928]
	fadd	DWORD PTR $T29311[esp+928]
	fld	DWORD PTR $T29312[esp+932]
	fadd	DWORD PTR $T29311[esp+932]
	fstp	DWORD PTR $T29313[esp+932]
	fxch	ST(1)
	fadd	DWORD PTR $T29311[esp+936]
	fstp	DWORD PTR $T29313[esp+936]
	fld	DWORD PTR $T29313[esp+932]
	mov	eax, DWORD PTR $T29313[esp+936]
	fld	DWORD PTR _finalQ$[esp+940]
	mov	DWORD PTR _finalQ$[esp+936], eax
	jmp	$L29394
$L29308:
	fld	DWORD PTR $T29402[esp+928]
	fmul	DWORD PTR $T26514[esp+940]
	fld	DWORD PTR _q2temp$29299[esp+940]
	fmul	DWORD PTR $T29403[esp+928]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _finalQ$[esp+940]
	fld	DWORD PTR _q2temp$29299[esp+928]
	fmul	DWORD PTR $T29403[esp+928]
	fld	DWORD PTR $T29403[esp+928]
	fmul	DWORD PTR _q2temp$29299[esp+932]
	fld	DWORD PTR $T29403[esp+928]
	fmul	DWORD PTR _q2temp$29299[esp+936]
	fstp	DWORD PTR $T29314[esp+936]
	fld	DWORD PTR $T29402[esp+928]
	fmul	DWORD PTR $T26514[esp+928]
	fld	DWORD PTR $T29402[esp+928]
	fmul	DWORD PTR $T26514[esp+932]
	fstp	DWORD PTR $T29315[esp+932]
	fld	DWORD PTR $T29402[esp+928]
	fmul	DWORD PTR $T26514[esp+936]
	fstp	DWORD PTR $T29315[esp+936]
	fadd	ST(0), ST(2)
	fstp	DWORD PTR $T29316[esp+928]
	fld	DWORD PTR $T29315[esp+932]
	fadd	ST(0), ST(1)
	fstp	DWORD PTR $T29316[esp+932]
	fstp	ST(0)
	fstp	ST(0)
	fld	DWORD PTR $T29315[esp+936]
	fadd	DWORD PTR $T29314[esp+936]
	fstp	DWORD PTR $T29316[esp+936]
	fld	DWORD PTR $T29316[esp+928]
	fmul	DWORD PTR $T29316[esp+928]
	fld	DWORD PTR _finalQ$[esp+940]
	fmul	DWORD PTR _finalQ$[esp+940]
	faddp	ST(1), ST(0)
	fld	DWORD PTR $T29316[esp+936]
	fmul	DWORD PTR $T29316[esp+936]
	faddp	ST(1), ST(0)
	fld	DWORD PTR $T29316[esp+932]
	fmul	DWORD PTR $T29316[esp+932]
	faddp	ST(1), ST(0)
	fsqrt
	fdivr	DWORD PTR __real@3f800000
	fstp	DWORD PTR _b$29396[esp+928]
	fld	DWORD PTR $T29316[esp+928]
	fmul	DWORD PTR _b$29396[esp+928]
	fld	DWORD PTR _b$29396[esp+928]
	fmul	DWORD PTR $T29316[esp+932]
	fld	DWORD PTR _b$29396[esp+928]
	fmul	DWORD PTR $T29316[esp+936]
	fstp	DWORD PTR _finalQ$[esp+936]
	fld	DWORD PTR _b$29396[esp+928]
	fmul	DWORD PTR _finalQ$[esp+940]
$L29394:

; 1359 : 			finalC.r = finalQ;

	fld	ST(1)
	fadd	ST(0), ST(0)
	fld	DWORD PTR _finalQ$[esp+936]
	fadd	ST(0), ST(0)

; 1360 : 			
; 1361 : 			inActor->mActorBones[i].SetCoords(finalC, false);

	mov	ecx, DWORD PTR [ebp+272]
	mov	edx, DWORD PTR -876+[esp+928]
	add	ecx, edx
	fstp	DWORD PTR _z2$29444[esp+928]
	fxch	ST(1)
	fadd	ST(0), ST(0)
	fstp	DWORD PTR _w2$29445[esp+928]
	fld	ST(2)
	fadd	ST(0), ST(0)
	fmul	ST(0), ST(3)
	fstp	DWORD PTR _xx2$29446[esp+928]
	fld	ST(0)
	fmul	ST(0), ST(2)
	fstp	DWORD PTR _yy2$29447[esp+928]
	fld	DWORD PTR _z2$29444[esp+928]
	fmul	DWORD PTR _finalQ$[esp+936]
	fstp	DWORD PTR _zz2$29448[esp+928]
	fmul	ST(0), ST(2)
	fstp	DWORD PTR _xy2$29450[esp+928]
	fld	DWORD PTR _z2$29444[esp+928]
	fmul	ST(0), ST(2)
	fstp	DWORD PTR _xz2$29451[esp+928]
	fld	DWORD PTR _w2$29445[esp+928]
	fmul	ST(0), ST(2)
	fstp	DWORD PTR _xw2$29452[esp+928]
	fld	DWORD PTR _z2$29444[esp+928]
	fmul	ST(0), ST(1)
	fstp	DWORD PTR _yz2$29453[esp+928]
	fld	DWORD PTR _w2$29445[esp+928]
	fmul	ST(0), ST(1)
	fstp	ST(2)
	fstp	ST(0)
	fld	DWORD PTR _w2$29445[esp+928]
	fmul	DWORD PTR _finalQ$[esp+936]
	fstp	DWORD PTR _zw2$29455[esp+928]
	fld	DWORD PTR _zz2$29448[esp+928]
	fadd	DWORD PTR _yy2$29447[esp+928]
	fsubr	DWORD PTR __real@3f800000
	fld	DWORD PTR _zw2$29455[esp+928]
	fadd	DWORD PTR _xy2$29450[esp+928]
	fld	DWORD PTR _xz2$29451[esp+928]
	fsub	ST(0), ST(3)
	fstp	DWORD PTR $T29457[esp+936]
	fld	DWORD PTR _xy2$29450[esp+928]
	fsub	DWORD PTR _zw2$29455[esp+928]
	mov	edx, DWORD PTR $T29457[esp+936]
	fstp	DWORD PTR $T29458[esp+928]
	fld	DWORD PTR _zz2$29448[esp+928]
	fadd	DWORD PTR _xx2$29446[esp+928]
	mov	eax, DWORD PTR $T29458[esp+928]
	fsubr	DWORD PTR __real@3f800000
	fstp	DWORD PTR $T29458[esp+932]
	fld	DWORD PTR _yz2$29453[esp+928]
	fadd	DWORD PTR _xw2$29452[esp+928]
	fstp	DWORD PTR $T29458[esp+936]
	fxch	ST(2)
	fadd	DWORD PTR _xz2$29451[esp+928]
	fstp	DWORD PTR $T29459[esp+928]
	fld	DWORD PTR _yz2$29453[esp+928]
	fsub	DWORD PTR _xw2$29452[esp+928]
	fstp	DWORD PTR $T29459[esp+932]
	fld	DWORD PTR _yy2$29447[esp+928]
	fadd	DWORD PTR _xx2$29446[esp+928]
	fsubr	DWORD PTR __real@3f800000
	fstp	DWORD PTR $T29459[esp+936]
	fstp	DWORD PTR [ecx]
	fstp	DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR $T29458[esp+932]
	mov	DWORD PTR [ecx+12], eax
	mov	eax, DWORD PTR $T29458[esp+936]
	mov	DWORD PTR [ecx+16], edx
	mov	edx, DWORD PTR $T29459[esp+928]
	mov	DWORD PTR [ecx+20], eax
	mov	eax, DWORD PTR $T29459[esp+932]
	mov	DWORD PTR [ecx+24], edx
	mov	edx, DWORD PTR $T29459[esp+936]
	mov	DWORD PTR [ecx+28], eax
	mov	eax, DWORD PTR $T26510[esp+928]
	mov	DWORD PTR [ecx+32], edx
	mov	edx, DWORD PTR $T26510[esp+932]
	mov	DWORD PTR [ecx+36], eax
	mov	eax, DWORD PTR $T26510[esp+936]
	mov	DWORD PTR [ecx+40], edx
	mov	edx, DWORD PTR $T26513[esp+928]
	mov	DWORD PTR [ecx+44], eax
	mov	eax, DWORD PTR $T26513[esp+932]
	mov	DWORD PTR [ecx+48], edx
	mov	edx, DWORD PTR $T26513[esp+936]
	mov	DWORD PTR [ecx+52], eax
	mov	DWORD PTR [ecx+56], edx
$L30808:
	push	0
	call	?ValidateAbs@CMacBone@@IAEX_N@Z		; CMacBone::ValidateAbs
$L13105:
	mov	eax, DWORD PTR _i$[esp+928]
	mov	edx, DWORD PTR -876+[esp+928]
	mov	ecx, DWORD PTR [ebp+276]
	inc	eax
	add	esi, 60					; 0000003cH
	add	edx, 140				; 0000008cH
	cmp	eax, ecx
	mov	DWORD PTR _i$[esp+928], eax
	mov	DWORD PTR -904+[esp+928], esi
	mov	DWORD PTR -876+[esp+928], edx
	jb	$L13104
$L13106:
	pop	edi
	pop	esi
	pop	ebp

; 1362 : 		}
; 1363 : 	}
; 1364 : 	
; 1365 : 	return(1);

	mov	al, 1
	pop	ebx

; 1366 : }

	add	esp, 912				; 00000390H
	ret	4
$L13030:
	pop	edi
	pop	esi
	pop	ebp

; 1208 : 		return(0);

	xor	al, al
	pop	ebx

; 1366 : }

	add	esp, 912				; 00000390H
	ret	4
?EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z ENDP ; OMacSequenceChannel::EvalBones
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT _$E114
_TEXT	SEGMENT
_$E114	PROC NEAR					; COMDAT
	ret	0
_$E114	ENDP
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT _$E113
_TEXT	SEGMENT
_$E113	PROC NEAR					; COMDAT
	ret	0
_$E113	ENDP
_TEXT	ENDS
PUBLIC	?EvalVerts@OMacSequenceChannel@@UAE_NPAVOMacActor@@KPAGPAVVVec3@@@Z ; OMacSequenceChannel::EvalVerts
_BSS	SEGMENT
?defaultRelay@?BC@??EvalVerts@OMacSequenceChannel@@UAE_NPAVOMacActor@@KPAGPAVVVec3@@@Z@4PAGA DW 0800H DUP (?) ; defaultRelay
; Function compile flags: /Ogty
_BSS	ENDS
;	COMDAT ?EvalVerts@OMacSequenceChannel@@UAE_NPAVOMacActor@@KPAGPAVVVec3@@@Z
_TEXT	SEGMENT
$T30819 = -84
$T30820 = -96
$T30821 = -60
$T30822 = -96
$T30823 = -72
$T30824 = -60
$T30825 = -84
$T30826 = -96
$T30827 = -60
$T30828 = -96
$T30829 = -112
$T30830 = -60
$T30831 = -72
$T30832 = -60
$T30833 = -96
$T30834 = -48
$T30835 = -84
$T30836 = -112
$T30837 = -72
$T30838 = -60
$T30839 = -48
$T30840 = -96
$T30841 = -112
$T30842 = -36
$T30843 = -112
$T30844 = -84
$T30845 = -36
$T30846 = -96
$T30847 = -48
$T30848 = -60
$T30849 = -96
$T30850 = -36
$T30851 = -24
$T30852 = -48
$T30853 = -60
$T30854 = -12
$T30881 = -112
$T30886 = -112
$T30891 = -112
$T30896 = -112
$T30901 = -112
$T30906 = -112
_inActor$ = 8
_inNumVerts$ = 12
_inVertRelay$ = 16
_ioVerts$ = 20
_this$ = -136
_frameAlpha$ = -132
_omframeAlpha$ = -128
_i$ = -116
_frm0Pure$ = -116
_frm1Pure$ = -116
_frm0Group$ = -124
_frm1Group$ = -120
_omBlendAlpha$ = -100
_vA$ = -84
_vB$ = -72
?EvalVerts@OMacSequenceChannel@@UAE_NPAVOMacActor@@KPAGPAVVVec3@@@Z PROC NEAR ; OMacSequenceChannel::EvalVerts, COMDAT
; _this$ = ecx

; 1368 : {

	sub	esp, 136				; 00000088H
	push	ebx
	push	ebp
	push	esi
	push	edi

; 1369 : 	if (!mSequence || !mSequence->m_Frames.GetCount() || !inActor)

	mov	edi, DWORD PTR [ecx+56]
	xor	ebp, ebp
	cmp	edi, ebp
	mov	DWORD PTR _this$[esp+152], ecx
	je	$L13138
	mov	esi, DWORD PTR [edi+80]
	cmp	esi, ebp
	je	$L13138
	cmp	DWORD PTR _inActor$[esp+148], ebp
	je	$L13138

; 1371 : 
; 1372 : 	NFloat frameF = mTime * mSequence->m_Frames.GetCount();

	mov	DWORD PTR -112+[esp+152], esi
	mov	DWORD PTR -112+[esp+156], ebp
	fild	QWORD PTR -112+[esp+152]
	fmul	DWORD PTR [ecx+60]

; 1373 : 	NDword frameI = (NDword)frameF;

	fld	ST(0)
	call	__ftol

; 1374 : 	NFloat frameAlpha = frameF - frameI;
; 1375 : 	NFloat omframeAlpha = 1.f - frameAlpha;
; 1376 : 	CCpjSeqFrame* sfrm[2];
; 1377 : 	sfrm[0] = &mSequence->m_Frames[frameI % mSequence->m_Frames.GetCount()];

	xor	edx, edx
	mov	ecx, eax
	div	esi
	mov	edi, DWORD PTR [edi+76]
	mov	DWORD PTR -112+[esp+152], ecx
	mov	DWORD PTR -112+[esp+156], ebp
	fild	QWORD PTR -112+[esp+152]
	fsubr	ST(0), ST(1)
	fstp	DWORD PTR _frameAlpha$[esp+152]
	fstp	ST(0)
	fld	DWORD PTR __real@3f800000
	fsub	DWORD PTR _frameAlpha$[esp+152]
	fstp	DWORD PTR _omframeAlpha$[esp+152]
	lea	eax, DWORD PTR [edx+edx*2]
	lea	edx, DWORD PTR [edx+eax*4]

; 1378 : 	sfrm[1] = &mSequence->m_Frames[(frameI+1) % mSequence->m_Frames.GetCount()];

	lea	eax, DWORD PTR [ecx+1]
	lea	ebx, DWORD PTR [edi+edx*4]
	xor	edx, edx
	div	esi
	lea	eax, DWORD PTR [edx+edx*2]
	lea	ecx, DWORD PTR [edx+eax*4]

; 1379 : 
; 1380 : 	if (!sfrm[0]->vertFrameName.Len() && !sfrm[1]->vertFrameName.Len())

	mov	edx, DWORD PTR [ebx]
	cmp	edx, ebp
	lea	esi, DWORD PTR [edi+ecx*4]
	je	SHORT $L31459
	mov	edi, edx
	or	ecx, -1
	xor	eax, eax
	repne scasb
	not	ecx
	dec	ecx
	mov	DWORD PTR $T30881[esp+152], ecx
	jne	SHORT $L13145
$L31459:
	mov	edi, DWORD PTR [esi]
	cmp	edi, ebp
	je	$L13138
	or	ecx, -1
	xor	eax, eax
	repne scasb
	not	ecx
	dec	ecx
	mov	DWORD PTR $T30886[esp+152], ecx

; 1381 : 		return(0); // bone-based frames, ignore

	je	$L13138
$L13145:

; 1382 : 
; 1383 : 	// make sure both frames are valid, by duplicating the frame if one is empty
; 1384 : 	if (sfrm[0]->vertFrameName.Len() && !sfrm[1]->vertFrameName.Len())

	cmp	edx, ebp
	je	SHORT $L31462
	mov	edi, edx
	or	ecx, -1
	xor	eax, eax
	repne scasb
	not	ecx
	dec	ecx
	mov	DWORD PTR $T30891[esp+152], ecx
	je	SHORT $L30900
	mov	edi, DWORD PTR [esi]
	cmp	edi, ebp
	je	SHORT $L31461
	or	ecx, -1
	repne scasb
	not	ecx
	dec	ecx
	mov	DWORD PTR $T30896[esp+152], ecx
	jne	SHORT $L30900
$L31461:

; 1385 : 		sfrm[1] = sfrm[0];

	mov	esi, ebx

; 1386 : 	else if (!sfrm[0]->vertFrameName.Len() && sfrm[1]->vertFrameName.Len())

	jmp	SHORT $L13148
$L30900:
	mov	edi, edx
	or	ecx, -1
	xor	eax, eax
	repne scasb
	not	ecx
	dec	ecx
	mov	DWORD PTR $T30901[esp+152], ecx
	jne	SHORT $L13148
$L31462:
	mov	edi, DWORD PTR [esi]
	cmp	edi, ebp
	je	SHORT $L13148
	or	ecx, -1
	xor	eax, eax
	repne scasb
	not	ecx
	dec	ecx
	mov	DWORD PTR $T30906[esp+152], ecx
	je	SHORT $L13148

; 1387 : 		sfrm[0] = sfrm[1];

	mov	ebx, esi
$L13148:

; 1388 : 
; 1389 : 	CCpjFrmFrame* frm[2];
; 1390 : 	frm[0] = inActor->FindFrame(*sfrm[0]->vertFrameName);

	mov	eax, DWORD PTR [ebx]
	cmp	eax, ebp
	jne	SHORT $L30915
	mov	eax, OFFSET FLAT:??_C@_00A@?$AA@	; `string'
$L30915:
	mov	edi, DWORD PTR _inActor$[esp+148]
	push	eax
	mov	ecx, edi
	call	?FindFrame@OMacActor@@QAEPAVCCpjFrmFrame@@PBD@Z ; OMacActor::FindFrame

; 1391 : 	frm[1] = inActor->FindFrame(*sfrm[1]->vertFrameName);

	mov	esi, DWORD PTR [esi]
	mov	ebx, eax
	cmp	esi, ebp
	jne	SHORT $L30926
	mov	esi, OFFSET FLAT:??_C@_00A@?$AA@	; `string'
$L30926:
	push	esi
	mov	ecx, edi
	call	?FindFrame@OMacActor@@QAEPAVCCpjFrmFrame@@PBD@Z ; OMacActor::FindFrame

; 1392 : 
; 1393 : 	if (!frm[0] && !frm[1])

	cmp	ebx, ebp
	mov	ecx, eax
	jne	SHORT $L31458
	cmp	ecx, ebp
	jne	SHORT $L31457
$L13138:
	pop	edi
	pop	esi
	pop	ebp

; 1370 : 		return(0);

	xor	al, al
	pop	ebx

; 1571 : }

	add	esp, 136				; 00000088H
	ret	16					; 00000010H
$L31458:

; 1394 : 		return(0); // neither frame was found, skip out
; 1395 : 
; 1396 : 	// one again make sure both frames are valid
; 1397 : 	if (frm[0] && !frm[1]) frm[1] = frm[0];

	cmp	ecx, ebp
	jne	SHORT $L13153
	mov	ecx, ebx

; 1398 : 	else if (!frm[0] && frm[1]) frm[0] = frm[1];

	jmp	SHORT $L13153
$L31457:
	mov	ebx, ecx
$L13153:

; 1399 : 
; 1400 : 	// set the relay
; 1401 : 	static NWord defaultRelay[2048];
; 1402 : 	static NBool defaultRelayInitialized = 0;
; 1403 : 	if (!defaultRelayInitialized)

	mov	al, BYTE PTR ?defaultRelayInitialized@?BC@??EvalVerts@OMacSequenceChannel@@UAE_NPAVOMacActor@@KPAGPAVVVec3@@@Z@4_NA
	test	al, al
	jne	SHORT $L13158

; 1404 : 	{
; 1405 : 		for (NDword i=0;i<2048;i++)

	xor	eax, eax
$L13160:

; 1406 : 			defaultRelay[i] = (NWord)i;

	mov	WORD PTR ?defaultRelay@?BC@??EvalVerts@OMacSequenceChannel@@UAE_NPAVOMacActor@@KPAGPAVVVec3@@@Z@4PAGA[eax*2], ax
	inc	eax
	cmp	eax, 2048				; 00000800H
	jb	SHORT $L13160

; 1407 : 		defaultRelayInitialized = 1;

	mov	BYTE PTR ?defaultRelayInitialized@?BC@??EvalVerts@OMacSequenceChannel@@UAE_NPAVOMacActor@@KPAGPAVVVec3@@@Z@4_NA, 1
$L13158:

; 1408 : 	}
; 1409 : 	if (!inVertRelay)

	mov	edi, DWORD PTR _inVertRelay$[esp+148]
	cmp	edi, ebp
	jne	SHORT $L13164

; 1410 : 		inVertRelay = defaultRelay;

	mov	edi, OFFSET FLAT:?defaultRelay@?BC@??EvalVerts@OMacSequenceChannel@@UAE_NPAVOMacActor@@KPAGPAVVVec3@@@Z@4PAGA
$L13164:

; 1411 : 
; 1412 : 	// build the verts
; 1413 : 	NDword i;
; 1414 : 	NDword count = inNumVerts;//frm[0]->GetNumPositions();
; 1415 : 	VVec3* oV = ioVerts;
; 1416 : 	NWord* iR = inVertRelay;
; 1417 : 
; 1418 : #if 1
; 1419 : 	NDword loopFlags = 0;
; 1420 : 	if (frm[0]->m_isCompressed) loopFlags |= 1;

	mov	al, BYTE PTR [ebx+8]
	xor	edx, edx
	test	al, al
	je	SHORT $L13170
	mov	edx, 1
$L13170:

; 1421 : 	if (frm[1]->m_isCompressed) loopFlags |= 2;

	mov	al, BYTE PTR [ecx+8]
	test	al, al
	je	SHORT $L13171
	or	edx, 2
$L13171:

; 1422 : 	if (mBlendAlpha < 1.f) loopFlags |= 4;

	mov	esi, DWORD PTR _this$[esp+152]
	fld	DWORD PTR [esi+64]
	fcomp	DWORD PTR __real@3f800000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L13172
	or	edx, 4
$L13172:

; 1423 : 
; 1424 : 	CCpjFrmBytePos* frm0Byte, *frm1Byte, *tempByte;
; 1425 : 	VVec3* frm0Pure, *frm1Pure;
; 1426 : 	CCpjFrmGroup* byteGroup, *frm0Group, *frm1Group;
; 1427 : 	NFloat omBlendAlpha = 1.f - mBlendAlpha;

	fld	DWORD PTR __real@3f800000
	fsub	DWORD PTR [esi+64]

; 1428 : 	VVec3 vA, vB;
; 1429 : 
; 1430 : 	switch(loopFlags)
; 1431 : 	{

	cmp	edx, 7
	fstp	DWORD PTR _omBlendAlpha$[esp+152]
	ja	$L13267
	jmp	DWORD PTR $L31470[edx*4]
$L13188:

; 1432 : 	case 0: // uncompressed, uncompressed, no blend
; 1433 : 		frm0Pure = &frm[0]->m_PurePos[0];
; 1434 : 		frm1Pure = &frm[1]->m_PurePos[0];
; 1435 : 		for (i=0; i<count; i++,oV++)

	mov	ebp, DWORD PTR _inNumVerts$[esp+148]
	mov	ebx, DWORD PTR [ebx+44]
	mov	ecx, DWORD PTR [ecx+44]
	xor	esi, esi
	test	ebp, ebp
	jbe	$L13267
	mov	edx, DWORD PTR _ioVerts$[esp+148]
	add	edx, 8
$L13189:

; 1436 : 			*oV = (frm1Pure[iR[i]]*frameAlpha) + (frm0Pure[iR[i]]*omframeAlpha);

	xor	eax, eax
	add	edx, 12					; 0000000cH
	mov	ax, WORD PTR [edi+esi*2]
	fld	DWORD PTR _omframeAlpha$[esp+152]
	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 2
	inc	esi
	fmul	DWORD PTR [eax+ebx]
	fld	DWORD PTR _omframeAlpha$[esp+152]
	fmul	DWORD PTR [eax+ebx+4]
	cmp	esi, ebp
	fstp	DWORD PTR $T30819[esp+156]
	fld	DWORD PTR _omframeAlpha$[esp+152]
	fmul	DWORD PTR [eax+ebx+8]
	fstp	DWORD PTR $T30819[esp+160]
	fld	DWORD PTR _frameAlpha$[esp+152]
	fmul	DWORD PTR [eax+ecx]
	fld	DWORD PTR _frameAlpha$[esp+152]
	fmul	DWORD PTR [eax+ecx+4]
	fstp	DWORD PTR $T30820[esp+156]
	fld	DWORD PTR _frameAlpha$[esp+152]
	fmul	DWORD PTR [eax+ecx+8]
	fstp	DWORD PTR $T30820[esp+160]
	faddp	ST(1), ST(0)
	fld	DWORD PTR $T30820[esp+156]
	fadd	DWORD PTR $T30819[esp+156]
	fld	DWORD PTR $T30820[esp+160]
	fadd	DWORD PTR $T30819[esp+160]
	fstp	DWORD PTR $T30821[esp+160]
	mov	eax, DWORD PTR $T30821[esp+160]
	fxch	ST(1)
	fstp	DWORD PTR [edx-20]
	mov	DWORD PTR [edx-12], eax
	fstp	DWORD PTR [edx-16]
	jb	SHORT $L13189
	pop	edi
	pop	esi
	pop	ebp

; 1546 : 		}
; 1547 : 		break;	
; 1548 : 	}
; 1549 : #else
; 1550 : 	if (mBlendAlpha >= 1.f)
; 1551 : 	{
; 1552 : 		for (i=0; i<count; i++,oV++)//,iE++)
; 1553 : 		{
; 1554 : 			//if (!(*iE))
; 1555 : 			//	continue;
; 1556 : 			*oV = (frm[1]->GetPosition(i)*frameAlpha) + (frm[0]->GetPosition(i)*(1.f-frameAlpha));
; 1557 : 		}
; 1558 : 	}
; 1559 : 	else
; 1560 : 	{
; 1561 : 		for (i=0; i<count; i++,oV++)//,iE++)
; 1562 : 		{
; 1563 : 			//if (!(*iE))
; 1564 : 			//	continue;
; 1565 : 			*oV = (((frm[1]->GetPosition(i)*frameAlpha) + (frm[0]->GetPosition(i)*(1.f-frameAlpha))) * mBlendAlpha) + (*oV * (1.f-mBlendAlpha));
; 1566 : 		}
; 1567 : 	}
; 1568 : #endif // #if 1
; 1569 : 
; 1570 : 	return(1);

	mov	al, 1
	pop	ebx

; 1571 : }

	add	esp, 136				; 00000088H
	ret	16					; 00000010H
$L13195:

; 1437 : 		break;
; 1438 : 	case 1: // compressed, uncompressed, no blend
; 1439 : 		frm0Byte = &frm[0]->m_BytePos[0];

	mov	esi, DWORD PTR [ebx+28]

; 1440 : 		frm1Pure = &frm[1]->m_PurePos[0];
; 1441 : 		frm0Group = &frm[0]->m_Groups[0];

	mov	edx, DWORD PTR [ebx+12]

; 1442 : 		for (i=0; i<count; i++,oV++)

	mov	eax, DWORD PTR _inNumVerts$[esp+148]
	mov	ecx, DWORD PTR [ecx+44]
	xor	ebx, ebx
	cmp	eax, ebp
	mov	DWORD PTR _frm1Pure$[esp+152], ecx
	mov	DWORD PTR _frm0Group$[esp+152], edx
	jbe	$L13267
	mov	eax, DWORD PTR _ioVerts$[esp+148]
	lea	ebp, DWORD PTR [eax+8]
$L13196:

; 1443 : 		{
; 1444 : 			tempByte = &frm0Byte[iR[i]];

	xor	eax, eax

; 1445 : 			byteGroup = &frm0Group[tempByte->group];

	mov	edx, DWORD PTR _frm0Group$[esp+152]
	mov	ax, WORD PTR [edi+ebx*2]
	xor	ecx, ecx
	add	ebp, 12					; 0000000cH
	mov	cl, BYTE PTR [esi+eax*4]
	lea	ecx, DWORD PTR [ecx+ecx*2]
	lea	ecx, DWORD PTR [edx+ecx*8]

; 1446 : 			vA.x = ((NFloat)tempByte->pos[0] * byteGroup->scale.x) + byteGroup->translate.x;

	xor	edx, edx
	mov	dl, BYTE PTR [esi+eax*4+1]
	mov	DWORD PTR -136+[esp+152], edx

; 1447 : 			vA.y = ((NFloat)tempByte->pos[1] * byteGroup->scale.y) + byteGroup->translate.y;

	xor	edx, edx
	fild	DWORD PTR -136+[esp+152]
	mov	dl, BYTE PTR [esi+eax*4+2]
	mov	DWORD PTR -136+[esp+152], edx

; 1448 : 			vA.z = ((NFloat)tempByte->pos[2] * byteGroup->scale.z) + byteGroup->translate.z;

	xor	edx, edx
	fmul	DWORD PTR [ecx]
	mov	dl, BYTE PTR [esi+eax*4+3]

; 1449 : 
; 1450 : 			*oV = (frm1Pure[iR[i]]*frameAlpha) + (vA*omframeAlpha);

	lea	eax, DWORD PTR [eax+eax*2]
	inc	ebx
	fadd	DWORD PTR [ecx+12]
	fild	DWORD PTR -136+[esp+152]
	mov	DWORD PTR -136+[esp+152], edx
	fmul	DWORD PTR [ecx+4]
	fadd	DWORD PTR [ecx+16]
	fild	DWORD PTR -136+[esp+152]
	fmul	DWORD PTR [ecx+8]
	fadd	DWORD PTR [ecx+20]
	mov	ecx, DWORD PTR _frm1Pure$[esp+152]
	lea	eax, DWORD PTR [ecx+eax*4]
	fstp	DWORD PTR _vA$[esp+160]
	fxch	ST(1)
	fmul	DWORD PTR _omframeAlpha$[esp+152]
	fstp	DWORD PTR $T30822[esp+152]
	fmul	DWORD PTR _omframeAlpha$[esp+152]
	fstp	DWORD PTR $T30822[esp+156]
	fld	DWORD PTR _vA$[esp+160]
	fmul	DWORD PTR _omframeAlpha$[esp+152]
	fld	DWORD PTR _frameAlpha$[esp+152]
	fmul	DWORD PTR [eax]
	fld	DWORD PTR _frameAlpha$[esp+152]
	fmul	DWORD PTR [eax+4]
	fstp	DWORD PTR $T30823[esp+156]
	fld	DWORD PTR _frameAlpha$[esp+152]
	fmul	DWORD PTR [eax+8]
	cmp	ebx, DWORD PTR _inNumVerts$[esp+148]
	fstp	DWORD PTR $T30823[esp+160]
	fadd	DWORD PTR $T30822[esp+152]
	fld	DWORD PTR $T30823[esp+156]
	fadd	DWORD PTR $T30822[esp+156]
	fld	DWORD PTR $T30823[esp+160]
	fadd	ST(0), ST(3)
	fstp	DWORD PTR $T30824[esp+160]
	mov	edx, DWORD PTR $T30824[esp+160]
	fxch	ST(1)
	fstp	DWORD PTR [ebp-20]
	mov	DWORD PTR [ebp-12], edx
	fstp	DWORD PTR [ebp-16]
	fstp	ST(0)
	jb	$L13196
	pop	edi
	pop	esi
	pop	ebp

; 1546 : 		}
; 1547 : 		break;	
; 1548 : 	}
; 1549 : #else
; 1550 : 	if (mBlendAlpha >= 1.f)
; 1551 : 	{
; 1552 : 		for (i=0; i<count; i++,oV++)//,iE++)
; 1553 : 		{
; 1554 : 			//if (!(*iE))
; 1555 : 			//	continue;
; 1556 : 			*oV = (frm[1]->GetPosition(i)*frameAlpha) + (frm[0]->GetPosition(i)*(1.f-frameAlpha));
; 1557 : 		}
; 1558 : 	}
; 1559 : 	else
; 1560 : 	{
; 1561 : 		for (i=0; i<count; i++,oV++)//,iE++)
; 1562 : 		{
; 1563 : 			//if (!(*iE))
; 1564 : 			//	continue;
; 1565 : 			*oV = (((frm[1]->GetPosition(i)*frameAlpha) + (frm[0]->GetPosition(i)*(1.f-frameAlpha))) * mBlendAlpha) + (*oV * (1.f-mBlendAlpha));
; 1566 : 		}
; 1567 : 	}
; 1568 : #endif // #if 1
; 1569 : 
; 1570 : 	return(1);

	mov	al, 1
	pop	ebx

; 1571 : }

	add	esp, 136				; 00000088H
	ret	16					; 00000010H
$L13205:

; 1451 : 		}
; 1452 : 		break;
; 1453 : 	case 2: // uncompressed, compressed, no blend
; 1454 : 		frm0Pure = &frm[0]->m_PurePos[0];

	mov	eax, DWORD PTR [ebx+44]

; 1455 : 		frm1Byte = &frm[1]->m_BytePos[0];

	mov	esi, DWORD PTR [ecx+28]

; 1456 : 		frm1Group = &frm[1]->m_Groups[0];

	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR _frm0Pure$[esp+152], eax

; 1457 : 		for (i=0; i<count; i++,oV++)

	mov	eax, DWORD PTR _inNumVerts$[esp+148]
	xor	edx, edx
	cmp	eax, ebp
	mov	DWORD PTR _frm1Group$[esp+152], ecx
	jbe	$L13267
	mov	eax, DWORD PTR _ioVerts$[esp+148]
	lea	ebp, DWORD PTR [eax+8]
$L13206:

; 1458 : 		{
; 1459 : 			tempByte = &frm1Byte[iR[i]];

	xor	eax, eax

; 1460 : 			byteGroup = &frm1Group[tempByte->group];

	mov	ebx, DWORD PTR _frm1Group$[esp+152]
	mov	ax, WORD PTR [edi+edx*2]
	xor	ecx, ecx
	add	ebp, 12					; 0000000cH
	mov	cl, BYTE PTR [esi+eax*4]
	lea	ecx, DWORD PTR [ecx+ecx*2]
	lea	ecx, DWORD PTR [ebx+ecx*8]

; 1461 : 			vB.x = ((NFloat)tempByte->pos[0] * byteGroup->scale.x) + byteGroup->translate.x;

	xor	ebx, ebx
	mov	bl, BYTE PTR [esi+eax*4+1]
	mov	DWORD PTR -136+[esp+152], ebx

; 1462 : 			vB.y = ((NFloat)tempByte->pos[1] * byteGroup->scale.y) + byteGroup->translate.y;

	xor	ebx, ebx
	fild	DWORD PTR -136+[esp+152]
	mov	bl, BYTE PTR [esi+eax*4+2]
	mov	DWORD PTR -136+[esp+152], ebx

; 1463 : 			vB.z = ((NFloat)tempByte->pos[2] * byteGroup->scale.z) + byteGroup->translate.z;

	xor	ebx, ebx
	fmul	DWORD PTR [ecx]
	mov	bl, BYTE PTR [esi+eax*4+3]

; 1464 : 
; 1465 : 			*oV = (vB*frameAlpha) + (frm0Pure[iR[i]]*omframeAlpha);

	lea	eax, DWORD PTR [eax+eax*2]
	inc	edx
	fadd	DWORD PTR [ecx+12]
	fild	DWORD PTR -136+[esp+152]
	mov	DWORD PTR -136+[esp+152], ebx
	fmul	DWORD PTR [ecx+4]
	fadd	DWORD PTR [ecx+16]
	fild	DWORD PTR -136+[esp+152]
	fmul	DWORD PTR [ecx+8]
	fadd	DWORD PTR [ecx+20]
	mov	ecx, DWORD PTR _frm0Pure$[esp+152]
	lea	eax, DWORD PTR [ecx+eax*4]
	fstp	DWORD PTR _vB$[esp+160]
	fld	DWORD PTR _omframeAlpha$[esp+152]
	fmul	DWORD PTR [eax]
	fstp	DWORD PTR $T30825[esp+152]
	fld	DWORD PTR _omframeAlpha$[esp+152]
	fmul	DWORD PTR [eax+4]
	fstp	DWORD PTR $T30825[esp+156]
	fld	DWORD PTR _omframeAlpha$[esp+152]
	fmul	DWORD PTR [eax+8]
	fstp	DWORD PTR $T30825[esp+160]
	fxch	ST(1)
	fmul	DWORD PTR _frameAlpha$[esp+152]
	fstp	DWORD PTR $T30826[esp+152]
	fmul	DWORD PTR _frameAlpha$[esp+152]
	fstp	DWORD PTR $T30826[esp+156]
	fld	DWORD PTR _vB$[esp+160]
	fmul	DWORD PTR _frameAlpha$[esp+152]
	fld	DWORD PTR $T30826[esp+152]
	fadd	DWORD PTR $T30825[esp+152]
	fld	DWORD PTR $T30826[esp+156]
	fadd	DWORD PTR $T30825[esp+156]
	fxch	ST(2)
	fadd	DWORD PTR $T30825[esp+160]
	fstp	DWORD PTR $T30827[esp+160]
	mov	eax, DWORD PTR $T30827[esp+160]
	fstp	DWORD PTR [ebp-20]
	mov	DWORD PTR [ebp-12], eax
	mov	eax, DWORD PTR _inNumVerts$[esp+148]
	fstp	DWORD PTR [ebp-16]
	cmp	edx, eax
	jb	$L13206
	pop	edi
	pop	esi
	pop	ebp

; 1546 : 		}
; 1547 : 		break;	
; 1548 : 	}
; 1549 : #else
; 1550 : 	if (mBlendAlpha >= 1.f)
; 1551 : 	{
; 1552 : 		for (i=0; i<count; i++,oV++)//,iE++)
; 1553 : 		{
; 1554 : 			//if (!(*iE))
; 1555 : 			//	continue;
; 1556 : 			*oV = (frm[1]->GetPosition(i)*frameAlpha) + (frm[0]->GetPosition(i)*(1.f-frameAlpha));
; 1557 : 		}
; 1558 : 	}
; 1559 : 	else
; 1560 : 	{
; 1561 : 		for (i=0; i<count; i++,oV++)//,iE++)
; 1562 : 		{
; 1563 : 			//if (!(*iE))
; 1564 : 			//	continue;
; 1565 : 			*oV = (((frm[1]->GetPosition(i)*frameAlpha) + (frm[0]->GetPosition(i)*(1.f-frameAlpha))) * mBlendAlpha) + (*oV * (1.f-mBlendAlpha));
; 1566 : 		}
; 1567 : 	}
; 1568 : #endif // #if 1
; 1569 : 
; 1570 : 	return(1);

	mov	al, 1
	pop	ebx

; 1571 : }

	add	esp, 136				; 00000088H
	ret	16					; 00000010H
$L13215:

; 1466 : 		}
; 1467 : 		break;
; 1468 : 	case 3: // compressed, compressed, no blend
; 1469 : 		frm0Byte = &frm[0]->m_BytePos[0];
; 1470 : 		frm1Byte = &frm[1]->m_BytePos[0];
; 1471 : 		frm0Group = &frm[0]->m_Groups[0];
; 1472 : 		frm1Group = &frm[1]->m_Groups[0];

	mov	eax, DWORD PTR [ecx+12]
	mov	ebp, DWORD PTR [ecx+28]

; 1473 : 		for (i=0; i<count; i++,oV++)

	mov	ecx, DWORD PTR _inNumVerts$[esp+148]
	mov	edx, DWORD PTR [ebx+12]
	mov	esi, DWORD PTR [ebx+28]
	mov	DWORD PTR _frm1Group$[esp+152], eax
	xor	eax, eax
	mov	DWORD PTR _frm0Group$[esp+152], edx
	test	ecx, ecx
	mov	DWORD PTR _i$[esp+152], eax
	jbe	$L13267
	mov	ecx, DWORD PTR _ioVerts$[esp+148]
	lea	edx, DWORD PTR [ecx+8]
$L13216:

; 1474 : 		{
; 1475 : 			tempByte = &frm0Byte[iR[i]];

	xor	ecx, ecx

; 1476 : 			byteGroup = &frm0Group[tempByte->group];

	mov	ebx, DWORD PTR _frm0Group$[esp+152]
	mov	cx, WORD PTR [edi+eax*2]
	mov	eax, ecx
	xor	ecx, ecx
	shl	eax, 2
	mov	cl, BYTE PTR [eax+esi]
	lea	ecx, DWORD PTR [ecx+ecx*2]
	lea	ecx, DWORD PTR [ebx+ecx*8]

; 1477 : 			vA.x = ((NFloat)tempByte->pos[0] * byteGroup->scale.x) + byteGroup->translate.x;

	xor	ebx, ebx
	mov	bl, BYTE PTR [eax+esi+1]
	mov	DWORD PTR -136+[esp+152], ebx

; 1478 : 			vA.y = ((NFloat)tempByte->pos[1] * byteGroup->scale.y) + byteGroup->translate.y;

	xor	ebx, ebx
	fild	DWORD PTR -136+[esp+152]
	mov	bl, BYTE PTR [eax+esi+2]
	mov	DWORD PTR -136+[esp+152], ebx

; 1479 : 			vA.z = ((NFloat)tempByte->pos[2] * byteGroup->scale.z) + byteGroup->translate.z;

	xor	ebx, ebx
	fmul	DWORD PTR [ecx]
	mov	bl, BYTE PTR [eax+esi+3]
	fadd	DWORD PTR [ecx+12]
	fild	DWORD PTR -136+[esp+152]
	mov	DWORD PTR -136+[esp+152], ebx

; 1480 : 
; 1481 : 			tempByte = &frm1Byte[iR[i]];
; 1482 : 			byteGroup = &frm1Group[tempByte->group];

	mov	ebx, DWORD PTR _frm1Group$[esp+152]
	fmul	DWORD PTR [ecx+4]
	fadd	DWORD PTR [ecx+16]
	fild	DWORD PTR -136+[esp+152]
	fmul	DWORD PTR [ecx+8]
	fadd	DWORD PTR [ecx+20]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+ebp]
	fstp	DWORD PTR _vA$[esp+160]
	lea	ecx, DWORD PTR [ecx+ecx*2]
	lea	ecx, DWORD PTR [ebx+ecx*8]

; 1483 : 			vB.x = ((NFloat)tempByte->pos[0] * byteGroup->scale.x) + byteGroup->translate.x;

	xor	ebx, ebx
	mov	bl, BYTE PTR [eax+ebp+1]
	mov	DWORD PTR -136+[esp+152], ebx

; 1484 : 			vB.y = ((NFloat)tempByte->pos[1] * byteGroup->scale.y) + byteGroup->translate.y;

	xor	ebx, ebx
	fild	DWORD PTR -136+[esp+152]
	mov	bl, BYTE PTR [eax+ebp+2]
	mov	DWORD PTR -136+[esp+152], ebx

; 1485 : 			vB.z = ((NFloat)tempByte->pos[2] * byteGroup->scale.z) + byteGroup->translate.z;

	xor	ebx, ebx
	fmul	DWORD PTR [ecx]
	mov	bl, BYTE PTR [eax+ebp+3]
	fadd	DWORD PTR [ecx+12]
	fstp	DWORD PTR _vB$[esp+152]
	fild	DWORD PTR -136+[esp+152]
	mov	DWORD PTR -136+[esp+152], ebx
	fmul	DWORD PTR [ecx+4]
	fadd	DWORD PTR [ecx+16]
	fstp	DWORD PTR _vB$[esp+156]
	fild	DWORD PTR -136+[esp+152]
	fmul	DWORD PTR [ecx+8]
	fadd	DWORD PTR [ecx+20]
	fstp	DWORD PTR _vB$[esp+160]

; 1486 : 
; 1487 : 			*oV = (vB*frameAlpha) + (vA*omframeAlpha);

	fxch	ST(1)
	fmul	DWORD PTR _omframeAlpha$[esp+152]
	fstp	DWORD PTR $T30828[esp+152]
	fmul	DWORD PTR _omframeAlpha$[esp+152]
	fstp	DWORD PTR $T30828[esp+156]
	fld	DWORD PTR _vA$[esp+160]
	fmul	DWORD PTR _omframeAlpha$[esp+152]
	fld	DWORD PTR _vB$[esp+152]
	fmul	DWORD PTR _frameAlpha$[esp+152]
	fld	DWORD PTR _vB$[esp+156]
	fmul	DWORD PTR _frameAlpha$[esp+152]
	fstp	DWORD PTR $T30829[esp+156]
	fld	DWORD PTR _vB$[esp+160]
	fmul	DWORD PTR _frameAlpha$[esp+152]
	fstp	DWORD PTR $T30829[esp+160]
	fadd	DWORD PTR $T30828[esp+152]
	fld	DWORD PTR $T30829[esp+156]
	fadd	DWORD PTR $T30828[esp+156]
	fld	DWORD PTR $T30829[esp+160]
	fadd	ST(0), ST(3)
	mov	ecx, DWORD PTR _inNumVerts$[esp+148]
	add	edx, 12					; 0000000cH
	fstp	DWORD PTR $T30830[esp+160]
	mov	eax, DWORD PTR $T30830[esp+160]
	fxch	ST(1)
	fstp	DWORD PTR [edx-20]
	mov	DWORD PTR [edx-12], eax
	mov	eax, DWORD PTR _i$[esp+152]
	fstp	DWORD PTR [edx-16]
	inc	eax
	cmp	eax, ecx
	mov	DWORD PTR _i$[esp+152], eax
	fstp	ST(0)
	jb	$L13216
	pop	edi
	pop	esi
	pop	ebp

; 1546 : 		}
; 1547 : 		break;	
; 1548 : 	}
; 1549 : #else
; 1550 : 	if (mBlendAlpha >= 1.f)
; 1551 : 	{
; 1552 : 		for (i=0; i<count; i++,oV++)//,iE++)
; 1553 : 		{
; 1554 : 			//if (!(*iE))
; 1555 : 			//	continue;
; 1556 : 			*oV = (frm[1]->GetPosition(i)*frameAlpha) + (frm[0]->GetPosition(i)*(1.f-frameAlpha));
; 1557 : 		}
; 1558 : 	}
; 1559 : 	else
; 1560 : 	{
; 1561 : 		for (i=0; i<count; i++,oV++)//,iE++)
; 1562 : 		{
; 1563 : 			//if (!(*iE))
; 1564 : 			//	continue;
; 1565 : 			*oV = (((frm[1]->GetPosition(i)*frameAlpha) + (frm[0]->GetPosition(i)*(1.f-frameAlpha))) * mBlendAlpha) + (*oV * (1.f-mBlendAlpha));
; 1566 : 		}
; 1567 : 	}
; 1568 : #endif // #if 1
; 1569 : 
; 1570 : 	return(1);

	mov	al, 1
	pop	ebx

; 1571 : }

	add	esp, 136				; 00000088H
	ret	16					; 00000010H
$L13228:

; 1488 : 		}
; 1489 : 		break;
; 1490 : 	case 4: // uncompressed, uncompressed, blend
; 1491 : 		frm0Pure = &frm[0]->m_PurePos[0];
; 1492 : 		frm1Pure = &frm[1]->m_PurePos[0];
; 1493 : 		for (i=0; i<count; i++,oV++)

	mov	ebp, DWORD PTR _inNumVerts$[esp+148]
	mov	ebx, DWORD PTR [ebx+44]
	mov	esi, DWORD PTR [ecx+44]
	xor	edx, edx
	test	ebp, ebp
	jbe	$L13267
	mov	ecx, DWORD PTR _ioVerts$[esp+148]
	add	ecx, 8
$L13229:

; 1494 : 			*oV = (((frm1Pure[iR[i]]*frameAlpha) + (frm0Pure[iR[i]]*omframeAlpha)) * mBlendAlpha) + (*oV * omBlendAlpha);

	fld	DWORD PTR _omBlendAlpha$[esp+152]
	fmul	DWORD PTR [ecx-8]
	fld	DWORD PTR _omBlendAlpha$[esp+152]
	fmul	DWORD PTR [ecx-4]
	xor	eax, eax
	add	ecx, 12					; 0000000cH
	mov	ax, WORD PTR [edi+edx*2]
	fstp	DWORD PTR $T30831[esp+156]
	fld	DWORD PTR _omBlendAlpha$[esp+152]
	fmul	DWORD PTR [ecx-12]
	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 2
	fstp	DWORD PTR $T30831[esp+160]
	fld	DWORD PTR _omframeAlpha$[esp+152]
	fmul	DWORD PTR [eax+ebx]
	fld	DWORD PTR _omframeAlpha$[esp+152]
	fmul	DWORD PTR [eax+ebx+4]
	fld	DWORD PTR _omframeAlpha$[esp+152]
	fmul	DWORD PTR [eax+ebx+8]
	inc	edx
	cmp	edx, ebp
	fstp	DWORD PTR $T30832[esp+160]
	fld	DWORD PTR _frameAlpha$[esp+152]
	fmul	DWORD PTR [eax+esi]
	fld	DWORD PTR _frameAlpha$[esp+152]
	fmul	DWORD PTR [eax+esi+4]
	fstp	DWORD PTR $T30833[esp+156]
	fld	DWORD PTR _frameAlpha$[esp+152]
	fmul	DWORD PTR [eax+esi+8]
	mov	eax, DWORD PTR _this$[esp+152]
	fstp	DWORD PTR $T30833[esp+160]
	fadd	ST(0), ST(2)
	fstp	DWORD PTR $T30834[esp+152]
	fld	DWORD PTR $T30833[esp+156]
	fadd	ST(0), ST(1)
	fstp	ST(2)
	fstp	ST(0)
	fld	DWORD PTR $T30833[esp+160]
	fadd	DWORD PTR $T30832[esp+160]
	fld	DWORD PTR [eax+64]
	fld	DWORD PTR $T30834[esp+152]
	fmul	ST(0), ST(1)
	fstp	DWORD PTR $T30835[esp+152]
	fxch	ST(2)
	fmul	ST(0), ST(2)
	fstp	DWORD PTR $T30835[esp+156]
	fmul	ST(0), ST(1)
	fstp	DWORD PTR $T30835[esp+160]
	fstp	ST(0)
	fadd	DWORD PTR $T30835[esp+152]
	fld	DWORD PTR $T30835[esp+156]
	fadd	DWORD PTR $T30831[esp+156]
	fld	DWORD PTR $T30835[esp+160]
	fadd	DWORD PTR $T30831[esp+160]
	fstp	DWORD PTR $T30836[esp+160]
	mov	eax, DWORD PTR $T30836[esp+160]
	fxch	ST(1)
	fstp	DWORD PTR [ecx-20]
	mov	DWORD PTR [ecx-12], eax
	fstp	DWORD PTR [ecx-16]
	jb	$L13229
	pop	edi
	pop	esi
	pop	ebp

; 1546 : 		}
; 1547 : 		break;	
; 1548 : 	}
; 1549 : #else
; 1550 : 	if (mBlendAlpha >= 1.f)
; 1551 : 	{
; 1552 : 		for (i=0; i<count; i++,oV++)//,iE++)
; 1553 : 		{
; 1554 : 			//if (!(*iE))
; 1555 : 			//	continue;
; 1556 : 			*oV = (frm[1]->GetPosition(i)*frameAlpha) + (frm[0]->GetPosition(i)*(1.f-frameAlpha));
; 1557 : 		}
; 1558 : 	}
; 1559 : 	else
; 1560 : 	{
; 1561 : 		for (i=0; i<count; i++,oV++)//,iE++)
; 1562 : 		{
; 1563 : 			//if (!(*iE))
; 1564 : 			//	continue;
; 1565 : 			*oV = (((frm[1]->GetPosition(i)*frameAlpha) + (frm[0]->GetPosition(i)*(1.f-frameAlpha))) * mBlendAlpha) + (*oV * (1.f-mBlendAlpha));
; 1566 : 		}
; 1567 : 	}
; 1568 : #endif // #if 1
; 1569 : 
; 1570 : 	return(1);

	mov	al, 1
	pop	ebx

; 1571 : }

	add	esp, 136				; 00000088H
	ret	16					; 00000010H
$L13238:

; 1495 : 		break;
; 1496 : 	case 5: // compressed, uncompressed, blend
; 1497 : 		frm0Byte = &frm[0]->m_BytePos[0];

	mov	ebp, DWORD PTR [ebx+28]

; 1498 : 		frm1Pure = &frm[1]->m_PurePos[0];
; 1499 : 		frm0Group = &frm[0]->m_Groups[0];

	mov	edx, DWORD PTR [ebx+12]

; 1500 : 		for (i=0; i<count; i++,oV++)

	mov	eax, DWORD PTR _inNumVerts$[esp+148]
	mov	ecx, DWORD PTR [ecx+44]
	xor	ebx, ebx
	mov	DWORD PTR _frm1Pure$[esp+152], ecx
	test	eax, eax
	mov	DWORD PTR _frm0Group$[esp+152], edx
	jbe	$L13267
	mov	eax, DWORD PTR _ioVerts$[esp+148]
	lea	ecx, DWORD PTR [eax+8]
$L13239:

; 1501 : 		{
; 1502 : 			tempByte = &frm0Byte[iR[i]];

	xor	eax, eax

; 1503 : 			byteGroup = &frm0Group[tempByte->group];

	mov	esi, DWORD PTR _frm0Group$[esp+152]
	mov	ax, WORD PTR [edi+ebx*2]
	xor	edx, edx
	mov	dl, BYTE PTR [ebp+eax*4]
	lea	edx, DWORD PTR [edx+edx*2]
	lea	esi, DWORD PTR [esi+edx*8]

; 1504 : 			vA.x = ((NFloat)tempByte->pos[0] * byteGroup->scale.x) + byteGroup->translate.x;

	xor	edx, edx
	mov	dl, BYTE PTR [ebp+eax*4+1]
	mov	DWORD PTR -120+[esp+152], edx

; 1505 : 			vA.y = ((NFloat)tempByte->pos[1] * byteGroup->scale.y) + byteGroup->translate.y;

	xor	edx, edx
	fild	DWORD PTR -120+[esp+152]
	mov	dl, BYTE PTR [ebp+eax*4+2]
	mov	DWORD PTR -120+[esp+152], edx

; 1506 : 			vA.z = ((NFloat)tempByte->pos[2] * byteGroup->scale.z) + byteGroup->translate.z;

	xor	edx, edx
	fmul	DWORD PTR [esi]
	mov	dl, BYTE PTR [ebp+eax*4+3]

; 1507 : 
; 1508 : 			*oV = (((frm1Pure[iR[i]]*frameAlpha) + (vA*omframeAlpha)) * mBlendAlpha) + (*oV * omBlendAlpha);

	lea	eax, DWORD PTR [eax+eax*2]
	fadd	DWORD PTR [esi+12]
	fild	DWORD PTR -120+[esp+152]
	mov	DWORD PTR -120+[esp+152], edx
	mov	edx, DWORD PTR _frm1Pure$[esp+152]
	fmul	DWORD PTR [esi+4]
	lea	eax, DWORD PTR [edx+eax*4]
	fadd	DWORD PTR [esi+16]
	fild	DWORD PTR -120+[esp+152]
	fmul	DWORD PTR [esi+8]
	fadd	DWORD PTR [esi+20]
	fstp	DWORD PTR _vA$[esp+160]
	fld	DWORD PTR _omBlendAlpha$[esp+152]
	fmul	DWORD PTR [ecx-8]
	fstp	DWORD PTR $T30837[esp+152]
	fld	DWORD PTR _omBlendAlpha$[esp+152]
	fmul	DWORD PTR [ecx-4]
	fstp	DWORD PTR $T30837[esp+156]
	fld	DWORD PTR _omBlendAlpha$[esp+152]
	fmul	DWORD PTR [ecx]
	fstp	DWORD PTR $T30837[esp+160]
	fxch	ST(1)
	fmul	DWORD PTR _omframeAlpha$[esp+152]
	fstp	DWORD PTR $T30838[esp+152]
	fmul	DWORD PTR _omframeAlpha$[esp+152]
	fld	DWORD PTR _vA$[esp+160]
	fmul	DWORD PTR _omframeAlpha$[esp+152]
	fld	DWORD PTR _frameAlpha$[esp+152]
	fmul	DWORD PTR [eax]
	fld	DWORD PTR _frameAlpha$[esp+152]
	fmul	DWORD PTR [eax+4]
	fld	DWORD PTR _frameAlpha$[esp+152]
	fmul	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _this$[esp+152]
	fstp	DWORD PTR $T30839[esp+160]
	fxch	ST(1)
	fadd	DWORD PTR $T30838[esp+152]
	fstp	DWORD PTR $T30840[esp+152]
	fadd	ST(0), ST(2)
	fstp	DWORD PTR $T30840[esp+156]
	fld	DWORD PTR $T30839[esp+160]
	fadd	ST(0), ST(1)
	fstp	ST(2)
	fstp	ST(0)
	fld	DWORD PTR [eax+64]
	fld	DWORD PTR $T30840[esp+152]
	fmul	ST(0), ST(1)
	fstp	DWORD PTR $T30841[esp+152]
	fld	DWORD PTR $T30840[esp+156]
	fmul	ST(0), ST(1)
	mov	eax, DWORD PTR _inNumVerts$[esp+148]
	inc	ebx
	add	ecx, 12					; 0000000cH
	cmp	ebx, eax
	fstp	DWORD PTR $T30841[esp+156]
	fxch	ST(1)
	fmul	ST(0), ST(1)
	fxch	ST(1)
	fstp	ST(0)
	fld	DWORD PTR $T30841[esp+152]
	fadd	DWORD PTR $T30837[esp+152]
	fld	DWORD PTR $T30841[esp+156]
	fadd	DWORD PTR $T30837[esp+156]
	fxch	ST(2)
	fadd	DWORD PTR $T30837[esp+160]
	fstp	DWORD PTR $T30842[esp+160]
	mov	edx, DWORD PTR $T30842[esp+160]
	fstp	DWORD PTR [ecx-20]
	mov	DWORD PTR [ecx-12], edx
	fstp	DWORD PTR [ecx-16]
	jb	$L13239
	pop	edi
	pop	esi
	pop	ebp

; 1546 : 		}
; 1547 : 		break;	
; 1548 : 	}
; 1549 : #else
; 1550 : 	if (mBlendAlpha >= 1.f)
; 1551 : 	{
; 1552 : 		for (i=0; i<count; i++,oV++)//,iE++)
; 1553 : 		{
; 1554 : 			//if (!(*iE))
; 1555 : 			//	continue;
; 1556 : 			*oV = (frm[1]->GetPosition(i)*frameAlpha) + (frm[0]->GetPosition(i)*(1.f-frameAlpha));
; 1557 : 		}
; 1558 : 	}
; 1559 : 	else
; 1560 : 	{
; 1561 : 		for (i=0; i<count; i++,oV++)//,iE++)
; 1562 : 		{
; 1563 : 			//if (!(*iE))
; 1564 : 			//	continue;
; 1565 : 			*oV = (((frm[1]->GetPosition(i)*frameAlpha) + (frm[0]->GetPosition(i)*(1.f-frameAlpha))) * mBlendAlpha) + (*oV * (1.f-mBlendAlpha));
; 1566 : 		}
; 1567 : 	}
; 1568 : #endif // #if 1
; 1569 : 
; 1570 : 	return(1);

	mov	al, 1
	pop	ebx

; 1571 : }

	add	esp, 136				; 00000088H
	ret	16					; 00000010H
$L13251:

; 1509 : 		}
; 1510 : 		break;
; 1511 : 	case 6: // uncompressed, compressed, blend
; 1512 : 		frm0Pure = &frm[0]->m_PurePos[0];

	mov	eax, DWORD PTR [ebx+44]

; 1513 : 		frm1Byte = &frm[1]->m_BytePos[0];

	mov	ebp, DWORD PTR [ecx+28]

; 1514 : 		frm1Group = &frm[1]->m_Groups[0];

	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR _frm0Pure$[esp+152], eax

; 1515 : 		for (i=0; i<count; i++,oV++)

	mov	eax, DWORD PTR _inNumVerts$[esp+148]
	xor	edx, edx
	test	eax, eax
	mov	DWORD PTR _frm1Group$[esp+152], ecx
	jbe	$L13267
	mov	eax, DWORD PTR _ioVerts$[esp+148]
	lea	ecx, DWORD PTR [eax+8]
$L13252:

; 1516 : 		{
; 1517 : 			tempByte = &frm1Byte[iR[i]];

	xor	eax, eax

; 1518 : 			byteGroup = &frm1Group[tempByte->group];

	xor	ebx, ebx
	mov	ax, WORD PTR [edi+edx*2]
	mov	bl, BYTE PTR [ebp+eax*4]
	mov	esi, ebx
	mov	ebx, DWORD PTR _frm1Group$[esp+152]
	lea	esi, DWORD PTR [esi+esi*2]
	lea	esi, DWORD PTR [ebx+esi*8]

; 1519 : 			vB.x = ((NFloat)tempByte->pos[0] * byteGroup->scale.x) + byteGroup->translate.x;

	xor	ebx, ebx
	mov	bl, BYTE PTR [ebp+eax*4+1]
	mov	DWORD PTR -124+[esp+152], ebx

; 1520 : 			vB.y = ((NFloat)tempByte->pos[1] * byteGroup->scale.y) + byteGroup->translate.y;

	xor	ebx, ebx
	fild	DWORD PTR -124+[esp+152]
	mov	bl, BYTE PTR [ebp+eax*4+2]
	mov	DWORD PTR -124+[esp+152], ebx

; 1521 : 			vB.z = ((NFloat)tempByte->pos[2] * byteGroup->scale.z) + byteGroup->translate.z;

	xor	ebx, ebx
	fmul	DWORD PTR [esi]
	mov	bl, BYTE PTR [ebp+eax*4+3]

; 1522 : 
; 1523 : 			*oV = (((vB*frameAlpha) + (frm0Pure[iR[i]]*omframeAlpha)) * mBlendAlpha) + (*oV * omBlendAlpha);

	lea	eax, DWORD PTR [eax+eax*2]
	fadd	DWORD PTR [esi+12]
	fild	DWORD PTR -124+[esp+152]
	mov	DWORD PTR -124+[esp+152], ebx
	fmul	DWORD PTR [esi+4]
	fadd	DWORD PTR [esi+16]
	fild	DWORD PTR -124+[esp+152]
	fmul	DWORD PTR [esi+8]
	fadd	DWORD PTR [esi+20]
	mov	esi, DWORD PTR _frm0Pure$[esp+152]
	lea	eax, DWORD PTR [esi+eax*4]
	fstp	DWORD PTR _vB$[esp+160]
	fld	DWORD PTR _omBlendAlpha$[esp+152]
	fmul	DWORD PTR [ecx-8]
	fstp	DWORD PTR $T30843[esp+152]
	fld	DWORD PTR _omBlendAlpha$[esp+152]
	fmul	DWORD PTR [ecx-4]
	fstp	DWORD PTR $T30843[esp+156]
	fld	DWORD PTR _omBlendAlpha$[esp+152]
	fmul	DWORD PTR [ecx]
	fstp	DWORD PTR $T30843[esp+160]
	fld	DWORD PTR _omframeAlpha$[esp+152]
	fmul	DWORD PTR [eax]
	fstp	DWORD PTR $T30844[esp+152]
	fld	DWORD PTR _omframeAlpha$[esp+152]
	fmul	DWORD PTR [eax+4]
	fstp	DWORD PTR $T30844[esp+156]
	fld	DWORD PTR _omframeAlpha$[esp+152]
	fmul	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _this$[esp+152]
	fstp	DWORD PTR $T30844[esp+160]
	fxch	ST(1)
	fmul	DWORD PTR _frameAlpha$[esp+152]
	fstp	DWORD PTR $T30845[esp+152]
	fmul	DWORD PTR _frameAlpha$[esp+152]
	fld	DWORD PTR _vB$[esp+160]
	fmul	DWORD PTR _frameAlpha$[esp+152]
	fld	DWORD PTR $T30845[esp+152]
	fadd	DWORD PTR $T30844[esp+152]
	fstp	DWORD PTR $T30846[esp+152]
	fxch	ST(1)
	fadd	DWORD PTR $T30844[esp+156]
	fstp	DWORD PTR $T30846[esp+156]
	fadd	DWORD PTR $T30844[esp+160]
	fld	DWORD PTR [eax+64]
	fld	DWORD PTR $T30846[esp+152]
	fmul	ST(0), ST(1)
	fstp	DWORD PTR $T30847[esp+152]
	fld	DWORD PTR $T30846[esp+156]
	fmul	ST(0), ST(1)
	inc	edx
	add	ecx, 12					; 0000000cH
	fstp	DWORD PTR $T30847[esp+156]
	fxch	ST(1)
	fmul	ST(0), ST(1)
	fxch	ST(1)
	fstp	ST(0)
	fld	DWORD PTR $T30847[esp+152]
	fadd	DWORD PTR $T30843[esp+152]
	fld	DWORD PTR $T30847[esp+156]
	fadd	DWORD PTR $T30843[esp+156]
	fxch	ST(2)
	fadd	DWORD PTR $T30843[esp+160]
	fstp	DWORD PTR $T30848[esp+160]
	mov	eax, DWORD PTR $T30848[esp+160]
	fstp	DWORD PTR [ecx-20]
	mov	DWORD PTR [ecx-12], eax
	mov	eax, DWORD PTR _inNumVerts$[esp+148]
	fstp	DWORD PTR [ecx-16]
	cmp	edx, eax
	jb	$L13252
	pop	edi
	pop	esi
	pop	ebp

; 1546 : 		}
; 1547 : 		break;	
; 1548 : 	}
; 1549 : #else
; 1550 : 	if (mBlendAlpha >= 1.f)
; 1551 : 	{
; 1552 : 		for (i=0; i<count; i++,oV++)//,iE++)
; 1553 : 		{
; 1554 : 			//if (!(*iE))
; 1555 : 			//	continue;
; 1556 : 			*oV = (frm[1]->GetPosition(i)*frameAlpha) + (frm[0]->GetPosition(i)*(1.f-frameAlpha));
; 1557 : 		}
; 1558 : 	}
; 1559 : 	else
; 1560 : 	{
; 1561 : 		for (i=0; i<count; i++,oV++)//,iE++)
; 1562 : 		{
; 1563 : 			//if (!(*iE))
; 1564 : 			//	continue;
; 1565 : 			*oV = (((frm[1]->GetPosition(i)*frameAlpha) + (frm[0]->GetPosition(i)*(1.f-frameAlpha))) * mBlendAlpha) + (*oV * (1.f-mBlendAlpha));
; 1566 : 		}
; 1567 : 	}
; 1568 : #endif // #if 1
; 1569 : 
; 1570 : 	return(1);

	mov	al, 1
	pop	ebx

; 1571 : }

	add	esp, 136				; 00000088H
	ret	16					; 00000010H
$L13264:

; 1524 : 		}
; 1525 : 		break;
; 1526 : 	case 7: // compressed, compressed, blend
; 1527 : 		frm0Byte = &frm[0]->m_BytePos[0];
; 1528 : 		frm1Byte = &frm[1]->m_BytePos[0];

	mov	edx, DWORD PTR [ecx+28]

; 1529 : 		frm0Group = &frm[0]->m_Groups[0];
; 1530 : 		frm1Group = &frm[1]->m_Groups[0];

	mov	ecx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR [ebx+12]
	mov	ebp, DWORD PTR [ebx+28]
	mov	DWORD PTR _frm1Group$[esp+152], ecx

; 1531 : 		for (i=0; i<count; i++,oV++)

	mov	ecx, DWORD PTR _inNumVerts$[esp+148]
	mov	DWORD PTR _frm0Group$[esp+152], eax
	xor	eax, eax
	test	ecx, ecx
	mov	DWORD PTR _i$[esp+152], eax
	jbe	$L13267
	mov	ecx, DWORD PTR _ioVerts$[esp+148]
	add	ecx, 8
$L13265:

; 1532 : 		{
; 1533 : 			tempByte = &frm0Byte[iR[i]];

	xor	esi, esi

; 1534 : 			byteGroup = &frm0Group[tempByte->group];

	xor	ebx, ebx
	mov	si, WORD PTR [edi+eax*2]
	mov	eax, esi
	shl	eax, 2
	mov	bl, BYTE PTR [eax+ebp]
	mov	esi, ebx
	mov	ebx, DWORD PTR _frm0Group$[esp+152]
	lea	esi, DWORD PTR [esi+esi*2]
	lea	esi, DWORD PTR [ebx+esi*8]

; 1535 : 			vA.x = ((NFloat)tempByte->pos[0] * byteGroup->scale.x) + byteGroup->translate.x;

	xor	ebx, ebx
	mov	bl, BYTE PTR [eax+ebp+1]
	mov	DWORD PTR -112+[esp+152], ebx

; 1536 : 			vA.y = ((NFloat)tempByte->pos[1] * byteGroup->scale.y) + byteGroup->translate.y;

	xor	ebx, ebx
	fild	DWORD PTR -112+[esp+152]
	mov	bl, BYTE PTR [eax+ebp+2]
	mov	DWORD PTR -112+[esp+152], ebx

; 1537 : 			vA.z = ((NFloat)tempByte->pos[2] * byteGroup->scale.z) + byteGroup->translate.z;

	xor	ebx, ebx
	fmul	DWORD PTR [esi]
	mov	bl, BYTE PTR [eax+ebp+3]
	fadd	DWORD PTR [esi+12]
	fild	DWORD PTR -112+[esp+152]
	mov	DWORD PTR -112+[esp+152], ebx

; 1538 : 
; 1539 : 			tempByte = &frm1Byte[iR[i]];
; 1540 : 			byteGroup = &frm1Group[tempByte->group];

	xor	ebx, ebx
	mov	bl, BYTE PTR [eax+edx]
	fmul	DWORD PTR [esi+4]
	fadd	DWORD PTR [esi+16]
	fild	DWORD PTR -112+[esp+152]
	fmul	DWORD PTR [esi+8]
	fadd	DWORD PTR [esi+20]
	mov	esi, ebx
	mov	ebx, DWORD PTR _frm1Group$[esp+152]
	lea	esi, DWORD PTR [esi+esi*2]
	fstp	DWORD PTR _vA$[esp+160]
	lea	esi, DWORD PTR [ebx+esi*8]

; 1541 : 			vB.x = ((NFloat)tempByte->pos[0] * byteGroup->scale.x) + byteGroup->translate.x;

	xor	ebx, ebx
	mov	bl, BYTE PTR [eax+edx+1]
	mov	DWORD PTR -112+[esp+152], ebx

; 1542 : 			vB.y = ((NFloat)tempByte->pos[1] * byteGroup->scale.y) + byteGroup->translate.y;

	xor	ebx, ebx
	fild	DWORD PTR -112+[esp+152]
	mov	bl, BYTE PTR [eax+edx+2]
	mov	DWORD PTR -112+[esp+152], ebx

; 1543 : 			vB.z = ((NFloat)tempByte->pos[2] * byteGroup->scale.z) + byteGroup->translate.z;

	xor	ebx, ebx
	fmul	DWORD PTR [esi]
	mov	bl, BYTE PTR [eax+edx+3]
	fadd	DWORD PTR [esi+12]
	fstp	DWORD PTR _vB$[esp+152]
	fild	DWORD PTR -112+[esp+152]
	mov	DWORD PTR -112+[esp+152], ebx
	fmul	DWORD PTR [esi+4]
	fadd	DWORD PTR [esi+16]
	fstp	DWORD PTR _vB$[esp+156]
	fild	DWORD PTR -112+[esp+152]
	fmul	DWORD PTR [esi+8]
	fadd	DWORD PTR [esi+20]
	fstp	DWORD PTR _vB$[esp+160]

; 1544 : 
; 1545 : 			*oV = (((vB*frameAlpha) + (vA*omframeAlpha)) * mBlendAlpha) + (*oV * omBlendAlpha);

	fld	DWORD PTR _omBlendAlpha$[esp+152]
	fmul	DWORD PTR [ecx-8]
	fstp	DWORD PTR $T30849[esp+152]
	fld	DWORD PTR _omBlendAlpha$[esp+152]
	fmul	DWORD PTR [ecx-4]
	fstp	DWORD PTR $T30849[esp+156]
	fld	DWORD PTR _omBlendAlpha$[esp+152]
	fmul	DWORD PTR [ecx]
	fstp	DWORD PTR $T30849[esp+160]
	fxch	ST(1)
	fmul	DWORD PTR _omframeAlpha$[esp+152]
	fstp	DWORD PTR $T30850[esp+152]
	fmul	DWORD PTR _omframeAlpha$[esp+152]
	fld	DWORD PTR _vA$[esp+160]
	fmul	DWORD PTR _omframeAlpha$[esp+152]
	fld	DWORD PTR _vB$[esp+152]
	fmul	DWORD PTR _frameAlpha$[esp+152]
	fld	DWORD PTR _vB$[esp+156]
	fmul	DWORD PTR _frameAlpha$[esp+152]
	fld	DWORD PTR _vB$[esp+160]
	fmul	DWORD PTR _frameAlpha$[esp+152]
	mov	eax, DWORD PTR _this$[esp+152]
	mov	esi, DWORD PTR _inNumVerts$[esp+148]
	add	ecx, 12					; 0000000cH
	fstp	DWORD PTR $T30851[esp+160]
	fxch	ST(1)
	fadd	DWORD PTR $T30850[esp+152]
	fstp	DWORD PTR $T30852[esp+152]
	fadd	ST(0), ST(2)
	fstp	DWORD PTR $T30852[esp+156]
	fld	DWORD PTR $T30851[esp+160]
	fadd	ST(0), ST(1)
	fstp	ST(2)
	fstp	ST(0)
	fld	DWORD PTR [eax+64]
	fld	DWORD PTR $T30852[esp+152]
	fmul	ST(0), ST(1)
	fstp	DWORD PTR $T30853[esp+152]
	fld	DWORD PTR $T30852[esp+156]
	fmul	ST(0), ST(1)
	fstp	DWORD PTR $T30853[esp+156]
	fxch	ST(1)
	fmul	ST(0), ST(1)
	fxch	ST(1)
	fstp	ST(0)
	fld	DWORD PTR $T30853[esp+152]
	fadd	DWORD PTR $T30849[esp+152]
	fld	DWORD PTR $T30853[esp+156]
	fadd	DWORD PTR $T30849[esp+156]
	fxch	ST(2)
	fadd	DWORD PTR $T30849[esp+160]
	fstp	DWORD PTR $T30854[esp+160]
	mov	eax, DWORD PTR $T30854[esp+160]
	fstp	DWORD PTR [ecx-20]
	mov	DWORD PTR [ecx-12], eax
	mov	eax, DWORD PTR _i$[esp+152]
	fstp	DWORD PTR [ecx-16]
	inc	eax
	cmp	eax, esi
	mov	DWORD PTR _i$[esp+152], eax
	jb	$L13265
$L13267:
	pop	edi
	pop	esi
	pop	ebp

; 1546 : 		}
; 1547 : 		break;	
; 1548 : 	}
; 1549 : #else
; 1550 : 	if (mBlendAlpha >= 1.f)
; 1551 : 	{
; 1552 : 		for (i=0; i<count; i++,oV++)//,iE++)
; 1553 : 		{
; 1554 : 			//if (!(*iE))
; 1555 : 			//	continue;
; 1556 : 			*oV = (frm[1]->GetPosition(i)*frameAlpha) + (frm[0]->GetPosition(i)*(1.f-frameAlpha));
; 1557 : 		}
; 1558 : 	}
; 1559 : 	else
; 1560 : 	{
; 1561 : 		for (i=0; i<count; i++,oV++)//,iE++)
; 1562 : 		{
; 1563 : 			//if (!(*iE))
; 1564 : 			//	continue;
; 1565 : 			*oV = (((frm[1]->GetPosition(i)*frameAlpha) + (frm[0]->GetPosition(i)*(1.f-frameAlpha))) * mBlendAlpha) + (*oV * (1.f-mBlendAlpha));
; 1566 : 		}
; 1567 : 	}
; 1568 : #endif // #if 1
; 1569 : 
; 1570 : 	return(1);

	mov	al, 1
	pop	ebx

; 1571 : }

	add	esp, 136				; 00000088H
	ret	16					; 00000010H
$L31470:
	DD	$L13188
	DD	$L13195
	DD	$L13205
	DD	$L13215
	DD	$L13228
	DD	$L13238
	DD	$L13251
	DD	$L13264
?EvalVerts@OMacSequenceChannel@@UAE_NPAVOMacActor@@KPAGPAVVVec3@@@Z ENDP ; OMacSequenceChannel::EvalVerts
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT _$E118
_TEXT	SEGMENT
_$E118	PROC NEAR					; COMDAT
	mov	ecx, OFFSET FLAT:?OMacIKChannel_objClassInstance@@3VCObjClass@@A
	call	??0CObjClass@@QAE@XZ			; CObjClass::CObjClass
	push	OFFSET FLAT:_$E116
	call	_atexit
	pop	ecx
	ret	0
_$E118	ENDP
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT _$E116
_TEXT	SEGMENT
_$E116	PROC NEAR					; COMDAT
	mov	ecx, OFFSET FLAT:?OMacIKChannel_objClassInstance@@3VCObjClass@@A
	jmp	??1CObjClass@@QAE@XZ			; CObjClass::~CObjClass
_$E116	ENDP
_TEXT	ENDS
PUBLIC	?New@OMacIKChannel@@SAPAV1@PAVOObject@@PAVCObjClass@@@Z ; OMacIKChannel::New
PUBLIC	??_C@_0O@HJCN@OMacIKChannel?$AA@		; `string'
;	COMDAT ??_C@_0O@HJCN@OMacIKChannel?$AA@
_DATA	SEGMENT
??_C@_0O@HJCN@OMacIKChannel?$AA@ DB 'OMacIKChannel', 00H ; `string'
; Function compile flags: /Ogty
_DATA	ENDS
;	COMDAT _$E121
_TEXT	SEGMENT
_$E121	PROC NEAR					; COMDAT
	push	0
	push	OFFSET FLAT:?New@OMacIKChannel@@SAPAV1@PAVOObject@@PAVCObjClass@@@Z ; OMacIKChannel::New
	push	OFFSET FLAT:??_C@_0M@BDBM@OMacChannel?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0O@HJCN@OMacIKChannel?$AA@ ; `string'
	push	OFFSET FLAT:?OMacIKChannel_objClassInstance@@3VCObjClass@@A ; OMacIKChannel_objClassInstance
	call	?OBJ_ConstructClass@@YAPAVCObjClass@@PAV1@PBD1P6APAVOObject@@PAV2@0@ZK@Z ; OBJ_ConstructClass
	add	esp, 20					; 00000014H
	mov	DWORD PTR ?staticObjClass@OMacIKChannel@@0PAVCObjClass@@A, eax ; OMacIKChannel::staticObjClass
	ret	0
_$E121	ENDP
_TEXT	ENDS
PUBLIC	__real@c0490fdb
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@c7efffffe0000000
PUBLIC	?EvalBones@OMacIKChannel@@UAE_NPAVOMacActor@@@Z	; OMacIKChannel::EvalBones
PUBLIC	__real@ff7fffff
;	COMDAT __real@ff7fffff
; File C:\duke4\Cannibal\VecMain.h
CONST	SEGMENT
__real@ff7fffff DD 0ff7fffffr			; -3.40282e+038
CONST	ENDS
;	COMDAT __real@c0490fdb
CONST	SEGMENT
__real@c0490fdb DD 0c0490fdbr			; -3.14159
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@c7efffffe0000000
CONST	SEGMENT
__real@c7efffffe0000000 DQ 0c7efffffe0000000r	; -3.40282e+038
; Function compile flags: /Ogty
; File C:\duke4\Cannibal\MacMain.cpp
CONST	ENDS
;	COMDAT ?EvalBones@OMacIKChannel@@UAE_NPAVOMacActor@@@Z
_TEXT	SEGMENT
$T31496 = -120
$T31497 = -384
$T31498 = -336
$T31499 = -132
$T31500 = -360
$T31501 = -108
$T31502 = -324
$T31573 = -276
_inActor$ = 8
_offsetPos$13309 = -580
_gbc$13312 = -496
_cbc$13314 = -640
_pc$13316 = -436
_pd$13318 = -348
_ud$13320 = -568
_npic$13323 = -664
_npid$13326 = -652
_raxis$13329 = -756
_wp$13336 = -768
_k1$13337 = -764
_k2$13338 = -772
_k3$13339 = -744
_cand1$13349 = -768
_cand2$13351 = -736
_cand3$13352 = -740
_tgoal$13355 = -760
_q$13359 = -424
_a$31713 = -764
_b$31714 = -772
_a$31734 = -744
_b$31735 = -772
$T31932 = -772
$T31934 = -288
_b$31946 = -772
$T31984 = -532
$T31985 = -520
$T31986 = -508
_z2$32012 = -772
_w2$32013 = -764
_xx2$32014 = -728
_yy2$32015 = -732
_zz2$32016 = -740
_xy2$32018 = -744
_xz2$32019 = -760
_xw2$32020 = -768
_yz2$32021 = -736
_yw2$32022 = -772
$T32225 = -36
$T32226 = -60
$T32227 = -84
_elderCoords$33284 = -724
$T33297 = -264
$T33311 = -156
$T33312 = -72
$T33313 = -12
$T33357 = -216
$T33360 = -300
$T33361 = -312
$T33362 = -252
$T33366 = -408
$T33367 = -48
$T33376 = -396
$T33396 = -96
$T33397 = -24
$T33398 = -372
$T31495 = -144
?EvalBones@OMacIKChannel@@UAE_NPAVOMacActor@@@Z PROC NEAR ; OMacIKChannel::EvalBones, COMDAT
; _this$ = ecx

; 1580 : 	if (!inActor || !mGoalBone)

	mov	eax, DWORD PTR _inActor$[esp-4]
	sub	esp, 772				; 00000304H
	test	eax, eax
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	ebp, ecx
	je	$L13302
	mov	edi, DWORD PTR [ebp+56]
	test	edi, edi
	je	$L13302

; 1582 : 
; 1583 : 	CMacBone* firstBone = mChildLimit ? mChildLimit : mGoalBone;

	mov	eax, DWORD PTR [ebp+60]
	test	eax, eax
	je	SHORT $L31493
	mov	edi, eax
$L31493:

; 1584 : 	CMacBone* lastBone = mParentLimit;
; 1585 : 
; 1586 : 	for (CMacBone* curBone = firstBone; curBone; curBone = curBone->mParent)

	test	edi, edi
	je	$L13308
$L13306:

; 1587 : 	{
; 1588 : 		VVec3 offsetPos = mGoalBoneOffset;

	mov	eax, DWORD PTR [ebp+68]
	mov	ecx, DWORD PTR [ebp+72]
	mov	DWORD PTR _offsetPos$13309[esp+788], eax
	mov	edx, DWORD PTR [ebp+76]

; 1589 : 		if (offsetPos.Length() < M_EPSILON)

	fld	DWORD PTR _offsetPos$13309[esp+788]
	fmul	DWORD PTR _offsetPos$13309[esp+788]
	mov	DWORD PTR _offsetPos$13309[esp+792], ecx
	mov	DWORD PTR _offsetPos$13309[esp+796], edx
	fld	DWORD PTR _offsetPos$13309[esp+792]
	fmul	DWORD PTR _offsetPos$13309[esp+792]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _offsetPos$13309[esp+796]
	fmul	DWORD PTR _offsetPos$13309[esp+796]
	faddp	ST(1), ST(0)
	fsqrt
	fcomp	DWORD PTR __real@3a83126f
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L31523

; 1590 : 			offsetPos = VVec3(0.f,0.f,0.1f);

	mov	DWORD PTR _offsetPos$13309[esp+788], 0
	mov	DWORD PTR _offsetPos$13309[esp+792], 0
	mov	DWORD PTR _offsetPos$13309[esp+796], 1036831949 ; 3dcccccdH
$L31523:

; 1591 : 
; 1592 : 		VCoords3 gbc = mGoalBone->GetCoords(true);

	mov	ebx, DWORD PTR [ebp+56]
	mov	esi, 1
	push	esi
	mov	ecx, ebx
	call	?ValidateAbs@CMacBone@@IAEX_N@Z		; CMacBone::ValidateAbs
	add	ebx, 60					; 0000003cH
	lea	ecx, DWORD PTR _gbc$13312[esp+788]
	push	ebx
	call	??0VCoords3@@QAE@ABV0@@Z		; VCoords3::VCoords3

; 1593 : 		VCoords3 cbc = curBone->GetCoords(true);

	push	esi
	mov	ecx, edi
	call	?ValidateAbs@CMacBone@@IAEX_N@Z		; CMacBone::ValidateAbs
	lea	ebx, DWORD PTR [edi+60]
	lea	ecx, DWORD PTR _cbc$13314[esp+788]
	push	ebx
	call	??0VCoords3@@QAE@ABV0@@Z		; VCoords3::VCoords3

; 1594 : 		VVec3 pc = offsetPos << gbc;

	fld	DWORD PTR _gbc$13312[esp+836]
	fmul	DWORD PTR _offsetPos$13309[esp+788]
	fld	DWORD PTR _gbc$13312[esp+840]
	fmul	DWORD PTR _offsetPos$13309[esp+792]
	fld	DWORD PTR _gbc$13312[esp+844]
	fmul	DWORD PTR _offsetPos$13309[esp+796]
	fld	DWORD PTR _gbc$13312[esp+788]
	fmul	ST(0), ST(3)
	fld	DWORD PTR _gbc$13312[esp+812]
	fmul	ST(0), ST(2)

; 1595 : 		VVec3 pd = mGoalPosition;

	mov	eax, DWORD PTR [ebp+84]
	mov	ecx, DWORD PTR [ebp+88]

; 1596 : 		VAxes3 uc = gbc.r;
; 1597 : 		VAxes3 ud = mGoalRotation;

	mov	edx, DWORD PTR [ebp+92]
	mov	DWORD PTR _pd$13318[esp+792], eax
	faddp	ST(1), ST(0)
	fld	DWORD PTR _gbc$13312[esp+800]
	fmul	ST(0), ST(3)
	mov	eax, DWORD PTR [ebp+96]
	mov	DWORD PTR _pd$13318[esp+796], ecx
	faddp	ST(1), ST(0)
	fstp	DWORD PTR $T31573[esp+788]
	fld	ST(2)
	fmul	DWORD PTR _gbc$13312[esp+792]
	fld	DWORD PTR _gbc$13312[esp+816]
	fmul	ST(0), ST(2)
	mov	DWORD PTR _ud$13320[esp+788], edx
	faddp	ST(1), ST(0)
	fld	DWORD PTR _gbc$13312[esp+804]
	fmul	ST(0), ST(3)
	faddp	ST(1), ST(0)
	fstp	DWORD PTR $T31573[esp+792]
	fxch	ST(2)
	fmul	DWORD PTR _gbc$13312[esp+796]
	fld	DWORD PTR _gbc$13312[esp+820]
	fmul	ST(0), ST(3)
	faddp	ST(1), ST(0)
	fld	DWORD PTR _gbc$13312[esp+808]
	fmul	ST(0), ST(2)
	faddp	ST(1), ST(0)
	fxch	ST(2)
	fstp	ST(0)
	fstp	ST(0)
	fld	DWORD PTR $T31573[esp+788]
	fadd	DWORD PTR _gbc$13312[esp+824]
	fstp	DWORD PTR _pc$13316[esp+788]
	fld	DWORD PTR _gbc$13312[esp+828]
	fadd	DWORD PTR $T31573[esp+792]
	fstp	DWORD PTR _pc$13316[esp+792]
	fld	DWORD PTR _gbc$13312[esp+832]
	fadd	ST(0), ST(1)
	fstp	DWORD PTR _pc$13316[esp+796]
	fstp	ST(0)
	fld	DWORD PTR [ebp+80]

; 1598 : 		VVec3 base = cbc.t;
; 1599 : 
; 1600 : 		if ((pc & pd) < M_EPSILON)

	fld	DWORD PTR _pc$13316[esp+788]
	fsubr	ST(0), ST(1)
	fld	DWORD PTR _pd$13318[esp+792]
	fsub	DWORD PTR _pc$13316[esp+792]
	fld	DWORD PTR _pd$13318[esp+796]
	fsub	DWORD PTR _pc$13316[esp+796]
	fld	ST(2)
	fmulp	ST(3), ST(0)
	mov	ecx, DWORD PTR [ebp+100]
	mov	edx, DWORD PTR [ebp+104]
	mov	DWORD PTR _ud$13320[esp+792], eax
	mov	eax, DWORD PTR [ebp+108]
	fld	ST(0)
	fmul	ST(0), ST(1)
	mov	DWORD PTR _ud$13320[esp+804], eax
	mov	eax, DWORD PTR [ebp+120]
	mov	DWORD PTR _ud$13320[esp+796], ecx
	mov	ecx, DWORD PTR [ebp+112]
	faddp	ST(3), ST(0)
	fld	ST(1)
	fmul	ST(0), ST(2)
	mov	DWORD PTR _ud$13320[esp+816], eax
	mov	DWORD PTR _ud$13320[esp+800], edx
	mov	edx, DWORD PTR [ebp+116]
	mov	DWORD PTR _ud$13320[esp+808], ecx
	faddp	ST(3), ST(0)
	fxch	ST(2)
	fsqrt
	mov	ecx, DWORD PTR [ebp+124]
	mov	DWORD PTR _ud$13320[esp+812], edx
	mov	DWORD PTR _ud$13320[esp+820], ecx
	fstp	ST(2)
	fstp	ST(0)
	fcomp	DWORD PTR __real@3a83126f
	fnstsw	ax
	test	ah, 5
	jnp	$L33530

; 1602 : 
; 1603 : 		VVec3 npic = pc - base;

	fld	DWORD PTR _pc$13316[esp+788]
	fsub	DWORD PTR _cbc$13314[esp+824]
	fld	DWORD PTR _pc$13316[esp+792]
	fsub	DWORD PTR _cbc$13314[esp+828]
	fld	DWORD PTR _pc$13316[esp+796]
	fsub	DWORD PTR _cbc$13314[esp+832]
	fstp	DWORD PTR _npic$13323[esp+796]

; 1604 : 		NFloat lpic = npic.Normalize();

	fld	ST(1)
	fmul	ST(0), ST(2)
	fld	DWORD PTR _npic$13323[esp+796]
	fmul	DWORD PTR _npic$13323[esp+796]
	faddp	ST(1), ST(0)
	fld	ST(1)
	fmul	ST(0), ST(2)
	faddp	ST(1), ST(0)
	fsqrt
	fstp	DWORD PTR _a$31713[esp+788]
	fld	DWORD PTR __real@3f800000
	fdiv	DWORD PTR _a$31713[esp+788]
	fst	DWORD PTR -732+[esp+788]
	fstp	DWORD PTR _b$31714[esp+788]
	fxch	ST(1)
	fmul	DWORD PTR _b$31714[esp+788]
	fstp	DWORD PTR _npic$13323[esp+788]
	fld	DWORD PTR _b$31714[esp+788]
	fmul	ST(0), ST(1)
	fstp	DWORD PTR _npic$13323[esp+792]
	fstp	ST(0)
	fld	DWORD PTR _b$31714[esp+788]
	fmul	DWORD PTR _npic$13323[esp+796]
	fstp	DWORD PTR _npic$13323[esp+796]

; 1605 : 		VVec3 npid = pd - base;

	fsub	DWORD PTR _cbc$13314[esp+824]
	fld	DWORD PTR _pd$13318[esp+792]
	fsub	DWORD PTR _cbc$13314[esp+828]
	fld	DWORD PTR _pd$13318[esp+796]
	fsub	DWORD PTR _cbc$13314[esp+832]
	fstp	DWORD PTR _npid$13326[esp+796]

; 1606 : 		NFloat lpid = npid.Normalize();

	fld	ST(1)
	fmul	ST(0), ST(2)
	fld	DWORD PTR _npid$13326[esp+796]
	fmul	DWORD PTR _npid$13326[esp+796]
	faddp	ST(1), ST(0)
	fld	ST(1)
	fmul	ST(0), ST(2)
	faddp	ST(1), ST(0)
	fsqrt
	fstp	DWORD PTR _a$31734[esp+788]
	fld	DWORD PTR __real@3f800000
	fdiv	DWORD PTR _a$31734[esp+788]
	fst	DWORD PTR -728+[esp+788]
	fstp	DWORD PTR _b$31735[esp+788]
	fxch	ST(1)
	fmul	DWORD PTR _b$31735[esp+788]
	fstp	DWORD PTR _npid$13326[esp+788]
	fld	DWORD PTR _b$31735[esp+788]
	fmul	ST(0), ST(1)
	fstp	DWORD PTR _npid$13326[esp+792]
	fstp	ST(0)
	fld	DWORD PTR _b$31735[esp+788]
	fmul	DWORD PTR _npid$13326[esp+796]
	fst	DWORD PTR _npid$13326[esp+796]

; 1607 : 		VVec3 raxis = npic ^ npid; raxis.Normalize();

	fmul	DWORD PTR _npic$13323[esp+792]
	fld	DWORD PTR _npid$13326[esp+792]
	fmul	DWORD PTR _npic$13323[esp+796]
	fsubp	ST(1), ST(0)
	fst	DWORD PTR _raxis$13329[esp+788]
	fld	DWORD PTR _npid$13326[esp+788]
	fmul	DWORD PTR _npic$13323[esp+796]
	fld	DWORD PTR _npic$13323[esp+788]
	fmul	DWORD PTR _npid$13326[esp+796]
	fsubp	ST(1), ST(0)
	fld	ST(0)
	fld	DWORD PTR _npic$13323[esp+788]
	fmul	DWORD PTR _npid$13326[esp+792]
	fld	DWORD PTR _npid$13326[esp+788]
	fmul	DWORD PTR _npic$13323[esp+792]
	fsubp	ST(1), ST(0)
	fst	DWORD PTR -740+[esp+788]
	fld	DWORD PTR _raxis$13329[esp+788]
	fmul	DWORD PTR _raxis$13329[esp+788]
	fld	ST(1)
	fmul	ST(0), ST(2)
	faddp	ST(1), ST(0)
	fld	ST(2)
	fmul	ST(0), ST(3)
	faddp	ST(1), ST(0)
	fsqrt
	fdivr	DWORD PTR __real@3f800000
	fld	DWORD PTR _raxis$13329[esp+788]
	fmul	ST(0), ST(1)
	fstp	DWORD PTR _raxis$13329[esp+788]
	fld	ST(0)
	fmul	ST(0), ST(3)
	fstp	DWORD PTR _raxis$13329[esp+792]
	fmul	ST(0), ST(1)
	fstp	DWORD PTR _raxis$13329[esp+796]
	fstp	ST(0)
	fstp	ST(0)

; 1608 : 
; 1609 : 		NFloat a = 1;
; 1610 : 		NFloat p;
; 1611 : 		if (lpic < lpid)

	fld	DWORD PTR _a$31713[esp+788]
	fcomp	DWORD PTR _a$31734[esp+788]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L13333

; 1612 : 			p = lpic / lpid;

	fld	DWORD PTR -728+[esp+788]
	fmul	DWORD PTR _a$31713[esp+788]

; 1613 : 		else

	jmp	SHORT $L13334
$L13333:

; 1614 : 			p = lpid / lpic;

	fld	DWORD PTR -732+[esp+788]
	fmul	DWORD PTR _a$31734[esp+788]
$L13334:

; 1615 : 				
; 1616 : 		NFloat wv = 1.f;
; 1617 : 		NFloat wp = a*(1.f+p);

	fadd	DWORD PTR __real@3f800000
	fstp	DWORD PTR _wp$13336[esp+788]

; 1618 : 
; 1619 : 		NFloat k1 = wp*(npid|raxis)*(npic|raxis) + wv*(((ud.vX|raxis)*(uc.vX|raxis))+((ud.vY|raxis)*(uc.vY|raxis))+((ud.vZ|raxis)*(uc.vZ|raxis)));

	fld	DWORD PTR _raxis$13329[esp+788]
	fmul	DWORD PTR _gbc$13312[esp+788]
	fld	DWORD PTR _raxis$13329[esp+792]
	fmul	DWORD PTR _gbc$13312[esp+792]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _raxis$13329[esp+796]
	fmul	DWORD PTR _gbc$13312[esp+796]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _raxis$13329[esp+788]
	fmul	DWORD PTR _ud$13320[esp+788]
	fld	DWORD PTR _ud$13320[esp+796]
	fmul	DWORD PTR _raxis$13329[esp+796]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _ud$13320[esp+792]
	fmul	DWORD PTR _raxis$13329[esp+792]
	faddp	ST(1), ST(0)
	fmulp	ST(1), ST(0)
	fld	DWORD PTR _raxis$13329[esp+788]
	fmul	DWORD PTR _gbc$13312[esp+812]
	fld	DWORD PTR _raxis$13329[esp+792]
	fmul	DWORD PTR _gbc$13312[esp+816]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _raxis$13329[esp+796]
	fmul	DWORD PTR _gbc$13312[esp+820]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _ud$13320[esp+812]
	fmul	DWORD PTR _raxis$13329[esp+788]
	fld	DWORD PTR _ud$13320[esp+820]
	fmul	DWORD PTR _raxis$13329[esp+796]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _ud$13320[esp+816]
	fmul	DWORD PTR _raxis$13329[esp+792]
	faddp	ST(1), ST(0)
	fmulp	ST(1), ST(0)
	faddp	ST(1), ST(0)
	fld	DWORD PTR _raxis$13329[esp+788]
	fmul	DWORD PTR _gbc$13312[esp+800]
	fld	DWORD PTR _raxis$13329[esp+792]
	fmul	DWORD PTR _gbc$13312[esp+804]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _raxis$13329[esp+796]
	fmul	DWORD PTR _gbc$13312[esp+808]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _ud$13320[esp+800]
	fmul	DWORD PTR _raxis$13329[esp+788]
	fld	DWORD PTR _ud$13320[esp+808]
	fmul	DWORD PTR _raxis$13329[esp+796]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _ud$13320[esp+804]
	fmul	DWORD PTR _raxis$13329[esp+792]
	faddp	ST(1), ST(0)
	fmulp	ST(1), ST(0)
	faddp	ST(1), ST(0)
	fld	DWORD PTR _raxis$13329[esp+788]
	fmul	DWORD PTR _npid$13326[esp+788]
	fld	DWORD PTR _raxis$13329[esp+796]
	fmul	DWORD PTR _npid$13326[esp+796]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _raxis$13329[esp+792]
	fmul	DWORD PTR _npid$13326[esp+792]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _raxis$13329[esp+788]
	fmul	DWORD PTR _npic$13323[esp+788]
	fld	DWORD PTR _raxis$13329[esp+796]
	fmul	DWORD PTR _npic$13323[esp+796]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _raxis$13329[esp+792]
	fmul	DWORD PTR _npic$13323[esp+792]
	faddp	ST(1), ST(0)
	fmulp	ST(1), ST(0)
	fmul	DWORD PTR _wp$13336[esp+788]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _k1$13337[esp+788]

; 1620 : 		NFloat k2 = wp*(npid|npic) + wv*((ud.vX|uc.vX)+(ud.vY|uc.vY)+(ud.vZ|uc.vZ));

	fld	DWORD PTR _ud$13320[esp+788]
	fmul	DWORD PTR _gbc$13312[esp+788]
	fld	DWORD PTR _ud$13320[esp+792]
	fmul	DWORD PTR _gbc$13312[esp+792]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _ud$13320[esp+796]
	fmul	DWORD PTR _gbc$13312[esp+796]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _ud$13320[esp+812]
	fmul	DWORD PTR _gbc$13312[esp+812]
	fld	DWORD PTR _ud$13320[esp+816]
	fmul	DWORD PTR _gbc$13312[esp+816]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _ud$13320[esp+820]
	fmul	DWORD PTR _gbc$13312[esp+820]
	faddp	ST(1), ST(0)
	faddp	ST(1), ST(0)
	fld	DWORD PTR _ud$13320[esp+800]
	fmul	DWORD PTR _gbc$13312[esp+800]
	fld	DWORD PTR _ud$13320[esp+804]
	fmul	DWORD PTR _gbc$13312[esp+804]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _ud$13320[esp+808]
	fmul	DWORD PTR _gbc$13312[esp+808]
	faddp	ST(1), ST(0)
	faddp	ST(1), ST(0)
	fld	DWORD PTR _npid$13326[esp+788]
	fmul	DWORD PTR _npic$13323[esp+788]
	fld	DWORD PTR _npid$13326[esp+796]
	fmul	DWORD PTR _npic$13323[esp+796]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _npid$13326[esp+792]
	fmul	DWORD PTR _npic$13323[esp+792]
	faddp	ST(1), ST(0)
	fmul	DWORD PTR _wp$13336[esp+788]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _k2$13338[esp+788]

; 1621 : 		NFloat k3 = raxis | ( (npic^npid)*wp + ((ud.vX^uc.vX)+(ud.vY^uc.vY)+(ud.vZ^uc.vZ))*wv );

	fld	DWORD PTR _ud$13320[esp+816]
	fmul	DWORD PTR _gbc$13312[esp+820]
	fld	DWORD PTR _ud$13320[esp+820]
	fmul	DWORD PTR _gbc$13312[esp+816]
	fsubp	ST(1), ST(0)
	fld	DWORD PTR _ud$13320[esp+820]
	fmul	DWORD PTR _gbc$13312[esp+812]
	fld	DWORD PTR _ud$13320[esp+812]
	fmul	DWORD PTR _gbc$13312[esp+820]
	fsubp	ST(1), ST(0)
	fld	DWORD PTR _ud$13320[esp+812]
	fmul	DWORD PTR _gbc$13312[esp+816]
	fld	DWORD PTR _ud$13320[esp+816]
	fmul	DWORD PTR _gbc$13312[esp+812]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR $T31495[esp+796]
	fld	DWORD PTR _ud$13320[esp+804]
	fmul	DWORD PTR _gbc$13312[esp+808]
	fld	DWORD PTR _ud$13320[esp+808]
	fmul	DWORD PTR _gbc$13312[esp+804]
	fsubp	ST(1), ST(0)
	fld	DWORD PTR _ud$13320[esp+808]
	fmul	DWORD PTR _gbc$13312[esp+800]
	fld	DWORD PTR _ud$13320[esp+800]
	fmul	DWORD PTR _gbc$13312[esp+808]
	fsubp	ST(1), ST(0)
	fld	DWORD PTR _ud$13320[esp+800]
	fmul	DWORD PTR _gbc$13312[esp+804]
	fld	DWORD PTR _ud$13320[esp+804]
	fmul	DWORD PTR _gbc$13312[esp+800]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR $T31496[esp+796]
	fld	DWORD PTR _ud$13320[esp+792]
	fmul	DWORD PTR _gbc$13312[esp+796]
	fld	DWORD PTR _ud$13320[esp+796]
	fmul	DWORD PTR _gbc$13312[esp+792]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR $T31497[esp+788]
	fld	DWORD PTR _gbc$13312[esp+788]
	fmul	DWORD PTR _ud$13320[esp+796]
	fld	DWORD PTR _ud$13320[esp+788]
	fmul	DWORD PTR _gbc$13312[esp+796]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR $T31497[esp+792]
	fld	DWORD PTR _ud$13320[esp+788]
	fmul	DWORD PTR _gbc$13312[esp+792]
	fld	DWORD PTR _gbc$13312[esp+788]
	fmul	DWORD PTR _ud$13320[esp+792]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR $T31497[esp+796]
	fld	DWORD PTR $T31497[esp+788]
	fadd	ST(0), ST(2)
	fstp	DWORD PTR $T31498[esp+788]
	fld	DWORD PTR $T31497[esp+792]
	fadd	ST(0), ST(1)
	fstp	ST(2)
	fstp	ST(0)
	fld	DWORD PTR $T31497[esp+796]
	fadd	DWORD PTR $T31496[esp+796]
	fstp	DWORD PTR $T31498[esp+796]
	fld	DWORD PTR $T31498[esp+788]
	fadd	ST(0), ST(3)
	fstp	DWORD PTR $T31499[esp+788]
	fadd	ST(0), ST(1)
	fstp	ST(2)
	fstp	ST(0)
	fld	DWORD PTR $T31498[esp+796]
	fadd	DWORD PTR $T31495[esp+796]
	fld	DWORD PTR $T31499[esp+788]
	fstp	DWORD PTR $T31500[esp+788]
	fxch	ST(1)
	fstp	DWORD PTR $T31500[esp+792]
	fstp	DWORD PTR $T31500[esp+796]
	fxch	ST(1)
	fstp	DWORD PTR $T31501[esp+788]
	fld	DWORD PTR -740+[esp+788]
	fld	DWORD PTR $T31501[esp+788]
	fmul	DWORD PTR _wp$13336[esp+788]
	fstp	DWORD PTR $T31502[esp+788]
	fld	DWORD PTR _wp$13336[esp+788]
	fmul	ST(0), ST(2)
	fstp	DWORD PTR $T31502[esp+792]
	fld	DWORD PTR _wp$13336[esp+788]
	fmul	ST(0), ST(1)
	fstp	ST(2)
	fstp	ST(0)
	fld	DWORD PTR $T31502[esp+788]
	fadd	DWORD PTR $T31500[esp+788]
	fld	DWORD PTR $T31502[esp+792]
	fadd	DWORD PTR $T31500[esp+792]
	fxch	ST(2)
	fadd	DWORD PTR $T31500[esp+796]
	fmul	DWORD PTR _raxis$13329[esp+796]
	fxch	ST(2)
	fmul	DWORD PTR _raxis$13329[esp+792]
	faddp	ST(2), ST(0)
	fmul	DWORD PTR _raxis$13329[esp+788]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _k3$13339[esp+788]

; 1622 : 
; 1623 : 		NFloat cand1 = (NFloat)atan(k3 / (k2 - k1));

	fld	DWORD PTR _k2$13338[esp+788]
	fsub	DWORD PTR _k1$13337[esp+788]
	fdivr	DWORD PTR _k3$13339[esp+788]
	fld1
	fpatan
	fst	DWORD PTR _cand1$13349[esp+788]

; 1624 : 		NFloat cand2 = cand1 + M_PI;

	fadd	DWORD PTR __real@40490fdb
	fstp	DWORD PTR _cand2$13351[esp+788]

; 1625 : 		NFloat cand3 = cand1 - M_PI;

	fld	DWORD PTR _cand1$13349[esp+788]
	fsub	DWORD PTR __real@40490fdb
	fstp	DWORD PTR _cand3$13352[esp+788]

; 1626 : 		NFloat phi = 0.f;

	fld	DWORD PTR __real@00000000

; 1627 : 		NFloat goalmax=-FLT_MAX;

	fld	DWORD PTR __real@ff7fffff

; 1628 : 		NFloat tgoal;
; 1629 : 		if ( (cand1 > -M_PI) && (cand1 < M_PI) && (tgoal = ((k1*(1.0 - cos(cand1)) + k2*cos(cand1) + k3*sin(cand1))) > goalmax) )

	fld	DWORD PTR _cand1$13349[esp+788]
	fcomp	DWORD PTR __real@c0490fdb
	fnstsw	ax
	and	eax, 16640				; 00004100H
	jne	SHORT $L13356
	fld	DWORD PTR _cand1$13349[esp+788]
	fcomp	DWORD PTR __real@40490fdb
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L13356
	fld	DWORD PTR _cand1$13349[esp+788]
	fcos
	mov	DWORD PTR -760+[esp+788], esi
	fld	DWORD PTR _cand1$13349[esp+788]
	fsin
	fmul	DWORD PTR _k3$13339[esp+788]
	fld	QWORD PTR __real@3ff0000000000000
	fsub	ST(0), ST(2)
	fmul	DWORD PTR _k1$13337[esp+788]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _k2$13338[esp+788]
	fmul	ST(0), ST(2)
	faddp	ST(1), ST(0)
	fcomp	QWORD PTR __real@c7efffffe0000000
	fnstsw	ax
	and	eax, 16640				; 00004100H
	fstp	ST(0)
	je	SHORT $L31505
	mov	DWORD PTR -760+[esp+788], 0
$L31505:
	fild	DWORD PTR -760+[esp+788]
	fst	DWORD PTR _tgoal$13355[esp+788]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	SHORT $L13356
	fstp	ST(0)
	fstp	ST(0)

; 1630 : 		{ phi = cand1; goalmax = tgoal; }

	fld	DWORD PTR _cand1$13349[esp+788]
	fld	DWORD PTR _tgoal$13355[esp+788]
$L13356:

; 1631 : 		if ( (cand2 > -M_PI) && (cand2 < M_PI) && (tgoal = ((k1*(1.0 - cos(cand2)) + k2*cos(cand2) + k3*sin(cand2))) > goalmax) )

	fld	DWORD PTR _cand2$13351[esp+788]
	fcomp	DWORD PTR __real@c0490fdb
	fnstsw	ax
	and	eax, 16640				; 00004100H
	jne	SHORT $L13357
	fld	DWORD PTR _cand2$13351[esp+788]
	fcomp	DWORD PTR __real@40490fdb
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L13357
	fld	DWORD PTR _cand2$13351[esp+788]
	fcos
	mov	DWORD PTR -760+[esp+788], esi
	fld	DWORD PTR _cand2$13351[esp+788]
	fsin
	fmul	DWORD PTR _k3$13339[esp+788]
	fld	QWORD PTR __real@3ff0000000000000
	fsub	ST(0), ST(2)
	fmul	DWORD PTR _k1$13337[esp+788]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _k2$13338[esp+788]
	fmul	ST(0), ST(2)
	faddp	ST(1), ST(0)
	fld	ST(2)
	fcompp
	fnstsw	ax
	test	ah, 5
	fstp	ST(0)
	jnp	SHORT $L31507
	mov	DWORD PTR -760+[esp+788], 0
$L31507:
	fild	DWORD PTR -760+[esp+788]
	fst	DWORD PTR _tgoal$13355[esp+788]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	SHORT $L13357
	fstp	ST(0)
	fstp	ST(0)

; 1632 : 		{ phi = cand2; goalmax = tgoal; }

	fld	DWORD PTR _cand2$13351[esp+788]
	fld	DWORD PTR _tgoal$13355[esp+788]
$L13357:

; 1633 : 		if ( (cand3 > -M_PI) && (cand3 < M_PI) && (tgoal = ((k1*(1.0 - cos(cand3)) + k2*cos(cand3) + k3*sin(cand3))) > goalmax) )

	fld	DWORD PTR _cand3$13352[esp+788]
	fcomp	DWORD PTR __real@c0490fdb
	fnstsw	ax
	and	eax, 16640				; 00004100H
	jne	SHORT $L33544
	fld	DWORD PTR _cand3$13352[esp+788]
	fcomp	DWORD PTR __real@40490fdb
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L33544
	fld	DWORD PTR _cand3$13352[esp+788]
	fcos
	fld	DWORD PTR _cand3$13352[esp+788]
	fsin
	fmul	DWORD PTR _k3$13339[esp+788]
	fld	QWORD PTR __real@3ff0000000000000
	fsub	ST(0), ST(2)
	fmul	DWORD PTR _k1$13337[esp+788]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _k2$13338[esp+788]
	fmul	ST(0), ST(2)
	mov	DWORD PTR -772+[esp+788], esi
	faddp	ST(1), ST(0)
	fxch	ST(1)
	fxch	ST(2)
	fcompp
	fnstsw	ax
	test	ah, 5
	fstp	ST(0)
	jnp	SHORT $L31509
	mov	DWORD PTR -772+[esp+788], 0
$L31509:
	fild	DWORD PTR -772+[esp+788]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	SHORT $L13358
	fstp	ST(0)

; 1634 : 		{ phi = cand3; goalmax = tgoal; }

	fld	DWORD PTR _cand3$13352[esp+788]
	jmp	SHORT $L13358
$L33544:

; 1633 : 		if ( (cand3 > -M_PI) && (cand3 < M_PI) && (tgoal = ((k1*(1.0 - cos(cand3)) + k2*cos(cand3) + k3*sin(cand3))) > goalmax) )

	fstp	ST(0)
$L13358:

; 1635 : 
; 1636 : 		phi *= mRigidity;

	fmul	DWORD PTR [ebp+128]

; 1637 : 		VQuat3 q; q.AxisAngle(raxis, phi);

	fld	DWORD PTR _raxis$13329[esp+788]
	fchs
	fld	DWORD PTR _raxis$13329[esp+792]
	fchs
	fld	DWORD PTR _raxis$13329[esp+796]
	fchs
	fstp	DWORD PTR $T31934[esp+796]
	fld	ST(1)
	fmul	ST(0), ST(2)
	fld	DWORD PTR $T31934[esp+796]
	fmul	DWORD PTR $T31934[esp+796]
	faddp	ST(1), ST(0)
	fld	ST(1)
	fmul	ST(0), ST(2)
	faddp	ST(1), ST(0)
	fsqrt
	fdivr	DWORD PTR __real@3f800000
	fst	DWORD PTR _b$31946[esp+788]
	fmul	ST(0), ST(2)
	fstp	DWORD PTR _q$13359[esp+788]
	fld	DWORD PTR _b$31946[esp+788]
	fmul	ST(0), ST(1)
	fstp	ST(2)
	fstp	ST(0)
	fld	DWORD PTR _b$31946[esp+788]
	fmul	DWORD PTR $T31934[esp+796]
	fstp	DWORD PTR _q$13359[esp+796]
	fxch	ST(1)
	fmul	DWORD PTR __real@3f000000
	fst	DWORD PTR -764+[esp+788]
	fsin
	fst	DWORD PTR $T31932[esp+788]
	fmul	DWORD PTR _q$13359[esp+788]
	fstp	DWORD PTR _q$13359[esp+788]
	fmul	DWORD PTR $T31932[esp+788]
	fld	DWORD PTR $T31932[esp+788]
	fmul	DWORD PTR _q$13359[esp+796]
	fld	DWORD PTR -764+[esp+788]
	fcos

; 1638 : 		cbc.r >>= q;

	fld	ST(2)
	fadd	ST(0), ST(0)
	fld	ST(2)
	fadd	ST(0), ST(0)
	fstp	DWORD PTR _z2$32012[esp+788]
	fxch	ST(1)
	fadd	ST(0), ST(0)
	fstp	DWORD PTR _w2$32013[esp+788]
	fld	DWORD PTR _q$13359[esp+788]
	fadd	ST(0), ST(0)
	fmul	DWORD PTR _q$13359[esp+788]
	fstp	DWORD PTR _xx2$32014[esp+788]
	fld	ST(0)
	fmul	ST(0), ST(3)
	fstp	DWORD PTR _yy2$32015[esp+788]
	fld	DWORD PTR _z2$32012[esp+788]
	fmul	ST(0), ST(2)
	fstp	DWORD PTR _zz2$32016[esp+788]
	fmul	DWORD PTR _q$13359[esp+788]
	fstp	DWORD PTR _xy2$32018[esp+788]
	fld	DWORD PTR _z2$32012[esp+788]
	fmul	DWORD PTR _q$13359[esp+788]
	fstp	DWORD PTR _xz2$32019[esp+788]
	fld	DWORD PTR _w2$32013[esp+788]
	fmul	DWORD PTR _q$13359[esp+788]
	fstp	DWORD PTR _xw2$32020[esp+788]
	fld	DWORD PTR _z2$32012[esp+788]
	fmul	ST(0), ST(2)
	fstp	DWORD PTR _yz2$32021[esp+788]
	fld	DWORD PTR _w2$32013[esp+788]
	fmul	ST(0), ST(2)
	fstp	DWORD PTR _yw2$32022[esp+788]
	fld	DWORD PTR _w2$32013[esp+788]
	fmul	ST(0), ST(1)
	fstp	ST(2)
	fstp	ST(0)
	fld	DWORD PTR _zz2$32016[esp+788]
	fadd	DWORD PTR _yy2$32015[esp+788]
	fsubr	DWORD PTR __real@3f800000
	fstp	DWORD PTR $T31984[esp+788]
	fld	DWORD PTR _xy2$32018[esp+788]
	fadd	ST(0), ST(1)
	fstp	DWORD PTR $T31984[esp+792]
	fld	DWORD PTR _xz2$32019[esp+788]
	fsub	DWORD PTR _yw2$32022[esp+788]
	fstp	DWORD PTR $T31984[esp+796]
	fld	DWORD PTR _xy2$32018[esp+788]
	fsub	ST(0), ST(1)
	fstp	DWORD PTR $T31985[esp+788]
	fstp	ST(0)
	fld	DWORD PTR _zz2$32016[esp+788]
	fadd	DWORD PTR _xx2$32014[esp+788]
	fsubr	DWORD PTR __real@3f800000
	fstp	DWORD PTR $T31985[esp+792]
	fld	DWORD PTR _yz2$32021[esp+788]
	fadd	DWORD PTR _xw2$32020[esp+788]
	fstp	DWORD PTR $T31985[esp+796]
	fld	DWORD PTR _yw2$32022[esp+788]
	fadd	DWORD PTR _xz2$32019[esp+788]
	fstp	DWORD PTR $T31986[esp+788]
	fld	DWORD PTR _yz2$32021[esp+788]
	fsub	DWORD PTR _xw2$32020[esp+788]
	fstp	DWORD PTR $T31986[esp+792]
	fld	DWORD PTR _yy2$32015[esp+788]
	fadd	DWORD PTR _xx2$32014[esp+788]
	fsubr	DWORD PTR __real@3f800000
	fstp	DWORD PTR $T31986[esp+796]
	fld	DWORD PTR _cbc$13314[esp+816]
	fmul	DWORD PTR $T31984[esp+792]
	fld	DWORD PTR $T31984[esp+788]
	fmul	DWORD PTR _cbc$13314[esp+812]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _cbc$13314[esp+820]
	fmul	DWORD PTR $T31984[esp+796]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _cbc$13314[esp+816]
	fmul	DWORD PTR $T31985[esp+792]
	fld	DWORD PTR $T31985[esp+788]
	fmul	DWORD PTR _cbc$13314[esp+812]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _cbc$13314[esp+820]
	fmul	DWORD PTR $T31985[esp+796]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _cbc$13314[esp+816]
	fmul	DWORD PTR $T31986[esp+792]
	fld	DWORD PTR $T31986[esp+788]
	fmul	DWORD PTR _cbc$13314[esp+812]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _cbc$13314[esp+820]
	fmul	DWORD PTR $T31986[esp+796]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR $T32225[esp+796]
	fld	DWORD PTR _cbc$13314[esp+808]
	fmul	DWORD PTR $T31984[esp+796]
	fld	DWORD PTR _cbc$13314[esp+804]
	fmul	DWORD PTR $T31984[esp+792]
	faddp	ST(1), ST(0)
	fld	DWORD PTR $T31984[esp+788]
	fmul	DWORD PTR _cbc$13314[esp+800]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _cbc$13314[esp+808]
	fmul	DWORD PTR $T31985[esp+796]
	fld	DWORD PTR _cbc$13314[esp+804]
	fmul	DWORD PTR $T31985[esp+792]
	mov	ecx, DWORD PTR $T32225[esp+796]

; 1639 : 		curBone->SetCoords(cbc, true);

	mov	DWORD PTR _elderCoords$33284[esp+788], 1065353216 ; 3f800000H
	mov	DWORD PTR _cbc$13314[esp+820], ecx
	mov	DWORD PTR _elderCoords$33284[esp+792], 0
	faddp	ST(1), ST(0)
	fld	DWORD PTR $T31985[esp+788]
	fmul	DWORD PTR _cbc$13314[esp+800]
	mov	DWORD PTR _elderCoords$33284[esp+796], 0
	mov	DWORD PTR _elderCoords$33284[esp+800], 0
	mov	DWORD PTR _elderCoords$33284[esp+804], 1065353216 ; 3f800000H
	mov	DWORD PTR _elderCoords$33284[esp+808], 0
	faddp	ST(1), ST(0)
	mov	DWORD PTR _elderCoords$33284[esp+812], 0
	mov	DWORD PTR _elderCoords$33284[esp+816], 0
	mov	DWORD PTR _elderCoords$33284[esp+820], 1065353216 ; 3f800000H
	fld	DWORD PTR _cbc$13314[esp+808]
	fmul	DWORD PTR $T31986[esp+796]
	fld	DWORD PTR _cbc$13314[esp+804]
	fmul	DWORD PTR $T31986[esp+792]
	faddp	ST(1), ST(0)
	fld	DWORD PTR $T31986[esp+788]
	fmul	DWORD PTR _cbc$13314[esp+800]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR $T32226[esp+796]
	fld	DWORD PTR _cbc$13314[esp+788]
	fmul	DWORD PTR $T31984[esp+788]
	fld	DWORD PTR _cbc$13314[esp+796]
	fmul	DWORD PTR $T31984[esp+796]
	mov	eax, DWORD PTR $T32226[esp+796]
	mov	DWORD PTR _cbc$13314[esp+808], eax
	faddp	ST(1), ST(0)
	fld	DWORD PTR _cbc$13314[esp+792]
	fmul	DWORD PTR $T31984[esp+792]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _cbc$13314[esp+788]
	fmul	DWORD PTR $T31985[esp+788]
	fld	DWORD PTR _cbc$13314[esp+796]
	fmul	DWORD PTR $T31985[esp+796]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _cbc$13314[esp+792]
	fmul	DWORD PTR $T31985[esp+792]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _cbc$13314[esp+788]
	fmul	DWORD PTR $T31986[esp+788]
	fld	DWORD PTR _cbc$13314[esp+796]
	fmul	DWORD PTR $T31986[esp+796]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _cbc$13314[esp+792]
	fmul	DWORD PTR $T31986[esp+792]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR $T32227[esp+796]
	fxch	ST(1)
	fstp	DWORD PTR _cbc$13314[esp+788]
	mov	edx, DWORD PTR $T32227[esp+796]
	fstp	DWORD PTR _cbc$13314[esp+792]
	fxch	ST(1)
	fstp	DWORD PTR _cbc$13314[esp+800]
	mov	DWORD PTR _cbc$13314[esp+796], edx
	fstp	DWORD PTR _cbc$13314[esp+804]
	fxch	ST(1)
	fstp	DWORD PTR _cbc$13314[esp+812]
	fstp	DWORD PTR _cbc$13314[esp+816]
	mov	esi, DWORD PTR [edi+128]
	mov	DWORD PTR _elderCoords$33284[esp+828], 0
	fld	DWORD PTR __real@00000000
	fld	DWORD PTR __real@3f800000
	test	esi, esi
	mov	DWORD PTR _elderCoords$33284[esp+832], 0
	mov	DWORD PTR _elderCoords$33284[esp+840], 1065353216 ; 3f800000H
	mov	DWORD PTR _elderCoords$33284[esp+844], 1065353216 ; 3f800000H
	je	$L33288
$L33286:
	fmul	DWORD PTR [esi+48]
	fstp	DWORD PTR $T33360[esp+788]
	fld	DWORD PTR _elderCoords$33284[esp+840]
	fmul	DWORD PTR [esi+52]
	fstp	DWORD PTR $T33360[esp+792]
	fld	DWORD PTR _elderCoords$33284[esp+844]
	fmul	DWORD PTR [esi+56]
	fstp	DWORD PTR $T33360[esp+796]
	fmul	DWORD PTR [esi+48]
	fld	DWORD PTR _elderCoords$33284[esp+828]
	fmul	DWORD PTR [esi+52]
	fld	DWORD PTR _elderCoords$33284[esp+832]
	fmul	DWORD PTR [esi+56]
	fld	ST(0)
	fmul	DWORD PTR [esi+24]
	fld	ST(2)
	fmul	DWORD PTR [esi+12]
	faddp	ST(1), ST(0)
	fld	ST(3)
	fmul	DWORD PTR [esi]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR $T33297[esp+788]
	fld	ST(1)
	fmul	DWORD PTR [esi+16]
	fld	ST(3)
	fmul	DWORD PTR [esi+4]
	faddp	ST(1), ST(0)
	fld	ST(1)
	fmul	DWORD PTR [esi+28]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR $T33297[esp+792]
	fxch	ST(1)
	fmul	DWORD PTR [esi+20]
	fxch	ST(2)
	fmul	DWORD PTR [esi+8]
	faddp	ST(2), ST(0)
	fld	ST(0)
	fmul	DWORD PTR [esi+32]
	faddp	ST(2), ST(0)
	fstp	ST(0)
	fld	DWORD PTR $T33297[esp+788]
	fadd	DWORD PTR [esi+36]
	fstp	DWORD PTR $T33361[esp+788]
	fld	DWORD PTR $T33297[esp+792]
	fadd	DWORD PTR [esi+40]
	fstp	DWORD PTR $T33361[esp+792]
	fadd	DWORD PTR [esi+44]
	fstp	DWORD PTR $T33361[esp+796]
	fld	DWORD PTR _elderCoords$33284[esp+812]
	fmul	DWORD PTR [esi]
	fld	DWORD PTR _elderCoords$33284[esp+820]
	fmul	DWORD PTR [esi+24]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _elderCoords$33284[esp+816]
	fmul	DWORD PTR [esi+12]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _elderCoords$33284[esp+816]
	fmul	DWORD PTR [esi+16]
	fld	DWORD PTR _elderCoords$33284[esp+820]
	fmul	DWORD PTR [esi+28]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _elderCoords$33284[esp+812]
	fmul	DWORD PTR [esi+4]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _elderCoords$33284[esp+816]
	fmul	DWORD PTR [esi+20]
	fld	DWORD PTR _elderCoords$33284[esp+820]
	fmul	DWORD PTR [esi+32]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _elderCoords$33284[esp+812]
	fmul	DWORD PTR [esi+8]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR $T33311[esp+796]
	fld	DWORD PTR _elderCoords$33284[esp+800]
	fmul	DWORD PTR [esi]
	fld	DWORD PTR _elderCoords$33284[esp+808]
	fmul	DWORD PTR [esi+24]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _elderCoords$33284[esp+804]
	fmul	DWORD PTR [esi+12]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _elderCoords$33284[esp+804]
	fmul	DWORD PTR [esi+16]
	fld	DWORD PTR _elderCoords$33284[esp+808]
	fmul	DWORD PTR [esi+28]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _elderCoords$33284[esp+800]
	fmul	DWORD PTR [esi+4]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _elderCoords$33284[esp+804]
	fmul	DWORD PTR [esi+20]
	fld	DWORD PTR _elderCoords$33284[esp+808]
	fmul	DWORD PTR [esi+32]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _elderCoords$33284[esp+800]
	fmul	DWORD PTR [esi+8]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR $T33312[esp+796]
	fld	DWORD PTR _elderCoords$33284[esp+796]
	fmul	DWORD PTR [esi+24]
	fld	DWORD PTR _elderCoords$33284[esp+792]
	fmul	DWORD PTR [esi+12]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _elderCoords$33284[esp+788]
	fmul	DWORD PTR [esi]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _elderCoords$33284[esp+792]
	fmul	DWORD PTR [esi+16]
	fld	DWORD PTR _elderCoords$33284[esp+796]
	fmul	DWORD PTR [esi+28]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _elderCoords$33284[esp+788]
	fmul	DWORD PTR [esi+4]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _elderCoords$33284[esp+792]
	fmul	DWORD PTR [esi+20]
	fld	DWORD PTR _elderCoords$33284[esp+796]
	fmul	DWORD PTR [esi+32]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _elderCoords$33284[esp+788]
	fmul	DWORD PTR [esi+8]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR $T33313[esp+796]
	mov	edx, DWORD PTR $T33313[esp+796]
	fxch	ST(1)
	fstp	DWORD PTR $T33362[esp+788]
	mov	DWORD PTR $T33362[esp+796], edx
	fstp	DWORD PTR $T33362[esp+792]
	fxch	ST(1)
	fstp	DWORD PTR $T33362[esp+800]
	mov	eax, DWORD PTR $T33312[esp+796]
	mov	ecx, DWORD PTR $T33311[esp+796]
	fstp	DWORD PTR $T33362[esp+804]
	mov	DWORD PTR $T33362[esp+808], eax
	lea	edx, DWORD PTR $T33360[esp+788]
	fxch	ST(1)
	fstp	DWORD PTR $T33362[esp+812]
	mov	DWORD PTR $T33362[esp+820], ecx
	lea	eax, DWORD PTR $T33361[esp+788]
	fstp	DWORD PTR $T33362[esp+816]
	push	edx
	lea	ecx, DWORD PTR $T33362[esp+792]
	push	eax
	push	ecx
	lea	ecx, DWORD PTR $T33357[esp+800]
	call	??0VCoords3@@QAE@ABVVAxes3@@ABVVVec3@@1@Z ; VCoords3::VCoords3
	mov	edx, DWORD PTR $T33357[esp+788]
	mov	eax, DWORD PTR $T33357[esp+792]
	mov	ecx, DWORD PTR $T33357[esp+796]
	mov	DWORD PTR _elderCoords$33284[esp+788], edx
	mov	edx, DWORD PTR $T33357[esp+800]
	mov	esi, DWORD PTR [esi+128]
	fld	DWORD PTR $T33357[esp+824]
	mov	DWORD PTR _elderCoords$33284[esp+792], eax
	mov	eax, DWORD PTR $T33357[esp+804]
	mov	DWORD PTR _elderCoords$33284[esp+796], ecx
	mov	ecx, DWORD PTR $T33357[esp+808]
	mov	DWORD PTR _elderCoords$33284[esp+800], edx
	mov	edx, DWORD PTR $T33357[esp+812]
	fld	DWORD PTR $T33357[esp+836]
	mov	DWORD PTR _elderCoords$33284[esp+804], eax
	mov	eax, DWORD PTR $T33357[esp+816]
	mov	DWORD PTR _elderCoords$33284[esp+808], ecx
	mov	ecx, DWORD PTR $T33357[esp+820]
	mov	DWORD PTR _elderCoords$33284[esp+812], edx
	mov	edx, DWORD PTR $T33357[esp+828]
	mov	DWORD PTR _elderCoords$33284[esp+816], eax
	mov	eax, DWORD PTR $T33357[esp+832]
	mov	DWORD PTR _elderCoords$33284[esp+820], ecx
	mov	ecx, DWORD PTR $T33357[esp+840]
	mov	DWORD PTR _elderCoords$33284[esp+828], edx
	mov	edx, DWORD PTR $T33357[esp+844]
	test	esi, esi
	mov	DWORD PTR _elderCoords$33284[esp+832], eax
	mov	DWORD PTR _elderCoords$33284[esp+840], ecx
	mov	DWORD PTR _elderCoords$33284[esp+844], edx
	jne	$L33286
$L33288:
	fld	DWORD PTR __real@3f800000
	fdiv	ST(0), ST(1)
	fstp	DWORD PTR -728+[esp+788]
	fstp	ST(0)
	fld	DWORD PTR _cbc$13314[esp+836]
	fmul	DWORD PTR -728+[esp+788]
	fstp	DWORD PTR $T33366[esp+788]
	fld	DWORD PTR __real@3f800000
	fdiv	DWORD PTR _elderCoords$33284[esp+840]
	fstp	DWORD PTR -732+[esp+788]
	fld	DWORD PTR _cbc$13314[esp+840]
	fmul	DWORD PTR -732+[esp+788]
	fstp	DWORD PTR $T33366[esp+792]
	fld	DWORD PTR __real@3f800000
	fdiv	DWORD PTR _elderCoords$33284[esp+844]
	fstp	DWORD PTR -772+[esp+788]
	fld	DWORD PTR _cbc$13314[esp+844]
	fmul	DWORD PTR -772+[esp+788]
	fstp	DWORD PTR $T33366[esp+796]
	fsubr	DWORD PTR _cbc$13314[esp+824]
	fld	DWORD PTR _cbc$13314[esp+828]
	fsub	DWORD PTR _elderCoords$33284[esp+828]
	fld	DWORD PTR _cbc$13314[esp+832]
	fsub	DWORD PTR _elderCoords$33284[esp+832]
	fld	DWORD PTR _elderCoords$33284[esp+796]
	fmul	ST(0), ST(1)
	fld	DWORD PTR _elderCoords$33284[esp+792]
	fmul	ST(0), ST(3)
	faddp	ST(1), ST(0)
	fld	ST(3)
	fmul	DWORD PTR _elderCoords$33284[esp+788]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR $T33376[esp+788]
	fld	ST(2)
	fmul	DWORD PTR _elderCoords$33284[esp+800]
	fld	DWORD PTR _elderCoords$33284[esp+808]
	fmul	ST(0), ST(2)
	faddp	ST(1), ST(0)
	fld	DWORD PTR _elderCoords$33284[esp+804]
	fmul	ST(0), ST(3)
	faddp	ST(1), ST(0)
	fstp	DWORD PTR $T33376[esp+792]
	fxch	ST(2)
	fmul	DWORD PTR _elderCoords$33284[esp+812]
	fld	DWORD PTR _elderCoords$33284[esp+820]
	fmul	ST(0), ST(3)
	faddp	ST(1), ST(0)
	fld	DWORD PTR _elderCoords$33284[esp+816]
	fmul	ST(0), ST(2)
	faddp	ST(1), ST(0)
	fstp	DWORD PTR $T33376[esp+796]
	fstp	ST(1)
	fstp	ST(0)
	fld	DWORD PTR $T33376[esp+788]
	fmul	DWORD PTR -728+[esp+788]
	fld	DWORD PTR -732+[esp+788]
	fmul	DWORD PTR $T33376[esp+792]
	fld	DWORD PTR -772+[esp+788]
	fmul	DWORD PTR $T33376[esp+796]
	fstp	DWORD PTR $T33367[esp+796]
	fld	DWORD PTR _cbc$13314[esp+816]
	fmul	DWORD PTR _elderCoords$33284[esp+792]
	fld	DWORD PTR _elderCoords$33284[esp+788]
	fmul	DWORD PTR _cbc$13314[esp+812]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _cbc$13314[esp+820]
	fmul	DWORD PTR _elderCoords$33284[esp+796]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _elderCoords$33284[esp+808]
	fmul	DWORD PTR _cbc$13314[esp+820]
	fld	DWORD PTR _elderCoords$33284[esp+804]
	fmul	DWORD PTR _cbc$13314[esp+816]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _elderCoords$33284[esp+800]
	fmul	DWORD PTR _cbc$13314[esp+812]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _elderCoords$33284[esp+820]
	fmul	DWORD PTR _cbc$13314[esp+820]
	fld	DWORD PTR _elderCoords$33284[esp+816]
	fmul	DWORD PTR _cbc$13314[esp+816]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _elderCoords$33284[esp+812]
	fmul	DWORD PTR _cbc$13314[esp+812]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR $T33396[esp+796]
	fld	DWORD PTR _cbc$13314[esp+808]
	fmul	DWORD PTR _elderCoords$33284[esp+796]
	fld	DWORD PTR _cbc$13314[esp+804]
	fmul	DWORD PTR _elderCoords$33284[esp+792]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _elderCoords$33284[esp+788]
	fmul	DWORD PTR _cbc$13314[esp+800]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _elderCoords$33284[esp+804]
	fmul	DWORD PTR _cbc$13314[esp+804]
	fld	DWORD PTR _elderCoords$33284[esp+800]
	fmul	DWORD PTR _cbc$13314[esp+800]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _elderCoords$33284[esp+808]
	fmul	DWORD PTR _cbc$13314[esp+808]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _elderCoords$33284[esp+816]
	fmul	DWORD PTR _cbc$13314[esp+804]
	fld	DWORD PTR _elderCoords$33284[esp+812]
	fmul	DWORD PTR _cbc$13314[esp+800]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _elderCoords$33284[esp+820]
	fmul	DWORD PTR _cbc$13314[esp+808]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR $T33397[esp+796]
	fld	DWORD PTR _elderCoords$33284[esp+788]
	fmul	DWORD PTR _cbc$13314[esp+788]
	fld	DWORD PTR _cbc$13314[esp+796]
	fmul	DWORD PTR _elderCoords$33284[esp+796]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _cbc$13314[esp+792]
	fmul	DWORD PTR _elderCoords$33284[esp+792]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR $T33398[esp+788]
	fld	DWORD PTR _elderCoords$33284[esp+808]
	fmul	DWORD PTR _cbc$13314[esp+796]
	fld	DWORD PTR _elderCoords$33284[esp+804]
	fmul	DWORD PTR _cbc$13314[esp+792]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _cbc$13314[esp+788]
	fmul	DWORD PTR _elderCoords$33284[esp+800]
	mov	eax, DWORD PTR $T33398[esp+788]
	mov	DWORD PTR [edi], eax
	mov	eax, DWORD PTR $T33397[esp+796]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR $T33398[esp+792]
	fld	DWORD PTR _elderCoords$33284[esp+820]
	fmul	DWORD PTR _cbc$13314[esp+796]
	fld	DWORD PTR _elderCoords$33284[esp+816]
	fmul	DWORD PTR _cbc$13314[esp+792]
	mov	ecx, DWORD PTR $T33398[esp+792]
	mov	DWORD PTR [edi+4], ecx
	mov	ecx, DWORD PTR $T33396[esp+796]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _cbc$13314[esp+788]
	fmul	DWORD PTR _elderCoords$33284[esp+812]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR $T33398[esp+796]
	mov	edx, DWORD PTR $T33398[esp+796]
	fxch	ST(1)
	mov	DWORD PTR [edi+8], edx
	fstp	DWORD PTR [edi+12]
	mov	edx, DWORD PTR $T33367[esp+796]
	mov	DWORD PTR [edi+20], eax
	fstp	DWORD PTR [edi+16]
	fxch	ST(1)
	fstp	DWORD PTR [edi+24]
	mov	eax, DWORD PTR $T33366[esp+788]
	mov	DWORD PTR [edi+32], ecx
	fstp	DWORD PTR [edi+28]
	mov	ecx, DWORD PTR $T33366[esp+792]
	mov	DWORD PTR [edi+44], edx
	mov	edx, DWORD PTR $T33366[esp+796]
	fxch	ST(1)
	fstp	DWORD PTR [edi+36]
	fstp	DWORD PTR [edi+40]
	mov	DWORD PTR [edi+48], eax
	mov	eax, DWORD PTR _cbc$13314[esp+788]
	mov	DWORD PTR [edi+52], ecx
	mov	ecx, DWORD PTR _cbc$13314[esp+792]
	mov	DWORD PTR [edi+56], edx
	mov	edx, DWORD PTR _cbc$13314[esp+796]
	mov	DWORD PTR [ebx], eax
	mov	eax, DWORD PTR _cbc$13314[esp+800]
	mov	DWORD PTR [ebx+4], ecx
	mov	ecx, DWORD PTR _cbc$13314[esp+804]
	mov	DWORD PTR [ebx+8], edx
	mov	edx, DWORD PTR _cbc$13314[esp+808]
	mov	DWORD PTR [ebx+12], eax
	mov	eax, DWORD PTR _cbc$13314[esp+812]
	mov	DWORD PTR [ebx+16], ecx
	mov	ecx, DWORD PTR _cbc$13314[esp+816]
	mov	DWORD PTR [ebx+20], edx
	mov	edx, DWORD PTR _cbc$13314[esp+820]
	mov	DWORD PTR [ebx+24], eax
	mov	eax, DWORD PTR _cbc$13314[esp+824]
	mov	DWORD PTR [ebx+28], ecx
	mov	ecx, DWORD PTR _cbc$13314[esp+828]
	mov	DWORD PTR [ebx+32], edx
	mov	edx, DWORD PTR _cbc$13314[esp+832]
	mov	DWORD PTR [ebx+36], eax
	mov	eax, DWORD PTR _cbc$13314[esp+836]
	mov	DWORD PTR [ebx+40], ecx
	mov	ecx, DWORD PTR _cbc$13314[esp+840]
	mov	DWORD PTR [ebx+44], edx
	mov	edx, DWORD PTR _cbc$13314[esp+844]
	mov	DWORD PTR [ebx+48], eax
	mov	DWORD PTR [ebx+52], ecx
	mov	DWORD PTR [ebx+56], edx
	mov	ecx, DWORD PTR [edi+132]
	test	ecx, ecx
	je	SHORT $L33289
	push	0
	call	?ValidateAbs@CMacBone@@IAEX_N@Z		; CMacBone::ValidateAbs
$L33289:
	mov	edi, DWORD PTR [edi+128]
	test	edi, edi
	jne	$L13306
	pop	edi
	pop	esi
	pop	ebp
	mov	al, 1
	pop	ebx

; 1640 : 
; 1641 : 		//ProcessConstraints(inCurBone);
; 1642 : 	}
; 1643 : 
; 1644 : 	return(1);
; 1645 : }

	add	esp, 772				; 00000304H
	ret	4
$L33530:

; 1598 : 		VVec3 base = cbc.t;
; 1599 : 
; 1600 : 		if ((pc & pd) < M_EPSILON)

	fstp	ST(0)
$L13308:
	pop	edi
	pop	esi
	pop	ebp

; 1601 : 			return(1); // already there man

	mov	al, 1
	pop	ebx

; 1640 : 
; 1641 : 		//ProcessConstraints(inCurBone);
; 1642 : 	}
; 1643 : 
; 1644 : 	return(1);
; 1645 : }

	add	esp, 772				; 00000304H
	ret	4
$L13302:
	pop	edi
	pop	esi
	pop	ebp

; 1581 : 		return(0);

	xor	al, al
	pop	ebx

; 1640 : 
; 1641 : 		//ProcessConstraints(inCurBone);
; 1642 : 	}
; 1643 : 
; 1644 : 	return(1);
; 1645 : }

	add	esp, 772				; 00000304H
	ret	4
?EvalBones@OMacIKChannel@@UAE_NPAVOMacActor@@@Z ENDP	; OMacIKChannel::EvalBones
_TEXT	ENDS
PUBLIC	??0?$TCorArray@VCMacTraceInfo@@@@QAE@K@Z	; TCorArray<CMacTraceInfo>::TCorArray<CMacTraceInfo>
; Function compile flags: /Ogty
;	COMDAT _$E127
_TEXT	SEGMENT
_$E127	PROC NEAR					; COMDAT
	push	0
	mov	ecx, OFFSET FLAT:?sTraceInfoList@CMacTraceInfo@@2V?$TCorArray@VCMacTraceInfo@@@@A
	call	??0?$TCorArray@VCMacTraceInfo@@@@QAE@K@Z ; TCorArray<CMacTraceInfo>::TCorArray<CMacTraceInfo>
	push	OFFSET FLAT:_$E124
	call	_atexit
	pop	ecx
	ret	0
_$E127	ENDP
_TEXT	ENDS
PUBLIC	??1?$TCorArray@VCMacTraceInfo@@@@QAE@XZ		; TCorArray<CMacTraceInfo>::~TCorArray<CMacTraceInfo>
_BSS	SEGMENT
_$S125	DB	01H DUP (?)
; Function compile flags: /Ogty
_BSS	ENDS
;	COMDAT _$E124
_TEXT	SEGMENT
_$E124	PROC NEAR					; COMDAT
	mov	cl, BYTE PTR _$S125
	mov	al, 1
	test	cl, al
	jne	SHORT $L13366
	or	cl, al
	mov	BYTE PTR _$S125, cl
	mov	ecx, OFFSET FLAT:?sTraceInfoList@CMacTraceInfo@@2V?$TCorArray@VCMacTraceInfo@@@@A
	jmp	??1?$TCorArray@VCMacTraceInfo@@@@QAE@XZ	; TCorArray<CMacTraceInfo>::~TCorArray<CMacTraceInfo>
$L13366:
	ret	0
_$E124	ENDP
_TEXT	ENDS
PUBLIC	?StaticFindInfo@CMacTraceInfo@@SAPAV1@PAVOMacActor@@PAVOCpjGeometry@@PAVOCpjSkeleton@@@Z ; CMacTraceInfo::StaticFindInfo
; Function compile flags: /Ogty
;	COMDAT ?StaticFindInfo@CMacTraceInfo@@SAPAV1@PAVOMacActor@@PAVOCpjGeometry@@PAVOCpjSkeleton@@@Z
_TEXT	SEGMENT
_inActor$ = 8
_inGeo$ = 12
_inSkl$ = 16
?StaticFindInfo@CMacTraceInfo@@SAPAV1@PAVOMacActor@@PAVOCpjGeometry@@PAVOCpjSkeleton@@@Z PROC NEAR ; CMacTraceInfo::StaticFindInfo, COMDAT

; 1653 : {

	push	ebx

; 1654 : 	if (!inGeo || !inSkl)

	mov	ebx, DWORD PTR _inGeo$[esp]
	push	esi
	push	edi
	test	ebx, ebx
	je	SHORT $L13378
	mov	edi, DWORD PTR _inSkl$[esp+8]
	test	edi, edi
	je	SHORT $L13378

; 1656 : 
; 1657 : 	CMacTraceInfo* ti;
; 1658 : 	for (NDword i=0;i<sTraceInfoList.GetCount();i++)

	mov	edx, DWORD PTR ?sTraceInfoList@CMacTraceInfo@@2V?$TCorArray@VCMacTraceInfo@@@@A+4
	xor	ecx, ecx
	test	edx, edx
	jbe	SHORT $L13383
	mov	eax, DWORD PTR ?sTraceInfoList@CMacTraceInfo@@2V?$TCorArray@VCMacTraceInfo@@@@A
$L13381:

; 1659 : 	{
; 1660 : 		ti = &sTraceInfoList[i];
; 1661 : 		if ((inGeo == ti->mTraceGeometry)
; 1662 : 		 && (inSkl == ti->mTraceSkeleton))

	cmp	ebx, DWORD PTR [eax]
	jne	SHORT $L13382
	cmp	edi, DWORD PTR [eax+4]
	je	SHORT $L13376
$L13382:

; 1656 : 
; 1657 : 	CMacTraceInfo* ti;
; 1658 : 	for (NDword i=0;i<sTraceInfoList.GetCount();i++)

	inc	ecx
	add	eax, 40					; 00000028H
	cmp	ecx, edx
	jb	SHORT $L13381
$L13383:

; 1663 : 			return(ti);
; 1664 : 	}
; 1665 : 	ti = &sTraceInfoList[sTraceInfoList.Add()];

	push	1
	mov	ecx, OFFSET FLAT:?sTraceInfoList@CMacTraceInfo@@2V?$TCorArray@VCMacTraceInfo@@@@A
	call	?Add@?$TCorArray@VCMacTraceInfo@@@@QAEKK@Z ; TCorArray<CMacTraceInfo>::Add
	mov	ecx, DWORD PTR ?sTraceInfoList@CMacTraceInfo@@2V?$TCorArray@VCMacTraceInfo@@@@A

; 1666 : 	ti->mTraceGeometry = inGeo;
; 1667 : 	ti->mTraceSkeleton = inSkl;
; 1668 : 	ti->Construct(inActor);

	mov	edx, DWORD PTR _inActor$[esp+8]
	lea	eax, DWORD PTR [eax+eax*4]
	push	edx
	lea	esi, DWORD PTR [ecx+eax*8]
	mov	ecx, esi
	mov	DWORD PTR [esi], ebx
	mov	DWORD PTR [esi+4], edi
	call	?Construct@CMacTraceInfo@@QAEXPAVOMacActor@@@Z ; CMacTraceInfo::Construct

; 1669 : 	return(ti);

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx

; 1670 : }

	ret	0
$L13378:

; 1655 : 		return(NULL);

	xor	eax, eax
$L13376:
	pop	edi
	pop	esi
	pop	ebx

; 1670 : }

	ret	0
?StaticFindInfo@CMacTraceInfo@@SAPAV1@PAVOMacActor@@PAVOCpjGeometry@@PAVOCpjSkeleton@@@Z ENDP ; CMacTraceInfo::StaticFindInfo
_TEXT	ENDS
PUBLIC	?AddNoConstruct@?$TCorArray@E@@QAEKK@Z		; TCorArray<unsigned char>::AddNoConstruct
PUBLIC	?Remove@?$TCorArray@E@@QAEXKK@Z			; TCorArray<unsigned char>::Remove
PUBLIC	?AddNoConstruct@?$TCorArray@VVBox3@@@@QAEKK@Z	; TCorArray<VBox3>::AddNoConstruct
PUBLIC	??1?$TCorArray@PAVOMacChannel@@@@QAE@XZ		; TCorArray<OMacChannel *>::~TCorArray<OMacChannel *>
PUBLIC	?AddNoConstruct@?$TCorArray@PAVOMacChannel@@@@QAEKK@Z ; TCorArray<OMacChannel *>::AddNoConstruct
PUBLIC	?Remove@?$TCorArray@PAVOMacChannel@@@@QAEXKK@Z	; TCorArray<OMacChannel *>::Remove
PUBLIC	??1CCorArray@@IAE@XZ				; CCorArray::~CCorArray
PUBLIC	?Remove@CCorArray@@QAEXKKK@Z			; CCorArray::Remove
PUBLIC	??1?$TCorArray@VVVec3@@@@QAE@XZ			; TCorArray<VVec3>::~TCorArray<VVec3>
_BSS	SEGMENT
	ALIGN	4

?influence@?1??Construct@CMacTraceInfo@@QAEXPAVOMacActor@@@Z@4PAMA DD 0100H DUP (?) ; influence
?boneMin@?M@??Construct@CMacTraceInfo@@QAEXPAVOMacActor@@@Z@4PAVVVec3@@A DB 0c00H DUP (?) ; boneMin
?$S129@?M@??Construct@CMacTraceInfo@@QAEXPAVOMacActor@@@Z@4EA DB 01H DUP (?) ; ?$S129@?M@??Construct@CMacTraceInfo@@QAEXPAVOMacActor@@@Z@4EA
	ALIGN	4

?boneMax@?M@??Construct@CMacTraceInfo@@QAEXPAVOMacActor@@@Z@4PAVVVec3@@A DB 0c00H DUP (?) ; boneMax
?boneUsed@?M@??Construct@CMacTraceInfo@@QAEXPAVOMacActor@@@Z@4PA_NA DB 0100H DUP (?) ; boneUsed
_BSS	ENDS
;	COMDAT xdata$x
; File C:\duke4\Cannibal\CorMain.h
xdata$x	SEGMENT
$T34830	DD	0ffffffffH
	DD	FLAT:$L33655
	DD	0ffffffffH
	DD	FLAT:$L33584
	DD	01H
	DD	FLAT:$L33585
	DD	01H
	DD	FLAT:$L34705
$T34790	DD	019930520H
	DD	04H
	DD	FLAT:$T34830
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File C:\duke4\Cannibal\MacMain.cpp
xdata$x	ENDS
;	COMDAT ?Construct@CMacTraceInfo@@QAEXPAVOMacActor@@@Z
_TEXT	SEGMENT
$T33580 = -132
_inActor$ = 8
_this$ = -308
_sklVerts$ = -296
_geoTris$ = -292
_gvZero$ = -300
_i$ = -304
_channelBackup$ = -288
_tempVerts$ = -208
__$EHRec$ = -12
_boneCoords$13461 = -272
$T33942 = -292
$T33943 = -296
$T33944 = -300
$T34267 = -292
$T34268 = -296
$T34269 = -300
$T34424 = -72
$T34427 = -192
$T34428 = -144
$T34429 = -180
?Construct@CMacTraceInfo@@QAEXPAVOMacActor@@@Z PROC NEAR ; CMacTraceInfo::Construct, COMDAT
; _this$ = ecx

; 1673 : {

	push	-1
	push	$L34829
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 300				; 0000012cH
	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx
	push	edi

; 1674 : 	mTriBones.Purge(); mTriBones.Shrink();

	xor	ebx, ebx
	mov	eax, DWORD PTR [esi+12]
	lea	edi, DWORD PTR [esi+8]
	push	eax
	push	ebx
	mov	ecx, edi
	mov	DWORD PTR _this$[esp+336], esi
	call	?Remove@?$TCorArray@E@@QAEXKK@Z		; TCorArray<unsigned char>::Remove
	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi+8]
	cmp	ecx, eax
	je	SHORT $L33592
	push	1
	mov	ecx, edi
	mov	DWORD PTR [edi+8], eax
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
$L33592:

; 1675 : 
; 1676 : 	mTraceGeometry->CacheIn();

	mov	ecx, DWORD PTR [esi]
	call	?CacheIn@OCpjChunk@@QAE_NXZ		; OCpjChunk::CacheIn

; 1677 : 	mTraceSkeleton->CacheIn();

	mov	ecx, DWORD PTR [esi+4]
	call	?CacheIn@OCpjChunk@@QAE_NXZ		; OCpjChunk::CacheIn

; 1678 : 
; 1679 : 	// pick the bones that has the most influence on each triangle
; 1680 : 	mTriBones.Add(mTraceGeometry->m_Tris.GetCount());

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [ecx+108]
	mov	ecx, edi
	push	eax
	call	?AddNoConstruct@?$TCorArray@E@@QAEKK@Z	; TCorArray<unsigned char>::AddNoConstruct

; 1681 : 	static NFloat influence[256];
; 1682 : 	CCpjSklVert* sklVerts = &mTraceSkeleton->m_Verts[0];

	mov	eax, DWORD PTR [esi+4]

; 1683 : 	CCpjGeoTri* geoTris = &mTraceGeometry->m_Tris[0];

	mov	ecx, DWORD PTR [esi]

; 1684 : 	CCpjGeoVert* gvZero = &mTraceGeometry->m_Verts[0];
; 1685 : 	CCpjSklBone* sbZero = &mTraceSkeleton->m_Bones[0];
; 1686 : 	NDword wCount;
; 1687 : 	CCpjSklWeight* w;
; 1688 : 	for (NDword i=0;i<mTriBones.GetCount();i++)

	mov	DWORD PTR _i$[esp+328], ebx
	mov	edx, DWORD PTR [eax+88]
	mov	ebp, DWORD PTR [eax+72]
	mov	eax, DWORD PTR [esi+12]
	mov	DWORD PTR _sklVerts$[esp+328], edx
	mov	edx, DWORD PTR [ecx+104]
	mov	ecx, DWORD PTR [ecx+72]
	cmp	eax, ebx
	mov	DWORD PTR _geoTris$[esp+328], edx
	mov	DWORD PTR _gvZero$[esp+328], ecx
	jbe	$L13400

; 1681 : 	static NFloat influence[256];
; 1682 : 	CCpjSklVert* sklVerts = &mTraceSkeleton->m_Verts[0];

	mov	ebx, edx
$L13398:

; 1689 : 	{
; 1690 : 		memset(influence, 0, 256*sizeof(NFloat));

	mov	ecx, 256				; 00000100H
	xor	eax, eax
	mov	edi, OFFSET FLAT:?influence@?1??Construct@CMacTraceInfo@@QAEXPAVOMacActor@@@Z@4PAMA
	mov	DWORD PTR -312+[esp+328], 3
	rep stosd
$L13403:

; 1692 : 		{
; 1693 : 			CCpjSklVert* v = &sklVerts[geoTris[i].edgeRing[j]->tailVertex - gvZero];

	mov	edx, DWORD PTR [ebx]
	mov	eax, DWORD PTR _gvZero$[esp+328]
	mov	esi, DWORD PTR _sklVerts$[esp+328]
	mov	ecx, DWORD PTR [edx+4]
	sub	ecx, eax
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	edx, eax
	shl	edx, 4
	add	edx, esi

; 1694 : 			wCount = v->weights.GetCount();

	mov	eax, DWORD PTR [edx+4]

; 1695 : 			w = &v->weights[0];

	mov	esi, DWORD PTR [edx]

; 1696 : 			for (NDword k=0;k<wCount;k++,w++)

	test	eax, eax
	jbe	SHORT $L13404

; 1692 : 		{
; 1693 : 			CCpjSklVert* v = &sklVerts[geoTris[i].edgeRing[j]->tailVertex - gvZero];

	mov	edi, eax
$L13408:

; 1697 : 				influence[w->bone - sbZero] += w->factor;

	mov	ecx, DWORD PTR [esi]
	mov	eax, 1808407283				; 6bca1af3H
	sub	ecx, ebp
	imul	ecx
	fld	DWORD PTR [esi+4]
	sar	edx, 5
	mov	ecx, edx
	add	esi, 20					; 00000014H
	shr	ecx, 31					; 0000001fH
	add	edx, ecx
	dec	edi
	fadd	DWORD PTR ?influence@?1??Construct@CMacTraceInfo@@QAEXPAVOMacActor@@@Z@4PAMA[edx*4]
	lea	eax, DWORD PTR ?influence@?1??Construct@CMacTraceInfo@@QAEXPAVOMacActor@@@Z@4PAMA[edx*4]
	fstp	DWORD PTR [eax]
	jne	SHORT $L13408
$L13404:

; 1691 : 		for (NDword j=0;j<3;j++)

	mov	eax, DWORD PTR -312+[esp+328]
	add	ebx, 4
	dec	eax
	mov	DWORD PTR -312+[esp+328], eax
	jne	SHORT $L13403

; 1698 : 		}			
; 1699 : 		NFloat maxInfluence = 0.f;
; 1700 : 		NByte maxBone = 255;
; 1701 : 		for (j=0;j<mTraceSkeleton->m_Bones.GetCount();j++)

	mov	edi, DWORD PTR _this$[esp+328]
	or	dl, 255					; 000000ffH
	fld	DWORD PTR __real@00000000
	mov	eax, DWORD PTR [edi+4]
	xor	ecx, ecx
	mov	esi, DWORD PTR [eax+76]
	test	esi, esi
	jbe	SHORT $L34823
$L13413:

; 1702 : 		{
; 1703 : 			if (influence[j] > maxInfluence)

	fcom	DWORD PTR ?influence@?1??Construct@CMacTraceInfo@@QAEXPAVOMacActor@@@Z@4PAMA[ecx*4]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L13414
	fstp	ST(0)

; 1704 : 			{
; 1705 : 				maxInfluence = influence[j];

	fld	DWORD PTR ?influence@?1??Construct@CMacTraceInfo@@QAEXPAVOMacActor@@@Z@4PAMA[ecx*4]

; 1706 : 				maxBone = (NByte)j;

	mov	dl, cl
$L13414:
	inc	ecx
	cmp	ecx, esi
	jb	SHORT $L13413
$L34823:

; 1707 : 			}
; 1708 : 		}
; 1709 : 		mTriBones[i] = maxBone;

	mov	ecx, DWORD PTR [edi+8]
	mov	eax, DWORD PTR _i$[esp+328]
	fstp	ST(0)
	mov	BYTE PTR [eax+ecx], dl
	mov	ecx, DWORD PTR [edi+12]
	inc	eax
	cmp	eax, ecx
	mov	DWORD PTR _i$[esp+328], eax
	jb	$L13398
	mov	esi, DWORD PTR _this$[esp+328]
	xor	ebx, ebx
$L13400:

; 1710 : 	}
; 1711 : 
; 1712 : 	// create the bone bounds based on default vert positions
; 1713 : 	TCorArray<OMacChannel*> channelBackup = inActor->mActorChannels;

	mov	edx, DWORD PTR _inActor$[esp+324]
	push	4
	lea	ecx, DWORD PTR _channelBackup$[esp+332]
	mov	eax, DWORD PTR [edx+292]
	lea	ebp, DWORD PTR [edx+288]
	push	eax
	mov	DWORD PTR -212+[esp+336], ebp
	call	??0CCorArray@@IAE@KK@Z			; CCorArray::CCorArray
	mov	eax, DWORD PTR [ebp+4]
	xor	edi, edi
	cmp	eax, ebx
	mov	DWORD PTR __$EHRec$[esp+336], ebx
	mov	DWORD PTR _channelBackup$[esp+332], ebx
	jbe	SHORT $L33683
$L33681:
	push	1
	lea	ecx, DWORD PTR _channelBackup$[esp+332]
	call	?AddNoConstruct@?$TCorArray@PAVOMacChannel@@@@QAEKK@Z ; TCorArray<OMacChannel *>::AddNoConstruct
	mov	ecx, DWORD PTR _channelBackup$[esp+328]
	lea	eax, DWORD PTR [ecx+eax*4]
	cmp	eax, ebx
	je	SHORT $L33671
	mov	edx, DWORD PTR [ebp]
	mov	ecx, DWORD PTR [edx+edi*4]
	mov	DWORD PTR [eax], ecx
$L33671:
	mov	eax, DWORD PTR [ebp+4]
	inc	edi
	cmp	edi, eax
	jb	SHORT $L33681
$L33683:

; 1714 : 	inActor->mActorChannels.Purge(); inActor->mActorChannels.Shrink();

	mov	edx, DWORD PTR [ebp+4]
	mov	ecx, ebp
	push	edx
	push	ebx
	mov	DWORD PTR __$EHRec$[esp+344], 1
	call	?Remove@?$TCorArray@PAVOMacChannel@@@@QAEXKK@Z ; TCorArray<OMacChannel *>::Remove
	mov	eax, DWORD PTR [ebp+4]
	mov	ecx, DWORD PTR [ebp+8]
	cmp	ecx, eax
	je	SHORT $L33691
	push	4
	mov	ecx, ebp
	mov	DWORD PTR [ebp+8], eax
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
$L33691:

; 1715 : 	inActor->mActorChannels.AddZeroed(MAC_NUMCHANNELS);

	push	16					; 00000010H
	mov	ecx, ebp
	call	?AddNoConstruct@?$TCorArray@PAVOMacChannel@@@@QAEKK@Z ; TCorArray<OMacChannel *>::AddNoConstruct
	mov	edi, DWORD PTR [ebp]
	mov	edx, eax
	mov	ecx, 16					; 00000010H
	xor	eax, eax
	lea	edi, DWORD PTR [edi+edx*4]

; 1716 : 	TCorArray<VVec3> tempVerts(mTraceGeometry->m_Verts.GetCount());

	push	12					; 0000000cH
	rep stosd
	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR _tempVerts$[esp+332]
	mov	eax, DWORD PTR [eax+76]
	push	eax
	call	??0CCorArray@@IAE@KK@Z			; CCorArray::CCorArray

; 1717 : 	NDword numVerts = inActor->EvaluateVerts(1.f, 1.f, &tempVerts[0]);

	mov	ecx, DWORD PTR _tempVerts$[esp+328]
	mov	bl, 2
	push	ecx
	mov	ecx, DWORD PTR _inActor$[esp+328]
	push	1065353216				; 3f800000H
	push	1065353216				; 3f800000H
	mov	BYTE PTR __$EHRec$[esp+348], bl
	call	?EvaluateVerts@OMacActor@@QAEKMMPAVVVec3@@@Z ; OMacActor::EvaluateVerts

; 1718 : 	
; 1719 : 	static VVec3 boneMin[256], boneMax[256];

	mov	al, BYTE PTR ?$S129@?M@??Construct@CMacTraceInfo@@QAEXPAVOMacActor@@@Z@4EA
	test	al, 1
	jne	SHORT $L13425
	mov	dl, al
	push	OFFSET FLAT:_$E130
	or	dl, 1
	mov	BYTE PTR ?$S129@?M@??Construct@CMacTraceInfo@@QAEXPAVOMacActor@@@Z@4EA, dl
	call	_atexit
	add	esp, 4
$L13425:
	mov	al, BYTE PTR ?$S129@?M@??Construct@CMacTraceInfo@@QAEXPAVOMacActor@@@Z@4EA
	test	al, bl
	jne	SHORT $L13430
	mov	dl, al
	push	OFFSET FLAT:_$E131
	or	dl, bl
	mov	BYTE PTR ?$S129@?M@??Construct@CMacTraceInfo@@QAEXPAVOMacActor@@@Z@4EA, dl
	call	_atexit
	add	esp, 4
$L13430:

; 1720 : 	static NBool boneUsed[256];
; 1721 : 	mBoneBounds.Add(mTraceSkeleton->m_Bones.GetCount());

	mov	edx, DWORD PTR [esi+4]
	mov	ebx, DWORD PTR _this$[esp+328]
	mov	esi, DWORD PTR [edx+76]
	lea	edi, DWORD PTR [ebx+24]
	push	esi
	mov	ecx, edi
	call	?AddNoConstruct@?$TCorArray@VVBox3@@@@QAEKK@Z ; TCorArray<VBox3>::AddNoConstruct
	lea	ecx, DWORD PTR [eax+esi]
	cmp	eax, ecx
	jae	SHORT $L33849
	lea	edx, DWORD PTR [eax+eax*2]
	lea	edx, DWORD PTR [edx+edx*4]
	shl	edx, 2
	sub	ecx, eax
	mov	DWORD PTR -312+[esp+328], ecx
$L33847:
	mov	eax, DWORD PTR [edi]
	add	eax, edx
	je	SHORT $L33822
	mov	ecx, 1065353216				; 3f800000H
	xor	esi, esi
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], esi
	mov	DWORD PTR [eax+8], esi
	mov	DWORD PTR [eax+12], esi
	mov	DWORD PTR [eax+16], ecx
	mov	DWORD PTR [eax+20], esi
	mov	DWORD PTR [eax+24], esi
	mov	DWORD PTR [eax+28], esi
	mov	DWORD PTR [eax+32], ecx
	mov	DWORD PTR [eax+36], esi
	mov	DWORD PTR [eax+40], esi
	mov	DWORD PTR [eax+44], esi
	mov	DWORD PTR [eax+48], ecx
	mov	DWORD PTR [eax+52], ecx
	mov	DWORD PTR [eax+56], ecx
$L33822:
	mov	eax, DWORD PTR -312+[esp+328]
	add	edx, 60					; 0000003cH
	dec	eax
	mov	DWORD PTR -312+[esp+328], eax
	jne	SHORT $L33847
$L33849:

; 1722 : 	for (i=0;i<mBoneBounds.GetCount();i++)

	mov	eax, DWORD PTR [ebx+28]
	xor	ecx, ecx
	test	eax, eax
	jbe	SHORT $L13437
	xor	eax, eax
	mov	esi, 2139095039				; 7f7fffffH
	mov	edx, -8388609				; ff7fffffH
$L13435:

; 1723 : 	{
; 1724 : 		boneMin[i] = VVec3(FLT_MAX,FLT_MAX,FLT_MAX);

	mov	DWORD PTR ?boneMin@?M@??Construct@CMacTraceInfo@@QAEXPAVOMacActor@@@Z@4PAVVVec3@@A[eax], esi
	mov	DWORD PTR ?boneMin@?M@??Construct@CMacTraceInfo@@QAEXPAVOMacActor@@@Z@4PAVVVec3@@A[eax+4], esi
	mov	DWORD PTR ?boneMin@?M@??Construct@CMacTraceInfo@@QAEXPAVOMacActor@@@Z@4PAVVVec3@@A[eax+8], esi

; 1725 : 		boneMax[i] = VVec3(-FLT_MAX,-FLT_MAX,-FLT_MAX);

	mov	DWORD PTR ?boneMax@?M@??Construct@CMacTraceInfo@@QAEXPAVOMacActor@@@Z@4PAVVVec3@@A[eax], edx
	mov	DWORD PTR ?boneMax@?M@??Construct@CMacTraceInfo@@QAEXPAVOMacActor@@@Z@4PAVVVec3@@A[eax+4], edx
	mov	DWORD PTR ?boneMax@?M@??Construct@CMacTraceInfo@@QAEXPAVOMacActor@@@Z@4PAVVVec3@@A[eax+8], edx

; 1726 : 		boneUsed[i] = 0;

	mov	BYTE PTR ?boneUsed@?M@??Construct@CMacTraceInfo@@QAEXPAVOMacActor@@@Z@4PA_NA[ecx], 0
	mov	edi, DWORD PTR [ebx+28]
	inc	ecx
	add	eax, 12					; 0000000cH
	cmp	ecx, edi
	jb	SHORT $L13435
$L13437:

; 1727 : 	}
; 1728 : 	for (i=0;i<mTriBones.GetCount();i++)

	mov	eax, DWORD PTR [ebx+12]
	xor	esi, esi
	test	eax, eax
	jbe	$L13442
	mov	edi, DWORD PTR _geoTris$[esp+328]
$L13440:

; 1729 : 	{
; 1730 : 		for (NDword j=0;j<3;j++)

	mov	DWORD PTR -312+[esp+328], 3
$L13444:

; 1731 : 		{
; 1732 : 			VVec3* v = &tempVerts[geoTris[i].edgeRing[j]->tailVertex - gvZero];

	mov	eax, DWORD PTR [edi]
	mov	edx, DWORD PTR _gvZero$[esp+328]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, 715827883				; 2aaaaaabH
	sub	ecx, edx
	imul	ecx
	sar	edx, 3
	mov	eax, DWORD PTR _tempVerts$[esp+328]
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	edx, ecx

; 1733 : 			VVec3* vMin = &boneMin[mTriBones[i]];

	mov	ecx, DWORD PTR [ebx+8]
	lea	edx, DWORD PTR [edx+edx*2]
	lea	edx, DWORD PTR [eax+edx*4]
	xor	eax, eax
	mov	al, BYTE PTR [esi+ecx]

; 1734 : 			VVec3* vMax = &boneMax[mTriBones[i]];
; 1735 : 			if (v->x < vMin->x) vMin->x = v->x;

	fld	DWORD PTR [edx]
	lea	ecx, DWORD PTR [eax+eax*2]
	shl	ecx, 2
	fcomp	DWORD PTR ?boneMin@?M@??Construct@CMacTraceInfo@@QAEXPAVOMacActor@@@Z@4PAVVVec3@@A[ecx]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L13450
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR ?boneMin@?M@??Construct@CMacTraceInfo@@QAEXPAVOMacActor@@@Z@4PAVVVec3@@A[ecx], eax
$L13450:

; 1736 : 			if (v->y < vMin->y) vMin->y = v->y;

	fld	DWORD PTR [edx+4]
	fcomp	DWORD PTR ?boneMin@?M@??Construct@CMacTraceInfo@@QAEXPAVOMacActor@@@Z@4PAVVVec3@@A[ecx+4]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L13451
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR ?boneMin@?M@??Construct@CMacTraceInfo@@QAEXPAVOMacActor@@@Z@4PAVVVec3@@A[ecx+4], eax
$L13451:

; 1737 : 			if (v->z < vMin->z) vMin->z = v->z;

	fld	DWORD PTR [edx+8]
	fcomp	DWORD PTR ?boneMin@?M@??Construct@CMacTraceInfo@@QAEXPAVOMacActor@@@Z@4PAVVVec3@@A[ecx+8]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L13452
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR ?boneMin@?M@??Construct@CMacTraceInfo@@QAEXPAVOMacActor@@@Z@4PAVVVec3@@A[ecx+8], eax
$L13452:

; 1738 : 			if (v->x > vMax->x) vMax->x = v->x;

	fld	DWORD PTR [edx]
	fcomp	DWORD PTR ?boneMax@?M@??Construct@CMacTraceInfo@@QAEXPAVOMacActor@@@Z@4PAVVVec3@@A[ecx]
	fnstsw	ax
	and	eax, 16640				; 00004100H
	jne	SHORT $L13453
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR ?boneMax@?M@??Construct@CMacTraceInfo@@QAEXPAVOMacActor@@@Z@4PAVVVec3@@A[ecx], eax
$L13453:

; 1739 : 			if (v->y > vMax->y) vMax->y = v->y;

	fld	DWORD PTR [edx+4]
	fcomp	DWORD PTR ?boneMax@?M@??Construct@CMacTraceInfo@@QAEXPAVOMacActor@@@Z@4PAVVVec3@@A[ecx+4]
	fnstsw	ax
	and	eax, 16640				; 00004100H
	jne	SHORT $L13454
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR ?boneMax@?M@??Construct@CMacTraceInfo@@QAEXPAVOMacActor@@@Z@4PAVVVec3@@A[ecx+4], eax
$L13454:

; 1740 : 			if (v->z > vMax->z) vMax->z = v->z;

	fld	DWORD PTR [edx+8]
	fcomp	DWORD PTR ?boneMax@?M@??Construct@CMacTraceInfo@@QAEXPAVOMacActor@@@Z@4PAVVVec3@@A[ecx+8]
	fnstsw	ax
	and	eax, 16640				; 00004100H
	jne	SHORT $L13455
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR ?boneMax@?M@??Construct@CMacTraceInfo@@QAEXPAVOMacActor@@@Z@4PAVVVec3@@A[ecx+8], edx
$L13455:

; 1741 : 			boneUsed[mTriBones[i]] = 1;

	mov	eax, DWORD PTR [ebx+8]
	xor	ecx, ecx
	add	edi, 4
	mov	cl, BYTE PTR [esi+eax]
	mov	eax, DWORD PTR -312+[esp+328]
	dec	eax
	mov	BYTE PTR ?boneUsed@?M@??Construct@CMacTraceInfo@@QAEXPAVOMacActor@@@Z@4PA_NA[ecx], 1
	mov	DWORD PTR -312+[esp+328], eax
	jne	$L13444
	mov	eax, DWORD PTR [ebx+12]
	inc	esi
	cmp	esi, eax
	jb	$L13440
$L13442:

; 1742 : 		}
; 1743 : 	}
; 1744 : 	for (i=0;i<mBoneBounds.GetCount();i++)

	mov	eax, DWORD PTR [ebx+28]
	mov	DWORD PTR _i$[esp+328], 0
	test	eax, eax
	jbe	$L13458
	xor	ebp, ebp
	xor	ebx, ebx
	xor	ecx, ecx
	xor	edi, edi
$L13456:

; 1745 : 	{
; 1746 : 		if (boneUsed[i])

	mov	edx, DWORD PTR _i$[esp+328]
	mov	al, BYTE PTR ?boneUsed@?M@??Construct@CMacTraceInfo@@QAEXPAVOMacActor@@@Z@4PA_NA[edx]

; 1747 : 		{
; 1748 : 			mBoneBounds[i] = VBox3(boneMin[i], boneMax[i]);

	mov	edx, DWORD PTR _this$[esp+328]
	test	al, al
	je	$L13459
	fld	DWORD PTR ?boneMin@?M@??Construct@CMacTraceInfo@@QAEXPAVOMacActor@@@Z@4PAVVVec3@@A[edi]
	fld	DWORD PTR ?boneMin@?M@??Construct@CMacTraceInfo@@QAEXPAVOMacActor@@@Z@4PAVVVec3@@A[edi+4]
	fld	DWORD PTR ?boneMax@?M@??Construct@CMacTraceInfo@@QAEXPAVOMacActor@@@Z@4PAVVVec3@@A[edi+8]
	fsub	DWORD PTR ?boneMin@?M@??Construct@CMacTraceInfo@@QAEXPAVOMacActor@@@Z@4PAVVVec3@@A[edi+8]
	mov	eax, DWORD PTR ?boneMin@?M@??Construct@CMacTraceInfo@@QAEXPAVOMacActor@@@Z@4PAVVVec3@@A[edi+8]

; 1749 : 			VCoords3 boneCoords = inActor->mActorBones[i].GetCoords(true);

	push	1
	mov	DWORD PTR $T33580[esp+376], eax
	lea	eax, DWORD PTR [edx+24]
	mov	edx, 1065353216				; 3f800000H
	fstp	DWORD PTR $T33944[esp+332]
	fld	DWORD PTR ?boneMax@?M@??Construct@CMacTraceInfo@@QAEXPAVOMacActor@@@Z@4PAVVVec3@@A[edi+4]
	fsub	DWORD PTR ?boneMin@?M@??Construct@CMacTraceInfo@@QAEXPAVOMacActor@@@Z@4PAVVVec3@@A[edi+4]
	mov	eax, DWORD PTR [eax]
	add	eax, ebp
	fstp	DWORD PTR $T33943[esp+332]
	fld	DWORD PTR ?boneMax@?M@??Construct@CMacTraceInfo@@QAEXPAVOMacActor@@@Z@4PAVVVec3@@A[edi]
	fsub	DWORD PTR ?boneMin@?M@??Construct@CMacTraceInfo@@QAEXPAVOMacActor@@@Z@4PAVVVec3@@A[edi]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx
	mov	DWORD PTR [eax+16], edx
	mov	DWORD PTR [eax+20], ecx
	fstp	DWORD PTR $T33942[esp+332]
	fxch	ST(1)
	mov	DWORD PTR [eax+24], ecx
	mov	DWORD PTR [eax+28], ecx
	mov	ecx, DWORD PTR $T33580[esp+376]
	mov	DWORD PTR [eax+32], edx
	fstp	DWORD PTR [eax+36]
	mov	edx, DWORD PTR $T33942[esp+332]
	mov	DWORD PTR [eax+44], ecx
	fstp	DWORD PTR [eax+40]
	mov	ecx, DWORD PTR $T33943[esp+332]
	mov	DWORD PTR [eax+48], edx
	mov	edx, DWORD PTR $T33944[esp+332]
	mov	DWORD PTR [eax+52], ecx
	mov	DWORD PTR [eax+56], edx
	mov	eax, DWORD PTR _inActor$[esp+328]
	mov	esi, DWORD PTR [eax+272]
	add	esi, ebx
	mov	ecx, esi
	call	?ValidateAbs@CMacBone@@IAEX_N@Z		; CMacBone::ValidateAbs
	mov	DWORD PTR _boneCoords$13461[esp+328], 1065353216 ; 3f800000H
	mov	DWORD PTR _boneCoords$13461[esp+332], 0
	mov	DWORD PTR _boneCoords$13461[esp+336], 0
	mov	DWORD PTR _boneCoords$13461[esp+340], 0
	mov	DWORD PTR _boneCoords$13461[esp+344], 1065353216 ; 3f800000H
	mov	DWORD PTR _boneCoords$13461[esp+348], 0
	mov	DWORD PTR _boneCoords$13461[esp+352], 0
	mov	DWORD PTR _boneCoords$13461[esp+356], 0
	mov	DWORD PTR _boneCoords$13461[esp+360], 1065353216 ; 3f800000H
	mov	ecx, DWORD PTR [esi+60]
	mov	DWORD PTR _boneCoords$13461[esp+328], ecx
	mov	edx, DWORD PTR [esi+64]
	mov	DWORD PTR _boneCoords$13461[esp+332], edx
	mov	eax, DWORD PTR [esi+68]
	mov	DWORD PTR _boneCoords$13461[esp+336], eax
	mov	ecx, DWORD PTR [esi+72]
	mov	DWORD PTR _boneCoords$13461[esp+340], ecx
	mov	edx, DWORD PTR [esi+76]
	mov	DWORD PTR _boneCoords$13461[esp+344], edx
	mov	eax, DWORD PTR [esi+80]
	mov	DWORD PTR _boneCoords$13461[esp+348], eax
	mov	ecx, DWORD PTR [esi+84]
	mov	DWORD PTR _boneCoords$13461[esp+352], ecx
	mov	edx, DWORD PTR [esi+88]
	mov	DWORD PTR _boneCoords$13461[esp+356], edx
	mov	eax, DWORD PTR [esi+92]
	mov	DWORD PTR _boneCoords$13461[esp+360], eax
	mov	ecx, DWORD PTR [esi+96]
	mov	DWORD PTR _boneCoords$13461[esp+364], ecx
	mov	edx, DWORD PTR [esi+100]
	mov	DWORD PTR _boneCoords$13461[esp+368], edx
	mov	eax, DWORD PTR [esi+104]
	mov	DWORD PTR _boneCoords$13461[esp+372], eax
	mov	ecx, DWORD PTR [esi+108]
	mov	DWORD PTR _boneCoords$13461[esp+376], ecx
	mov	edx, DWORD PTR [esi+112]
	mov	DWORD PTR _boneCoords$13461[esp+380], edx
	mov	eax, DWORD PTR [esi+116]

; 1750 : 			mBoneBounds[i].c >>= boneCoords;

	mov	ecx, DWORD PTR _this$[esp+328]
	mov	DWORD PTR _boneCoords$13461[esp+384], eax
	mov	esi, DWORD PTR [ecx+24]
	lea	eax, DWORD PTR [ecx+24]
	add	esi, ebp
	fld	DWORD PTR [esi+56]
	fdiv	DWORD PTR _boneCoords$13461[esp+384]
	fld	DWORD PTR [esi+52]
	fdiv	DWORD PTR _boneCoords$13461[esp+380]
	fld	DWORD PTR [esi+48]
	fdiv	DWORD PTR _boneCoords$13461[esp+376]
	fstp	DWORD PTR $T34427[esp+328]
	fstp	DWORD PTR $T34427[esp+332]
	fstp	DWORD PTR $T34427[esp+336]
	fld	DWORD PTR _boneCoords$13461[esp+356]
	fmul	DWORD PTR [esi+28]
	fld	DWORD PTR _boneCoords$13461[esp+352]
	fmul	DWORD PTR [esi+24]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _boneCoords$13461[esp+360]
	fmul	DWORD PTR [esi+32]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _boneCoords$13461[esp+344]
	fmul	DWORD PTR [esi+28]
	fld	DWORD PTR _boneCoords$13461[esp+340]
	fmul	DWORD PTR [esi+24]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _boneCoords$13461[esp+348]
	fmul	DWORD PTR [esi+32]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _boneCoords$13461[esp+332]
	fmul	DWORD PTR [esi+28]
	fld	DWORD PTR _boneCoords$13461[esp+336]
	fmul	DWORD PTR [esi+32]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _boneCoords$13461[esp+328]
	fmul	DWORD PTR [esi+24]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _boneCoords$13461[esp+360]
	fmul	DWORD PTR [esi+20]
	fld	DWORD PTR _boneCoords$13461[esp+356]
	fmul	DWORD PTR [esi+16]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _boneCoords$13461[esp+352]
	fmul	DWORD PTR [esi+12]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _boneCoords$13461[esp+348]
	fmul	DWORD PTR [esi+20]
	fld	DWORD PTR _boneCoords$13461[esp+344]
	fmul	DWORD PTR [esi+16]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _boneCoords$13461[esp+340]
	fmul	DWORD PTR [esi+12]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _boneCoords$13461[esp+336]
	fmul	DWORD PTR [esi+20]
	fld	DWORD PTR _boneCoords$13461[esp+328]
	fmul	DWORD PTR [esi+12]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _boneCoords$13461[esp+332]
	fmul	DWORD PTR [esi+16]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _boneCoords$13461[esp+360]
	fmul	DWORD PTR [esi+8]
	fld	DWORD PTR _boneCoords$13461[esp+356]
	fmul	DWORD PTR [esi+4]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _boneCoords$13461[esp+352]
	fmul	DWORD PTR [esi]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR $T34269[esp+328]
	fld	DWORD PTR _boneCoords$13461[esp+348]
	fmul	DWORD PTR [esi+8]
	fld	DWORD PTR _boneCoords$13461[esp+344]
	fmul	DWORD PTR [esi+4]
	mov	ecx, DWORD PTR $T34269[esp+328]
	mov	DWORD PTR $T34429[esp+336], ecx
	lea	ecx, DWORD PTR [esi+36]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _boneCoords$13461[esp+340]
	fmul	DWORD PTR [esi]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR $T34268[esp+328]
	fld	DWORD PTR _boneCoords$13461[esp+336]
	fmul	DWORD PTR [esi+8]
	fld	DWORD PTR _boneCoords$13461[esp+332]
	fmul	DWORD PTR [esi+4]
	mov	eax, DWORD PTR $T34268[esp+328]
	mov	DWORD PTR $T34429[esp+332], eax
	lea	eax, DWORD PTR _boneCoords$13461[esp+328]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _boneCoords$13461[esp+328]
	fmul	DWORD PTR [esi]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR $T34267[esp+328]
	mov	edx, DWORD PTR $T34267[esp+328]
	fstp	DWORD PTR $T34429[esp+340]
	mov	DWORD PTR $T34429[esp+328], edx
	lea	edx, DWORD PTR $T34427[esp+328]
	fstp	DWORD PTR $T34429[esp+344]
	push	edx
	push	eax
	fstp	DWORD PTR $T34429[esp+356]
	lea	edx, DWORD PTR $T34428[esp+336]
	push	ecx
	fstp	DWORD PTR $T34429[esp+364]
	push	edx
	fstp	DWORD PTR $T34429[esp+372]
	fstp	DWORD PTR $T34429[esp+376]
	call	??5@YA?AVVVec3@@ABV0@ABVVCoords3@@@Z	; operator>>
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR $T34424[esp+332]
	push	eax
	lea	eax, DWORD PTR $T34429[esp+336]
	push	eax
	call	??0VCoords3@@QAE@ABVVAxes3@@ABVVVec3@@1@Z ; VCoords3::VCoords3
	lea	ecx, DWORD PTR $T34424[esp+328]
	push	ecx
	mov	ecx, esi
	call	??4VCoords3@@QAEAAV0@ABV0@@Z		; VCoords3::operator=

; 1751 : 		}
; 1752 : 		else

	xor	ecx, ecx
	jmp	SHORT $L13457
$L13459:

; 1753 : 			mBoneBounds[i] = VBox3(VVec3(-0.5f,-0.5f,-0.5f), VVec3(0.5f,0.5f,0.5f));

	lea	eax, DWORD PTR [edx+24]
	mov	edx, 1065353216				; 3f800000H
	mov	esi, -1090519040			; bf000000H
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [eax+ebp], edx
	add	eax, ebp
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx
	mov	DWORD PTR [eax+16], edx
	mov	DWORD PTR [eax+20], ecx
	mov	DWORD PTR [eax+24], ecx
	mov	DWORD PTR [eax+28], ecx
	mov	DWORD PTR [eax+32], edx
	mov	DWORD PTR [eax+36], esi
	mov	DWORD PTR [eax+40], esi
	mov	DWORD PTR [eax+44], esi
	mov	DWORD PTR [eax+48], edx
	mov	DWORD PTR [eax+52], edx
	mov	DWORD PTR [eax+56], edx
$L13457:
	mov	edx, DWORD PTR _this$[esp+328]
	mov	eax, DWORD PTR _i$[esp+328]
	inc	eax
	add	edi, 12					; 0000000cH
	mov	esi, DWORD PTR [edx+28]
	add	ebx, 140				; 0000008cH
	add	ebp, 60					; 0000003cH
	cmp	eax, esi
	mov	DWORD PTR _i$[esp+328], eax
	jb	$L13456

; 1742 : 		}
; 1743 : 	}
; 1744 : 	for (i=0;i<mBoneBounds.GetCount();i++)

	mov	ebp, DWORD PTR -212+[esp+328]
$L13458:

; 1754 : 
; 1755 : 		//LOG_Logf("PostBone %d: pos (%f,%f,%f) dim (%f,%f,%f)", i, mBoneBounds[i].c.t.x, mBoneBounds[i].c.t.y, mBoneBounds[i].c.t.z,
; 1756 : 		//	mBoneBounds[i].c.s.x, mBoneBounds[i].c.s.y, mBoneBounds[i].c.s.z);
; 1757 : 	}
; 1758 : 
; 1759 : 	inActor->mActorChannels = channelBackup;

	lea	eax, DWORD PTR _channelBackup$[esp+328]
	cmp	ebp, eax
	je	$L34702
	mov	ecx, DWORD PTR [ebp]
	mov	eax, DWORD PTR _channelBackup$[esp+332]
	test	ecx, ecx
	mov	DWORD PTR [ebp+4], 0
	mov	DWORD PTR [ebp+8], eax
	mov	DWORD PTR [ebp+12], 4
	je	$L34683
	test	eax, eax
	je	SHORT $L34685
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [ebp+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [ebp+8]
	push	ecx
	mov	ecx, DWORD PTR [ebp]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+4]
	mov	DWORD PTR [ebp], eax
	jmp	SHORT $L34690
$L34685:
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [ebp]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L34689:
	mov	DWORD PTR [ebp], 0
$L34690:
	mov	eax, DWORD PTR _channelBackup$[esp+332]
	xor	esi, esi
	test	eax, eax
	jbe	SHORT $L34702
$L34700:
	push	1
	mov	ecx, ebp
	call	?AddNoConstruct@?$TCorArray@PAVOMacChannel@@@@QAEKK@Z ; TCorArray<OMacChannel *>::AddNoConstruct
	mov	edx, DWORD PTR [ebp]
	lea	eax, DWORD PTR [edx+eax*4]
	test	eax, eax
	je	SHORT $L34679
	mov	ecx, DWORD PTR _channelBackup$[esp+328]
	mov	edx, DWORD PTR [ecx+esi*4]
	mov	DWORD PTR [eax], edx
$L34679:
	mov	eax, DWORD PTR _channelBackup$[esp+332]
	inc	esi
	cmp	esi, eax
	jb	SHORT $L34700
$L34702:

; 1760 : }

	mov	eax, DWORD PTR _tempVerts$[esp+332]
	push	12					; 0000000cH
	push	eax
	push	0
	lea	ecx, DWORD PTR _tempVerts$[esp+340]
	mov	BYTE PTR __$EHRec$[esp+348], 3
	call	?Remove@CCorArray@@QAEXKKK@Z		; CCorArray::Remove
	mov	eax, DWORD PTR _tempVerts$[esp+328]
	mov	BYTE PTR __$EHRec$[esp+336], 1
	test	eax, eax
	je	SHORT $L34738
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR _tempVerts$[esp+328]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L34738:
	mov	eax, DWORD PTR _channelBackup$[esp+332]
	mov	DWORD PTR __$EHRec$[esp+336], -1
	test	eax, eax
	mov	esi, eax
	je	SHORT $L34777
	mov	ecx, DWORD PTR _channelBackup$[esp+328]
	push	0
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	push	ecx
	call	DWORD PTR __imp__memmove
	mov	eax, DWORD PTR _channelBackup$[esp+344]
	add	esp, 12					; 0000000cH
	sub	eax, esi
	mov	DWORD PTR _channelBackup$[esp+332], eax
$L34777:
	mov	eax, DWORD PTR _channelBackup$[esp+328]
	pop	edi
	pop	esi
	pop	ebp
	test	eax, eax
	pop	ebx
	je	SHORT $L34787
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR _channelBackup$[esp+312]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L34787:
	mov	ecx, DWORD PTR __$EHRec$[esp+312]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 312				; 00000138H
	ret	4

; 1754 : 
; 1755 : 		//LOG_Logf("PostBone %d: pos (%f,%f,%f) dim (%f,%f,%f)", i, mBoneBounds[i].c.t.x, mBoneBounds[i].c.t.y, mBoneBounds[i].c.t.z,
; 1756 : 		//	mBoneBounds[i].c.s.x, mBoneBounds[i].c.s.y, mBoneBounds[i].c.s.z);
; 1757 : 	}
; 1758 : 
; 1759 : 	inActor->mActorChannels = channelBackup;

$L34683:
	test	eax, eax
	je	$L34689
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [ebp+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [ebp+8]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	DWORD PTR [ebp], eax
	jmp	$L34690
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L33655:
	lea	ecx, DWORD PTR _channelBackup$[ebp]
	jmp	??1CCorArray@@IAE@XZ			; CCorArray::~CCorArray
$L33584:
	lea	ecx, DWORD PTR _channelBackup$[ebp]
	jmp	??1?$TCorArray@PAVOMacChannel@@@@QAE@XZ	; TCorArray<OMacChannel *>::~TCorArray<OMacChannel *>
$L33585:
	lea	ecx, DWORD PTR _tempVerts$[ebp]
	jmp	??1?$TCorArray@VVVec3@@@@QAE@XZ		; TCorArray<VVec3>::~TCorArray<VVec3>
$L34705:
	lea	ecx, DWORD PTR _tempVerts$[ebp]
	jmp	??1CCorArray@@IAE@XZ			; CCorArray::~CCorArray
$L34829:
	mov	eax, OFFSET FLAT:$T34790
	jmp	___CxxFrameHandler
text$x	ENDS
?Construct@CMacTraceInfo@@QAEXPAVOMacActor@@@Z ENDP	; CMacTraceInfo::Construct
; Function compile flags: /Ogty
; File C:\duke4\Cannibal\CorMain.h
;	COMDAT ??1CCorArray@@IAE@XZ
_TEXT	SEGMENT
??1CCorArray@@IAE@XZ PROC NEAR				; CCorArray::~CCorArray, COMDAT
; _this$ = ecx

; 215  : 	{

	push	esi
	mov	esi, ecx

; 216  : 		if (m_Data)

	cmp	DWORD PTR [esi], 0
	je	SHORT $L4960

; 217  : 			MEM_Free(m_Data);

	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L4960:
	pop	esi

; 218  : 	}

	ret	0
??1CCorArray@@IAE@XZ ENDP				; CCorArray::~CCorArray
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?Remove@CCorArray@@QAEXKKK@Z
_TEXT	SEGMENT
_inIndex$ = 8
_inCount$ = 12
_inElemSize$ = 16
?Remove@CCorArray@@QAEXKKK@Z PROC NEAR			; CCorArray::Remove, COMDAT
; _this$ = ecx

; 242  : 	{

	push	esi
	push	edi

; 243  : 		if (!inCount)

	mov	edi, DWORD PTR _inCount$[esp+4]
	mov	esi, ecx
	test	edi, edi
	je	SHORT $L4971

; 244  : 			return;
; 245  : 		memmove((NByte*)m_Data+inIndex*inElemSize, (NByte*)m_Data+(inIndex+inCount)*inElemSize, (m_Count-inIndex-inCount)*inElemSize);

	mov	eax, DWORD PTR _inIndex$[esp+4]
	mov	edx, DWORD PTR _inElemSize$[esp+4]
	push	ebx
	mov	ebx, DWORD PTR [esi+4]
	sub	ebx, eax
	mov	ecx, DWORD PTR [esi]
	sub	ebx, edi
	imul	ebx, edx
	push	ebx
	lea	ebx, DWORD PTR [eax+edi]
	imul	ebx, edx
	imul	eax, edx
	add	ebx, ecx
	add	eax, ecx
	push	ebx
	push	eax
	call	DWORD PTR __imp__memmove

; 246  : 		m_Count -= inCount;

	mov	eax, DWORD PTR [esi+4]
	add	esp, 12					; 0000000cH
	sub	eax, edi
	mov	DWORD PTR [esi+4], eax
	pop	ebx
$L4971:
	pop	edi
	pop	esi

; 247  : 	}

	ret	12					; 0000000cH
?Remove@CCorArray@@QAEXKKK@Z ENDP			; CCorArray::Remove
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT _$E131
_TEXT	SEGMENT
_$E131	PROC NEAR					; COMDAT
	ret	0
_$E131	ENDP
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT _$E130
_TEXT	SEGMENT
_$E130	PROC NEAR					; COMDAT
	ret	0
_$E130	ENDP
; Function compile flags: /Ogty
; File C:\duke4\Cannibal\VecMain.h
_TEXT	ENDS
;	COMDAT ??0VCoords3@@QAE@XZ
_TEXT	SEGMENT
??0VCoords3@@QAE@XZ PROC NEAR				; VCoords3::VCoords3, COMDAT
; _this$ = ecx

; 397  : 	VEC_INLINE VCoords3() : r(), t(0,0,0), s(1,1,1) {}

	mov	eax, ecx
	mov	edx, 1065353216				; 3f800000H
	xor	ecx, ecx
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx
	mov	DWORD PTR [eax+16], edx
	mov	DWORD PTR [eax+20], ecx
	mov	DWORD PTR [eax+24], ecx
	mov	DWORD PTR [eax+28], ecx
	mov	DWORD PTR [eax+32], edx
	mov	DWORD PTR [eax+36], ecx
	mov	DWORD PTR [eax+40], ecx
	mov	DWORD PTR [eax+44], ecx
	mov	DWORD PTR [eax+48], edx
	mov	DWORD PTR [eax+52], edx
	mov	DWORD PTR [eax+56], edx
	ret	0
??0VCoords3@@QAE@XZ ENDP				; VCoords3::VCoords3
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??0VCoords3@@QAE@ABV0@@Z
_TEXT	SEGMENT
_inC$ = 8
??0VCoords3@@QAE@ABV0@@Z PROC NEAR			; VCoords3::VCoords3, COMDAT
; _this$ = ecx

; 398  : 	VEC_INLINE VCoords3(const VCoords3& inC) { r = inC.r; t = inC.t; s = inC.s; }

	mov	eax, ecx
	mov	edx, 1065353216				; 3f800000H
	xor	ecx, ecx
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx
	mov	DWORD PTR [eax+16], edx
	mov	DWORD PTR [eax+20], ecx
	mov	DWORD PTR [eax+24], ecx
	mov	DWORD PTR [eax+28], ecx
	mov	ecx, DWORD PTR _inC$[esp-4]
	mov	DWORD PTR [eax+32], edx
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+20], edx
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax+24], edx
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR [eax+28], edx
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR [eax+32], edx
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [eax+36], edx
	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR [eax+40], edx
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR [eax+44], edx
	mov	edx, DWORD PTR [ecx+48]
	mov	DWORD PTR [eax+48], edx
	mov	edx, DWORD PTR [ecx+52]
	mov	DWORD PTR [eax+52], edx
	mov	ecx, DWORD PTR [ecx+56]
	mov	DWORD PTR [eax+56], ecx
	ret	4
??0VCoords3@@QAE@ABV0@@Z ENDP				; VCoords3::VCoords3
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??0VCoords3@@QAE@ABVVAxes3@@ABVVVec3@@1@Z
_TEXT	SEGMENT
_inRotate$ = 8
_inTranslate$ = 12
_inScale$ = 16
??0VCoords3@@QAE@ABVVAxes3@@ABVVVec3@@1@Z PROC NEAR	; VCoords3::VCoords3, COMDAT
; _this$ = ecx

; 399  : 	VEC_INLINE VCoords3(const VAxes3& inRotate, const VVec3& inTranslate = VVec3(0,0,0), const VVec3& inScale = VVec3(1,1,1) )

	mov	eax, ecx
	mov	edx, 1065353216				; 3f800000H
	xor	ecx, ecx
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx
	mov	DWORD PTR [eax+16], edx
	mov	DWORD PTR [eax+20], ecx
	mov	DWORD PTR [eax+24], ecx
	mov	DWORD PTR [eax+28], ecx

; 400  : 	{
; 401  : 		r = inRotate; t = inTranslate; s = inScale;

	mov	ecx, DWORD PTR _inRotate$[esp-4]
	mov	DWORD PTR [eax+32], edx
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+20], edx
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax+24], edx
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR [eax+28], edx
	mov	ecx, DWORD PTR [ecx+32]
	mov	DWORD PTR [eax+32], ecx
	mov	ecx, DWORD PTR _inTranslate$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+36], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+40], edx
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+44], ecx
	mov	ecx, DWORD PTR _inScale$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+48], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+52], edx
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+56], ecx

; 402  : 	}

	ret	12					; 0000000cH
??0VCoords3@@QAE@ABVVAxes3@@ABVVVec3@@1@Z ENDP		; VCoords3::VCoords3
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??4VCoords3@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
_inC$ = 8
??4VCoords3@@QAEAAV0@ABV0@@Z PROC NEAR			; VCoords3::operator=, COMDAT
; _this$ = ecx

; 404  : 	VEC_INLINE VCoords3& operator = (const VCoords3& inC){ r = inC.r; t = inC.t; s = inC.s; return(*this); }

	mov	eax, ecx
	mov	ecx, DWORD PTR _inC$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+20], edx
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax+24], edx
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR [eax+28], edx
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR [eax+32], edx
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [eax+36], edx
	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR [eax+40], edx
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR [eax+44], edx
	mov	edx, DWORD PTR [ecx+48]
	mov	DWORD PTR [eax+48], edx
	mov	edx, DWORD PTR [ecx+52]
	mov	DWORD PTR [eax+52], edx
	mov	ecx, DWORD PTR [ecx+56]
	mov	DWORD PTR [eax+56], ecx
	ret	4
??4VCoords3@@QAEAAV0@ABV0@@Z ENDP			; VCoords3::operator=
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??5@YA?AVVVec3@@ABV0@ABVVCoords3@@@Z
_TEXT	SEGMENT
_inV$ = 12
_inC$ = 16
___$ReturnUdt$ = 8
$T35035 = -12
??5@YA?AVVVec3@@ABV0@ABVVCoords3@@@Z PROC NEAR		; operator>>, COMDAT

; 417  : 	{

	sub	esp, 12					; 0000000cH

; 418  : 		return(((inV-inC.t) >> inC.r) / inC.s);

	mov	ecx, DWORD PTR _inV$[esp+8]
	mov	eax, DWORD PTR _inC$[esp+8]
	fld	DWORD PTR [ecx]
	fsub	DWORD PTR [eax+36]
	fld	DWORD PTR [ecx+4]
	fsub	DWORD PTR [eax+40]
	fld	DWORD PTR [ecx+8]
	fsub	DWORD PTR [eax+44]
	fld	ST(0)
	fmul	DWORD PTR [eax+8]
	fld	ST(2)
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	fld	ST(3)
	fmul	DWORD PTR [eax]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR $T35035[esp+12]
	fld	ST(0)
	fmul	DWORD PTR [eax+20]
	fld	ST(2)
	fmul	DWORD PTR [eax+16]
	faddp	ST(1), ST(0)
	fld	ST(3)
	fmul	DWORD PTR [eax+12]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR $T35035[esp+16]
	fmul	DWORD PTR [eax+32]
	fxch	ST(1)
	fmul	DWORD PTR [eax+28]
	faddp	ST(1), ST(0)
	fxch	ST(1)
	fmul	DWORD PTR [eax+24]
	faddp	ST(1), ST(0)
	fdiv	DWORD PTR [eax+56]
	fld	DWORD PTR $T35035[esp+16]
	fdiv	DWORD PTR [eax+52]
	fld	DWORD PTR $T35035[esp+12]
	fdiv	DWORD PTR [eax+48]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+8]
	fstp	DWORD PTR [eax]
	fstp	DWORD PTR [eax+4]
	fstp	DWORD PTR [eax+8]

; 419  : 	}

	add	esp, 12					; 0000000cH
	ret	0
??5@YA?AVVVec3@@ABV0@ABVVCoords3@@@Z ENDP		; operator>>
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??6@YA?AVVVec3@@ABV0@ABVVCoords3@@@Z
_TEXT	SEGMENT
_inV$ = 12
_inC$ = 16
___$ReturnUdt$ = 8
$T35092 = -12
??6@YA?AVVVec3@@ABV0@ABVVCoords3@@@Z PROC NEAR		; operator<<, COMDAT

; 421  : 	{

	sub	esp, 12					; 0000000cH

; 422  : 		return(((inV*inC.s) << inC.r) + inC.t);

	mov	eax, DWORD PTR _inC$[esp+8]
	mov	ecx, DWORD PTR _inV$[esp+8]
	fld	DWORD PTR [eax+48]
	fmul	DWORD PTR [ecx]
	fld	DWORD PTR [eax+52]
	fmul	DWORD PTR [ecx+4]
	fld	DWORD PTR [eax+56]
	fmul	DWORD PTR [ecx+8]
	fld	ST(0)
	fmul	DWORD PTR [eax+24]
	fld	ST(2)
	fmul	DWORD PTR [eax+12]
	faddp	ST(1), ST(0)
	fld	ST(3)
	fmul	DWORD PTR [eax]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR $T35092[esp+12]
	fld	ST(0)
	fmul	DWORD PTR [eax+28]
	fld	ST(3)
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	fld	ST(2)
	fmul	DWORD PTR [eax+16]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR $T35092[esp+16]
	fmul	DWORD PTR [eax+32]
	fxch	ST(2)
	fmul	DWORD PTR [eax+8]
	faddp	ST(2), ST(0)
	fld	ST(0)
	fmul	DWORD PTR [eax+20]
	faddp	ST(2), ST(0)
	fstp	ST(0)
	fadd	DWORD PTR [eax+44]
	fld	DWORD PTR $T35092[esp+16]
	fadd	DWORD PTR [eax+40]
	fld	DWORD PTR $T35092[esp+12]
	fadd	DWORD PTR [eax+36]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+8]
	fstp	DWORD PTR [eax]
	fstp	DWORD PTR [eax+4]
	fstp	DWORD PTR [eax+8]

; 423  : 	}

	add	esp, 12					; 0000000cH
	ret	0
??6@YA?AVVVec3@@ABV0@ABVVCoords3@@@Z ENDP		; operator<<
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??6@YA?AVVCoords3@@ABV0@0@Z
_TEXT	SEGMENT
_inC1$ = 12
_inC2$ = 16
___$ReturnUdt$ = 8
$T35131 = -12
$T35132 = -24
$T35188 = -60
$T35277 = -36
$T35278 = -48
$T35279 = -60
??6@YA?AVVCoords3@@ABV0@0@Z PROC NEAR			; operator<<, COMDAT

; 429  : 	{

	sub	esp, 60					; 0000003cH

; 430  : 		return(VCoords3(inC1.r << inC2.r, inC1.t << inC2, inC1.s * inC2.s));

	mov	eax, DWORD PTR _inC2$[esp+56]
	mov	ecx, DWORD PTR _inC1$[esp+56]
	fld	DWORD PTR [eax+48]
	fmul	DWORD PTR [ecx+48]
	fld	DWORD PTR [ecx+52]
	fmul	DWORD PTR [eax+52]
	fld	DWORD PTR [ecx+56]
	fmul	DWORD PTR [eax+56]
	fstp	DWORD PTR $T35131[esp+68]
	fld	DWORD PTR [ecx+36]
	fmul	DWORD PTR [eax+48]
	fld	DWORD PTR [eax+52]
	fmul	DWORD PTR [ecx+40]
	fld	DWORD PTR [eax+56]
	fmul	DWORD PTR [ecx+44]
	fld	ST(1)
	fmul	DWORD PTR [eax+12]
	fld	ST(3)
	fmul	DWORD PTR [eax]
	faddp	ST(1), ST(0)
	fld	ST(1)
	fmul	DWORD PTR [eax+24]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR $T35188[esp+60]
	fld	ST(0)
	fmul	DWORD PTR [eax+28]
	fld	ST(3)
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	fld	ST(2)
	fmul	DWORD PTR [eax+16]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR $T35188[esp+64]
	fmul	DWORD PTR [eax+32]
	fxch	ST(2)
	fmul	DWORD PTR [eax+8]
	faddp	ST(2), ST(0)
	fmul	DWORD PTR [eax+20]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR $T35188[esp+68]
	fld	DWORD PTR $T35188[esp+60]
	fadd	DWORD PTR [eax+36]
	fld	DWORD PTR $T35188[esp+64]
	fadd	DWORD PTR [eax+40]
	fld	DWORD PTR $T35188[esp+68]
	fadd	DWORD PTR [eax+44]
	fstp	DWORD PTR $T35132[esp+68]
	fld	DWORD PTR [ecx+24]
	fmul	DWORD PTR [eax]
	fld	DWORD PTR [eax+24]
	fmul	DWORD PTR [ecx+32]
	faddp	ST(1), ST(0)
	fld	DWORD PTR [eax+12]
	fmul	DWORD PTR [ecx+28]
	faddp	ST(1), ST(0)
	fld	DWORD PTR [ecx+32]
	fmul	DWORD PTR [eax+28]
	fld	DWORD PTR [ecx+28]
	fmul	DWORD PTR [eax+16]
	faddp	ST(1), ST(0)
	fld	DWORD PTR [eax+4]
	fmul	DWORD PTR [ecx+24]
	faddp	ST(1), ST(0)
	fld	DWORD PTR [ecx+32]
	fmul	DWORD PTR [eax+32]
	fld	DWORD PTR [ecx+28]
	fmul	DWORD PTR [eax+20]
	faddp	ST(1), ST(0)
	fld	DWORD PTR [eax+8]
	fmul	DWORD PTR [ecx+24]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR $T35277[esp+68]
	fld	DWORD PTR [eax+24]
	fmul	DWORD PTR [ecx+20]
	fld	DWORD PTR [eax+12]
	fmul	DWORD PTR [ecx+16]
	faddp	ST(1), ST(0)
	fld	DWORD PTR [ecx+12]
	fmul	DWORD PTR [eax]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR $T35278[esp+60]
	fld	DWORD PTR [eax+28]
	fmul	DWORD PTR [ecx+20]
	fld	DWORD PTR [eax+16]
	fmul	DWORD PTR [ecx+16]
	faddp	ST(1), ST(0)
	fld	DWORD PTR [eax+4]
	fmul	DWORD PTR [ecx+12]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR $T35278[esp+64]
	fld	DWORD PTR [eax+32]
	fmul	DWORD PTR [ecx+20]
	fld	DWORD PTR [eax+20]
	fmul	DWORD PTR [ecx+16]
	faddp	ST(1), ST(0)
	fld	DWORD PTR [eax+8]
	fmul	DWORD PTR [ecx+12]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR $T35278[esp+68]
	fld	DWORD PTR [ecx]
	fmul	DWORD PTR [eax]
	fld	DWORD PTR [eax+24]
	fmul	DWORD PTR [ecx+8]
	faddp	ST(1), ST(0)
	fld	DWORD PTR [eax+12]
	fmul	DWORD PTR [ecx+4]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR $T35279[esp+60]
	fld	DWORD PTR [eax+4]
	fmul	DWORD PTR [ecx]
	fld	DWORD PTR [eax+28]
	fmul	DWORD PTR [ecx+8]
	faddp	ST(1), ST(0)
	fld	DWORD PTR [eax+16]
	fmul	DWORD PTR [ecx+4]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR $T35279[esp+64]
	fld	DWORD PTR [eax+8]
	fmul	DWORD PTR [ecx]
	fld	DWORD PTR [eax+32]
	fmul	DWORD PTR [ecx+8]
	faddp	ST(1), ST(0)
	fld	DWORD PTR [eax+20]
	fmul	DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+56]
	xor	ecx, ecx
	faddp	ST(1), ST(0)
	mov	DWORD PTR [eax+12], ecx
	fstp	DWORD PTR $T35279[esp+68]
	mov	edx, 1065353216				; 3f800000H
	mov	DWORD PTR [eax+20], ecx
	mov	DWORD PTR [eax+16], edx
	mov	DWORD PTR [eax+24], ecx
	mov	DWORD PTR [eax+28], ecx
	mov	ecx, DWORD PTR $T35279[esp+60]
	mov	DWORD PTR [eax+32], edx
	mov	edx, DWORD PTR $T35279[esp+64]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR $T35279[esp+68]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR $T35278[esp+60]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR $T35278[esp+64]
	mov	DWORD PTR [eax+12], edx
	mov	edx, DWORD PTR $T35278[esp+68]
	fxch	ST(1)
	mov	DWORD PTR [eax+16], ecx
	mov	ecx, DWORD PTR $T35277[esp+68]
	mov	DWORD PTR [eax+20], edx
	mov	edx, DWORD PTR $T35132[esp+68]
	fstp	DWORD PTR [eax+24]
	mov	DWORD PTR [eax+32], ecx
	mov	ecx, DWORD PTR $T35131[esp+68]
	fstp	DWORD PTR [eax+28]
	fxch	ST(1)
	fstp	DWORD PTR [eax+36]
	mov	DWORD PTR [eax+44], edx
	fstp	DWORD PTR [eax+40]
	fxch	ST(1)
	fstp	DWORD PTR [eax+48]
	mov	DWORD PTR [eax+56], ecx
	fstp	DWORD PTR [eax+52]

; 431  : 	}

	add	esp, 60					; 0000003cH
	ret	0
??6@YA?AVVCoords3@@ABV0@0@Z ENDP			; operator<<
_TEXT	ENDS
PUBLIC	??0IMsgRouter@@QAE@XZ				; IMsgRouter::IMsgRouter
PUBLIC	??_7IMsgRouter@@6B@				; IMsgRouter::`vftable'
EXTRN	__purecall:NEAR
;	COMDAT ??_7IMsgRouter@@6B@
CONST	SEGMENT
??_7IMsgRouter@@6B@ DD FLAT:__purecall			; IMsgRouter::`vftable'
	DD	FLAT:__purecall
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ??0IMsgRouter@@QAE@XZ
_TEXT	SEGMENT
??0IMsgRouter@@QAE@XZ PROC NEAR				; IMsgRouter::IMsgRouter, COMDAT
; _this$ = ecx
	mov	eax, ecx
	mov	DWORD PTR [eax], OFFSET FLAT:??_7IMsgRouter@@6B@ ; IMsgRouter::`vftable'
	ret	0
??0IMsgRouter@@QAE@XZ ENDP				; IMsgRouter::IMsgRouter
_TEXT	ENDS
PUBLIC	??0IMsgRouter@@QAE@ABV0@@Z			; IMsgRouter::IMsgRouter
; Function compile flags: /Ogty
;	COMDAT ??0IMsgRouter@@QAE@ABV0@@Z
_TEXT	SEGMENT
??0IMsgRouter@@QAE@ABV0@@Z PROC NEAR			; IMsgRouter::IMsgRouter, COMDAT
; _this$ = ecx
	mov	eax, ecx
	mov	DWORD PTR [eax], OFFSET FLAT:??_7IMsgRouter@@6B@ ; IMsgRouter::`vftable'
	ret	4
??0IMsgRouter@@QAE@ABV0@@Z ENDP				; IMsgRouter::IMsgRouter
_TEXT	ENDS
PUBLIC	??4IMsgRouter@@QAEAAV0@ABV0@@Z			; IMsgRouter::operator=
; Function compile flags: /Ogty
;	COMDAT ??4IMsgRouter@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
??4IMsgRouter@@QAEAAV0@ABV0@@Z PROC NEAR		; IMsgRouter::operator=, COMDAT
; _this$ = ecx
	mov	eax, ecx
	ret	4
??4IMsgRouter@@QAEAAV0@ABV0@@Z ENDP			; IMsgRouter::operator=
_TEXT	ENDS
PUBLIC	??0IMsgTarget@@QAE@XZ				; IMsgTarget::IMsgTarget
PUBLIC	??_7IMsgTarget@@6B@				; IMsgTarget::`vftable'
;	COMDAT ??_7IMsgTarget@@6B@
CONST	SEGMENT
??_7IMsgTarget@@6B@ DD FLAT:__purecall			; IMsgTarget::`vftable'
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ??0IMsgTarget@@QAE@XZ
_TEXT	SEGMENT
??0IMsgTarget@@QAE@XZ PROC NEAR				; IMsgTarget::IMsgTarget, COMDAT
; _this$ = ecx
	mov	eax, ecx
	mov	DWORD PTR [eax], OFFSET FLAT:??_7IMsgTarget@@6B@ ; IMsgTarget::`vftable'
	ret	0
??0IMsgTarget@@QAE@XZ ENDP				; IMsgTarget::IMsgTarget
_TEXT	ENDS
PUBLIC	??0IMsgTarget@@QAE@ABV0@@Z			; IMsgTarget::IMsgTarget
; Function compile flags: /Ogty
;	COMDAT ??0IMsgTarget@@QAE@ABV0@@Z
_TEXT	SEGMENT
??0IMsgTarget@@QAE@ABV0@@Z PROC NEAR			; IMsgTarget::IMsgTarget, COMDAT
; _this$ = ecx
	mov	eax, ecx
	mov	DWORD PTR [eax], OFFSET FLAT:??_7IMsgTarget@@6B@ ; IMsgTarget::`vftable'
	ret	4
??0IMsgTarget@@QAE@ABV0@@Z ENDP				; IMsgTarget::IMsgTarget
_TEXT	ENDS
PUBLIC	??4IMsgTarget@@QAEAAV0@ABV0@@Z			; IMsgTarget::operator=
; Function compile flags: /Ogty
;	COMDAT ??4IMsgTarget@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
??4IMsgTarget@@QAEAAV0@ABV0@@Z PROC NEAR		; IMsgTarget::operator=, COMDAT
; _this$ = ecx
	mov	eax, ecx
	ret	4
??4IMsgTarget@@QAEAAV0@ABV0@@Z ENDP			; IMsgTarget::operator=
_TEXT	ENDS
PUBLIC	?GetFirstInterface@CObjInterface@@SAPAV1@XZ	; CObjInterface::GetFirstInterface
EXTRN	?sInterfaceList@CObjInterface@@0PAV1@A:DWORD	; CObjInterface::sInterfaceList
; Function compile flags: /Ogty
; File C:\duke4\Cannibal\ObjMain.h
;	COMDAT ?GetFirstInterface@CObjInterface@@SAPAV1@XZ
_TEXT	SEGMENT
?GetFirstInterface@CObjInterface@@SAPAV1@XZ PROC NEAR	; CObjInterface::GetFirstInterface, COMDAT

; 128  : 	static CObjInterface* GetFirstInterface() { return(sInterfaceList); }

	mov	eax, DWORD PTR ?sInterfaceList@CObjInterface@@0PAV1@A ; CObjInterface::sInterfaceList
	ret	0
?GetFirstInterface@CObjInterface@@SAPAV1@XZ ENDP	; CObjInterface::GetFirstInterface
_TEXT	ENDS
PUBLIC	?GetNextInterface@CObjInterface@@QAEPAV1@XZ	; CObjInterface::GetNextInterface
; Function compile flags: /Ogty
;	COMDAT ?GetNextInterface@CObjInterface@@QAEPAV1@XZ
_TEXT	SEGMENT
?GetNextInterface@CObjInterface@@QAEPAV1@XZ PROC NEAR	; CObjInterface::GetNextInterface, COMDAT
; _this$ = ecx

; 129  : 	CObjInterface* GetNextInterface() { return(mNext); }

	mov	eax, DWORD PTR [ecx+4]
	ret	0
?GetNextInterface@CObjInterface@@QAEPAV1@XZ ENDP	; CObjInterface::GetNextInterface
_TEXT	ENDS
PUBLIC	??0CObjInterface@@QAE@ABV0@@Z			; CObjInterface::CObjInterface
; Function compile flags: /Ogty
;	COMDAT ??0CObjInterface@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8
??0CObjInterface@@QAE@ABV0@@Z PROC NEAR			; CObjInterface::CObjInterface, COMDAT
; _this$ = ecx
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR ___that$[esp+4]
	mov	ebx, ecx
	push	esi
	push	edi
	mov	DWORD PTR [ebx], 0
	mov	esi, DWORD PTR [ebp]
	test	esi, esi
	je	SHORT $L35434
	cmp	BYTE PTR [esi], 0
	jne	SHORT $L35434
	xor	esi, esi
$L35434:
	test	esi, esi
	mov	DWORD PTR [ebx], 0
	je	SHORT $L35437
	mov	edi, esi
	or	ecx, -1
	xor	eax, eax
	repne scasb
	not	ecx
	dec	ecx
	mov	edi, ecx
	inc	edi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	edi
	mov	ecx, eax
	call	DWORD PTR [edx]
	test	eax, eax
	mov	DWORD PTR [ebx], eax
	je	SHORT $L35437
	mov	ecx, eax
$L35439:
	mov	al, BYTE PTR [esi]
	inc	esi
	mov	BYTE PTR [ecx], al
	inc	ecx
	test	al, al
	jne	SHORT $L35439
	add	DWORD PTR ?sMemTotal@CCorString@@0KA, edi ; CCorString::sMemTotal
$L35437:
	mov	eax, DWORD PTR [ebp+4]
	pop	edi
	mov	DWORD PTR [ebx+4], eax
	pop	esi
	mov	eax, ebx
	pop	ebp
	pop	ebx
	ret	4
??0CObjInterface@@QAE@ABV0@@Z ENDP			; CObjInterface::CObjInterface
_TEXT	ENDS
PUBLIC	??4CObjInterface@@QAEAAV0@ABV0@@Z		; CObjInterface::operator=
; Function compile flags: /Ogty
;	COMDAT ??4CObjInterface@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8
??4CObjInterface@@QAEAAV0@ABV0@@Z PROC NEAR		; CObjInterface::operator=, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	ebx
	push	ebp
	push	esi
	mov	ebx, DWORD PTR [eax]
	push	edi
	test	ebx, ebx
	mov	ebp, ecx
	je	SHORT $L35459
	cmp	BYTE PTR [ebx], 0
	jne	SHORT $L35459
	xor	ebx, ebx
$L35459:
	mov	edi, DWORD PTR [ebp]
	test	edi, edi
	je	SHORT $L35460
	or	ecx, -1
	xor	eax, eax
	repne scasb
	mov	edi, DWORD PTR ?sMemTotal@CCorString@@0KA ; CCorString::sMemTotal
	or	edx, -1
	not	ecx
	dec	ecx
	sub	edx, ecx
	add	edi, edx
	mov	DWORD PTR ?sMemTotal@CCorString@@0KA, edi ; CCorString::sMemTotal
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [ebp]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L35460:
	test	ebx, ebx
	mov	DWORD PTR [ebp], 0
	je	SHORT $L35463
	mov	edi, ebx
	or	ecx, -1
	xor	eax, eax
	repne scasb
	not	ecx
	dec	ecx
	mov	esi, ecx
	inc	esi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	ecx, eax
	call	DWORD PTR [edx]
	test	eax, eax
	mov	DWORD PTR [ebp], eax
	je	SHORT $L35463
$L35465:
	mov	cl, BYTE PTR [ebx]
	inc	ebx
	mov	BYTE PTR [eax], cl
	inc	eax
	test	cl, cl
	jne	SHORT $L35465
	add	DWORD PTR ?sMemTotal@CCorString@@0KA, esi ; CCorString::sMemTotal
$L35463:
	mov	eax, DWORD PTR ___that$[esp+12]
	pop	edi
	pop	esi
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, ebp
	mov	DWORD PTR [ebp+4], ecx
	pop	ebp
	pop	ebx
	ret	4
??4CObjInterface@@QAEAAV0@ABV0@@Z ENDP			; CObjInterface::operator=
_TEXT	ENDS
PUBLIC	?GetFirstClass@CObjClass@@SAPAV1@XZ		; CObjClass::GetFirstClass
EXTRN	?sClassList@CObjClass@@0PAV1@A:DWORD		; CObjClass::sClassList
; Function compile flags: /Ogty
;	COMDAT ?GetFirstClass@CObjClass@@SAPAV1@XZ
_TEXT	SEGMENT
?GetFirstClass@CObjClass@@SAPAV1@XZ PROC NEAR		; CObjClass::GetFirstClass, COMDAT

; 173  :     static CObjClass* GetFirstClass() { return(sClassList); }

	mov	eax, DWORD PTR ?sClassList@CObjClass@@0PAV1@A ; CObjClass::sClassList
	ret	0
?GetFirstClass@CObjClass@@SAPAV1@XZ ENDP		; CObjClass::GetFirstClass
_TEXT	ENDS
PUBLIC	?GetNextClass@CObjClass@@QAEPAV1@XZ		; CObjClass::GetNextClass
; Function compile flags: /Ogty
;	COMDAT ?GetNextClass@CObjClass@@QAEPAV1@XZ
_TEXT	SEGMENT
?GetNextClass@CObjClass@@QAEPAV1@XZ PROC NEAR		; CObjClass::GetNextClass, COMDAT
; _this$ = ecx

; 174  :     CObjClass* GetNextClass() { return(mNext); }

	mov	eax, DWORD PTR [ecx+20]
	ret	0
?GetNextClass@CObjClass@@QAEPAV1@XZ ENDP		; CObjClass::GetNextClass
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??0CObjClass@@QAE@XZ
_TEXT	SEGMENT
??0CObjClass@@QAE@XZ PROC NEAR				; CObjClass::CObjClass, COMDAT
; _this$ = ecx

; 176  : 	CObjClass() {}

	mov	eax, ecx
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
	ret	0
??0CObjClass@@QAE@XZ ENDP				; CObjClass::CObjClass
_TEXT	ENDS
PUBLIC	??0CObjClass@@QAE@ABV0@@Z			; CObjClass::CObjClass
;	COMDAT xdata$x
xdata$x	SEGMENT
$T35543	DD	0ffffffffH
	DD	FLAT:$L35489
$T35537	DD	019930520H
	DD	01H
	DD	FLAT:$T35543
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ??0CObjClass@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8
_this$ = -16
__$EHRec$ = -12
??0CObjClass@@QAE@ABV0@@Z PROC NEAR			; CObjClass::CObjClass, COMDAT
; _this$ = ecx
	push	-1
	push	$L35542
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	mov	eax, DWORD PTR ___that$[esp+12]
	push	ebp
	push	esi
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+28], esi
	mov	DWORD PTR [esi], 0
	mov	ebp, DWORD PTR [eax]
	test	ebp, ebp
	je	SHORT $L35507
	cmp	BYTE PTR [ebp], 0
	jne	SHORT $L35507
	xor	ebp, ebp
$L35507:
	test	ebp, ebp
	mov	DWORD PTR [esi], 0
	je	SHORT $L35510
	mov	edi, ebp
	or	ecx, -1
	xor	eax, eax
	repne scasb
	not	ecx
	dec	ecx
	mov	edi, ecx
	inc	edi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	edi
	mov	ecx, eax
	call	DWORD PTR [edx]
	test	eax, eax
	mov	DWORD PTR [esi], eax
	je	SHORT $L35540
$L35512:
	mov	cl, BYTE PTR [ebp]
	inc	ebp
	mov	BYTE PTR [eax], cl
	inc	eax
	test	cl, cl
	jne	SHORT $L35512
	add	DWORD PTR ?sMemTotal@CCorString@@0KA, edi ; CCorString::sMemTotal
$L35540:
	mov	eax, DWORD PTR ___that$[esp+24]
$L35510:
	mov	DWORD PTR [esi+4], 0
	mov	ebp, DWORD PTR [eax+4]
	test	ebp, ebp
	mov	DWORD PTR __$EHRec$[esp+36], 0
	je	SHORT $L35529
	cmp	BYTE PTR [ebp], 0
	jne	SHORT $L35529
	xor	ebp, ebp
$L35529:
	test	ebp, ebp
	mov	DWORD PTR [esi+4], 0
	je	SHORT $L35532
	mov	edi, ebp
	or	ecx, -1
	xor	eax, eax
	repne scasb
	not	ecx
	dec	ecx
	mov	edi, ecx
	inc	edi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	edi
	mov	ecx, eax
	call	DWORD PTR [edx]
	test	eax, eax
	mov	DWORD PTR [esi+4], eax
	je	SHORT $L35541
$L35534:
	mov	cl, BYTE PTR [ebp]
	inc	ebp
	mov	BYTE PTR [eax], cl
	inc	eax
	test	cl, cl
	jne	SHORT $L35534
	add	DWORD PTR ?sMemTotal@CCorString@@0KA, edi ; CCorString::sMemTotal
$L35541:
	mov	eax, DWORD PTR ___that$[esp+24]
$L35532:
	mov	ecx, DWORD PTR [eax+8]
	pop	edi
	mov	DWORD PTR [esi+8], ecx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [esi+12], edx
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [esi+16], ecx
	mov	edx, DWORD PTR [eax+20]
	mov	DWORD PTR [esi+20], edx
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR [esi+24], ecx
	mov	edx, DWORD PTR [eax+28]
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR [esi+28], edx
	mov	eax, DWORD PTR [eax+32]
	mov	DWORD PTR [esi+32], eax
	mov	eax, esi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L35489:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CCorString@@QAE@XZ			; CCorString::~CCorString
$L35542:
	mov	eax, OFFSET FLAT:$T35537
	jmp	___CxxFrameHandler
text$x	ENDS
??0CObjClass@@QAE@ABV0@@Z ENDP				; CObjClass::CObjClass
PUBLIC	??4CObjClass@@QAEAAV0@ABV0@@Z			; CObjClass::operator=
; Function compile flags: /Ogty
;	COMDAT ??4CObjClass@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8
??4CObjClass@@QAEAAV0@ABV0@@Z PROC NEAR			; CObjClass::operator=, COMDAT
; _this$ = ecx
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR ___that$[esp+4]
	push	esi
	push	edi
	mov	esi, ecx
	mov	ebx, DWORD PTR [ebp]
	test	ebx, ebx
	je	SHORT $L35564
	cmp	BYTE PTR [ebx], 0
	jne	SHORT $L35564
	xor	ebx, ebx
$L35564:
	mov	edi, DWORD PTR [esi]
	test	edi, edi
	je	SHORT $L35565
	or	ecx, -1
	xor	eax, eax
	repne scasb
	not	ecx
	dec	ecx
	or	eax, -1
	sub	eax, ecx
	mov	ecx, DWORD PTR ?sMemTotal@CCorString@@0KA ; CCorString::sMemTotal
	add	ecx, eax
	mov	DWORD PTR ?sMemTotal@CCorString@@0KA, ecx ; CCorString::sMemTotal
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L35565:
	test	ebx, ebx
	mov	DWORD PTR [esi], 0
	je	SHORT $L35568
	mov	edi, ebx
	or	ecx, -1
	xor	eax, eax
	repne scasb
	not	ecx
	dec	ecx
	mov	edi, ecx
	inc	edi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	edi
	mov	ecx, eax
	call	DWORD PTR [edx]
	test	eax, eax
	mov	DWORD PTR [esi], eax
	je	SHORT $L35568
$L35570:
	mov	cl, BYTE PTR [ebx]
	inc	ebx
	mov	BYTE PTR [eax], cl
	inc	eax
	test	cl, cl
	jne	SHORT $L35570
	add	DWORD PTR ?sMemTotal@CCorString@@0KA, edi ; CCorString::sMemTotal
$L35568:
	mov	ebx, DWORD PTR [ebp+4]
	test	ebx, ebx
	je	SHORT $L35587
	cmp	BYTE PTR [ebx], 0
	jne	SHORT $L35587
	xor	ebx, ebx
$L35587:
	mov	edi, DWORD PTR [esi+4]
	test	edi, edi
	je	SHORT $L35588
	or	ecx, -1
	xor	eax, eax
	repne scasb
	not	ecx
	dec	ecx
	or	eax, -1
	sub	eax, ecx
	mov	ecx, DWORD PTR ?sMemTotal@CCorString@@0KA ; CCorString::sMemTotal
	add	ecx, eax
	mov	DWORD PTR ?sMemTotal@CCorString@@0KA, ecx ; CCorString::sMemTotal
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L35588:
	test	ebx, ebx
	mov	DWORD PTR [esi+4], 0
	je	SHORT $L35591
	mov	edi, ebx
	or	ecx, -1
	xor	eax, eax
	repne scasb
	not	ecx
	dec	ecx
	mov	edi, ecx
	inc	edi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	edi
	mov	ecx, eax
	call	DWORD PTR [edx]
	test	eax, eax
	mov	DWORD PTR [esi+4], eax
	je	SHORT $L35591
	mov	edx, ebx
$L35585:
	mov	cl, BYTE PTR [edx]
	inc	edx
	mov	BYTE PTR [eax], cl
	inc	eax
	test	cl, cl
	jne	SHORT $L35585
	add	DWORD PTR ?sMemTotal@CCorString@@0KA, edi ; CCorString::sMemTotal
$L35591:
	mov	eax, DWORD PTR [ebp+8]
	pop	edi
	mov	DWORD PTR [esi+8], eax
	mov	ecx, DWORD PTR [ebp+12]
	mov	DWORD PTR [esi+12], ecx
	mov	edx, DWORD PTR [ebp+16]
	mov	DWORD PTR [esi+16], edx
	mov	eax, DWORD PTR [ebp+20]
	mov	DWORD PTR [esi+20], eax
	mov	ecx, DWORD PTR [ebp+24]
	mov	DWORD PTR [esi+24], ecx
	mov	edx, DWORD PTR [ebp+28]
	mov	DWORD PTR [esi+28], edx
	mov	eax, DWORD PTR [ebp+32]
	mov	DWORD PTR [esi+32], eax
	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx
	ret	4
??4CObjClass@@QAEAAV0@ABV0@@Z ENDP			; CObjClass::operator=
_TEXT	ENDS
PUBLIC	?GetChild@CObjLink@@QAEPAVOObject@@XZ		; CObjLink::GetChild
; Function compile flags: /Ogty
;	COMDAT ?GetChild@CObjLink@@QAEPAVOObject@@XZ
_TEXT	SEGMENT
?GetChild@CObjLink@@QAEPAVOObject@@XZ PROC NEAR		; CObjLink::GetChild, COMDAT
; _this$ = ecx

; 218  : 	inline OObject* GetChild() { return(mChild); }

	mov	eax, DWORD PTR [ecx]
	ret	0
?GetChild@CObjLink@@QAEPAVOObject@@XZ ENDP		; CObjLink::GetChild
_TEXT	ENDS
PUBLIC	?SetChild@CObjLink@@QAEXPAVOObject@@@Z		; CObjLink::SetChild
; Function compile flags: /Ogty
;	COMDAT ?SetChild@CObjLink@@QAEXPAVOObject@@@Z
_TEXT	SEGMENT
_inObj$ = 8
?SetChild@CObjLink@@QAEXPAVOObject@@@Z PROC NEAR	; CObjLink::SetChild, COMDAT
; _this$ = ecx

; 219  : 	inline void SetChild(OObject* inObj) { mChild = inObj; }

	mov	eax, DWORD PTR _inObj$[esp-4]
	mov	DWORD PTR [ecx], eax
	ret	4
?SetChild@CObjLink@@QAEXPAVOObject@@@Z ENDP		; CObjLink::SetChild
_TEXT	ENDS
PUBLIC	?GetParent@CObjLink@@QAEPAVOObject@@XZ		; CObjLink::GetParent
; Function compile flags: /Ogty
;	COMDAT ?GetParent@CObjLink@@QAEPAVOObject@@XZ
_TEXT	SEGMENT
?GetParent@CObjLink@@QAEPAVOObject@@XZ PROC NEAR	; CObjLink::GetParent, COMDAT
; _this$ = ecx

; 220  : 	inline OObject* GetParent() { return(mParent); }

	mov	eax, DWORD PTR [ecx+4]
	ret	0
?GetParent@CObjLink@@QAEPAVOObject@@XZ ENDP		; CObjLink::GetParent
_TEXT	ENDS
PUBLIC	?SetParent@CObjLink@@QAEXPAVOObject@@@Z		; CObjLink::SetParent
; Function compile flags: /Ogty
;	COMDAT ?SetParent@CObjLink@@QAEXPAVOObject@@@Z
_TEXT	SEGMENT
_inObj$ = 8
?SetParent@CObjLink@@QAEXPAVOObject@@@Z PROC NEAR	; CObjLink::SetParent, COMDAT
; _this$ = ecx

; 221  : 	inline void SetParent(OObject* inObj) { mParent = inObj; }

	mov	eax, DWORD PTR _inObj$[esp-4]
	mov	DWORD PTR [ecx+4], eax
	ret	4
?SetParent@CObjLink@@QAEXPAVOObject@@@Z ENDP		; CObjLink::SetParent
_TEXT	ENDS
PUBLIC	?GetNext@CObjLink@@QAEPAV1@XZ			; CObjLink::GetNext
; Function compile flags: /Ogty
;	COMDAT ?GetNext@CObjLink@@QAEPAV1@XZ
_TEXT	SEGMENT
?GetNext@CObjLink@@QAEPAV1@XZ PROC NEAR			; CObjLink::GetNext, COMDAT
; _this$ = ecx

; 222  :     inline CObjLink* GetNext() { return(mNext); }

	mov	eax, DWORD PTR [ecx+8]
	ret	0
?GetNext@CObjLink@@QAEPAV1@XZ ENDP			; CObjLink::GetNext
_TEXT	ENDS
PUBLIC	?SetNext@CObjLink@@QAEXPAV1@@Z			; CObjLink::SetNext
; Function compile flags: /Ogty
;	COMDAT ?SetNext@CObjLink@@QAEXPAV1@@Z
_TEXT	SEGMENT
_inLink$ = 8
?SetNext@CObjLink@@QAEXPAV1@@Z PROC NEAR		; CObjLink::SetNext, COMDAT
; _this$ = ecx

; 223  :     inline void SetNext(CObjLink* inLink) { mNext = inLink; }

	mov	eax, DWORD PTR _inLink$[esp-4]
	mov	DWORD PTR [ecx+8], eax
	ret	4
?SetNext@CObjLink@@QAEXPAV1@@Z ENDP			; CObjLink::SetNext
_TEXT	ENDS
PUBLIC	?GetPrev@CObjLink@@QAEPAV1@XZ			; CObjLink::GetPrev
; Function compile flags: /Ogty
;	COMDAT ?GetPrev@CObjLink@@QAEPAV1@XZ
_TEXT	SEGMENT
?GetPrev@CObjLink@@QAEPAV1@XZ PROC NEAR			; CObjLink::GetPrev, COMDAT
; _this$ = ecx

; 224  :     inline CObjLink* GetPrev() { return(mPrev); }

	mov	eax, DWORD PTR [ecx+12]
	ret	0
?GetPrev@CObjLink@@QAEPAV1@XZ ENDP			; CObjLink::GetPrev
_TEXT	ENDS
PUBLIC	?SetPrev@CObjLink@@QAEXPAV1@@Z			; CObjLink::SetPrev
; Function compile flags: /Ogty
;	COMDAT ?SetPrev@CObjLink@@QAEXPAV1@@Z
_TEXT	SEGMENT
_inLink$ = 8
?SetPrev@CObjLink@@QAEXPAV1@@Z PROC NEAR		; CObjLink::SetPrev, COMDAT
; _this$ = ecx

; 225  :     inline void SetPrev(CObjLink* inLink) { mPrev = inLink; }

	mov	eax, DWORD PTR _inLink$[esp-4]
	mov	DWORD PTR [ecx+12], eax
	ret	4
?SetPrev@CObjLink@@QAEXPAV1@@Z ENDP			; CObjLink::SetPrev
_TEXT	ENDS
PUBLIC	?PreConstruct@CObjLink@@QAEXXZ			; CObjLink::PreConstruct
; Function compile flags: /Ogty
;	COMDAT ?PreConstruct@CObjLink@@QAEXXZ
_TEXT	SEGMENT
?PreConstruct@CObjLink@@QAEXXZ PROC NEAR		; CObjLink::PreConstruct, COMDAT
; _this$ = ecx

; 231  : 	void PreConstruct() { mChild = mParent = NULL; mNext = mPrev = this; }

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx], 0
	mov	DWORD PTR [ecx+12], ecx
	mov	DWORD PTR [ecx+8], ecx
	ret	0
?PreConstruct@CObjLink@@QAEXXZ ENDP			; CObjLink::PreConstruct
_TEXT	ENDS
PUBLIC	??0CObjLink@@QAE@XZ				; CObjLink::CObjLink
; Function compile flags: /Ogty
;	COMDAT ??0CObjLink@@QAE@XZ
_TEXT	SEGMENT
??0CObjLink@@QAE@XZ PROC NEAR				; CObjLink::CObjLink, COMDAT
; _this$ = ecx

; 232  :     CObjLink() {}

	mov	eax, ecx
	ret	0
??0CObjLink@@QAE@XZ ENDP				; CObjLink::CObjLink
_TEXT	ENDS
PUBLIC	??1CObjLink@@QAE@XZ				; CObjLink::~CObjLink
; Function compile flags: /Ogty
;	COMDAT ??1CObjLink@@QAE@XZ
_TEXT	SEGMENT
??1CObjLink@@QAE@XZ PROC NEAR				; CObjLink::~CObjLink, COMDAT
; _this$ = ecx

; 233  :     ~CObjLink() { Unlink(); }

	mov	eax, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR [ecx+12]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	DWORD PTR [ecx+12], ecx
	mov	DWORD PTR [ecx+8], ecx
	ret	0
??1CObjLink@@QAE@XZ ENDP				; CObjLink::~CObjLink
_TEXT	ENDS
PUBLIC	??4CObjLink@@QAEAAV0@ABV0@@Z			; CObjLink::operator=
; Function compile flags: /Ogty
;	COMDAT ??4CObjLink@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8
??4CObjLink@@QAEAAV0@ABV0@@Z PROC NEAR			; CObjLink::operator=, COMDAT
; _this$ = ecx
	mov	eax, ecx
	mov	ecx, DWORD PTR ___that$[esp-4]
	push	esi
	mov	edx, eax
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [edx], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], esi
	pop	esi
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], ecx
	ret	4
??4CObjLink@@QAEAAV0@ABV0@@Z ENDP			; CObjLink::operator=
_TEXT	ENDS
PUBLIC	??2OObject@@CAPAXIPAV0@PAVCObjClass@@@Z		; OObject::operator new
EXTRN	?sObjCount@OObject@@1KA:DWORD			; OObject::sObjCount
EXTRN	?PreConstruct@OObject@@QAEXPAV1@@Z:NEAR		; OObject::PreConstruct
; Function compile flags: /Ogty
;	COMDAT ??2OObject@@CAPAXIPAV0@PAVCObjClass@@@Z
_TEXT	SEGMENT
_inParent$ = 12
_inSetClass$ = 16
??2OObject@@CAPAXIPAV0@PAVCObjClass@@@Z PROC NEAR	; OObject::operator new, COMDAT

; 246  : 	OBJ_BASE_CLASS_DEFINE(OObject);

	push	esi
	push	edi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	56					; 00000038H
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	ecx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	mov	esi, eax
	inc	ecx
	xor	eax, eax
	mov	DWORD PTR ?sObjCount@OObject@@1KA, ecx	; OObject::sObjCount
	mov	ecx, 14					; 0000000eH
	mov	edi, esi
	rep stosd
	mov	eax, DWORD PTR [esi+40]
	mov	DWORD PTR [esi+4], 305419896		; 12345678H
	test	eax, eax
	jne	SHORT $L35647
	mov	eax, DWORD PTR _inSetClass$[esp+4]
	mov	DWORD PTR [esi+40], eax
$L35647:
	mov	ecx, DWORD PTR _inParent$[esp+4]
	push	ecx
	mov	ecx, esi
	call	?PreConstruct@OObject@@QAEXPAV1@@Z	; OObject::PreConstruct
	mov	eax, esi
	pop	edi
	pop	esi
	ret	0
??2OObject@@CAPAXIPAV0@PAVCObjClass@@@Z ENDP		; OObject::operator new
_TEXT	ENDS
PUBLIC	??3OObject@@CAXPAX@Z				; OObject::operator delete
; Function compile flags: /Ogty
;	COMDAT ??3OObject@@CAXPAX@Z
_TEXT	SEGMENT
_ptr$ = 8
??3OObject@@CAXPAX@Z PROC NEAR				; OObject::operator delete, COMDAT

; 246  : 	OBJ_BASE_CLASS_DEFINE(OObject);

	push	esi
	mov	esi, DWORD PTR _ptr$[esp]
	mov	DWORD PTR [esi+4], 0
	mov	edx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	dec	edx
	mov	DWORD PTR ?sObjCount@OObject@@1KA, edx	; OObject::sObjCount
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	ecx, eax
	call	DWORD PTR [edx+8]
	pop	esi
	ret	0
??3OObject@@CAXPAX@Z ENDP				; OObject::operator delete
_TEXT	ENDS
PUBLIC	??3OObject@@CAXPAXPAV0@PAVCObjClass@@@Z		; OObject::operator delete
; Function compile flags: /Ogty
;	COMDAT ??3OObject@@CAXPAXPAV0@PAVCObjClass@@@Z
_TEXT	SEGMENT
_ptr$ = 8
??3OObject@@CAXPAXPAV0@PAVCObjClass@@@Z PROC NEAR	; OObject::operator delete, COMDAT

; 246  : 	OBJ_BASE_CLASS_DEFINE(OObject);

	push	esi
	mov	esi, DWORD PTR _ptr$[esp]
	mov	DWORD PTR [esi+4], 0
	mov	edx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	dec	edx
	mov	DWORD PTR ?sObjCount@OObject@@1KA, edx	; OObject::sObjCount
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	ecx, eax
	call	DWORD PTR [edx+8]
	pop	esi
	ret	0
??3OObject@@CAXPAXPAV0@PAVCObjClass@@@Z ENDP		; OObject::operator delete
_TEXT	ENDS
PUBLIC	?GetStaticClass@OObject@@SAPAVCObjClass@@XZ	; OObject::GetStaticClass
EXTRN	?staticObjClass@OObject@@0PAVCObjClass@@A:DWORD	; OObject::staticObjClass
; Function compile flags: /Ogty
;	COMDAT ?GetStaticClass@OObject@@SAPAVCObjClass@@XZ
_TEXT	SEGMENT
?GetStaticClass@OObject@@SAPAVCObjClass@@XZ PROC NEAR	; OObject::GetStaticClass, COMDAT

; 246  : 	OBJ_BASE_CLASS_DEFINE(OObject);

	mov	eax, DWORD PTR ?staticObjClass@OObject@@0PAVCObjClass@@A ; OObject::staticObjClass
	ret	0
?GetStaticClass@OObject@@SAPAVCObjClass@@XZ ENDP	; OObject::GetStaticClass
_TEXT	ENDS
PUBLIC	?New@OObject@@SAPAV1@PAV1@PAVCObjClass@@@Z	; OObject::New
EXTRN	??0OObject@@QAE@XZ:NEAR				; OObject::OObject
;	COMDAT xdata$x
xdata$x	SEGMENT
$T35702	DD	0ffffffffH
	DD	FLAT:$L35675
$T35700	DD	019930520H
	DD	01H
	DD	FLAT:$T35702
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ?New@OObject@@SAPAV1@PAV1@PAVCObjClass@@@Z
_TEXT	SEGMENT
$T35672 = -16
__$EHRec$ = -12
_inParent$ = 8
_inSetClass$ = 12
?New@OObject@@SAPAV1@PAV1@PAVCObjClass@@@Z PROC NEAR	; OObject::New, COMDAT

; 246  : 	OBJ_BASE_CLASS_DEFINE(OObject);

	push	-1
	push	$L35701
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	push	ebx
	mov	ebx, DWORD PTR _inSetClass$[esp+16]
	test	ebx, ebx
	push	esi
	jne	SHORT $L6871
	mov	ebx, DWORD PTR ?staticObjClass@OObject@@0PAVCObjClass@@A ; OObject::staticObjClass
	mov	DWORD PTR _inSetClass$[esp+20], ebx
$L6871:
	push	edi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	56					; 00000038H
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	ecx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	mov	esi, eax
	inc	ecx
	xor	eax, eax
	mov	DWORD PTR ?sObjCount@OObject@@1KA, ecx	; OObject::sObjCount
	mov	ecx, 14					; 0000000eH
	mov	edi, esi
	rep stosd
	mov	eax, DWORD PTR [esi+40]
	mov	DWORD PTR [esi+4], 305419896		; 12345678H
	test	eax, eax
	pop	edi
	jne	SHORT $L35695
	mov	DWORD PTR [esi+40], ebx
$L35695:
	mov	eax, DWORD PTR _inParent$[esp+20]
	mov	ecx, esi
	push	eax
	call	?PreConstruct@OObject@@QAEXPAV1@@Z	; OObject::PreConstruct
	mov	DWORD PTR $T35672[esp+24], esi
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+32], 0
	call	??0OObject@@QAE@XZ			; OObject::OObject
	mov	esi, eax
	mov	DWORD PTR __$EHRec$[esp+32], -1
	mov	ecx, esi
	mov	edx, DWORD PTR [esi]
	call	DWORD PTR [edx+24]
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	eax, esi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L35675:
	mov	eax, DWORD PTR _inSetClass$[ebp-4]
	push	eax
	mov	ecx, DWORD PTR _inParent$[ebp-4]
	push	ecx
	mov	edx, DWORD PTR $T35672[ebp]
	push	edx
	call	??3OObject@@CAXPAXPAV0@PAVCObjClass@@@Z	; OObject::operator delete
	add	esp, 12					; 0000000cH
	ret	0
$L35701:
	mov	eax, OFFSET FLAT:$T35700
	jmp	___CxxFrameHandler
text$x	ENDS
?New@OObject@@SAPAV1@PAV1@PAVCObjClass@@@Z ENDP		; OObject::New
PUBLIC	?GetClass@OObject@@UAEPAVCObjClass@@XZ		; OObject::GetClass
; Function compile flags: /Ogty
;	COMDAT ?GetClass@OObject@@UAEPAVCObjClass@@XZ
_TEXT	SEGMENT
?GetClass@OObject@@UAEPAVCObjClass@@XZ PROC NEAR	; OObject::GetClass, COMDAT
; _this$ = ecx

; 246  : 	OBJ_BASE_CLASS_DEFINE(OObject);

	mov	eax, DWORD PTR [ecx+40]
	ret	0
?GetClass@OObject@@UAEPAVCObjClass@@XZ ENDP		; OObject::GetClass
_TEXT	ENDS
PUBLIC	?SetClass@OObject@@QAEXPAVCObjClass@@@Z		; OObject::SetClass
; Function compile flags: /Ogty
;	COMDAT ?SetClass@OObject@@QAEXPAVCObjClass@@@Z
_TEXT	SEGMENT
_inClass$ = 8
?SetClass@OObject@@QAEXPAVCObjClass@@@Z PROC NEAR	; OObject::SetClass, COMDAT
; _this$ = ecx

; 250  : 		if (mClass)

	mov	eax, DWORD PTR [ecx+40]
	test	eax, eax
	jne	SHORT $L6882

; 251  : 			return; // can only be set once, at initialization
; 252  : 		mClass = inClass;

	mov	eax, DWORD PTR _inClass$[esp-4]
	mov	DWORD PTR [ecx+40], eax
$L6882:

; 253  : 	}

	ret	4
?SetClass@OObject@@QAEXPAVCObjClass@@@Z ENDP		; OObject::SetClass
_TEXT	ENDS
PUBLIC	?SetValid@OObject@@QAEX_N@Z			; OObject::SetValid
; Function compile flags: /Ogty
;	COMDAT ?SetValid@OObject@@QAEX_N@Z
_TEXT	SEGMENT
_inIsValid$ = 8
?SetValid@OObject@@QAEX_N@Z PROC NEAR			; OObject::SetValid, COMDAT
; _this$ = ecx

; 257  : 		if (inIsValid) mValidityStamp = OBJ_VALIDITY_STAMP;

	mov	al, BYTE PTR _inIsValid$[esp-4]
	test	al, al
	je	SHORT $L6886
	mov	DWORD PTR [ecx+4], 305419896		; 12345678H

; 259  : 	}

	ret	4
$L6886:

; 258  : 		else mValidityStamp = 0;

	mov	DWORD PTR [ecx+4], 0

; 259  : 	}

	ret	4
?SetValid@OObject@@QAEX_N@Z ENDP			; OObject::SetValid
_TEXT	ENDS
PUBLIC	?GetObjectCount@OObject@@SAKXZ			; OObject::GetObjectCount
; Function compile flags: /Ogty
;	COMDAT ?GetObjectCount@OObject@@SAKXZ
_TEXT	SEGMENT
?GetObjectCount@OObject@@SAKXZ PROC NEAR		; OObject::GetObjectCount, COMDAT

; 273  : 	static NDword GetObjectCount() { return(sObjCount); }

	mov	eax, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	ret	0
?GetObjectCount@OObject@@SAKXZ ENDP			; OObject::GetObjectCount
_TEXT	ENDS
PUBLIC	?HasName@OObject@@QAE_NXZ			; OObject::HasName
; Function compile flags: /Ogty
;	COMDAT ?HasName@OObject@@QAE_NXZ
_TEXT	SEGMENT
?HasName@OObject@@QAE_NXZ PROC NEAR			; OObject::HasName, COMDAT
; _this$ = ecx

; 277  : 	inline NBool HasName() { return(mName.Len()!=0); }

	push	edi
	mov	edi, DWORD PTR [ecx+44]
	test	edi, edi
	jne	SHORT $L35723
	xor	ecx, ecx
	xor	eax, eax
	test	ecx, ecx
	setne	al
	pop	edi
	ret	0
$L35723:
	or	ecx, -1
	xor	eax, eax
	repne scasb
	not	ecx
	dec	ecx
	pop	edi
	test	ecx, ecx
	setne	al
	ret	0
?HasName@OObject@@QAE_NXZ ENDP				; OObject::HasName
_TEXT	ENDS
PUBLIC	?GetName@OObject@@QAEPBDXZ			; OObject::GetName
; Function compile flags: /Ogty
;	COMDAT ?GetName@OObject@@QAEPBDXZ
_TEXT	SEGMENT
?GetName@OObject@@QAEPBDXZ PROC NEAR			; OObject::GetName, COMDAT
; _this$ = ecx

; 278  : 	inline const NChar* GetName() { return(*mName); }

	mov	eax, DWORD PTR [ecx+44]
	test	eax, eax
	jne	SHORT $L35737
	mov	eax, OFFSET FLAT:??_C@_00A@?$AA@	; `string'
$L35737:
	ret	0
?GetName@OObject@@QAEPBDXZ ENDP				; OObject::GetName
_TEXT	ENDS
PUBLIC	?GetNameHash@OObject@@QAEKXZ			; OObject::GetNameHash
; Function compile flags: /Ogty
;	COMDAT ?GetNameHash@OObject@@QAEKXZ
_TEXT	SEGMENT
?GetNameHash@OObject@@QAEKXZ PROC NEAR			; OObject::GetNameHash, COMDAT
; _this$ = ecx

; 279  : 	inline NDword GetNameHash() { return(mNameHash); }

	mov	eax, DWORD PTR [ecx+48]
	ret	0
?GetNameHash@OObject@@QAEKXZ ENDP			; OObject::GetNameHash
_TEXT	ENDS
PUBLIC	?SetName@OObject@@QAEXPBD@Z			; OObject::SetName
; Function compile flags: /Ogty
;	COMDAT ?SetName@OObject@@QAEXPBD@Z
_TEXT	SEGMENT
_inName$ = 8
?SetName@OObject@@QAEXPBD@Z PROC NEAR			; OObject::SetName, COMDAT
; _this$ = ecx

; 280  : 	inline void SetName(const NChar* inName) { mName = inName; mNameHash = STR_CalcHash((NChar*)inName); }

	push	ebx
	push	ebp
	push	esi
	mov	esi, DWORD PTR _inName$[esp+8]
	test	esi, esi
	push	edi
	mov	ebx, ecx
	mov	ebp, esi
	je	SHORT $L35763
	cmp	BYTE PTR [esi], 0
	jne	SHORT $L35763
	xor	ebp, ebp
$L35763:
	mov	edi, DWORD PTR [ebx+44]
	test	edi, edi
	je	SHORT $L35764
	or	ecx, -1
	xor	eax, eax
	repne scasb
	not	ecx
	dec	ecx
	or	eax, -1
	sub	eax, ecx
	mov	ecx, DWORD PTR ?sMemTotal@CCorString@@0KA ; CCorString::sMemTotal
	add	ecx, eax
	mov	DWORD PTR ?sMemTotal@CCorString@@0KA, ecx ; CCorString::sMemTotal
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [ebx+44]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L35764:
	test	ebp, ebp
	mov	DWORD PTR [ebx+44], 0
	je	SHORT $L35767
	mov	edi, ebp
	or	ecx, -1
	xor	eax, eax
	repne scasb
	not	ecx
	dec	ecx
	mov	esi, ecx
	inc	esi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	ecx, eax
	call	DWORD PTR [edx]
	test	eax, eax
	mov	DWORD PTR [ebx+44], eax
	je	SHORT $L35771
	mov	edx, ebp
$L35761:
	mov	cl, BYTE PTR [edx]
	inc	edx
	mov	BYTE PTR [eax], cl
	inc	eax
	test	cl, cl
	jne	SHORT $L35761
	add	DWORD PTR ?sMemTotal@CCorString@@0KA, esi ; CCorString::sMemTotal
$L35771:
	mov	esi, DWORD PTR _inName$[esp+12]
$L35767:
	push	esi
	call	?STR_CalcHash@@YAKPAD@Z			; STR_CalcHash
	add	esp, 4
	mov	DWORD PTR [ebx+48], eax
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	4
?SetName@OObject@@QAEXPBD@Z ENDP			; OObject::SetName
_TEXT	ENDS
PUBLIC	?GetFlags@OObject@@QAEKXZ			; OObject::GetFlags
; Function compile flags: /Ogty
;	COMDAT ?GetFlags@OObject@@QAEKXZ
_TEXT	SEGMENT
?GetFlags@OObject@@QAEKXZ PROC NEAR			; OObject::GetFlags, COMDAT
; _this$ = ecx

; 282  : 	inline NDword GetFlags() { return(mFlags); }

	mov	eax, DWORD PTR [ecx+52]
	ret	0
?GetFlags@OObject@@QAEKXZ ENDP				; OObject::GetFlags
_TEXT	ENDS
PUBLIC	?SetFlags@OObject@@QAEXK@Z			; OObject::SetFlags
; Function compile flags: /Ogty
;	COMDAT ?SetFlags@OObject@@QAEXK@Z
_TEXT	SEGMENT
_inFlags$ = 8
?SetFlags@OObject@@QAEXK@Z PROC NEAR			; OObject::SetFlags, COMDAT
; _this$ = ecx

; 283  : 	inline void SetFlags(NDword inFlags) { mFlags = inFlags; }

	mov	eax, DWORD PTR _inFlags$[esp-4]
	mov	DWORD PTR [ecx+52], eax
	ret	4
?SetFlags@OObject@@QAEXK@Z ENDP				; OObject::SetFlags
_TEXT	ENDS
PUBLIC	?AddFlags@OObject@@QAEXK@Z			; OObject::AddFlags
; Function compile flags: /Ogty
;	COMDAT ?AddFlags@OObject@@QAEXK@Z
_TEXT	SEGMENT
_inFlags$ = 8
?AddFlags@OObject@@QAEXK@Z PROC NEAR			; OObject::AddFlags, COMDAT
; _this$ = ecx

; 284  : 	inline void AddFlags(NDword inFlags) { mFlags |= inFlags; }

	mov	eax, DWORD PTR _inFlags$[esp-4]
	mov	edx, DWORD PTR [ecx+52]
	or	edx, eax
	mov	DWORD PTR [ecx+52], edx
	ret	4
?AddFlags@OObject@@QAEXK@Z ENDP				; OObject::AddFlags
_TEXT	ENDS
PUBLIC	?SubFlags@OObject@@QAEXK@Z			; OObject::SubFlags
; Function compile flags: /Ogty
;	COMDAT ?SubFlags@OObject@@QAEXK@Z
_TEXT	SEGMENT
_inFlags$ = 8
?SubFlags@OObject@@QAEXK@Z PROC NEAR			; OObject::SubFlags, COMDAT
; _this$ = ecx

; 285  : 	inline void SubFlags(NDword inFlags) { mFlags &= ~inFlags; }

	mov	eax, DWORD PTR _inFlags$[esp-4]
	mov	edx, DWORD PTR [ecx+52]
	not	eax
	and	edx, eax
	mov	DWORD PTR [ecx+52], edx
	ret	4
?SubFlags@OObject@@QAEXK@Z ENDP				; OObject::SubFlags
_TEXT	ENDS
PUBLIC	?IsValid@OObject@@QAE_NXZ			; OObject::IsValid
; Function compile flags: /Ogty
;	COMDAT ?IsValid@OObject@@QAE_NXZ
_TEXT	SEGMENT
?IsValid@OObject@@QAE_NXZ PROC NEAR			; OObject::IsValid, COMDAT
; _this$ = ecx

; 287  : 	inline NBool IsValid() { return(mValidityStamp == OBJ_VALIDITY_STAMP); }

	mov	edx, DWORD PTR [ecx+4]
	xor	eax, eax
	cmp	edx, 305419896				; 12345678H
	sete	al
	ret	0
?IsValid@OObject@@QAE_NXZ ENDP				; OObject::IsValid
_TEXT	ENDS
PUBLIC	?HasChildren@OObject@@UAE_NXZ			; OObject::HasChildren
; Function compile flags: /Ogty
;	COMDAT ?HasChildren@OObject@@UAE_NXZ
_TEXT	SEGMENT
?HasChildren@OObject@@UAE_NXZ PROC NEAR			; OObject::HasChildren, COMDAT
; _this$ = ecx

; 297  : 	virtual NBool HasChildren() { return(mChildLink.GetNext() != &mChildLink); }

	push	esi
	mov	esi, DWORD PTR [ecx+32]
	lea	eax, DWORD PTR [ecx+24]
	xor	edx, edx
	cmp	esi, eax
	pop	esi
	setne	dl
	mov	al, dl
	ret	0
?HasChildren@OObject@@UAE_NXZ ENDP			; OObject::HasChildren
_TEXT	ENDS
PUBLIC	?IsA@OObject@@UAE_NPAVCObjClass@@@Z		; OObject::IsA
EXTRN	?IsDerivedFrom@CObjClass@@QAE_NPAV1@@Z:NEAR	; CObjClass::IsDerivedFrom
; Function compile flags: /Ogty
;	COMDAT ?IsA@OObject@@UAE_NPAVCObjClass@@@Z
_TEXT	SEGMENT
_inClass$ = 8
?IsA@OObject@@UAE_NPAVCObjClass@@@Z PROC NEAR		; OObject::IsA, COMDAT
; _this$ = ecx

; 298  :     virtual NBool IsA(CObjClass* inClass) { return(GetClass()->IsDerivedFrom(inClass)); }

	mov	eax, DWORD PTR _inClass$[esp-4]
	mov	edx, DWORD PTR [ecx]
	push	eax
	call	DWORD PTR [edx+16]
	mov	ecx, eax
	call	?IsDerivedFrom@CObjClass@@QAE_NPAV1@@Z	; CObjClass::IsDerivedFrom
	ret	4
?IsA@OObject@@UAE_NPAVCObjClass@@@Z ENDP		; OObject::IsA
_TEXT	ENDS
PUBLIC	??0OObject@@QAE@ABV0@@Z				; OObject::OObject
PUBLIC	??_7OObject@@6B@				; OObject::`vftable'
PUBLIC	??_EOObject@@UAEPAXI@Z				; OObject::`vector deleting destructor'
EXTRN	?Destroy@OObject@@UAEXXZ:NEAR			; OObject::Destroy
EXTRN	?GetParent@OObject@@UAEPAV1@XZ:NEAR		; OObject::GetParent
EXTRN	?SetParent@OObject@@UAEXPAV1@_N@Z:NEAR		; OObject::SetParent
EXTRN	?Msg@OObject@@UAE_NPAVIMsg@@@Z:NEAR		; OObject::Msg
EXTRN	?MsgGetParent@OObject@@UAEPAVIMsgTarget@@XZ:NEAR ; OObject::MsgGetParent
EXTRN	?MsgGetRoot@OObject@@UAEPAVIMsgTarget@@XZ:NEAR	; OObject::MsgGetRoot
;	COMDAT xdata$x
xdata$x	SEGMENT
$T35833	DD	0ffffffffH
	DD	FLAT:$L35800
	DD	00H
	DD	FLAT:$L35801
$T35830	DD	019930520H
	DD	02H
	DD	FLAT:$T35833
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_7OObject@@6B@
CONST	SEGMENT
??_7OObject@@6B@ DD FLAT:?Msg@OObject@@UAE_NPAVIMsg@@@Z	; OObject::`vftable'
	DD	FLAT:?MsgGetChild@OObject@@UAEPAVIMsgTarget@@PAD@Z
	DD	FLAT:?MsgGetParent@OObject@@UAEPAVIMsgTarget@@XZ
	DD	FLAT:?MsgGetRoot@OObject@@UAEPAVIMsgTarget@@XZ
	DD	FLAT:?GetClass@OObject@@UAEPAVCObjClass@@XZ
	DD	FLAT:??_EOObject@@UAEPAXI@Z
	DD	FLAT:?Create@OObject@@UAEXXZ
	DD	FLAT:?Destroy@OObject@@UAEXXZ
	DD	FLAT:?GetParent@OObject@@UAEPAV1@XZ
	DD	FLAT:?SetParent@OObject@@UAEXPAV1@_N@Z
	DD	FLAT:?HasChildren@OObject@@UAE_NXZ
	DD	FLAT:?IsA@OObject@@UAE_NPAVCObjClass@@@Z
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ??0OObject@@QAE@ABV0@@Z
_TEXT	SEGMENT
__$EHRec$ = -12
___that$ = 8
_this$ = -16
??0OObject@@QAE@ABV0@@Z PROC NEAR			; OObject::OObject, COMDAT
; _this$ = ecx
	push	-1
	push	$L35832
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	push	ebx
	mov	ebx, DWORD PTR ___that$[esp+16]
	push	ebp
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [ebx+8]
	push	edi
	mov	DWORD PTR _this$[esp+32], esi
	mov	DWORD PTR [esi], OFFSET FLAT:??_7IMsgTarget@@6B@ ; IMsgTarget::`vftable'
	mov	eax, DWORD PTR [ebx+4]
	mov	DWORD PTR [esi+4], eax
	mov	eax, DWORD PTR [ecx]
	lea	edx, DWORD PTR [esi+8]
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], ecx
	lea	edx, DWORD PTR [ebx+24]
	lea	ecx, DWORD PTR [esi+24]
	xor	eax, eax
	mov	edi, DWORD PTR [edx]
	mov	DWORD PTR __$EHRec$[esp+40], eax
	mov	DWORD PTR [ecx], edi
	mov	edi, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], edi
	mov	edi, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], edi
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [ecx+12], edx
	mov	ecx, DWORD PTR [ebx+40]
	mov	BYTE PTR __$EHRec$[esp+40], 1
	mov	DWORD PTR [esi+40], ecx
	mov	DWORD PTR [esi+44], eax
	mov	ebp, DWORD PTR [ebx+44]
	cmp	ebp, eax
	je	SHORT $L35823
	cmp	BYTE PTR [ebp], 0
	jne	SHORT $L35823
	xor	ebp, ebp
$L35823:
	cmp	ebp, eax
	mov	DWORD PTR [esi+44], eax
	je	SHORT $L35826
	mov	edi, ebp
	or	ecx, -1
	xor	eax, eax
	repne scasb
	not	ecx
	dec	ecx
	mov	edi, ecx
	inc	edi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	edi
	mov	ecx, eax
	call	DWORD PTR [edx]
	test	eax, eax
	mov	DWORD PTR [esi+44], eax
	je	SHORT $L35826
	mov	ecx, eax
$L35820:
	mov	al, BYTE PTR [ebp]
	inc	ebp
	mov	BYTE PTR [ecx], al
	inc	ecx
	test	al, al
	jne	SHORT $L35820
	add	DWORD PTR ?sMemTotal@CCorString@@0KA, edi ; CCorString::sMemTotal
$L35826:
	mov	eax, DWORD PTR [ebx+48]
	pop	edi
	mov	DWORD PTR [esi+48], eax
	mov	ecx, DWORD PTR [ebx+52]
	mov	DWORD PTR [esi+52], ecx
	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR [esi], OFFSET FLAT:??_7OObject@@6B@ ; OObject::`vftable'
	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L35800:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1CObjLink@@QAE@XZ			; CObjLink::~CObjLink
$L35801:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	jmp	??1CObjLink@@QAE@XZ			; CObjLink::~CObjLink
$L35832:
	mov	eax, OFFSET FLAT:$T35830
	jmp	___CxxFrameHandler
text$x	ENDS
??0OObject@@QAE@ABV0@@Z ENDP				; OObject::OObject
PUBLIC	??4OObject@@QAEAAV0@ABV0@@Z			; OObject::operator=
; Function compile flags: /Ogty
;	COMDAT ??4OObject@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8
??4OObject@@QAEAAV0@ABV0@@Z PROC NEAR			; OObject::operator=, COMDAT
; _this$ = ecx
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR ___that$[esp+4]
	push	esi
	mov	esi, ecx
	push	edi
	mov	eax, DWORD PTR [ebp+4]
	lea	ecx, DWORD PTR [ebp+8]
	mov	DWORD PTR [esi+4], eax
	lea	edx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	lea	eax, DWORD PTR [esi+24]
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], ecx
	lea	edx, DWORD PTR [ebp+24]
	mov	ecx, DWORD PTR [ebp+24]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR [ebp+40]
	mov	DWORD PTR [esi+40], eax
	mov	ebx, DWORD PTR [ebp+44]
	test	ebx, ebx
	je	SHORT $L35858
	cmp	BYTE PTR [ebx], 0
	jne	SHORT $L35858
	xor	ebx, ebx
$L35858:
	mov	edi, DWORD PTR [esi+44]
	test	edi, edi
	je	SHORT $L35859
	or	ecx, -1
	xor	eax, eax
	repne scasb
	mov	eax, DWORD PTR ?sMemTotal@CCorString@@0KA ; CCorString::sMemTotal
	or	edx, -1
	not	ecx
	dec	ecx
	sub	edx, ecx
	add	eax, edx
	mov	DWORD PTR ?sMemTotal@CCorString@@0KA, eax ; CCorString::sMemTotal
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+44]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L35859:
	test	ebx, ebx
	mov	DWORD PTR [esi+44], 0
	je	SHORT $L35862
	mov	edi, ebx
	or	ecx, -1
	xor	eax, eax
	repne scasb
	not	ecx
	dec	ecx
	mov	edi, ecx
	inc	edi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	edi
	mov	ecx, eax
	call	DWORD PTR [edx]
	test	eax, eax
	mov	DWORD PTR [esi+44], eax
	je	SHORT $L35862
$L35856:
	mov	cl, BYTE PTR [ebx]
	inc	ebx
	mov	BYTE PTR [eax], cl
	inc	eax
	test	cl, cl
	jne	SHORT $L35856
	add	DWORD PTR ?sMemTotal@CCorString@@0KA, edi ; CCorString::sMemTotal
$L35862:
	mov	eax, DWORD PTR [ebp+48]
	pop	edi
	mov	DWORD PTR [esi+48], eax
	mov	ecx, DWORD PTR [ebp+52]
	mov	DWORD PTR [esi+52], ecx
	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx
	ret	4
??4OObject@@QAEAAV0@ABV0@@Z ENDP			; OObject::operator=
_TEXT	ENDS
PUBLIC	??_GOObject@@UAEPAXI@Z				; OObject::`scalar deleting destructor'
EXTRN	??1OObject@@UAE@XZ:NEAR				; OObject::~OObject
; Function compile flags: /Ogty
;	COMDAT ??_GOObject@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_GOObject@@UAEPAXI@Z PROC NEAR			; OObject::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1OObject@@UAE@XZ			; OObject::~OObject
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $L35881
	mov	DWORD PTR [esi+4], 0
	mov	edx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	dec	edx
	mov	DWORD PTR ?sObjCount@OObject@@1KA, edx	; OObject::sObjCount
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L35881:
	mov	eax, esi
	pop	esi
	ret	4
??_GOObject@@UAEPAXI@Z ENDP				; OObject::`scalar deleting destructor'
_TEXT	ENDS
EXTRN	??_M@YGXPAXIHP6EX0@Z@Z:NEAR			; `eh vector destructor iterator'
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
; Function compile flags: /Ogty
;	COMDAT ??_EOObject@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_EOObject@@UAEPAXI@Z PROC NEAR			; OObject::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebx
	mov	bl, BYTE PTR ___flags$[esp]
	push	esi
	mov	esi, ecx
	test	bl, 2
	je	SHORT $L6925
	mov	eax, DWORD PTR [esi-4]
	push	edi
	lea	edi, DWORD PTR [esi-4]
	push	OFFSET FLAT:??1OObject@@UAE@XZ		; OObject::~OObject
	push	eax
	push	56					; 00000038H
	push	esi
	call	??_M@YGXPAXIHP6EX0@Z@Z			; `eh vector destructor iterator'
	test	bl, 1
	je	SHORT $L6926
	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L6926:
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	ret	4
$L6925:
	mov	ecx, esi
	call	??1OObject@@UAE@XZ			; OObject::~OObject
	test	bl, 1
	je	SHORT $L35896
	mov	DWORD PTR [esi+4], 0
	mov	edx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	dec	edx
	mov	DWORD PTR ?sObjCount@OObject@@1KA, edx	; OObject::sObjCount
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L35896:
	mov	eax, esi
	pop	esi
	pop	ebx
	ret	4
??_EOObject@@UAEPAXI@Z ENDP				; OObject::`vector deleting destructor'
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?GetObject@CObjIter@@IAEPAVOObject@@XZ
_TEXT	SEGMENT
?GetObject@CObjIter@@IAEPAVOObject@@XZ PROC NEAR	; CObjIter::GetObject, COMDAT
; _this$ = ecx

; 339  : 		if (!mLink)

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	jne	SHORT $L6958

; 342  : 	}

	ret	0
$L6958:

; 340  : 			return(NULL);
; 341  : 		return(mLink->GetChild());

	mov	eax, DWORD PTR [eax]

; 342  : 	}

	ret	0
?GetObject@CObjIter@@IAEPAVOObject@@XZ ENDP		; CObjIter::GetObject
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?GetNext@CObjIter@@IAEXXZ
_TEXT	SEGMENT
?GetNext@CObjIter@@IAEXXZ PROC NEAR			; CObjIter::GetNext, COMDAT
; _this$ = ecx

; 345  : 		if (mReverse)

	mov	al, BYTE PTR [ecx+8]
	test	al, al

; 346  : 			mLinkNext = mLink->GetPrev();

	mov	eax, DWORD PTR [ecx]
	je	SHORT $L6961
	mov	edx, DWORD PTR [eax+12]

; 347  : 		else
; 348  : 			mLinkNext = mLink->GetNext();

	mov	DWORD PTR [ecx+4], edx

; 349  : 	}

	ret	0
$L6961:

; 347  : 		else
; 348  : 			mLinkNext = mLink->GetNext();

	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+4], edx

; 349  : 	}

	ret	0
?GetNext@CObjIter@@IAEXXZ ENDP				; CObjIter::GetNext
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?Reset@CObjIter@@QAEXPAVOObject@@_N@Z
_TEXT	SEGMENT
_inObj$ = 8
_inReverse$ = 12
?Reset@CObjIter@@QAEXPAVOObject@@_N@Z PROC NEAR		; CObjIter::Reset, COMDAT
; _this$ = ecx

; 359  : 		mLink = mLinkNext = NULL;
; 360  : 		if (!inObj)

	mov	eax, DWORD PTR _inObj$[esp-4]
	mov	DWORD PTR [ecx+4], 0
	test	eax, eax
	mov	DWORD PTR [ecx], 0
	je	SHORT $L35962

; 361  : 			return;
; 362  : 		mLink = &inObj->mChildLink;
; 363  : 		mReverse = inReverse;

	mov	dl, BYTE PTR _inReverse$[esp-4]
	add	eax, 24					; 00000018H

; 364  : 		GetNext();

	test	dl, dl
	mov	DWORD PTR [ecx], eax
	mov	BYTE PTR [ecx+8], dl
	je	SHORT $L35934
	mov	eax, DWORD PTR [eax+12]
	jmp	SHORT $L35964
$L35934:
	mov	eax, DWORD PTR [eax+8]
$L35964:

; 365  : 		Advance();

	test	dl, dl
	mov	DWORD PTR [ecx+4], eax
	mov	DWORD PTR [ecx], eax
	je	SHORT $L35961
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+4], edx

; 366  : 	}

	ret	8

; 365  : 		Advance();

$L35961:
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+4], eax
$L35962:

; 366  : 	}

	ret	8
?Reset@CObjIter@@QAEXPAVOObject@@_N@Z ENDP		; CObjIter::Reset
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??0CObjIter@@QAE@PAVOObject@@_N@Z
_TEXT	SEGMENT
_inObj$ = 8
_inReverse$ = 12
??0CObjIter@@QAE@PAVOObject@@_N@Z PROC NEAR		; CObjIter::CObjIter, COMDAT
; _this$ = ecx

; 367  :     inline CObjIter(OObject* inObj, bool inReverse=false) { Reset(inObj,inReverse); }

	mov	eax, ecx
	mov	ecx, DWORD PTR _inObj$[esp-4]
	test	ecx, ecx
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax], 0
	je	SHORT $L36031
	mov	dl, BYTE PTR _inReverse$[esp-4]
	add	ecx, 24					; 00000018H
	test	dl, dl
	mov	DWORD PTR [eax], ecx
	mov	BYTE PTR [eax+8], dl
	je	SHORT $L36021
	mov	ecx, DWORD PTR [ecx+12]
	jmp	SHORT $L36036
$L36021:
	mov	ecx, DWORD PTR [ecx+8]
$L36036:
	test	dl, dl
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax], ecx
	je	SHORT $L36030
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+4], edx
	ret	8
$L36030:
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+4], ecx
$L36031:
	ret	8
??0CObjIter@@QAE@PAVOObject@@_N@Z ENDP			; CObjIter::CObjIter
_TEXT	ENDS
PUBLIC	?LinkBefore@CObjLink@@QAEXPAV1@@Z		; CObjLink::LinkBefore
; Function compile flags: /Ogty
;	COMDAT ?LinkBefore@CObjLink@@QAEXPAV1@@Z
_TEXT	SEGMENT
_inLink$ = 8
?LinkBefore@CObjLink@@QAEXPAV1@@Z PROC NEAR		; CObjLink::LinkBefore, COMDAT
; _this$ = ecx

; 424  : 	mNext = inLink;

	mov	eax, DWORD PTR _inLink$[esp-4]
	mov	DWORD PTR [ecx+8], eax

; 425  : 	mPrev = inLink->mPrev;

	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax

; 426  : 	mNext->mPrev = mPrev->mNext = this;

	mov	DWORD PTR [eax+8], ecx
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+12], ecx

; 427  : }

	ret	4
?LinkBefore@CObjLink@@QAEXPAV1@@Z ENDP			; CObjLink::LinkBefore
_TEXT	ENDS
PUBLIC	?LinkAfter@CObjLink@@QAEXPAV1@@Z		; CObjLink::LinkAfter
; Function compile flags: /Ogty
;	COMDAT ?LinkAfter@CObjLink@@QAEXPAV1@@Z
_TEXT	SEGMENT
_inLink$ = 8
?LinkAfter@CObjLink@@QAEXPAV1@@Z PROC NEAR		; CObjLink::LinkAfter, COMDAT
; _this$ = ecx

; 430  : 	mPrev = inLink;

	mov	eax, DWORD PTR _inLink$[esp-4]
	mov	DWORD PTR [ecx+12], eax

; 431  : 	mNext = inLink->mNext;

	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx

; 432  : 	mNext->mPrev = mPrev->mNext = this;

	mov	DWORD PTR [eax+8], ecx
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+12], ecx

; 433  : }

	ret	4
?LinkAfter@CObjLink@@QAEXPAV1@@Z ENDP			; CObjLink::LinkAfter
_TEXT	ENDS
PUBLIC	?Unlink@CObjLink@@QAEXXZ			; CObjLink::Unlink
; Function compile flags: /Ogty
;	COMDAT ?Unlink@CObjLink@@QAEXXZ
_TEXT	SEGMENT
?Unlink@CObjLink@@QAEXXZ PROC NEAR			; CObjLink::Unlink, COMDAT
; _this$ = ecx

; 436  : 	mNext->mPrev = mPrev;

	mov	eax, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx

; 437  : 	mPrev->mNext = mNext;

	mov	eax, DWORD PTR [ecx+12]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx

; 438  : 	mNext = mPrev = this;

	mov	DWORD PTR [ecx+12], ecx
	mov	DWORD PTR [ecx+8], ecx

; 439  : }

	ret	0
?Unlink@CObjLink@@QAEXXZ ENDP				; CObjLink::Unlink
_TEXT	ENDS
PUBLIC	??2OCpjRes@@CAPAXIPAVOObject@@PAVCObjClass@@@Z	; OCpjRes::operator new
; Function compile flags: /Ogty
; File C:\duke4\Cannibal\CpjMain.h
;	COMDAT ??2OCpjRes@@CAPAXIPAVOObject@@PAVCObjClass@@@Z
_TEXT	SEGMENT
_inParent$ = 12
_inSetClass$ = 16
??2OCpjRes@@CAPAXIPAVOObject@@PAVCObjClass@@@Z PROC NEAR ; OCpjRes::operator new, COMDAT

; 30   : 	OBJ_CLASS_DEFINE(OCpjRes, OObject);

	push	esi
	push	edi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	56					; 00000038H
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	ecx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	mov	esi, eax
	inc	ecx
	xor	eax, eax
	mov	DWORD PTR ?sObjCount@OObject@@1KA, ecx	; OObject::sObjCount
	mov	ecx, 14					; 0000000eH
	mov	edi, esi
	rep stosd
	mov	eax, DWORD PTR [esi+40]
	mov	DWORD PTR [esi+4], 305419896		; 12345678H
	test	eax, eax
	jne	SHORT $L36056
	mov	eax, DWORD PTR _inSetClass$[esp+4]
	mov	DWORD PTR [esi+40], eax
$L36056:
	mov	ecx, DWORD PTR _inParent$[esp+4]
	push	ecx
	mov	ecx, esi
	call	?PreConstruct@OObject@@QAEXPAV1@@Z	; OObject::PreConstruct
	mov	eax, esi
	pop	edi
	pop	esi
	ret	0
??2OCpjRes@@CAPAXIPAVOObject@@PAVCObjClass@@@Z ENDP	; OCpjRes::operator new
_TEXT	ENDS
PUBLIC	??3OCpjRes@@CAXPAX@Z				; OCpjRes::operator delete
; Function compile flags: /Ogty
;	COMDAT ??3OCpjRes@@CAXPAX@Z
_TEXT	SEGMENT
_ptr$ = 8
??3OCpjRes@@CAXPAX@Z PROC NEAR				; OCpjRes::operator delete, COMDAT

; 30   : 	OBJ_CLASS_DEFINE(OCpjRes, OObject);

	push	esi
	mov	esi, DWORD PTR _ptr$[esp]
	mov	DWORD PTR [esi+4], 0
	mov	edx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	dec	edx
	mov	DWORD PTR ?sObjCount@OObject@@1KA, edx	; OObject::sObjCount
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	ecx, eax
	call	DWORD PTR [edx+8]
	pop	esi
	ret	0
??3OCpjRes@@CAXPAX@Z ENDP				; OCpjRes::operator delete
_TEXT	ENDS
PUBLIC	??3OCpjRes@@CAXPAXPAVOObject@@PAVCObjClass@@@Z	; OCpjRes::operator delete
; Function compile flags: /Ogty
;	COMDAT ??3OCpjRes@@CAXPAXPAVOObject@@PAVCObjClass@@@Z
_TEXT	SEGMENT
_ptr$ = 8
??3OCpjRes@@CAXPAXPAVOObject@@PAVCObjClass@@@Z PROC NEAR ; OCpjRes::operator delete, COMDAT

; 30   : 	OBJ_CLASS_DEFINE(OCpjRes, OObject);

	push	esi
	mov	esi, DWORD PTR _ptr$[esp]
	mov	DWORD PTR [esi+4], 0
	mov	edx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	dec	edx
	mov	DWORD PTR ?sObjCount@OObject@@1KA, edx	; OObject::sObjCount
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	ecx, eax
	call	DWORD PTR [edx+8]
	pop	esi
	ret	0
??3OCpjRes@@CAXPAXPAVOObject@@PAVCObjClass@@@Z ENDP	; OCpjRes::operator delete
_TEXT	ENDS
PUBLIC	?GetStaticClass@OCpjRes@@SAPAVCObjClass@@XZ	; OCpjRes::GetStaticClass
EXTRN	?staticObjClass@OCpjRes@@0PAVCObjClass@@A:DWORD	; OCpjRes::staticObjClass
; Function compile flags: /Ogty
;	COMDAT ?GetStaticClass@OCpjRes@@SAPAVCObjClass@@XZ
_TEXT	SEGMENT
?GetStaticClass@OCpjRes@@SAPAVCObjClass@@XZ PROC NEAR	; OCpjRes::GetStaticClass, COMDAT

; 30   : 	OBJ_CLASS_DEFINE(OCpjRes, OObject);

	mov	eax, DWORD PTR ?staticObjClass@OCpjRes@@0PAVCObjClass@@A ; OCpjRes::staticObjClass
	ret	0
?GetStaticClass@OCpjRes@@SAPAVCObjClass@@XZ ENDP	; OCpjRes::GetStaticClass
_TEXT	ENDS
PUBLIC	?New@OCpjRes@@SAPAV1@PAVOObject@@PAVCObjClass@@@Z ; OCpjRes::New
PUBLIC	?GetClass@OCpjRes@@UAEPAVCObjClass@@XZ		; OCpjRes::GetClass
PUBLIC	?GetFileExtension@OCpjRes@@UAEPADXZ		; OCpjRes::GetFileExtension
PUBLIC	?GetFileDescription@OCpjRes@@UAEPADXZ		; OCpjRes::GetFileDescription
PUBLIC	?LoadFile@OCpjRes@@UAE_NPAD@Z			; OCpjRes::LoadFile
PUBLIC	?SaveFile@OCpjRes@@UAE_NPAD@Z			; OCpjRes::SaveFile
PUBLIC	??_7OCpjRes@@6B@				; OCpjRes::`vftable'
PUBLIC	??_EOCpjRes@@UAEPAXI@Z				; OCpjRes::`vector deleting destructor'
;	COMDAT xdata$x
xdata$x	SEGMENT
$T36115	DD	0ffffffffH
	DD	FLAT:$L36084
$T36113	DD	019930520H
	DD	01H
	DD	FLAT:$T36115
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_7OCpjRes@@6B@
CONST	SEGMENT
??_7OCpjRes@@6B@ DD FLAT:?Msg@OObject@@UAE_NPAVIMsg@@@Z	; OCpjRes::`vftable'
	DD	FLAT:?MsgGetChild@OObject@@UAEPAVIMsgTarget@@PAD@Z
	DD	FLAT:?MsgGetParent@OObject@@UAEPAVIMsgTarget@@XZ
	DD	FLAT:?MsgGetRoot@OObject@@UAEPAVIMsgTarget@@XZ
	DD	FLAT:?GetClass@OCpjRes@@UAEPAVCObjClass@@XZ
	DD	FLAT:??_EOCpjRes@@UAEPAXI@Z
	DD	FLAT:?Create@OObject@@UAEXXZ
	DD	FLAT:?Destroy@OObject@@UAEXXZ
	DD	FLAT:?GetParent@OObject@@UAEPAV1@XZ
	DD	FLAT:?SetParent@OObject@@UAEXPAV1@_N@Z
	DD	FLAT:?HasChildren@OObject@@UAE_NXZ
	DD	FLAT:?IsA@OObject@@UAE_NPAVCObjClass@@@Z
	DD	FLAT:?GetFileExtension@OCpjRes@@UAEPADXZ
	DD	FLAT:?GetFileDescription@OCpjRes@@UAEPADXZ
	DD	FLAT:?LoadFile@OCpjRes@@UAE_NPAD@Z
	DD	FLAT:?SaveFile@OCpjRes@@UAE_NPAD@Z
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?New@OCpjRes@@SAPAV1@PAVOObject@@PAVCObjClass@@@Z
_TEXT	SEGMENT
$T36081 = -16
__$EHRec$ = -12
_inParent$ = 8
_inSetClass$ = 12
?New@OCpjRes@@SAPAV1@PAVOObject@@PAVCObjClass@@@Z PROC NEAR ; OCpjRes::New, COMDAT

; 30   : 	OBJ_CLASS_DEFINE(OCpjRes, OObject);

	push	-1
	push	$L36114
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	push	ebx
	mov	ebx, DWORD PTR _inSetClass$[esp+16]
	test	ebx, ebx
	push	esi
	jne	SHORT $L7081
	mov	ebx, DWORD PTR ?staticObjClass@OCpjRes@@0PAVCObjClass@@A ; OCpjRes::staticObjClass
	mov	DWORD PTR _inSetClass$[esp+20], ebx
$L7081:
	push	edi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	56					; 00000038H
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	ecx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	mov	esi, eax
	inc	ecx
	xor	eax, eax
	mov	DWORD PTR ?sObjCount@OObject@@1KA, ecx	; OObject::sObjCount
	mov	ecx, 14					; 0000000eH
	mov	edi, esi
	rep stosd
	mov	eax, DWORD PTR [esi+40]
	mov	DWORD PTR [esi+4], 305419896		; 12345678H
	test	eax, eax
	pop	edi
	jne	SHORT $L36104
	mov	DWORD PTR [esi+40], ebx
$L36104:
	mov	eax, DWORD PTR _inParent$[esp+20]
	mov	ecx, esi
	push	eax
	call	?PreConstruct@OObject@@QAEXPAV1@@Z	; OObject::PreConstruct
	mov	DWORD PTR $T36081[esp+24], esi
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+32], 0
	call	??0OObject@@QAE@XZ			; OObject::OObject
	mov	DWORD PTR [esi], OFFSET FLAT:??_7OCpjRes@@6B@ ; OCpjRes::`vftable'
	mov	edx, DWORD PTR [esi]
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+32], -1
	call	DWORD PTR [edx+24]
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	eax, esi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L36084:
	mov	eax, DWORD PTR _inSetClass$[ebp-4]
	push	eax
	mov	ecx, DWORD PTR _inParent$[ebp-4]
	push	ecx
	mov	edx, DWORD PTR $T36081[ebp]
	push	edx
	call	??3OCpjRes@@CAXPAXPAVOObject@@PAVCObjClass@@@Z ; OCpjRes::operator delete
	add	esp, 12					; 0000000cH
	ret	0
$L36114:
	mov	eax, OFFSET FLAT:$T36113
	jmp	___CxxFrameHandler
text$x	ENDS
?New@OCpjRes@@SAPAV1@PAVOObject@@PAVCObjClass@@@Z ENDP	; OCpjRes::New
; Function compile flags: /Ogty
;	COMDAT ?GetClass@OCpjRes@@UAEPAVCObjClass@@XZ
_TEXT	SEGMENT
?GetClass@OCpjRes@@UAEPAVCObjClass@@XZ PROC NEAR	; OCpjRes::GetClass, COMDAT
; _this$ = ecx

; 30   : 	OBJ_CLASS_DEFINE(OCpjRes, OObject);

	mov	eax, DWORD PTR [ecx+40]
	ret	0
?GetClass@OCpjRes@@UAEPAVCObjClass@@XZ ENDP		; OCpjRes::GetClass
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?GetFileExtension@OCpjRes@@UAEPADXZ
_TEXT	SEGMENT
?GetFileExtension@OCpjRes@@UAEPADXZ PROC NEAR		; OCpjRes::GetFileExtension, COMDAT
; _this$ = ecx

; 32   : 	virtual NChar* GetFileExtension() { return(NULL); }

	xor	eax, eax
	ret	0
?GetFileExtension@OCpjRes@@UAEPADXZ ENDP		; OCpjRes::GetFileExtension
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?GetFileDescription@OCpjRes@@UAEPADXZ
_TEXT	SEGMENT
?GetFileDescription@OCpjRes@@UAEPADXZ PROC NEAR		; OCpjRes::GetFileDescription, COMDAT
; _this$ = ecx

; 33   : 	virtual NChar* GetFileDescription() { return(NULL); }

	xor	eax, eax
	ret	0
?GetFileDescription@OCpjRes@@UAEPADXZ ENDP		; OCpjRes::GetFileDescription
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?LoadFile@OCpjRes@@UAE_NPAD@Z
_TEXT	SEGMENT
?LoadFile@OCpjRes@@UAE_NPAD@Z PROC NEAR			; OCpjRes::LoadFile, COMDAT
; _this$ = ecx

; 34   : 	virtual NBool LoadFile(NChar* inFileName) { return(0); }

	xor	al, al
	ret	4
?LoadFile@OCpjRes@@UAE_NPAD@Z ENDP			; OCpjRes::LoadFile
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?SaveFile@OCpjRes@@UAE_NPAD@Z
_TEXT	SEGMENT
?SaveFile@OCpjRes@@UAE_NPAD@Z PROC NEAR			; OCpjRes::SaveFile, COMDAT
; _this$ = ecx

; 35   : 	virtual NBool SaveFile(NChar* inFileName) { return(0); }

	xor	al, al
	ret	4
?SaveFile@OCpjRes@@UAE_NPAD@Z ENDP			; OCpjRes::SaveFile
_TEXT	ENDS
PUBLIC	??0OCpjRes@@QAE@XZ				; OCpjRes::OCpjRes
; Function compile flags: /Ogty
;	COMDAT ??0OCpjRes@@QAE@XZ
_TEXT	SEGMENT
??0OCpjRes@@QAE@XZ PROC NEAR				; OCpjRes::OCpjRes, COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??0OObject@@QAE@XZ			; OObject::OObject
	mov	DWORD PTR [esi], OFFSET FLAT:??_7OCpjRes@@6B@ ; OCpjRes::`vftable'
	mov	eax, esi
	pop	esi
	ret	0
??0OCpjRes@@QAE@XZ ENDP					; OCpjRes::OCpjRes
_TEXT	ENDS
PUBLIC	??0OCpjRes@@QAE@ABV0@@Z				; OCpjRes::OCpjRes
;	COMDAT xdata$x
xdata$x	SEGMENT
$T36189	DD	0ffffffffH
	DD	FLAT:$L36142
	DD	00H
	DD	FLAT:$L36143
$T36186	DD	019930520H
	DD	02H
	DD	FLAT:$T36189
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ??0OCpjRes@@QAE@ABV0@@Z
_TEXT	SEGMENT
__$EHRec$ = -12
___that$ = 8
_this$ = -16
??0OCpjRes@@QAE@ABV0@@Z PROC NEAR			; OCpjRes::OCpjRes, COMDAT
; _this$ = ecx
	push	-1
	push	$L36188
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	push	ebx
	mov	ebx, DWORD PTR ___that$[esp+16]
	push	ebp
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [ebx+8]
	push	edi
	mov	DWORD PTR _this$[esp+32], esi
	mov	DWORD PTR [esi], OFFSET FLAT:??_7IMsgTarget@@6B@ ; IMsgTarget::`vftable'
	mov	eax, DWORD PTR [ebx+4]
	mov	DWORD PTR [esi+4], eax
	mov	eax, DWORD PTR [ecx]
	lea	edx, DWORD PTR [esi+8]
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], ecx
	lea	edx, DWORD PTR [ebx+24]
	lea	ecx, DWORD PTR [esi+24]
	xor	eax, eax
	mov	edi, DWORD PTR [edx]
	mov	DWORD PTR __$EHRec$[esp+40], eax
	mov	DWORD PTR [ecx], edi
	mov	edi, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], edi
	mov	edi, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], edi
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [ecx+12], edx
	mov	ecx, DWORD PTR [ebx+40]
	mov	BYTE PTR __$EHRec$[esp+40], 1
	mov	DWORD PTR [esi+40], ecx
	mov	DWORD PTR [esi+44], eax
	mov	ebp, DWORD PTR [ebx+44]
	cmp	ebp, eax
	je	SHORT $L36179
	cmp	BYTE PTR [ebp], 0
	jne	SHORT $L36179
	xor	ebp, ebp
$L36179:
	cmp	ebp, eax
	mov	DWORD PTR [esi+44], eax
	je	SHORT $L36182
	mov	edi, ebp
	or	ecx, -1
	xor	eax, eax
	repne scasb
	not	ecx
	dec	ecx
	mov	edi, ecx
	inc	edi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	edi
	mov	ecx, eax
	call	DWORD PTR [edx]
	test	eax, eax
	mov	DWORD PTR [esi+44], eax
	je	SHORT $L36182
	mov	ecx, eax
$L36176:
	mov	al, BYTE PTR [ebp]
	inc	ebp
	mov	BYTE PTR [ecx], al
	inc	ecx
	test	al, al
	jne	SHORT $L36176
	add	DWORD PTR ?sMemTotal@CCorString@@0KA, edi ; CCorString::sMemTotal
$L36182:
	mov	eax, DWORD PTR [ebx+48]
	pop	edi
	mov	DWORD PTR [esi+48], eax
	mov	ecx, DWORD PTR [ebx+52]
	mov	DWORD PTR [esi+52], ecx
	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR [esi], OFFSET FLAT:??_7OCpjRes@@6B@ ; OCpjRes::`vftable'
	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L36142:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1CObjLink@@QAE@XZ			; CObjLink::~CObjLink
$L36143:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	jmp	??1CObjLink@@QAE@XZ			; CObjLink::~CObjLink
$L36188:
	mov	eax, OFFSET FLAT:$T36186
	jmp	___CxxFrameHandler
text$x	ENDS
??0OCpjRes@@QAE@ABV0@@Z ENDP				; OCpjRes::OCpjRes
PUBLIC	??4OCpjRes@@QAEAAV0@ABV0@@Z			; OCpjRes::operator=
; Function compile flags: /Ogty
;	COMDAT ??4OCpjRes@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8
??4OCpjRes@@QAEAAV0@ABV0@@Z PROC NEAR			; OCpjRes::operator=, COMDAT
; _this$ = ecx
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR ___that$[esp+4]
	push	esi
	mov	esi, ecx
	push	edi
	mov	eax, DWORD PTR [ebp+4]
	lea	ecx, DWORD PTR [ebp+8]
	mov	DWORD PTR [esi+4], eax
	lea	edx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	lea	eax, DWORD PTR [esi+24]
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], ecx
	lea	edx, DWORD PTR [ebp+24]
	mov	ecx, DWORD PTR [ebp+24]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR [ebp+40]
	mov	DWORD PTR [esi+40], eax
	mov	ebx, DWORD PTR [ebp+44]
	test	ebx, ebx
	je	SHORT $L36227
	cmp	BYTE PTR [ebx], 0
	jne	SHORT $L36227
	xor	ebx, ebx
$L36227:
	mov	edi, DWORD PTR [esi+44]
	test	edi, edi
	je	SHORT $L36228
	or	ecx, -1
	xor	eax, eax
	repne scasb
	mov	eax, DWORD PTR ?sMemTotal@CCorString@@0KA ; CCorString::sMemTotal
	or	edx, -1
	not	ecx
	dec	ecx
	sub	edx, ecx
	add	eax, edx
	mov	DWORD PTR ?sMemTotal@CCorString@@0KA, eax ; CCorString::sMemTotal
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+44]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L36228:
	test	ebx, ebx
	mov	DWORD PTR [esi+44], 0
	je	SHORT $L36231
	mov	edi, ebx
	or	ecx, -1
	xor	eax, eax
	repne scasb
	not	ecx
	dec	ecx
	mov	edi, ecx
	inc	edi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	edi
	mov	ecx, eax
	call	DWORD PTR [edx]
	test	eax, eax
	mov	DWORD PTR [esi+44], eax
	je	SHORT $L36231
$L36233:
	mov	cl, BYTE PTR [ebx]
	inc	ebx
	mov	BYTE PTR [eax], cl
	inc	eax
	test	cl, cl
	jne	SHORT $L36233
	add	DWORD PTR ?sMemTotal@CCorString@@0KA, edi ; CCorString::sMemTotal
$L36231:
	mov	eax, DWORD PTR [ebp+48]
	pop	edi
	mov	DWORD PTR [esi+48], eax
	mov	ecx, DWORD PTR [ebp+52]
	mov	DWORD PTR [esi+52], ecx
	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx
	ret	4
??4OCpjRes@@QAEAAV0@ABV0@@Z ENDP			; OCpjRes::operator=
_TEXT	ENDS
PUBLIC	??1OCpjRes@@UAE@XZ				; OCpjRes::~OCpjRes
; Function compile flags: /Ogty
;	COMDAT ??1OCpjRes@@UAE@XZ
_TEXT	SEGMENT
??1OCpjRes@@UAE@XZ PROC NEAR				; OCpjRes::~OCpjRes, COMDAT
; _this$ = ecx
	jmp	??1OObject@@UAE@XZ			; OObject::~OObject
??1OCpjRes@@UAE@XZ ENDP					; OCpjRes::~OCpjRes
_TEXT	ENDS
PUBLIC	??_GOCpjRes@@UAEPAXI@Z				; OCpjRes::`scalar deleting destructor'
; Function compile flags: /Ogty
;	COMDAT ??_GOCpjRes@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_GOCpjRes@@UAEPAXI@Z PROC NEAR			; OCpjRes::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1OCpjRes@@UAE@XZ			; OCpjRes::~OCpjRes
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $L36256
	mov	DWORD PTR [esi+4], 0
	mov	edx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	dec	edx
	mov	DWORD PTR ?sObjCount@OObject@@1KA, edx	; OObject::sObjCount
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L36256:
	mov	eax, esi
	pop	esi
	ret	4
??_GOCpjRes@@UAEPAXI@Z ENDP				; OCpjRes::`scalar deleting destructor'
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??_EOCpjRes@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_EOCpjRes@@UAEPAXI@Z PROC NEAR			; OCpjRes::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebx
	mov	bl, BYTE PTR ___flags$[esp]
	push	esi
	mov	esi, ecx
	test	bl, 2
	je	SHORT $L7116
	mov	eax, DWORD PTR [esi-4]
	push	edi
	lea	edi, DWORD PTR [esi-4]
	push	OFFSET FLAT:??1OCpjRes@@UAE@XZ		; OCpjRes::~OCpjRes
	push	eax
	push	56					; 00000038H
	push	esi
	call	??_M@YGXPAXIHP6EX0@Z@Z			; `eh vector destructor iterator'
	test	bl, 1
	je	SHORT $L7117
	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L7117:
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	ret	4
$L7116:
	mov	ecx, esi
	call	??1OCpjRes@@UAE@XZ			; OCpjRes::~OCpjRes
	test	bl, 1
	je	SHORT $L36271
	mov	DWORD PTR [esi+4], 0
	mov	edx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	dec	edx
	mov	DWORD PTR ?sObjCount@OObject@@1KA, edx	; OObject::sObjCount
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L36271:
	mov	eax, esi
	pop	esi
	pop	ebx
	ret	4
??_EOCpjRes@@UAEPAXI@Z ENDP				; OCpjRes::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??2OCpjChunk@@CAPAXIPAVOObject@@PAVCObjClass@@@Z ; OCpjChunk::operator new
; Function compile flags: /Ogty
;	COMDAT ??2OCpjChunk@@CAPAXIPAVOObject@@PAVCObjClass@@@Z
_TEXT	SEGMENT
_inParent$ = 12
_inSetClass$ = 16
??2OCpjChunk@@CAPAXIPAVOObject@@PAVCObjClass@@@Z PROC NEAR ; OCpjChunk::operator new, COMDAT

; 52   : 	OBJ_CLASS_DEFINE(OCpjChunk, OCpjRes);

	push	esi
	push	edi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	72					; 00000048H
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	ecx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	mov	esi, eax
	inc	ecx
	xor	eax, eax
	mov	DWORD PTR ?sObjCount@OObject@@1KA, ecx	; OObject::sObjCount
	mov	ecx, 18					; 00000012H
	mov	edi, esi
	rep stosd
	mov	eax, DWORD PTR [esi+40]
	mov	DWORD PTR [esi+4], 305419896		; 12345678H
	test	eax, eax
	jne	SHORT $L36282
	mov	eax, DWORD PTR _inSetClass$[esp+4]
	mov	DWORD PTR [esi+40], eax
$L36282:
	mov	ecx, DWORD PTR _inParent$[esp+4]
	push	ecx
	mov	ecx, esi
	call	?PreConstruct@OObject@@QAEXPAV1@@Z	; OObject::PreConstruct
	mov	eax, esi
	pop	edi
	pop	esi
	ret	0
??2OCpjChunk@@CAPAXIPAVOObject@@PAVCObjClass@@@Z ENDP	; OCpjChunk::operator new
_TEXT	ENDS
PUBLIC	??3OCpjChunk@@CAXPAX@Z				; OCpjChunk::operator delete
; Function compile flags: /Ogty
;	COMDAT ??3OCpjChunk@@CAXPAX@Z
_TEXT	SEGMENT
_ptr$ = 8
??3OCpjChunk@@CAXPAX@Z PROC NEAR			; OCpjChunk::operator delete, COMDAT

; 52   : 	OBJ_CLASS_DEFINE(OCpjChunk, OCpjRes);

	push	esi
	mov	esi, DWORD PTR _ptr$[esp]
	mov	DWORD PTR [esi+4], 0
	mov	edx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	dec	edx
	mov	DWORD PTR ?sObjCount@OObject@@1KA, edx	; OObject::sObjCount
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	ecx, eax
	call	DWORD PTR [edx+8]
	pop	esi
	ret	0
??3OCpjChunk@@CAXPAX@Z ENDP				; OCpjChunk::operator delete
_TEXT	ENDS
PUBLIC	??3OCpjChunk@@CAXPAXPAVOObject@@PAVCObjClass@@@Z ; OCpjChunk::operator delete
; Function compile flags: /Ogty
;	COMDAT ??3OCpjChunk@@CAXPAXPAVOObject@@PAVCObjClass@@@Z
_TEXT	SEGMENT
_ptr$ = 8
??3OCpjChunk@@CAXPAXPAVOObject@@PAVCObjClass@@@Z PROC NEAR ; OCpjChunk::operator delete, COMDAT

; 52   : 	OBJ_CLASS_DEFINE(OCpjChunk, OCpjRes);

	push	esi
	mov	esi, DWORD PTR _ptr$[esp]
	mov	DWORD PTR [esi+4], 0
	mov	edx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	dec	edx
	mov	DWORD PTR ?sObjCount@OObject@@1KA, edx	; OObject::sObjCount
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	ecx, eax
	call	DWORD PTR [edx+8]
	pop	esi
	ret	0
??3OCpjChunk@@CAXPAXPAVOObject@@PAVCObjClass@@@Z ENDP	; OCpjChunk::operator delete
_TEXT	ENDS
PUBLIC	?GetStaticClass@OCpjChunk@@SAPAVCObjClass@@XZ	; OCpjChunk::GetStaticClass
EXTRN	?staticObjClass@OCpjChunk@@0PAVCObjClass@@A:DWORD ; OCpjChunk::staticObjClass
; Function compile flags: /Ogty
;	COMDAT ?GetStaticClass@OCpjChunk@@SAPAVCObjClass@@XZ
_TEXT	SEGMENT
?GetStaticClass@OCpjChunk@@SAPAVCObjClass@@XZ PROC NEAR	; OCpjChunk::GetStaticClass, COMDAT

; 52   : 	OBJ_CLASS_DEFINE(OCpjChunk, OCpjRes);

	mov	eax, DWORD PTR ?staticObjClass@OCpjChunk@@0PAVCObjClass@@A ; OCpjChunk::staticObjClass
	ret	0
?GetStaticClass@OCpjChunk@@SAPAVCObjClass@@XZ ENDP	; OCpjChunk::GetStaticClass
_TEXT	ENDS
PUBLIC	?New@OCpjChunk@@SAPAV1@PAVOObject@@PAVCObjClass@@@Z ; OCpjChunk::New
PUBLIC	?GetClass@OCpjChunk@@UAEPAVCObjClass@@XZ	; OCpjChunk::GetClass
PUBLIC	?Create@OCpjChunk@@UAEXXZ			; OCpjChunk::Create
PUBLIC	?GetFourCC@OCpjChunk@@UAEKXZ			; OCpjChunk::GetFourCC
PUBLIC	?LoadChunk@OCpjChunk@@UAE_NPAXK@Z		; OCpjChunk::LoadChunk
PUBLIC	?SaveChunk@OCpjChunk@@UAE_NPAXPAK@Z		; OCpjChunk::SaveChunk
PUBLIC	??_7OCpjChunk@@6B@				; OCpjChunk::`vftable'
PUBLIC	??_EOCpjChunk@@UAEPAXI@Z			; OCpjChunk::`vector deleting destructor'
EXTRN	?LoadFile@OCpjChunk@@UAE_NPAD@Z:NEAR		; OCpjChunk::LoadFile
EXTRN	?SaveFile@OCpjChunk@@UAE_NPAD@Z:NEAR		; OCpjChunk::SaveFile
;	COMDAT xdata$x
xdata$x	SEGMENT
$T36347	DD	0ffffffffH
	DD	FLAT:$L36310
$T36345	DD	019930520H
	DD	01H
	DD	FLAT:$T36347
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_7OCpjChunk@@6B@
CONST	SEGMENT
??_7OCpjChunk@@6B@ DD FLAT:?Msg@OObject@@UAE_NPAVIMsg@@@Z ; OCpjChunk::`vftable'
	DD	FLAT:?MsgGetChild@OObject@@UAEPAVIMsgTarget@@PAD@Z
	DD	FLAT:?MsgGetParent@OObject@@UAEPAVIMsgTarget@@XZ
	DD	FLAT:?MsgGetRoot@OObject@@UAEPAVIMsgTarget@@XZ
	DD	FLAT:?GetClass@OCpjChunk@@UAEPAVCObjClass@@XZ
	DD	FLAT:??_EOCpjChunk@@UAEPAXI@Z
	DD	FLAT:?Create@OCpjChunk@@UAEXXZ
	DD	FLAT:?Destroy@OObject@@UAEXXZ
	DD	FLAT:?GetParent@OObject@@UAEPAV1@XZ
	DD	FLAT:?SetParent@OObject@@UAEXPAV1@_N@Z
	DD	FLAT:?HasChildren@OObject@@UAE_NXZ
	DD	FLAT:?IsA@OObject@@UAE_NPAVCObjClass@@@Z
	DD	FLAT:?GetFileExtension@OCpjRes@@UAEPADXZ
	DD	FLAT:?GetFileDescription@OCpjRes@@UAEPADXZ
	DD	FLAT:?LoadFile@OCpjChunk@@UAE_NPAD@Z
	DD	FLAT:?SaveFile@OCpjChunk@@UAE_NPAD@Z
	DD	FLAT:?GetFourCC@OCpjChunk@@UAEKXZ
	DD	FLAT:?LoadChunk@OCpjChunk@@UAE_NPAXK@Z
	DD	FLAT:?SaveChunk@OCpjChunk@@UAE_NPAXPAK@Z
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?New@OCpjChunk@@SAPAV1@PAVOObject@@PAVCObjClass@@@Z
_TEXT	SEGMENT
_inParent$ = 8
_inSetClass$ = 12
$T36307 = -16
__$EHRec$ = -12
?New@OCpjChunk@@SAPAV1@PAVOObject@@PAVCObjClass@@@Z PROC NEAR ; OCpjChunk::New, COMDAT

; 52   : 	OBJ_CLASS_DEFINE(OCpjChunk, OCpjRes);

	push	-1
	push	$L36346
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	push	ebx
	mov	ebx, DWORD PTR _inSetClass$[esp+16]
	test	ebx, ebx
	push	esi
	jne	SHORT $L7186
	mov	ebx, DWORD PTR ?staticObjClass@OCpjChunk@@0PAVCObjClass@@A ; OCpjChunk::staticObjClass
	mov	DWORD PTR _inSetClass$[esp+20], ebx
$L7186:
	push	edi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	72					; 00000048H
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	ecx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	mov	esi, eax
	inc	ecx
	xor	eax, eax
	mov	DWORD PTR ?sObjCount@OObject@@1KA, ecx	; OObject::sObjCount
	mov	ecx, 18					; 00000012H
	mov	edi, esi
	rep stosd
	mov	eax, DWORD PTR [esi+40]
	mov	DWORD PTR [esi+4], 305419896		; 12345678H
	test	eax, eax
	pop	edi
	jne	SHORT $L36332
	mov	DWORD PTR [esi+40], ebx
$L36332:
	mov	eax, DWORD PTR _inParent$[esp+20]
	mov	ecx, esi
	push	eax
	call	?PreConstruct@OObject@@QAEXPAV1@@Z	; OObject::PreConstruct
	mov	DWORD PTR $T36307[esp+24], esi
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+32], 0
	call	??0OObject@@QAE@XZ			; OObject::OObject
	mov	DWORD PTR [esi], OFFSET FLAT:??_7OCpjChunk@@6B@ ; OCpjChunk::`vftable'
	mov	edx, DWORD PTR [esi]
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+32], -1
	call	DWORD PTR [edx+24]
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	eax, esi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L36310:
	mov	eax, DWORD PTR _inSetClass$[ebp-4]
	push	eax
	mov	ecx, DWORD PTR _inParent$[ebp-4]
	push	ecx
	mov	edx, DWORD PTR $T36307[ebp]
	push	edx
	call	??3OCpjChunk@@CAXPAXPAVOObject@@PAVCObjClass@@@Z ; OCpjChunk::operator delete
	add	esp, 12					; 0000000cH
	ret	0
$L36346:
	mov	eax, OFFSET FLAT:$T36345
	jmp	___CxxFrameHandler
text$x	ENDS
?New@OCpjChunk@@SAPAV1@PAVOObject@@PAVCObjClass@@@Z ENDP ; OCpjChunk::New
; Function compile flags: /Ogty
;	COMDAT ?GetClass@OCpjChunk@@UAEPAVCObjClass@@XZ
_TEXT	SEGMENT
?GetClass@OCpjChunk@@UAEPAVCObjClass@@XZ PROC NEAR	; OCpjChunk::GetClass, COMDAT
; _this$ = ecx

; 52   : 	OBJ_CLASS_DEFINE(OCpjChunk, OCpjRes);

	mov	eax, DWORD PTR [ecx+40]
	ret	0
?GetClass@OCpjChunk@@UAEPAVCObjClass@@XZ ENDP		; OCpjChunk::GetClass
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?Create@OCpjChunk@@UAEXXZ
_TEXT	SEGMENT
?Create@OCpjChunk@@UAEXXZ PROC NEAR			; OCpjChunk::Create, COMDAT
; _this$ = ecx

; 58   : 	void Create() { Super::Create(); mIsLoaded = 0; mProxyOfs = mProxyLen = 0; mProxyTimeStamp = 0.f; }

	push	esi
	mov	esi, ecx
	call	?Create@OObject@@UAEXXZ			; OObject::Create
	xor	eax, eax
	mov	BYTE PTR [esi+56], al
	mov	DWORD PTR [esi+64], eax
	mov	DWORD PTR [esi+60], eax
	mov	DWORD PTR [esi+68], eax
	pop	esi
	ret	0
?Create@OCpjChunk@@UAEXXZ ENDP				; OCpjChunk::Create
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?GetFourCC@OCpjChunk@@UAEKXZ
_TEXT	SEGMENT
?GetFourCC@OCpjChunk@@UAEKXZ PROC NEAR			; OCpjChunk::GetFourCC, COMDAT
; _this$ = ecx

; 64   : 	virtual NDword GetFourCC() { return(0); }

	xor	eax, eax
	ret	0
?GetFourCC@OCpjChunk@@UAEKXZ ENDP			; OCpjChunk::GetFourCC
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?LoadChunk@OCpjChunk@@UAE_NPAXK@Z
_TEXT	SEGMENT
?LoadChunk@OCpjChunk@@UAE_NPAXK@Z PROC NEAR		; OCpjChunk::LoadChunk, COMDAT
; _this$ = ecx

; 65   : 	virtual NBool LoadChunk(void* inImagePtr, NDword inImageLen) { return(0); }

	xor	al, al
	ret	8
?LoadChunk@OCpjChunk@@UAE_NPAXK@Z ENDP			; OCpjChunk::LoadChunk
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?SaveChunk@OCpjChunk@@UAE_NPAXPAK@Z
_TEXT	SEGMENT
?SaveChunk@OCpjChunk@@UAE_NPAXPAK@Z PROC NEAR		; OCpjChunk::SaveChunk, COMDAT
; _this$ = ecx

; 66   : 	virtual NBool SaveChunk(void* inImagePtr, NDword* outImageLen) { return(0); }

	xor	al, al
	ret	8
?SaveChunk@OCpjChunk@@UAE_NPAXPAK@Z ENDP		; OCpjChunk::SaveChunk
_TEXT	ENDS
PUBLIC	??0OCpjChunk@@QAE@XZ				; OCpjChunk::OCpjChunk
; Function compile flags: /Ogty
;	COMDAT ??0OCpjChunk@@QAE@XZ
_TEXT	SEGMENT
??0OCpjChunk@@QAE@XZ PROC NEAR				; OCpjChunk::OCpjChunk, COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??0OObject@@QAE@XZ			; OObject::OObject
	mov	DWORD PTR [esi], OFFSET FLAT:??_7OCpjChunk@@6B@ ; OCpjChunk::`vftable'
	mov	eax, esi
	pop	esi
	ret	0
??0OCpjChunk@@QAE@XZ ENDP				; OCpjChunk::OCpjChunk
_TEXT	ENDS
PUBLIC	??0OCpjChunk@@QAE@ABV0@@Z			; OCpjChunk::OCpjChunk
;	COMDAT xdata$x
xdata$x	SEGMENT
$T36443	DD	0ffffffffH
	DD	FLAT:$L36380
	DD	00H
	DD	FLAT:$L36381
$T36440	DD	019930520H
	DD	02H
	DD	FLAT:$T36443
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ??0OCpjChunk@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8
_this$ = -16
__$EHRec$ = -12
??0OCpjChunk@@QAE@ABV0@@Z PROC NEAR			; OCpjChunk::OCpjChunk, COMDAT
; _this$ = ecx
	push	-1
	push	$L36442
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	push	ebx
	mov	ebx, DWORD PTR ___that$[esp+16]
	push	ebp
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [ebx+8]
	push	edi
	mov	DWORD PTR _this$[esp+32], esi
	mov	DWORD PTR [esi], OFFSET FLAT:??_7IMsgTarget@@6B@ ; IMsgTarget::`vftable'
	mov	eax, DWORD PTR [ebx+4]
	mov	DWORD PTR [esi+4], eax
	mov	eax, DWORD PTR [ecx]
	lea	edx, DWORD PTR [esi+8]
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], ecx
	lea	edx, DWORD PTR [ebx+24]
	lea	ecx, DWORD PTR [esi+24]
	xor	eax, eax
	mov	edi, DWORD PTR [edx]
	mov	DWORD PTR __$EHRec$[esp+40], eax
	mov	DWORD PTR [ecx], edi
	mov	edi, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], edi
	mov	edi, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], edi
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [ecx+12], edx
	mov	ecx, DWORD PTR [ebx+40]
	mov	BYTE PTR __$EHRec$[esp+40], 1
	mov	DWORD PTR [esi+40], ecx
	mov	DWORD PTR [esi+44], eax
	mov	ebp, DWORD PTR [ebx+44]
	cmp	ebp, eax
	je	SHORT $L36432
	cmp	BYTE PTR [ebp], 0
	jne	SHORT $L36432
	xor	ebp, ebp
$L36432:
	cmp	ebp, eax
	mov	DWORD PTR [esi+44], eax
	je	SHORT $L36435
	mov	edi, ebp
	or	ecx, -1
	xor	eax, eax
	repne scasb
	not	ecx
	dec	ecx
	mov	edi, ecx
	inc	edi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	edi
	mov	ecx, eax
	call	DWORD PTR [edx]
	test	eax, eax
	mov	DWORD PTR [esi+44], eax
	je	SHORT $L36435
	mov	ecx, eax
$L36437:
	mov	al, BYTE PTR [ebp]
	inc	ebp
	mov	BYTE PTR [ecx], al
	inc	ecx
	test	al, al
	jne	SHORT $L36437
	add	DWORD PTR ?sMemTotal@CCorString@@0KA, edi ; CCorString::sMemTotal
$L36435:
	mov	eax, DWORD PTR [ebx+48]
	pop	edi
	mov	DWORD PTR [esi+48], eax
	mov	ecx, DWORD PTR [ebx+52]
	mov	DWORD PTR [esi+52], ecx
	mov	DWORD PTR [esi], OFFSET FLAT:??_7OCpjRes@@6B@ ; OCpjRes::`vftable'
	mov	dl, BYTE PTR [ebx+56]
	mov	BYTE PTR [esi+56], dl
	mov	eax, DWORD PTR [ebx+60]
	mov	DWORD PTR [esi+60], eax
	mov	ecx, DWORD PTR [ebx+64]
	mov	DWORD PTR [esi+64], ecx
	mov	edx, DWORD PTR [ebx+68]
	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR [esi+68], edx
	mov	DWORD PTR [esi], OFFSET FLAT:??_7OCpjChunk@@6B@ ; OCpjChunk::`vftable'
	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L36380:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1CObjLink@@QAE@XZ			; CObjLink::~CObjLink
$L36381:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	jmp	??1CObjLink@@QAE@XZ			; CObjLink::~CObjLink
$L36442:
	mov	eax, OFFSET FLAT:$T36440
	jmp	___CxxFrameHandler
text$x	ENDS
??0OCpjChunk@@QAE@ABV0@@Z ENDP				; OCpjChunk::OCpjChunk
PUBLIC	??4OCpjChunk@@QAEAAV0@ABV0@@Z			; OCpjChunk::operator=
; Function compile flags: /Ogty
;	COMDAT ??4OCpjChunk@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8
??4OCpjChunk@@QAEAAV0@ABV0@@Z PROC NEAR			; OCpjChunk::operator=, COMDAT
; _this$ = ecx
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR ___that$[esp+4]
	push	esi
	mov	esi, ecx
	push	edi
	mov	eax, DWORD PTR [ebp+4]
	lea	ecx, DWORD PTR [ebp+8]
	mov	DWORD PTR [esi+4], eax
	lea	edx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	lea	eax, DWORD PTR [esi+24]
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], ecx
	lea	edx, DWORD PTR [ebp+24]
	mov	ecx, DWORD PTR [ebp+24]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR [ebp+40]
	mov	DWORD PTR [esi+40], eax
	mov	ebx, DWORD PTR [ebp+44]
	test	ebx, ebx
	je	SHORT $L36499
	cmp	BYTE PTR [ebx], 0
	jne	SHORT $L36499
	xor	ebx, ebx
$L36499:
	mov	edi, DWORD PTR [esi+44]
	test	edi, edi
	je	SHORT $L36500
	or	ecx, -1
	xor	eax, eax
	repne scasb
	mov	eax, DWORD PTR ?sMemTotal@CCorString@@0KA ; CCorString::sMemTotal
	or	edx, -1
	not	ecx
	dec	ecx
	sub	edx, ecx
	add	eax, edx
	mov	DWORD PTR ?sMemTotal@CCorString@@0KA, eax ; CCorString::sMemTotal
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+44]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L36500:
	test	ebx, ebx
	mov	DWORD PTR [esi+44], 0
	je	SHORT $L36503
	mov	edi, ebx
	or	ecx, -1
	xor	eax, eax
	repne scasb
	not	ecx
	dec	ecx
	mov	edi, ecx
	inc	edi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	edi
	mov	ecx, eax
	call	DWORD PTR [edx]
	test	eax, eax
	mov	DWORD PTR [esi+44], eax
	je	SHORT $L36503
$L36505:
	mov	cl, BYTE PTR [ebx]
	inc	ebx
	mov	BYTE PTR [eax], cl
	inc	eax
	test	cl, cl
	jne	SHORT $L36505
	add	DWORD PTR ?sMemTotal@CCorString@@0KA, edi ; CCorString::sMemTotal
$L36503:
	mov	eax, DWORD PTR [ebp+48]
	pop	edi
	mov	DWORD PTR [esi+48], eax
	mov	ecx, DWORD PTR [ebp+52]
	mov	DWORD PTR [esi+52], ecx
	mov	dl, BYTE PTR [ebp+56]
	mov	BYTE PTR [esi+56], dl
	mov	eax, DWORD PTR [ebp+60]
	mov	DWORD PTR [esi+60], eax
	mov	ecx, DWORD PTR [ebp+64]
	mov	DWORD PTR [esi+64], ecx
	mov	edx, DWORD PTR [ebp+68]
	mov	DWORD PTR [esi+68], edx
	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx
	ret	4
??4OCpjChunk@@QAEAAV0@ABV0@@Z ENDP			; OCpjChunk::operator=
; Function compile flags: /Ogty
; File C:\duke4\Cannibal\CorMain.h
_TEXT	ENDS
;	COMDAT ??1?$TCorArray@VVVec3@@@@QAE@XZ
_TEXT	SEGMENT
??1?$TCorArray@VVVec3@@@@QAE@XZ PROC NEAR		; TCorArray<VVec3>::~TCorArray<VVec3>, COMDAT
; _this$ = ecx

; 280  : 	{

	push	esi
	mov	esi, ecx
	push	edi

; 281  : 		Purge();

	mov	edi, DWORD PTR [esi+4]
	test	edi, edi
	je	SHORT $L36536
	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [edi+edi*2]
	shl	eax, 2
	mov	edx, eax
	sub	edx, eax
	add	eax, ecx
	push	edx
	push	eax
	push	ecx
	call	DWORD PTR __imp__memmove
	mov	eax, DWORD PTR [esi+4]
	add	esp, 12					; 0000000cH
	sub	eax, edi
	mov	DWORD PTR [esi+4], eax
$L36536:

; 282  : 	}

	cmp	DWORD PTR [esi], 0
	je	SHORT $L36541
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L36541:
	pop	edi
	pop	esi
	ret	0
??1?$TCorArray@VVVec3@@@@QAE@XZ ENDP			; TCorArray<VVec3>::~TCorArray<VVec3>
_TEXT	ENDS
PUBLIC	??1OCpjChunk@@UAE@XZ				; OCpjChunk::~OCpjChunk
; Function compile flags: /Ogty
;	COMDAT ??1OCpjChunk@@UAE@XZ
_TEXT	SEGMENT
??1OCpjChunk@@UAE@XZ PROC NEAR				; OCpjChunk::~OCpjChunk, COMDAT
; _this$ = ecx
	jmp	??1OObject@@UAE@XZ			; OObject::~OObject
??1OCpjChunk@@UAE@XZ ENDP				; OCpjChunk::~OCpjChunk
_TEXT	ENDS
PUBLIC	??_GOCpjChunk@@UAEPAXI@Z			; OCpjChunk::`scalar deleting destructor'
; Function compile flags: /Ogty
;	COMDAT ??_GOCpjChunk@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_GOCpjChunk@@UAEPAXI@Z PROC NEAR			; OCpjChunk::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1OCpjChunk@@UAE@XZ			; OCpjChunk::~OCpjChunk
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $L36568
	mov	DWORD PTR [esi+4], 0
	mov	edx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	dec	edx
	mov	DWORD PTR ?sObjCount@OObject@@1KA, edx	; OObject::sObjCount
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L36568:
	mov	eax, esi
	pop	esi
	ret	4
??_GOCpjChunk@@UAEPAXI@Z ENDP				; OCpjChunk::`scalar deleting destructor'
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??_EOCpjChunk@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_EOCpjChunk@@UAEPAXI@Z PROC NEAR			; OCpjChunk::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebx
	mov	bl, BYTE PTR ___flags$[esp]
	push	esi
	mov	esi, ecx
	test	bl, 2
	je	SHORT $L7221
	mov	eax, DWORD PTR [esi-4]
	push	edi
	lea	edi, DWORD PTR [esi-4]
	push	OFFSET FLAT:??1OCpjChunk@@UAE@XZ	; OCpjChunk::~OCpjChunk
	push	eax
	push	72					; 00000048H
	push	esi
	call	??_M@YGXPAXIHP6EX0@Z@Z			; `eh vector destructor iterator'
	test	bl, 1
	je	SHORT $L7222
	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L7222:
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	ret	4
$L7221:
	mov	ecx, esi
	call	??1OCpjChunk@@UAE@XZ			; OCpjChunk::~OCpjChunk
	test	bl, 1
	je	SHORT $L36580
	mov	DWORD PTR [esi+4], 0
	mov	edx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	dec	edx
	mov	DWORD PTR ?sObjCount@OObject@@1KA, edx	; OObject::sObjCount
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L36580:
	mov	eax, esi
	pop	esi
	pop	ebx
	ret	4
??_EOCpjChunk@@UAEPAXI@Z ENDP				; OCpjChunk::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??2OCpjUnkChunk@@CAPAXIPAVOObject@@PAVCObjClass@@@Z ; OCpjUnkChunk::operator new
; Function compile flags: /Ogty
; File C:\duke4\Cannibal\CpjMain.h
;	COMDAT ??2OCpjUnkChunk@@CAPAXIPAVOObject@@PAVCObjClass@@@Z
_TEXT	SEGMENT
_inParent$ = 12
_inSetClass$ = 16
??2OCpjUnkChunk@@CAPAXIPAVOObject@@PAVCObjClass@@@Z PROC NEAR ; OCpjUnkChunk::operator new, COMDAT

; 80   : 	OBJ_CLASS_DEFINE(OCpjUnkChunk, OCpjChunk);

	push	esi
	push	edi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	88					; 00000058H
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	ecx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	mov	esi, eax
	inc	ecx
	xor	eax, eax
	mov	DWORD PTR ?sObjCount@OObject@@1KA, ecx	; OObject::sObjCount
	mov	ecx, 22					; 00000016H
	mov	edi, esi
	rep stosd
	mov	eax, DWORD PTR [esi+40]
	mov	DWORD PTR [esi+4], 305419896		; 12345678H
	test	eax, eax
	jne	SHORT $L36594
	mov	eax, DWORD PTR _inSetClass$[esp+4]
	mov	DWORD PTR [esi+40], eax
$L36594:
	mov	ecx, DWORD PTR _inParent$[esp+4]
	push	ecx
	mov	ecx, esi
	call	?PreConstruct@OObject@@QAEXPAV1@@Z	; OObject::PreConstruct
	mov	eax, esi
	pop	edi
	pop	esi
	ret	0
??2OCpjUnkChunk@@CAPAXIPAVOObject@@PAVCObjClass@@@Z ENDP ; OCpjUnkChunk::operator new
_TEXT	ENDS
PUBLIC	??3OCpjUnkChunk@@CAXPAX@Z			; OCpjUnkChunk::operator delete
; Function compile flags: /Ogty
;	COMDAT ??3OCpjUnkChunk@@CAXPAX@Z
_TEXT	SEGMENT
_ptr$ = 8
??3OCpjUnkChunk@@CAXPAX@Z PROC NEAR			; OCpjUnkChunk::operator delete, COMDAT

; 80   : 	OBJ_CLASS_DEFINE(OCpjUnkChunk, OCpjChunk);

	push	esi
	mov	esi, DWORD PTR _ptr$[esp]
	mov	DWORD PTR [esi+4], 0
	mov	edx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	dec	edx
	mov	DWORD PTR ?sObjCount@OObject@@1KA, edx	; OObject::sObjCount
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	ecx, eax
	call	DWORD PTR [edx+8]
	pop	esi
	ret	0
??3OCpjUnkChunk@@CAXPAX@Z ENDP				; OCpjUnkChunk::operator delete
_TEXT	ENDS
PUBLIC	??3OCpjUnkChunk@@CAXPAXPAVOObject@@PAVCObjClass@@@Z ; OCpjUnkChunk::operator delete
; Function compile flags: /Ogty
;	COMDAT ??3OCpjUnkChunk@@CAXPAXPAVOObject@@PAVCObjClass@@@Z
_TEXT	SEGMENT
_ptr$ = 8
??3OCpjUnkChunk@@CAXPAXPAVOObject@@PAVCObjClass@@@Z PROC NEAR ; OCpjUnkChunk::operator delete, COMDAT

; 80   : 	OBJ_CLASS_DEFINE(OCpjUnkChunk, OCpjChunk);

	push	esi
	mov	esi, DWORD PTR _ptr$[esp]
	mov	DWORD PTR [esi+4], 0
	mov	edx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	dec	edx
	mov	DWORD PTR ?sObjCount@OObject@@1KA, edx	; OObject::sObjCount
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	ecx, eax
	call	DWORD PTR [edx+8]
	pop	esi
	ret	0
??3OCpjUnkChunk@@CAXPAXPAVOObject@@PAVCObjClass@@@Z ENDP ; OCpjUnkChunk::operator delete
_TEXT	ENDS
PUBLIC	?GetStaticClass@OCpjUnkChunk@@SAPAVCObjClass@@XZ ; OCpjUnkChunk::GetStaticClass
EXTRN	?staticObjClass@OCpjUnkChunk@@0PAVCObjClass@@A:DWORD ; OCpjUnkChunk::staticObjClass
; Function compile flags: /Ogty
;	COMDAT ?GetStaticClass@OCpjUnkChunk@@SAPAVCObjClass@@XZ
_TEXT	SEGMENT
?GetStaticClass@OCpjUnkChunk@@SAPAVCObjClass@@XZ PROC NEAR ; OCpjUnkChunk::GetStaticClass, COMDAT

; 80   : 	OBJ_CLASS_DEFINE(OCpjUnkChunk, OCpjChunk);

	mov	eax, DWORD PTR ?staticObjClass@OCpjUnkChunk@@0PAVCObjClass@@A ; OCpjUnkChunk::staticObjClass
	ret	0
?GetStaticClass@OCpjUnkChunk@@SAPAVCObjClass@@XZ ENDP	; OCpjUnkChunk::GetStaticClass
_TEXT	ENDS
PUBLIC	?New@OCpjUnkChunk@@SAPAV1@PAVOObject@@PAVCObjClass@@@Z ; OCpjUnkChunk::New
PUBLIC	?GetClass@OCpjUnkChunk@@UAEPAVCObjClass@@XZ	; OCpjUnkChunk::GetClass
PUBLIC	??_7OCpjUnkChunk@@6B@				; OCpjUnkChunk::`vftable'
PUBLIC	??_EOCpjUnkChunk@@UAEPAXI@Z			; OCpjUnkChunk::`vector deleting destructor'
EXTRN	?LoadChunk@OCpjUnkChunk@@UAE_NPAXK@Z:NEAR	; OCpjUnkChunk::LoadChunk
EXTRN	?SaveChunk@OCpjUnkChunk@@UAE_NPAXPAK@Z:NEAR	; OCpjUnkChunk::SaveChunk
;	COMDAT xdata$x
; File C:\duke4\Cannibal\CorMain.h
xdata$x	SEGMENT
$T36723	DD	0ffffffffH
	DD	FLAT:$L36622
	DD	00H
	DD	FLAT:$L36647
$T36721	DD	019930520H
	DD	02H
	DD	FLAT:$T36723
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_7OCpjUnkChunk@@6B@
CONST	SEGMENT
??_7OCpjUnkChunk@@6B@ DD FLAT:?Msg@OObject@@UAE_NPAVIMsg@@@Z ; OCpjUnkChunk::`vftable'
	DD	FLAT:?MsgGetChild@OObject@@UAEPAVIMsgTarget@@PAD@Z
	DD	FLAT:?MsgGetParent@OObject@@UAEPAVIMsgTarget@@XZ
	DD	FLAT:?MsgGetRoot@OObject@@UAEPAVIMsgTarget@@XZ
	DD	FLAT:?GetClass@OCpjUnkChunk@@UAEPAVCObjClass@@XZ
	DD	FLAT:??_EOCpjUnkChunk@@UAEPAXI@Z
	DD	FLAT:?Create@OCpjChunk@@UAEXXZ
	DD	FLAT:?Destroy@OObject@@UAEXXZ
	DD	FLAT:?GetParent@OObject@@UAEPAV1@XZ
	DD	FLAT:?SetParent@OObject@@UAEXPAV1@_N@Z
	DD	FLAT:?HasChildren@OObject@@UAE_NXZ
	DD	FLAT:?IsA@OObject@@UAE_NPAVCObjClass@@@Z
	DD	FLAT:?GetFileExtension@OCpjRes@@UAEPADXZ
	DD	FLAT:?GetFileDescription@OCpjRes@@UAEPADXZ
	DD	FLAT:?LoadFile@OCpjChunk@@UAE_NPAD@Z
	DD	FLAT:?SaveFile@OCpjChunk@@UAE_NPAD@Z
	DD	FLAT:?GetFourCC@OCpjChunk@@UAEKXZ
	DD	FLAT:?LoadChunk@OCpjUnkChunk@@UAE_NPAXK@Z
	DD	FLAT:?SaveChunk@OCpjUnkChunk@@UAE_NPAXPAK@Z
; Function compile flags: /Ogty
; File C:\duke4\Cannibal\CpjMain.h
CONST	ENDS
;	COMDAT ?New@OCpjUnkChunk@@SAPAV1@PAVOObject@@PAVCObjClass@@@Z
_TEXT	SEGMENT
$T36619 = -16
_inParent$ = 8
_inSetClass$ = 12
__$EHRec$ = -12
?New@OCpjUnkChunk@@SAPAV1@PAVOObject@@PAVCObjClass@@@Z PROC NEAR ; OCpjUnkChunk::New, COMDAT

; 80   : 	OBJ_CLASS_DEFINE(OCpjUnkChunk, OCpjChunk);

	push	-1
	push	$L36722
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	push	ebx
	mov	ebx, DWORD PTR _inSetClass$[esp+16]
	push	ebp
	xor	ebp, ebp
	cmp	ebx, ebp
	push	esi
	jne	SHORT $L7324
	mov	ebx, DWORD PTR ?staticObjClass@OCpjUnkChunk@@0PAVCObjClass@@A ; OCpjUnkChunk::staticObjClass
	mov	DWORD PTR _inSetClass$[esp+24], ebx
$L7324:
	push	edi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	88					; 00000058H
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	ecx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	mov	esi, eax
	inc	ecx
	xor	eax, eax
	mov	DWORD PTR ?sObjCount@OObject@@1KA, ecx	; OObject::sObjCount
	mov	ecx, 22					; 00000016H
	mov	edi, esi
	rep stosd
	mov	eax, DWORD PTR [esi+40]
	mov	DWORD PTR [esi+4], 305419896		; 12345678H
	cmp	eax, ebp
	pop	edi
	jne	SHORT $L36642
	mov	DWORD PTR [esi+40], ebx
$L36642:
	mov	eax, DWORD PTR _inParent$[esp+24]
	mov	ecx, esi
	push	eax
	call	?PreConstruct@OObject@@QAEXPAV1@@Z	; OObject::PreConstruct
	mov	DWORD PTR $T36619[esp+28], esi
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+36], ebp
	call	??0OObject@@QAE@XZ			; OObject::OObject
	mov	DWORD PTR [esi+76], ebp
	mov	DWORD PTR [esi+80], ebp
	mov	DWORD PTR [esi+84], 1
	mov	DWORD PTR [esi+72], ebp
	mov	DWORD PTR [esi], OFFSET FLAT:??_7OCpjUnkChunk@@6B@ ; OCpjUnkChunk::`vftable'
	mov	edx, DWORD PTR [esi]
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+36], -1
	call	DWORD PTR [edx+24]
	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L36622:
	mov	eax, DWORD PTR _inSetClass$[ebp-4]
	push	eax
	mov	ecx, DWORD PTR _inParent$[ebp-4]
	push	ecx
	mov	edx, DWORD PTR $T36619[ebp]
	push	edx
	call	??3OCpjUnkChunk@@CAXPAXPAVOObject@@PAVCObjClass@@@Z ; OCpjUnkChunk::operator delete
	add	esp, 12					; 0000000cH
	ret	0
$L36647:
	mov	ecx, DWORD PTR $T36619[ebp]
	jmp	??1OCpjChunk@@UAE@XZ			; OCpjChunk::~OCpjChunk
$L36722:
	mov	eax, OFFSET FLAT:$T36721
	jmp	___CxxFrameHandler
text$x	ENDS
?New@OCpjUnkChunk@@SAPAV1@PAVOObject@@PAVCObjClass@@@Z ENDP ; OCpjUnkChunk::New
; Function compile flags: /Ogty
;	COMDAT ?GetClass@OCpjUnkChunk@@UAEPAVCObjClass@@XZ
_TEXT	SEGMENT
?GetClass@OCpjUnkChunk@@UAEPAVCObjClass@@XZ PROC NEAR	; OCpjUnkChunk::GetClass, COMDAT
; _this$ = ecx

; 80   : 	OBJ_CLASS_DEFINE(OCpjUnkChunk, OCpjChunk);

	mov	eax, DWORD PTR [ecx+40]
	ret	0
?GetClass@OCpjUnkChunk@@UAEPAVCObjClass@@XZ ENDP	; OCpjUnkChunk::GetClass
_TEXT	ENDS
PUBLIC	??0OCpjUnkChunk@@QAE@XZ				; OCpjUnkChunk::OCpjUnkChunk
;	COMDAT xdata$x
xdata$x	SEGMENT
$T36788	DD	0ffffffffH
	DD	FLAT:$L36732
$T36786	DD	019930520H
	DD	01H
	DD	FLAT:$T36788
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ??0OCpjUnkChunk@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12
_this$ = -20
??0OCpjUnkChunk@@QAE@XZ PROC NEAR			; OCpjUnkChunk::OCpjUnkChunk, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR fs:__except_list
	push	-1
	push	$L36787
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	esi
	mov	esi, ecx
	call	??0OObject@@QAE@XZ			; OObject::OObject
	mov	ecx, DWORD PTR __$EHRec$[esp+16]
	xor	eax, eax
	mov	DWORD PTR [esi+76], eax
	mov	DWORD PTR [esi+80], eax
	mov	DWORD PTR [esi+84], 1
	mov	DWORD PTR [esi+72], eax
	mov	DWORD PTR [esi], OFFSET FLAT:??_7OCpjUnkChunk@@6B@ ; OCpjUnkChunk::`vftable'
	mov	eax, esi
	mov	DWORD PTR fs:__except_list, ecx
	pop	esi
	add	esp, 12					; 0000000cH
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L36732:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1OCpjChunk@@UAE@XZ			; OCpjChunk::~OCpjChunk
$L36787:
	mov	eax, OFFSET FLAT:$T36786
	jmp	___CxxFrameHandler
text$x	ENDS
??0OCpjUnkChunk@@QAE@XZ ENDP				; OCpjUnkChunk::OCpjUnkChunk
PUBLIC	??0OCpjUnkChunk@@QAE@AAV0@@Z			; OCpjUnkChunk::OCpjUnkChunk
;	COMDAT xdata$x
xdata$x	SEGMENT
$T36892	DD	0ffffffffH
	DD	FLAT:$L36801
	DD	00H
	DD	FLAT:$L36802
	DD	0ffffffffH
	DD	FLAT:$L36794
	DD	02H
	DD	FLAT:$L36841
$T36887	DD	019930520H
	DD	04H
	DD	FLAT:$T36892
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ??0OCpjUnkChunk@@QAE@AAV0@@Z
_TEXT	SEGMENT
___that$ = 8
_this$ = -20
_i$36880 = 8
$T36884 = -16
__$EHRec$ = -12
??0OCpjUnkChunk@@QAE@AAV0@@Z PROC NEAR			; OCpjUnkChunk::OCpjUnkChunk, COMDAT
; _this$ = ecx
	push	-1
	push	$L36891
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 8
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, DWORD PTR ___that$[esp+32]
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+36], esi
	mov	DWORD PTR [esi], OFFSET FLAT:??_7IMsgTarget@@6B@ ; IMsgTarget::`vftable'
	mov	eax, DWORD PTR [edi+4]
	lea	ecx, DWORD PTR [edi+8]
	mov	DWORD PTR [esi+4], eax
	lea	edx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], ecx
	lea	edx, DWORD PTR [edi+24]
	lea	eax, DWORD PTR [esi+24]
	xor	ebx, ebx
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR __$EHRec$[esp+44], ebx
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR [edi+40]
	lea	ecx, DWORD PTR [esi+44]
	mov	DWORD PTR [esi+40], eax
	mov	BYTE PTR __$EHRec$[esp+44], 1
	mov	DWORD PTR [ecx], ebx
	mov	edx, DWORD PTR [edi+44]
	push	edx
	call	?Set@CCorString@@QAEXPAD@Z		; CCorString::Set
	mov	eax, DWORD PTR [edi+48]
	mov	DWORD PTR [esi+48], eax
	mov	ecx, DWORD PTR [edi+52]
	mov	DWORD PTR [esi+52], ecx
	mov	DWORD PTR [esi], OFFSET FLAT:??_7OCpjRes@@6B@ ; OCpjRes::`vftable'
	mov	dl, BYTE PTR [edi+56]
	mov	BYTE PTR [esi+56], dl
	mov	eax, DWORD PTR [edi+60]
	mov	DWORD PTR [esi+60], eax
	mov	ecx, DWORD PTR [edi+64]
	mov	DWORD PTR [esi+64], ecx
	mov	edx, DWORD PTR [edi+68]
	mov	DWORD PTR [esi+68], edx
	mov	DWORD PTR [esi], OFFSET FLAT:??_7OCpjChunk@@6B@ ; OCpjChunk::`vftable'
	mov	eax, DWORD PTR [edi+76]
	lea	ebp, DWORD PTR [esi+72]
	push	1
	mov	ecx, ebp
	mov	DWORD PTR __$EHRec$[esp+48], 2
	mov	DWORD PTR $T36884[esp+40], ebp
	mov	DWORD PTR [ebp], ebx
	mov	DWORD PTR [ebp+4], eax
	mov	DWORD PTR [ebp+8], eax
	mov	DWORD PTR [ebp+12], 1
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
	mov	DWORD PTR [ebp+4], ebx
	mov	eax, DWORD PTR [edi+76]
	xor	ecx, ecx
	cmp	eax, ebx
	mov	BYTE PTR __$EHRec$[esp+44], 3
	mov	DWORD PTR _i$36880[esp+32], ecx
	jbe	SHORT $L36890
$L36881:
	mov	ebx, DWORD PTR [ebp+4]
	mov	edx, DWORD PTR [ebp+8]
	lea	eax, DWORD PTR [ebx+1]
	cmp	eax, edx
	mov	DWORD PTR [ebp+4], eax
	jbe	SHORT $L36872
	mov	ecx, eax
	push	1
	shr	ecx, 2
	lea	edx, DWORD PTR [ecx+eax+32]
	mov	ecx, ebp
	mov	DWORD PTR [ebp+8], edx
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
	mov	ecx, DWORD PTR _i$36880[esp+32]
$L36872:
	mov	eax, DWORD PTR [ebp]
	add	eax, ebx
	je	SHORT $L36865
	mov	edx, DWORD PTR [edi+72]
	mov	dl, BYTE PTR [ecx+edx]
	mov	BYTE PTR [eax], dl
$L36865:
	mov	eax, DWORD PTR [edi+76]
	inc	ecx
	cmp	ecx, eax
	mov	DWORD PTR _i$36880[esp+32], ecx
	jb	SHORT $L36881
$L36890:
	mov	ecx, DWORD PTR __$EHRec$[esp+36]
	mov	DWORD PTR [esi], OFFSET FLAT:??_7OCpjUnkChunk@@6B@ ; OCpjUnkChunk::`vftable'
	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 20					; 00000014H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L36801:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1CObjLink@@QAE@XZ			; CObjLink::~CObjLink
$L36802:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	jmp	??1CObjLink@@QAE@XZ			; CObjLink::~CObjLink
$L36794:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1OCpjChunk@@UAE@XZ			; OCpjChunk::~OCpjChunk
$L36841:
	mov	ecx, DWORD PTR $T36884[ebp]
	jmp	??1CCorArray@@IAE@XZ			; CCorArray::~CCorArray
$L36891:
	mov	eax, OFFSET FLAT:$T36887
	jmp	___CxxFrameHandler
text$x	ENDS
??0OCpjUnkChunk@@QAE@AAV0@@Z ENDP			; OCpjUnkChunk::OCpjUnkChunk
PUBLIC	??4?$TCorArray@E@@QAEAAV0@AAV0@@Z		; TCorArray<unsigned char>::operator=
PUBLIC	??4OCpjUnkChunk@@QAEAAV0@AAV0@@Z		; OCpjUnkChunk::operator=
; Function compile flags: /Ogty
;	COMDAT ??4OCpjUnkChunk@@QAEAAV0@AAV0@@Z
_TEXT	SEGMENT
___that$ = 8
??4OCpjUnkChunk@@QAEAAV0@AAV0@@Z PROC NEAR		; OCpjUnkChunk::operator=, COMDAT
; _this$ = ecx
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR ___that$[esp+4]
	push	esi
	mov	esi, ecx
	push	edi
	mov	eax, DWORD PTR [ebp+4]
	lea	ecx, DWORD PTR [ebp+8]
	mov	DWORD PTR [esi+4], eax
	lea	edx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	lea	eax, DWORD PTR [esi+24]
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], ecx
	lea	edx, DWORD PTR [ebp+24]
	mov	ecx, DWORD PTR [ebp+24]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR [ebp+40]
	mov	DWORD PTR [esi+40], eax
	mov	ebx, DWORD PTR [ebp+44]
	test	ebx, ebx
	je	SHORT $L36967
	cmp	BYTE PTR [ebx], 0
	jne	SHORT $L36967
	xor	ebx, ebx
$L36967:
	mov	edi, DWORD PTR [esi+44]
	test	edi, edi
	je	SHORT $L36968
	or	ecx, -1
	xor	eax, eax
	repne scasb
	mov	eax, DWORD PTR ?sMemTotal@CCorString@@0KA ; CCorString::sMemTotal
	or	edx, -1
	not	ecx
	dec	ecx
	sub	edx, ecx
	add	eax, edx
	mov	DWORD PTR ?sMemTotal@CCorString@@0KA, eax ; CCorString::sMemTotal
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+44]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L36968:
	test	ebx, ebx
	mov	DWORD PTR [esi+44], 0
	je	SHORT $L36971
	mov	edi, ebx
	or	ecx, -1
	xor	eax, eax
	repne scasb
	not	ecx
	dec	ecx
	mov	edi, ecx
	inc	edi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	edi
	mov	ecx, eax
	call	DWORD PTR [edx]
	test	eax, eax
	mov	DWORD PTR [esi+44], eax
	je	SHORT $L36971
$L36965:
	mov	cl, BYTE PTR [ebx]
	inc	ebx
	mov	BYTE PTR [eax], cl
	inc	eax
	test	cl, cl
	jne	SHORT $L36965
	add	DWORD PTR ?sMemTotal@CCorString@@0KA, edi ; CCorString::sMemTotal
$L36971:
	mov	eax, DWORD PTR [ebp+48]
	add	ebp, 72					; 00000048H
	mov	DWORD PTR [esi+48], eax
	mov	ecx, DWORD PTR [ebp-20]
	mov	DWORD PTR [esi+52], ecx
	mov	dl, BYTE PTR [ebp-16]
	mov	BYTE PTR [esi+56], dl
	mov	eax, DWORD PTR [ebp-12]
	mov	DWORD PTR [esi+60], eax
	mov	ecx, DWORD PTR [ebp-8]
	mov	DWORD PTR [esi+64], ecx
	mov	edx, DWORD PTR [ebp-4]
	push	ebp
	lea	ecx, DWORD PTR [esi+72]
	mov	DWORD PTR [esi+68], edx
	call	??4?$TCorArray@E@@QAEAAV0@AAV0@@Z	; TCorArray<unsigned char>::operator=
	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	4
??4OCpjUnkChunk@@QAEAAV0@AAV0@@Z ENDP			; OCpjUnkChunk::operator=
; Function compile flags: /Ogty
; File C:\duke4\Cannibal\CorMain.h
_TEXT	ENDS
;	COMDAT ??4?$TCorArray@E@@QAEAAV0@AAV0@@Z
_TEXT	SEGMENT
_inArray$ = 8
??4?$TCorArray@E@@QAEAAV0@AAV0@@Z PROC NEAR		; TCorArray<unsigned char>::operator=, COMDAT
; _this$ = ecx

; 269  : 	{

	push	ebp

; 270  : 		if (this == &inArray)

	mov	ebp, DWORD PTR _inArray$[esp]
	push	esi
	mov	esi, ecx
	cmp	esi, ebp

; 271  : 			return(*this);

	je	$L37012
	push	ebx

; 272  : 		m_Count = 0;

	xor	ebx, ebx
	mov	DWORD PTR [esi+4], ebx

; 273  : 		m_Limit = inArray.m_Count;

	mov	eax, DWORD PTR [ebp+4]
	mov	DWORD PTR [esi+8], eax

; 274  : 		Realloc(sizeof(T));

	mov	eax, DWORD PTR [esi]
	cmp	eax, ebx
	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [esi+12], 1
	je	SHORT $L36988
	cmp	eax, ebx
	je	SHORT $L36990
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [esi+8]
	push	ecx
	mov	ecx, DWORD PTR [esi]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+4]
	mov	DWORD PTR [esi], eax
	jmp	SHORT $L36995
$L36990:
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L36994:
	mov	DWORD PTR [esi], ebx
$L36995:

; 275  : 		for (NDword i=0;i<inArray.m_Count;i++)

	cmp	DWORD PTR [ebp+4], ebx
	jbe	SHORT $L13509
	push	edi
$L13507:

; 276  : 			new(&(*this)[AddNoConstruct()]) T(inArray[i]);

	mov	edi, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	lea	eax, DWORD PTR [edi+1]
	cmp	eax, ecx
	mov	DWORD PTR [esi+4], eax
	jbe	SHORT $L37000
	mov	edx, eax
	push	1
	shr	edx, 2
	mov	ecx, esi
	lea	eax, DWORD PTR [edx+eax+32]
	mov	DWORD PTR [esi+8], eax
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
$L37000:
	mov	eax, DWORD PTR [esi]
	add	eax, edi
	je	SHORT $L36982
	mov	ecx, DWORD PTR [ebp]
	mov	dl, BYTE PTR [ebx+ecx]
	mov	BYTE PTR [eax], dl
$L36982:
	mov	eax, DWORD PTR [ebp+4]
	inc	ebx
	cmp	ebx, eax
	jb	SHORT $L13507
	pop	edi
$L13509:
	pop	ebx
$L37012:

; 277  : 		return(*this);

	mov	eax, esi
	pop	esi
	pop	ebp

; 278  : 	}

	ret	4
$L36988:

; 274  : 		Realloc(sizeof(T));

	cmp	eax, ebx
	je	SHORT $L36994
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [esi+8]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	DWORD PTR [esi], eax
	jmp	SHORT $L36995
??4?$TCorArray@E@@QAEAAV0@AAV0@@Z ENDP			; TCorArray<unsigned char>::operator=
_TEXT	ENDS
PUBLIC	??1OCpjUnkChunk@@UAE@XZ				; OCpjUnkChunk::~OCpjUnkChunk
;	COMDAT xdata$x
xdata$x	SEGMENT
$T37083	DD	0ffffffffH
	DD	FLAT:$L37016
$T37079	DD	019930520H
	DD	01H
	DD	FLAT:$T37083
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ??1OCpjUnkChunk@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16
__$EHRec$ = -12
??1OCpjUnkChunk@@UAE@XZ PROC NEAR			; OCpjUnkChunk::~OCpjUnkChunk, COMDAT
; _this$ = ecx
	push	-1
	push	$L37082
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	push	esi
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+24], esi
	mov	edi, DWORD PTR [esi+76]
	mov	DWORD PTR __$EHRec$[esp+32], 0
	test	edi, edi
	je	SHORT $L37057
	mov	eax, DWORD PTR [esi+72]
	mov	ecx, edi
	sub	ecx, edi
	lea	edx, DWORD PTR [eax+edi]
	push	ecx
	push	edx
	push	eax
	call	DWORD PTR __imp__memmove
	mov	eax, DWORD PTR [esi+76]
	add	esp, 12					; 0000000cH
	sub	eax, edi
	mov	DWORD PTR [esi+76], eax
$L37057:
	mov	eax, DWORD PTR [esi+72]
	test	eax, eax
	je	SHORT $L37066
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+72]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L37066:
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+32], -1
	call	??1OObject@@UAE@XZ			; OObject::~OObject
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L37016:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1OCpjChunk@@UAE@XZ			; OCpjChunk::~OCpjChunk
$L37082:
	mov	eax, OFFSET FLAT:$T37079
	jmp	___CxxFrameHandler
text$x	ENDS
??1OCpjUnkChunk@@UAE@XZ ENDP				; OCpjUnkChunk::~OCpjUnkChunk
PUBLIC	??_GOCpjUnkChunk@@UAEPAXI@Z			; OCpjUnkChunk::`scalar deleting destructor'
; Function compile flags: /Ogty
;	COMDAT ??_GOCpjUnkChunk@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_GOCpjUnkChunk@@UAEPAXI@Z PROC NEAR			; OCpjUnkChunk::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1OCpjUnkChunk@@UAE@XZ			; OCpjUnkChunk::~OCpjUnkChunk
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $L37101
	mov	DWORD PTR [esi+4], 0
	mov	edx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	dec	edx
	mov	DWORD PTR ?sObjCount@OObject@@1KA, edx	; OObject::sObjCount
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L37101:
	mov	eax, esi
	pop	esi
	ret	4
??_GOCpjUnkChunk@@UAEPAXI@Z ENDP			; OCpjUnkChunk::`scalar deleting destructor'
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??_EOCpjUnkChunk@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_EOCpjUnkChunk@@UAEPAXI@Z PROC NEAR			; OCpjUnkChunk::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebx
	mov	bl, BYTE PTR ___flags$[esp]
	push	esi
	mov	esi, ecx
	test	bl, 2
	je	SHORT $L7351
	mov	eax, DWORD PTR [esi-4]
	push	edi
	lea	edi, DWORD PTR [esi-4]
	push	OFFSET FLAT:??1OCpjUnkChunk@@UAE@XZ	; OCpjUnkChunk::~OCpjUnkChunk
	push	eax
	push	88					; 00000058H
	push	esi
	call	??_M@YGXPAXIHP6EX0@Z@Z			; `eh vector destructor iterator'
	test	bl, 1
	je	SHORT $L7352
	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L7352:
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	ret	4
$L7351:
	mov	ecx, esi
	call	??1OCpjUnkChunk@@UAE@XZ			; OCpjUnkChunk::~OCpjUnkChunk
	test	bl, 1
	je	SHORT $L37111
	mov	DWORD PTR [esi+4], 0
	mov	edx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	dec	edx
	mov	DWORD PTR ?sObjCount@OObject@@1KA, edx	; OObject::sObjCount
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L37111:
	mov	eax, esi
	pop	esi
	pop	ebx
	ret	4
??_EOCpjUnkChunk@@UAEPAXI@Z ENDP			; OCpjUnkChunk::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??2OCpjImporter@@CAPAXIPAVOObject@@PAVCObjClass@@@Z ; OCpjImporter::operator new
; Function compile flags: /Ogty
; File C:\duke4\Cannibal\CpjMain.h
;	COMDAT ??2OCpjImporter@@CAPAXIPAVOObject@@PAVCObjClass@@@Z
_TEXT	SEGMENT
_inParent$ = 12
_inSetClass$ = 16
??2OCpjImporter@@CAPAXIPAVOObject@@PAVCObjClass@@@Z PROC NEAR ; OCpjImporter::operator new, COMDAT

; 97   : 	OBJ_CLASS_DEFINE(OCpjImporter, OObject);

	push	esi
	push	edi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	56					; 00000038H
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	ecx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	mov	esi, eax
	inc	ecx
	xor	eax, eax
	mov	DWORD PTR ?sObjCount@OObject@@1KA, ecx	; OObject::sObjCount
	mov	ecx, 14					; 0000000eH
	mov	edi, esi
	rep stosd
	mov	eax, DWORD PTR [esi+40]
	mov	DWORD PTR [esi+4], 305419896		; 12345678H
	test	eax, eax
	jne	SHORT $L37127
	mov	eax, DWORD PTR _inSetClass$[esp+4]
	mov	DWORD PTR [esi+40], eax
$L37127:
	mov	ecx, DWORD PTR _inParent$[esp+4]
	push	ecx
	mov	ecx, esi
	call	?PreConstruct@OObject@@QAEXPAV1@@Z	; OObject::PreConstruct
	mov	eax, esi
	pop	edi
	pop	esi
	ret	0
??2OCpjImporter@@CAPAXIPAVOObject@@PAVCObjClass@@@Z ENDP ; OCpjImporter::operator new
_TEXT	ENDS
PUBLIC	??3OCpjImporter@@CAXPAX@Z			; OCpjImporter::operator delete
; Function compile flags: /Ogty
;	COMDAT ??3OCpjImporter@@CAXPAX@Z
_TEXT	SEGMENT
_ptr$ = 8
??3OCpjImporter@@CAXPAX@Z PROC NEAR			; OCpjImporter::operator delete, COMDAT

; 97   : 	OBJ_CLASS_DEFINE(OCpjImporter, OObject);

	push	esi
	mov	esi, DWORD PTR _ptr$[esp]
	mov	DWORD PTR [esi+4], 0
	mov	edx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	dec	edx
	mov	DWORD PTR ?sObjCount@OObject@@1KA, edx	; OObject::sObjCount
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	ecx, eax
	call	DWORD PTR [edx+8]
	pop	esi
	ret	0
??3OCpjImporter@@CAXPAX@Z ENDP				; OCpjImporter::operator delete
_TEXT	ENDS
PUBLIC	??3OCpjImporter@@CAXPAXPAVOObject@@PAVCObjClass@@@Z ; OCpjImporter::operator delete
; Function compile flags: /Ogty
;	COMDAT ??3OCpjImporter@@CAXPAXPAVOObject@@PAVCObjClass@@@Z
_TEXT	SEGMENT
_ptr$ = 8
??3OCpjImporter@@CAXPAXPAVOObject@@PAVCObjClass@@@Z PROC NEAR ; OCpjImporter::operator delete, COMDAT

; 97   : 	OBJ_CLASS_DEFINE(OCpjImporter, OObject);

	push	esi
	mov	esi, DWORD PTR _ptr$[esp]
	mov	DWORD PTR [esi+4], 0
	mov	edx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	dec	edx
	mov	DWORD PTR ?sObjCount@OObject@@1KA, edx	; OObject::sObjCount
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	ecx, eax
	call	DWORD PTR [edx+8]
	pop	esi
	ret	0
??3OCpjImporter@@CAXPAXPAVOObject@@PAVCObjClass@@@Z ENDP ; OCpjImporter::operator delete
_TEXT	ENDS
PUBLIC	?GetStaticClass@OCpjImporter@@SAPAVCObjClass@@XZ ; OCpjImporter::GetStaticClass
EXTRN	?staticObjClass@OCpjImporter@@0PAVCObjClass@@A:DWORD ; OCpjImporter::staticObjClass
; Function compile flags: /Ogty
;	COMDAT ?GetStaticClass@OCpjImporter@@SAPAVCObjClass@@XZ
_TEXT	SEGMENT
?GetStaticClass@OCpjImporter@@SAPAVCObjClass@@XZ PROC NEAR ; OCpjImporter::GetStaticClass, COMDAT

; 97   : 	OBJ_CLASS_DEFINE(OCpjImporter, OObject);

	mov	eax, DWORD PTR ?staticObjClass@OCpjImporter@@0PAVCObjClass@@A ; OCpjImporter::staticObjClass
	ret	0
?GetStaticClass@OCpjImporter@@SAPAVCObjClass@@XZ ENDP	; OCpjImporter::GetStaticClass
_TEXT	ENDS
PUBLIC	?New@OCpjImporter@@SAPAV1@PAVOObject@@PAVCObjClass@@@Z ; OCpjImporter::New
PUBLIC	?GetClass@OCpjImporter@@UAEPAVCObjClass@@XZ	; OCpjImporter::GetClass
PUBLIC	?GetImportClass@OCpjImporter@@UAEPAVCObjClass@@XZ ; OCpjImporter::GetImportClass
PUBLIC	?GetFileExtension@OCpjImporter@@UAEPADXZ	; OCpjImporter::GetFileExtension
PUBLIC	?GetFileDescription@OCpjImporter@@UAEPADXZ	; OCpjImporter::GetFileDescription
PUBLIC	?Configure@OCpjImporter@@UAE_NPAVOObject@@PAD@Z	; OCpjImporter::Configure
PUBLIC	?Import@OCpjImporter@@UAE_NPAVOObject@@PAD1@Z	; OCpjImporter::Import
PUBLIC	??_7OCpjImporter@@6B@				; OCpjImporter::`vftable'
PUBLIC	??_EOCpjImporter@@UAEPAXI@Z			; OCpjImporter::`vector deleting destructor'
;	COMDAT xdata$x
xdata$x	SEGMENT
$T37186	DD	0ffffffffH
	DD	FLAT:$L37155
$T37184	DD	019930520H
	DD	01H
	DD	FLAT:$T37186
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_7OCpjImporter@@6B@
CONST	SEGMENT
??_7OCpjImporter@@6B@ DD FLAT:?Msg@OObject@@UAE_NPAVIMsg@@@Z ; OCpjImporter::`vftable'
	DD	FLAT:?MsgGetChild@OObject@@UAEPAVIMsgTarget@@PAD@Z
	DD	FLAT:?MsgGetParent@OObject@@UAEPAVIMsgTarget@@XZ
	DD	FLAT:?MsgGetRoot@OObject@@UAEPAVIMsgTarget@@XZ
	DD	FLAT:?GetClass@OCpjImporter@@UAEPAVCObjClass@@XZ
	DD	FLAT:??_EOCpjImporter@@UAEPAXI@Z
	DD	FLAT:?Create@OObject@@UAEXXZ
	DD	FLAT:?Destroy@OObject@@UAEXXZ
	DD	FLAT:?GetParent@OObject@@UAEPAV1@XZ
	DD	FLAT:?SetParent@OObject@@UAEXPAV1@_N@Z
	DD	FLAT:?HasChildren@OObject@@UAE_NXZ
	DD	FLAT:?IsA@OObject@@UAE_NPAVCObjClass@@@Z
	DD	FLAT:?GetImportClass@OCpjImporter@@UAEPAVCObjClass@@XZ
	DD	FLAT:?GetFileExtension@OCpjImporter@@UAEPADXZ
	DD	FLAT:?GetFileDescription@OCpjImporter@@UAEPADXZ
	DD	FLAT:?Configure@OCpjImporter@@UAE_NPAVOObject@@PAD@Z
	DD	FLAT:?Import@OCpjImporter@@UAE_NPAVOObject@@PAD1@Z
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?New@OCpjImporter@@SAPAV1@PAVOObject@@PAVCObjClass@@@Z
_TEXT	SEGMENT
_inParent$ = 8
_inSetClass$ = 12
$T37152 = -16
__$EHRec$ = -12
?New@OCpjImporter@@SAPAV1@PAVOObject@@PAVCObjClass@@@Z PROC NEAR ; OCpjImporter::New, COMDAT

; 97   : 	OBJ_CLASS_DEFINE(OCpjImporter, OObject);

	push	-1
	push	$L37185
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	push	ebx
	mov	ebx, DWORD PTR _inSetClass$[esp+16]
	test	ebx, ebx
	push	esi
	jne	SHORT $L7411
	mov	ebx, DWORD PTR ?staticObjClass@OCpjImporter@@0PAVCObjClass@@A ; OCpjImporter::staticObjClass
	mov	DWORD PTR _inSetClass$[esp+20], ebx
$L7411:
	push	edi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	56					; 00000038H
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	ecx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	mov	esi, eax
	inc	ecx
	xor	eax, eax
	mov	DWORD PTR ?sObjCount@OObject@@1KA, ecx	; OObject::sObjCount
	mov	ecx, 14					; 0000000eH
	mov	edi, esi
	rep stosd
	mov	eax, DWORD PTR [esi+40]
	mov	DWORD PTR [esi+4], 305419896		; 12345678H
	test	eax, eax
	pop	edi
	jne	SHORT $L37177
	mov	DWORD PTR [esi+40], ebx
$L37177:
	mov	eax, DWORD PTR _inParent$[esp+20]
	mov	ecx, esi
	push	eax
	call	?PreConstruct@OObject@@QAEXPAV1@@Z	; OObject::PreConstruct
	mov	DWORD PTR $T37152[esp+24], esi
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+32], 0
	call	??0OObject@@QAE@XZ			; OObject::OObject
	mov	DWORD PTR [esi], OFFSET FLAT:??_7OCpjImporter@@6B@ ; OCpjImporter::`vftable'
	mov	edx, DWORD PTR [esi]
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+32], -1
	call	DWORD PTR [edx+24]
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	eax, esi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L37155:
	mov	eax, DWORD PTR _inSetClass$[ebp-4]
	push	eax
	mov	ecx, DWORD PTR _inParent$[ebp-4]
	push	ecx
	mov	edx, DWORD PTR $T37152[ebp]
	push	edx
	call	??3OCpjImporter@@CAXPAXPAVOObject@@PAVCObjClass@@@Z ; OCpjImporter::operator delete
	add	esp, 12					; 0000000cH
	ret	0
$L37185:
	mov	eax, OFFSET FLAT:$T37184
	jmp	___CxxFrameHandler
text$x	ENDS
?New@OCpjImporter@@SAPAV1@PAVOObject@@PAVCObjClass@@@Z ENDP ; OCpjImporter::New
; Function compile flags: /Ogty
;	COMDAT ?GetClass@OCpjImporter@@UAEPAVCObjClass@@XZ
_TEXT	SEGMENT
?GetClass@OCpjImporter@@UAEPAVCObjClass@@XZ PROC NEAR	; OCpjImporter::GetClass, COMDAT
; _this$ = ecx

; 97   : 	OBJ_CLASS_DEFINE(OCpjImporter, OObject);

	mov	eax, DWORD PTR [ecx+40]
	ret	0
?GetClass@OCpjImporter@@UAEPAVCObjClass@@XZ ENDP	; OCpjImporter::GetClass
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?GetImportClass@OCpjImporter@@UAEPAVCObjClass@@XZ
_TEXT	SEGMENT
?GetImportClass@OCpjImporter@@UAEPAVCObjClass@@XZ PROC NEAR ; OCpjImporter::GetImportClass, COMDAT
; _this$ = ecx

; 99   : 	virtual CObjClass* GetImportClass() { return(NULL); }

	xor	eax, eax
	ret	0
?GetImportClass@OCpjImporter@@UAEPAVCObjClass@@XZ ENDP	; OCpjImporter::GetImportClass
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?GetFileExtension@OCpjImporter@@UAEPADXZ
_TEXT	SEGMENT
?GetFileExtension@OCpjImporter@@UAEPADXZ PROC NEAR	; OCpjImporter::GetFileExtension, COMDAT
; _this$ = ecx

; 100  : 	virtual NChar* GetFileExtension() { return(NULL); }

	xor	eax, eax
	ret	0
?GetFileExtension@OCpjImporter@@UAEPADXZ ENDP		; OCpjImporter::GetFileExtension
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?GetFileDescription@OCpjImporter@@UAEPADXZ
_TEXT	SEGMENT
?GetFileDescription@OCpjImporter@@UAEPADXZ PROC NEAR	; OCpjImporter::GetFileDescription, COMDAT
; _this$ = ecx

; 101  : 	virtual NChar* GetFileDescription() { return(NULL); }

	xor	eax, eax
	ret	0
?GetFileDescription@OCpjImporter@@UAEPADXZ ENDP		; OCpjImporter::GetFileDescription
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?Configure@OCpjImporter@@UAE_NPAVOObject@@PAD@Z
_TEXT	SEGMENT
?Configure@OCpjImporter@@UAE_NPAVOObject@@PAD@Z PROC NEAR ; OCpjImporter::Configure, COMDAT
; _this$ = ecx

; 102  : 	virtual NBool Configure(OObject* inRes, NChar* inFileName) { return(1); }

	mov	al, 1
	ret	8
?Configure@OCpjImporter@@UAE_NPAVOObject@@PAD@Z ENDP	; OCpjImporter::Configure
_TEXT	ENDS
PUBLIC	??_C@_0BB@OEJH@Invalid?5importer?$AA@		; `string'
;	COMDAT ??_C@_0BB@OEJH@Invalid?5importer?$AA@
_DATA	SEGMENT
??_C@_0BB@OEJH@Invalid?5importer?$AA@ DB 'Invalid importer', 00H ; `string'
; Function compile flags: /Ogty
_DATA	ENDS
;	COMDAT ?Import@OCpjImporter@@UAE_NPAVOObject@@PAD1@Z
_TEXT	SEGMENT
_outError$ = 16
?Import@OCpjImporter@@UAE_NPAVOObject@@PAD1@Z PROC NEAR	; OCpjImporter::Import, COMDAT
; _this$ = ecx

; 105  : 		strcpy(outError, "Invalid importer");

	mov	edx, DWORD PTR _outError$[esp-4]
	mov	eax, OFFSET FLAT:??_C@_0BB@OEJH@Invalid?5importer?$AA@ ; `string'
	sub	edx, eax
$L37207:
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx+eax], cl
	inc	eax
	test	cl, cl
	jne	SHORT $L37207

; 106  : 		return(0);

	xor	al, al

; 107  : 	}

	ret	12					; 0000000cH
?Import@OCpjImporter@@UAE_NPAVOObject@@PAD1@Z ENDP	; OCpjImporter::Import
_TEXT	ENDS
PUBLIC	??0OCpjImporter@@QAE@XZ				; OCpjImporter::OCpjImporter
; Function compile flags: /Ogty
;	COMDAT ??0OCpjImporter@@QAE@XZ
_TEXT	SEGMENT
??0OCpjImporter@@QAE@XZ PROC NEAR			; OCpjImporter::OCpjImporter, COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??0OObject@@QAE@XZ			; OObject::OObject
	mov	DWORD PTR [esi], OFFSET FLAT:??_7OCpjImporter@@6B@ ; OCpjImporter::`vftable'
	mov	eax, esi
	pop	esi
	ret	0
??0OCpjImporter@@QAE@XZ ENDP				; OCpjImporter::OCpjImporter
_TEXT	ENDS
PUBLIC	??0OCpjImporter@@QAE@ABV0@@Z			; OCpjImporter::OCpjImporter
;	COMDAT xdata$x
xdata$x	SEGMENT
$T37265	DD	0ffffffffH
	DD	FLAT:$L37218
	DD	00H
	DD	FLAT:$L37219
$T37262	DD	019930520H
	DD	02H
	DD	FLAT:$T37265
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ??0OCpjImporter@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8
_this$ = -16
__$EHRec$ = -12
??0OCpjImporter@@QAE@ABV0@@Z PROC NEAR			; OCpjImporter::OCpjImporter, COMDAT
; _this$ = ecx
	push	-1
	push	$L37264
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	push	ebx
	mov	ebx, DWORD PTR ___that$[esp+16]
	push	ebp
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [ebx+8]
	push	edi
	mov	DWORD PTR _this$[esp+32], esi
	mov	DWORD PTR [esi], OFFSET FLAT:??_7IMsgTarget@@6B@ ; IMsgTarget::`vftable'
	mov	eax, DWORD PTR [ebx+4]
	mov	DWORD PTR [esi+4], eax
	mov	eax, DWORD PTR [ecx]
	lea	edx, DWORD PTR [esi+8]
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], ecx
	lea	edx, DWORD PTR [ebx+24]
	lea	ecx, DWORD PTR [esi+24]
	xor	eax, eax
	mov	edi, DWORD PTR [edx]
	mov	DWORD PTR __$EHRec$[esp+40], eax
	mov	DWORD PTR [ecx], edi
	mov	edi, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], edi
	mov	edi, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], edi
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [ecx+12], edx
	mov	ecx, DWORD PTR [ebx+40]
	mov	BYTE PTR __$EHRec$[esp+40], 1
	mov	DWORD PTR [esi+40], ecx
	mov	DWORD PTR [esi+44], eax
	mov	ebp, DWORD PTR [ebx+44]
	cmp	ebp, eax
	je	SHORT $L37254
	cmp	BYTE PTR [ebp], 0
	jne	SHORT $L37254
	xor	ebp, ebp
$L37254:
	cmp	ebp, eax
	mov	DWORD PTR [esi+44], eax
	je	SHORT $L37257
	mov	edi, ebp
	or	ecx, -1
	xor	eax, eax
	repne scasb
	not	ecx
	dec	ecx
	mov	edi, ecx
	inc	edi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	edi
	mov	ecx, eax
	call	DWORD PTR [edx]
	test	eax, eax
	mov	DWORD PTR [esi+44], eax
	je	SHORT $L37257
	mov	ecx, eax
$L37259:
	mov	al, BYTE PTR [ebp]
	inc	ebp
	mov	BYTE PTR [ecx], al
	inc	ecx
	test	al, al
	jne	SHORT $L37259
	add	DWORD PTR ?sMemTotal@CCorString@@0KA, edi ; CCorString::sMemTotal
$L37257:
	mov	eax, DWORD PTR [ebx+48]
	pop	edi
	mov	DWORD PTR [esi+48], eax
	mov	ecx, DWORD PTR [ebx+52]
	mov	DWORD PTR [esi+52], ecx
	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR [esi], OFFSET FLAT:??_7OCpjImporter@@6B@ ; OCpjImporter::`vftable'
	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L37218:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1CObjLink@@QAE@XZ			; CObjLink::~CObjLink
$L37219:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	jmp	??1CObjLink@@QAE@XZ			; CObjLink::~CObjLink
$L37264:
	mov	eax, OFFSET FLAT:$T37262
	jmp	___CxxFrameHandler
text$x	ENDS
??0OCpjImporter@@QAE@ABV0@@Z ENDP			; OCpjImporter::OCpjImporter
PUBLIC	??4OCpjImporter@@QAEAAV0@ABV0@@Z		; OCpjImporter::operator=
; Function compile flags: /Ogty
;	COMDAT ??4OCpjImporter@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8
??4OCpjImporter@@QAEAAV0@ABV0@@Z PROC NEAR		; OCpjImporter::operator=, COMDAT
; _this$ = ecx
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR ___that$[esp+4]
	push	esi
	mov	esi, ecx
	push	edi
	mov	eax, DWORD PTR [ebp+4]
	lea	ecx, DWORD PTR [ebp+8]
	mov	DWORD PTR [esi+4], eax
	lea	edx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	lea	eax, DWORD PTR [esi+24]
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], ecx
	lea	edx, DWORD PTR [ebp+24]
	mov	ecx, DWORD PTR [ebp+24]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR [ebp+40]
	mov	DWORD PTR [esi+40], eax
	mov	ebx, DWORD PTR [ebp+44]
	test	ebx, ebx
	je	SHORT $L37304
	cmp	BYTE PTR [ebx], 0
	jne	SHORT $L37304
	xor	ebx, ebx
$L37304:
	mov	edi, DWORD PTR [esi+44]
	test	edi, edi
	je	SHORT $L37305
	or	ecx, -1
	xor	eax, eax
	repne scasb
	mov	eax, DWORD PTR ?sMemTotal@CCorString@@0KA ; CCorString::sMemTotal
	or	edx, -1
	not	ecx
	dec	ecx
	sub	edx, ecx
	add	eax, edx
	mov	DWORD PTR ?sMemTotal@CCorString@@0KA, eax ; CCorString::sMemTotal
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+44]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L37305:
	test	ebx, ebx
	mov	DWORD PTR [esi+44], 0
	je	SHORT $L37308
	mov	edi, ebx
	or	ecx, -1
	xor	eax, eax
	repne scasb
	not	ecx
	dec	ecx
	mov	edi, ecx
	inc	edi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	edi
	mov	ecx, eax
	call	DWORD PTR [edx]
	test	eax, eax
	mov	DWORD PTR [esi+44], eax
	je	SHORT $L37308
$L37310:
	mov	cl, BYTE PTR [ebx]
	inc	ebx
	mov	BYTE PTR [eax], cl
	inc	eax
	test	cl, cl
	jne	SHORT $L37310
	add	DWORD PTR ?sMemTotal@CCorString@@0KA, edi ; CCorString::sMemTotal
$L37308:
	mov	eax, DWORD PTR [ebp+48]
	pop	edi
	mov	DWORD PTR [esi+48], eax
	mov	ecx, DWORD PTR [ebp+52]
	mov	DWORD PTR [esi+52], ecx
	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx
	ret	4
??4OCpjImporter@@QAEAAV0@ABV0@@Z ENDP			; OCpjImporter::operator=
_TEXT	ENDS
PUBLIC	??1OCpjImporter@@UAE@XZ				; OCpjImporter::~OCpjImporter
; Function compile flags: /Ogty
;	COMDAT ??1OCpjImporter@@UAE@XZ
_TEXT	SEGMENT
??1OCpjImporter@@UAE@XZ PROC NEAR			; OCpjImporter::~OCpjImporter, COMDAT
; _this$ = ecx
	jmp	??1OObject@@UAE@XZ			; OObject::~OObject
??1OCpjImporter@@UAE@XZ ENDP				; OCpjImporter::~OCpjImporter
_TEXT	ENDS
PUBLIC	??_GOCpjImporter@@UAEPAXI@Z			; OCpjImporter::`scalar deleting destructor'
; Function compile flags: /Ogty
;	COMDAT ??_GOCpjImporter@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_GOCpjImporter@@UAEPAXI@Z PROC NEAR			; OCpjImporter::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1OCpjImporter@@UAE@XZ			; OCpjImporter::~OCpjImporter
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $L37332
	mov	DWORD PTR [esi+4], 0
	mov	edx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	dec	edx
	mov	DWORD PTR ?sObjCount@OObject@@1KA, edx	; OObject::sObjCount
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L37332:
	mov	eax, esi
	pop	esi
	ret	4
??_GOCpjImporter@@UAEPAXI@Z ENDP			; OCpjImporter::`scalar deleting destructor'
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??_EOCpjImporter@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_EOCpjImporter@@UAEPAXI@Z PROC NEAR			; OCpjImporter::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebx
	mov	bl, BYTE PTR ___flags$[esp]
	push	esi
	mov	esi, ecx
	test	bl, 2
	je	SHORT $L7449
	mov	eax, DWORD PTR [esi-4]
	push	edi
	lea	edi, DWORD PTR [esi-4]
	push	OFFSET FLAT:??1OCpjImporter@@UAE@XZ	; OCpjImporter::~OCpjImporter
	push	eax
	push	56					; 00000038H
	push	esi
	call	??_M@YGXPAXIHP6EX0@Z@Z			; `eh vector destructor iterator'
	test	bl, 1
	je	SHORT $L7450
	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L7450:
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	ret	4
$L7449:
	mov	ecx, esi
	call	??1OCpjImporter@@UAE@XZ			; OCpjImporter::~OCpjImporter
	test	bl, 1
	je	SHORT $L37342
	mov	DWORD PTR [esi+4], 0
	mov	edx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	dec	edx
	mov	DWORD PTR ?sObjCount@OObject@@1KA, edx	; OObject::sObjCount
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L37342:
	mov	eax, esi
	pop	esi
	pop	ebx
	ret	4
??_EOCpjImporter@@UAEPAXI@Z ENDP			; OCpjImporter::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??2OCpjExporter@@CAPAXIPAVOObject@@PAVCObjClass@@@Z ; OCpjExporter::operator new
; Function compile flags: /Ogty
;	COMDAT ??2OCpjExporter@@CAPAXIPAVOObject@@PAVCObjClass@@@Z
_TEXT	SEGMENT
_inParent$ = 12
_inSetClass$ = 16
??2OCpjExporter@@CAPAXIPAVOObject@@PAVCObjClass@@@Z PROC NEAR ; OCpjExporter::operator new, COMDAT

; 118  : 	OBJ_CLASS_DEFINE(OCpjExporter, OObject);

	push	esi
	push	edi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	56					; 00000038H
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	ecx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	mov	esi, eax
	inc	ecx
	xor	eax, eax
	mov	DWORD PTR ?sObjCount@OObject@@1KA, ecx	; OObject::sObjCount
	mov	ecx, 14					; 0000000eH
	mov	edi, esi
	rep stosd
	mov	eax, DWORD PTR [esi+40]
	mov	DWORD PTR [esi+4], 305419896		; 12345678H
	test	eax, eax
	jne	SHORT $L37358
	mov	eax, DWORD PTR _inSetClass$[esp+4]
	mov	DWORD PTR [esi+40], eax
$L37358:
	mov	ecx, DWORD PTR _inParent$[esp+4]
	push	ecx
	mov	ecx, esi
	call	?PreConstruct@OObject@@QAEXPAV1@@Z	; OObject::PreConstruct
	mov	eax, esi
	pop	edi
	pop	esi
	ret	0
??2OCpjExporter@@CAPAXIPAVOObject@@PAVCObjClass@@@Z ENDP ; OCpjExporter::operator new
_TEXT	ENDS
PUBLIC	??3OCpjExporter@@CAXPAX@Z			; OCpjExporter::operator delete
; Function compile flags: /Ogty
;	COMDAT ??3OCpjExporter@@CAXPAX@Z
_TEXT	SEGMENT
_ptr$ = 8
??3OCpjExporter@@CAXPAX@Z PROC NEAR			; OCpjExporter::operator delete, COMDAT

; 118  : 	OBJ_CLASS_DEFINE(OCpjExporter, OObject);

	push	esi
	mov	esi, DWORD PTR _ptr$[esp]
	mov	DWORD PTR [esi+4], 0
	mov	edx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	dec	edx
	mov	DWORD PTR ?sObjCount@OObject@@1KA, edx	; OObject::sObjCount
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	ecx, eax
	call	DWORD PTR [edx+8]
	pop	esi
	ret	0
??3OCpjExporter@@CAXPAX@Z ENDP				; OCpjExporter::operator delete
_TEXT	ENDS
PUBLIC	??3OCpjExporter@@CAXPAXPAVOObject@@PAVCObjClass@@@Z ; OCpjExporter::operator delete
; Function compile flags: /Ogty
;	COMDAT ??3OCpjExporter@@CAXPAXPAVOObject@@PAVCObjClass@@@Z
_TEXT	SEGMENT
_ptr$ = 8
??3OCpjExporter@@CAXPAXPAVOObject@@PAVCObjClass@@@Z PROC NEAR ; OCpjExporter::operator delete, COMDAT

; 118  : 	OBJ_CLASS_DEFINE(OCpjExporter, OObject);

	push	esi
	mov	esi, DWORD PTR _ptr$[esp]
	mov	DWORD PTR [esi+4], 0
	mov	edx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	dec	edx
	mov	DWORD PTR ?sObjCount@OObject@@1KA, edx	; OObject::sObjCount
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	ecx, eax
	call	DWORD PTR [edx+8]
	pop	esi
	ret	0
??3OCpjExporter@@CAXPAXPAVOObject@@PAVCObjClass@@@Z ENDP ; OCpjExporter::operator delete
_TEXT	ENDS
PUBLIC	?GetStaticClass@OCpjExporter@@SAPAVCObjClass@@XZ ; OCpjExporter::GetStaticClass
EXTRN	?staticObjClass@OCpjExporter@@0PAVCObjClass@@A:DWORD ; OCpjExporter::staticObjClass
; Function compile flags: /Ogty
;	COMDAT ?GetStaticClass@OCpjExporter@@SAPAVCObjClass@@XZ
_TEXT	SEGMENT
?GetStaticClass@OCpjExporter@@SAPAVCObjClass@@XZ PROC NEAR ; OCpjExporter::GetStaticClass, COMDAT

; 118  : 	OBJ_CLASS_DEFINE(OCpjExporter, OObject);

	mov	eax, DWORD PTR ?staticObjClass@OCpjExporter@@0PAVCObjClass@@A ; OCpjExporter::staticObjClass
	ret	0
?GetStaticClass@OCpjExporter@@SAPAVCObjClass@@XZ ENDP	; OCpjExporter::GetStaticClass
_TEXT	ENDS
PUBLIC	?New@OCpjExporter@@SAPAV1@PAVOObject@@PAVCObjClass@@@Z ; OCpjExporter::New
PUBLIC	?GetClass@OCpjExporter@@UAEPAVCObjClass@@XZ	; OCpjExporter::GetClass
PUBLIC	?GetExportClass@OCpjExporter@@UAEPAVCObjClass@@XZ ; OCpjExporter::GetExportClass
PUBLIC	?GetFileExtension@OCpjExporter@@UAEPADXZ	; OCpjExporter::GetFileExtension
PUBLIC	?GetFileDescription@OCpjExporter@@UAEPADXZ	; OCpjExporter::GetFileDescription
PUBLIC	?Configure@OCpjExporter@@UAE_NPAVOObject@@PAD@Z	; OCpjExporter::Configure
PUBLIC	?Export@OCpjExporter@@UAE_NPAVOObject@@PAD1@Z	; OCpjExporter::Export
PUBLIC	??_7OCpjExporter@@6B@				; OCpjExporter::`vftable'
PUBLIC	??_EOCpjExporter@@UAEPAXI@Z			; OCpjExporter::`vector deleting destructor'
;	COMDAT xdata$x
xdata$x	SEGMENT
$T37417	DD	0ffffffffH
	DD	FLAT:$L37386
$T37415	DD	019930520H
	DD	01H
	DD	FLAT:$T37417
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_7OCpjExporter@@6B@
CONST	SEGMENT
??_7OCpjExporter@@6B@ DD FLAT:?Msg@OObject@@UAE_NPAVIMsg@@@Z ; OCpjExporter::`vftable'
	DD	FLAT:?MsgGetChild@OObject@@UAEPAVIMsgTarget@@PAD@Z
	DD	FLAT:?MsgGetParent@OObject@@UAEPAVIMsgTarget@@XZ
	DD	FLAT:?MsgGetRoot@OObject@@UAEPAVIMsgTarget@@XZ
	DD	FLAT:?GetClass@OCpjExporter@@UAEPAVCObjClass@@XZ
	DD	FLAT:??_EOCpjExporter@@UAEPAXI@Z
	DD	FLAT:?Create@OObject@@UAEXXZ
	DD	FLAT:?Destroy@OObject@@UAEXXZ
	DD	FLAT:?GetParent@OObject@@UAEPAV1@XZ
	DD	FLAT:?SetParent@OObject@@UAEXPAV1@_N@Z
	DD	FLAT:?HasChildren@OObject@@UAE_NXZ
	DD	FLAT:?IsA@OObject@@UAE_NPAVCObjClass@@@Z
	DD	FLAT:?GetExportClass@OCpjExporter@@UAEPAVCObjClass@@XZ
	DD	FLAT:?GetFileExtension@OCpjExporter@@UAEPADXZ
	DD	FLAT:?GetFileDescription@OCpjExporter@@UAEPADXZ
	DD	FLAT:?Configure@OCpjExporter@@UAE_NPAVOObject@@PAD@Z
	DD	FLAT:?Export@OCpjExporter@@UAE_NPAVOObject@@PAD1@Z
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?New@OCpjExporter@@SAPAV1@PAVOObject@@PAVCObjClass@@@Z
_TEXT	SEGMENT
_inParent$ = 8
_inSetClass$ = 12
$T37383 = -16
__$EHRec$ = -12
?New@OCpjExporter@@SAPAV1@PAVOObject@@PAVCObjClass@@@Z PROC NEAR ; OCpjExporter::New, COMDAT

; 118  : 	OBJ_CLASS_DEFINE(OCpjExporter, OObject);

	push	-1
	push	$L37416
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	push	ebx
	mov	ebx, DWORD PTR _inSetClass$[esp+16]
	test	ebx, ebx
	push	esi
	jne	SHORT $L7509
	mov	ebx, DWORD PTR ?staticObjClass@OCpjExporter@@0PAVCObjClass@@A ; OCpjExporter::staticObjClass
	mov	DWORD PTR _inSetClass$[esp+20], ebx
$L7509:
	push	edi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	56					; 00000038H
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	ecx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	mov	esi, eax
	inc	ecx
	xor	eax, eax
	mov	DWORD PTR ?sObjCount@OObject@@1KA, ecx	; OObject::sObjCount
	mov	ecx, 14					; 0000000eH
	mov	edi, esi
	rep stosd
	mov	eax, DWORD PTR [esi+40]
	mov	DWORD PTR [esi+4], 305419896		; 12345678H
	test	eax, eax
	pop	edi
	jne	SHORT $L37407
	mov	DWORD PTR [esi+40], ebx
$L37407:
	mov	eax, DWORD PTR _inParent$[esp+20]
	mov	ecx, esi
	push	eax
	call	?PreConstruct@OObject@@QAEXPAV1@@Z	; OObject::PreConstruct
	mov	DWORD PTR $T37383[esp+24], esi
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+32], 0
	call	??0OObject@@QAE@XZ			; OObject::OObject
	mov	DWORD PTR [esi], OFFSET FLAT:??_7OCpjExporter@@6B@ ; OCpjExporter::`vftable'
	mov	edx, DWORD PTR [esi]
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+32], -1
	call	DWORD PTR [edx+24]
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	eax, esi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L37386:
	mov	eax, DWORD PTR _inSetClass$[ebp-4]
	push	eax
	mov	ecx, DWORD PTR _inParent$[ebp-4]
	push	ecx
	mov	edx, DWORD PTR $T37383[ebp]
	push	edx
	call	??3OCpjExporter@@CAXPAXPAVOObject@@PAVCObjClass@@@Z ; OCpjExporter::operator delete
	add	esp, 12					; 0000000cH
	ret	0
$L37416:
	mov	eax, OFFSET FLAT:$T37415
	jmp	___CxxFrameHandler
text$x	ENDS
?New@OCpjExporter@@SAPAV1@PAVOObject@@PAVCObjClass@@@Z ENDP ; OCpjExporter::New
; Function compile flags: /Ogty
;	COMDAT ?GetClass@OCpjExporter@@UAEPAVCObjClass@@XZ
_TEXT	SEGMENT
?GetClass@OCpjExporter@@UAEPAVCObjClass@@XZ PROC NEAR	; OCpjExporter::GetClass, COMDAT
; _this$ = ecx

; 118  : 	OBJ_CLASS_DEFINE(OCpjExporter, OObject);

	mov	eax, DWORD PTR [ecx+40]
	ret	0
?GetClass@OCpjExporter@@UAEPAVCObjClass@@XZ ENDP	; OCpjExporter::GetClass
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?GetExportClass@OCpjExporter@@UAEPAVCObjClass@@XZ
_TEXT	SEGMENT
?GetExportClass@OCpjExporter@@UAEPAVCObjClass@@XZ PROC NEAR ; OCpjExporter::GetExportClass, COMDAT
; _this$ = ecx

; 120  : 	virtual CObjClass* GetExportClass() { return(NULL); }

	xor	eax, eax
	ret	0
?GetExportClass@OCpjExporter@@UAEPAVCObjClass@@XZ ENDP	; OCpjExporter::GetExportClass
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?GetFileExtension@OCpjExporter@@UAEPADXZ
_TEXT	SEGMENT
?GetFileExtension@OCpjExporter@@UAEPADXZ PROC NEAR	; OCpjExporter::GetFileExtension, COMDAT
; _this$ = ecx

; 121  : 	virtual NChar* GetFileExtension() { return(NULL); }

	xor	eax, eax
	ret	0
?GetFileExtension@OCpjExporter@@UAEPADXZ ENDP		; OCpjExporter::GetFileExtension
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?GetFileDescription@OCpjExporter@@UAEPADXZ
_TEXT	SEGMENT
?GetFileDescription@OCpjExporter@@UAEPADXZ PROC NEAR	; OCpjExporter::GetFileDescription, COMDAT
; _this$ = ecx

; 122  : 	virtual NChar* GetFileDescription() { return(NULL); }

	xor	eax, eax
	ret	0
?GetFileDescription@OCpjExporter@@UAEPADXZ ENDP		; OCpjExporter::GetFileDescription
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?Configure@OCpjExporter@@UAE_NPAVOObject@@PAD@Z
_TEXT	SEGMENT
?Configure@OCpjExporter@@UAE_NPAVOObject@@PAD@Z PROC NEAR ; OCpjExporter::Configure, COMDAT
; _this$ = ecx

; 123  : 	virtual NBool Configure(OObject* inRes, NChar* inFileName) { return(1); }

	mov	al, 1
	ret	8
?Configure@OCpjExporter@@UAE_NPAVOObject@@PAD@Z ENDP	; OCpjExporter::Configure
_TEXT	ENDS
PUBLIC	??_C@_0BB@PIMA@Invalid?5exporter?$AA@		; `string'
;	COMDAT ??_C@_0BB@PIMA@Invalid?5exporter?$AA@
_DATA	SEGMENT
??_C@_0BB@PIMA@Invalid?5exporter?$AA@ DB 'Invalid exporter', 00H ; `string'
; Function compile flags: /Ogty
_DATA	ENDS
;	COMDAT ?Export@OCpjExporter@@UAE_NPAVOObject@@PAD1@Z
_TEXT	SEGMENT
_outError$ = 16
?Export@OCpjExporter@@UAE_NPAVOObject@@PAD1@Z PROC NEAR	; OCpjExporter::Export, COMDAT
; _this$ = ecx

; 126  : 		strcpy(outError, "Invalid exporter");

	mov	edx, DWORD PTR _outError$[esp-4]
	mov	eax, OFFSET FLAT:??_C@_0BB@PIMA@Invalid?5exporter?$AA@ ; `string'
	sub	edx, eax
$L37438:
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx+eax], cl
	inc	eax
	test	cl, cl
	jne	SHORT $L37438

; 127  : 		return(0);

	xor	al, al

; 128  : 	}

	ret	12					; 0000000cH
?Export@OCpjExporter@@UAE_NPAVOObject@@PAD1@Z ENDP	; OCpjExporter::Export
_TEXT	ENDS
PUBLIC	??0OCpjExporter@@QAE@XZ				; OCpjExporter::OCpjExporter
; Function compile flags: /Ogty
;	COMDAT ??0OCpjExporter@@QAE@XZ
_TEXT	SEGMENT
??0OCpjExporter@@QAE@XZ PROC NEAR			; OCpjExporter::OCpjExporter, COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??0OObject@@QAE@XZ			; OObject::OObject
	mov	DWORD PTR [esi], OFFSET FLAT:??_7OCpjExporter@@6B@ ; OCpjExporter::`vftable'
	mov	eax, esi
	pop	esi
	ret	0
??0OCpjExporter@@QAE@XZ ENDP				; OCpjExporter::OCpjExporter
_TEXT	ENDS
PUBLIC	??0OCpjExporter@@QAE@ABV0@@Z			; OCpjExporter::OCpjExporter
;	COMDAT xdata$x
xdata$x	SEGMENT
$T37496	DD	0ffffffffH
	DD	FLAT:$L37449
	DD	00H
	DD	FLAT:$L37450
$T37493	DD	019930520H
	DD	02H
	DD	FLAT:$T37496
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ??0OCpjExporter@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8
_this$ = -16
__$EHRec$ = -12
??0OCpjExporter@@QAE@ABV0@@Z PROC NEAR			; OCpjExporter::OCpjExporter, COMDAT
; _this$ = ecx
	push	-1
	push	$L37495
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	push	ebx
	mov	ebx, DWORD PTR ___that$[esp+16]
	push	ebp
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [ebx+8]
	push	edi
	mov	DWORD PTR _this$[esp+32], esi
	mov	DWORD PTR [esi], OFFSET FLAT:??_7IMsgTarget@@6B@ ; IMsgTarget::`vftable'
	mov	eax, DWORD PTR [ebx+4]
	mov	DWORD PTR [esi+4], eax
	mov	eax, DWORD PTR [ecx]
	lea	edx, DWORD PTR [esi+8]
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], ecx
	lea	edx, DWORD PTR [ebx+24]
	lea	ecx, DWORD PTR [esi+24]
	xor	eax, eax
	mov	edi, DWORD PTR [edx]
	mov	DWORD PTR __$EHRec$[esp+40], eax
	mov	DWORD PTR [ecx], edi
	mov	edi, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], edi
	mov	edi, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], edi
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [ecx+12], edx
	mov	ecx, DWORD PTR [ebx+40]
	mov	BYTE PTR __$EHRec$[esp+40], 1
	mov	DWORD PTR [esi+40], ecx
	mov	DWORD PTR [esi+44], eax
	mov	ebp, DWORD PTR [ebx+44]
	cmp	ebp, eax
	je	SHORT $L37486
	cmp	BYTE PTR [ebp], 0
	jne	SHORT $L37486
	xor	ebp, ebp
$L37486:
	cmp	ebp, eax
	mov	DWORD PTR [esi+44], eax
	je	SHORT $L37489
	mov	edi, ebp
	or	ecx, -1
	xor	eax, eax
	repne scasb
	not	ecx
	dec	ecx
	mov	edi, ecx
	inc	edi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	edi
	mov	ecx, eax
	call	DWORD PTR [edx]
	test	eax, eax
	mov	DWORD PTR [esi+44], eax
	je	SHORT $L37489
	mov	ecx, eax
$L37491:
	mov	al, BYTE PTR [ebp]
	inc	ebp
	mov	BYTE PTR [ecx], al
	inc	ecx
	test	al, al
	jne	SHORT $L37491
	add	DWORD PTR ?sMemTotal@CCorString@@0KA, edi ; CCorString::sMemTotal
$L37489:
	mov	eax, DWORD PTR [ebx+48]
	pop	edi
	mov	DWORD PTR [esi+48], eax
	mov	ecx, DWORD PTR [ebx+52]
	mov	DWORD PTR [esi+52], ecx
	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR [esi], OFFSET FLAT:??_7OCpjExporter@@6B@ ; OCpjExporter::`vftable'
	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L37449:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1CObjLink@@QAE@XZ			; CObjLink::~CObjLink
$L37450:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	jmp	??1CObjLink@@QAE@XZ			; CObjLink::~CObjLink
$L37495:
	mov	eax, OFFSET FLAT:$T37493
	jmp	___CxxFrameHandler
text$x	ENDS
??0OCpjExporter@@QAE@ABV0@@Z ENDP			; OCpjExporter::OCpjExporter
PUBLIC	??4OCpjExporter@@QAEAAV0@ABV0@@Z		; OCpjExporter::operator=
; Function compile flags: /Ogty
;	COMDAT ??4OCpjExporter@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8
??4OCpjExporter@@QAEAAV0@ABV0@@Z PROC NEAR		; OCpjExporter::operator=, COMDAT
; _this$ = ecx
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR ___that$[esp+4]
	push	esi
	mov	esi, ecx
	push	edi
	mov	eax, DWORD PTR [ebp+4]
	lea	ecx, DWORD PTR [ebp+8]
	mov	DWORD PTR [esi+4], eax
	lea	edx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	lea	eax, DWORD PTR [esi+24]
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], ecx
	lea	edx, DWORD PTR [ebp+24]
	mov	ecx, DWORD PTR [ebp+24]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR [ebp+40]
	mov	DWORD PTR [esi+40], eax
	mov	ebx, DWORD PTR [ebp+44]
	test	ebx, ebx
	je	SHORT $L37536
	cmp	BYTE PTR [ebx], 0
	jne	SHORT $L37536
	xor	ebx, ebx
$L37536:
	mov	edi, DWORD PTR [esi+44]
	test	edi, edi
	je	SHORT $L37537
	or	ecx, -1
	xor	eax, eax
	repne scasb
	mov	eax, DWORD PTR ?sMemTotal@CCorString@@0KA ; CCorString::sMemTotal
	or	edx, -1
	not	ecx
	dec	ecx
	sub	edx, ecx
	add	eax, edx
	mov	DWORD PTR ?sMemTotal@CCorString@@0KA, eax ; CCorString::sMemTotal
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+44]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L37537:
	test	ebx, ebx
	mov	DWORD PTR [esi+44], 0
	je	SHORT $L37540
	mov	edi, ebx
	or	ecx, -1
	xor	eax, eax
	repne scasb
	not	ecx
	dec	ecx
	mov	edi, ecx
	inc	edi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	edi
	mov	ecx, eax
	call	DWORD PTR [edx]
	test	eax, eax
	mov	DWORD PTR [esi+44], eax
	je	SHORT $L37540
$L37542:
	mov	cl, BYTE PTR [ebx]
	inc	ebx
	mov	BYTE PTR [eax], cl
	inc	eax
	test	cl, cl
	jne	SHORT $L37542
	add	DWORD PTR ?sMemTotal@CCorString@@0KA, edi ; CCorString::sMemTotal
$L37540:
	mov	eax, DWORD PTR [ebp+48]
	pop	edi
	mov	DWORD PTR [esi+48], eax
	mov	ecx, DWORD PTR [ebp+52]
	mov	DWORD PTR [esi+52], ecx
	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx
	ret	4
??4OCpjExporter@@QAEAAV0@ABV0@@Z ENDP			; OCpjExporter::operator=
_TEXT	ENDS
PUBLIC	??1OCpjExporter@@UAE@XZ				; OCpjExporter::~OCpjExporter
; Function compile flags: /Ogty
;	COMDAT ??1OCpjExporter@@UAE@XZ
_TEXT	SEGMENT
??1OCpjExporter@@UAE@XZ PROC NEAR			; OCpjExporter::~OCpjExporter, COMDAT
; _this$ = ecx
	jmp	??1OObject@@UAE@XZ			; OObject::~OObject
??1OCpjExporter@@UAE@XZ ENDP				; OCpjExporter::~OCpjExporter
_TEXT	ENDS
PUBLIC	??_GOCpjExporter@@UAEPAXI@Z			; OCpjExporter::`scalar deleting destructor'
; Function compile flags: /Ogty
;	COMDAT ??_GOCpjExporter@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_GOCpjExporter@@UAEPAXI@Z PROC NEAR			; OCpjExporter::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1OCpjExporter@@UAE@XZ			; OCpjExporter::~OCpjExporter
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $L37563
	mov	DWORD PTR [esi+4], 0
	mov	edx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	dec	edx
	mov	DWORD PTR ?sObjCount@OObject@@1KA, edx	; OObject::sObjCount
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L37563:
	mov	eax, esi
	pop	esi
	ret	4
??_GOCpjExporter@@UAEPAXI@Z ENDP			; OCpjExporter::`scalar deleting destructor'
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??_EOCpjExporter@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_EOCpjExporter@@UAEPAXI@Z PROC NEAR			; OCpjExporter::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebx
	mov	bl, BYTE PTR ___flags$[esp]
	push	esi
	mov	esi, ecx
	test	bl, 2
	je	SHORT $L7547
	mov	eax, DWORD PTR [esi-4]
	push	edi
	lea	edi, DWORD PTR [esi-4]
	push	OFFSET FLAT:??1OCpjExporter@@UAE@XZ	; OCpjExporter::~OCpjExporter
	push	eax
	push	56					; 00000038H
	push	esi
	call	??_M@YGXPAXIHP6EX0@Z@Z			; `eh vector destructor iterator'
	test	bl, 1
	je	SHORT $L7548
	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L7548:
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	ret	4
$L7547:
	mov	ecx, esi
	call	??1OCpjExporter@@UAE@XZ			; OCpjExporter::~OCpjExporter
	test	bl, 1
	je	SHORT $L37573
	mov	DWORD PTR [esi+4], 0
	mov	edx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	dec	edx
	mov	DWORD PTR ?sObjCount@OObject@@1KA, edx	; OObject::sObjCount
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L37573:
	mov	eax, esi
	pop	esi
	pop	ebx
	ret	4
??_EOCpjExporter@@UAEPAXI@Z ENDP			; OCpjExporter::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??2OCpjProject@@CAPAXIPAVOObject@@PAVCObjClass@@@Z ; OCpjProject::operator new
; Function compile flags: /Ogty
; File C:\duke4\Cannibal\CpjProj.h
;	COMDAT ??2OCpjProject@@CAPAXIPAVOObject@@PAVCObjClass@@@Z
_TEXT	SEGMENT
_inParent$ = 12
_inSetClass$ = 16
??2OCpjProject@@CAPAXIPAVOObject@@PAVCObjClass@@@Z PROC NEAR ; OCpjProject::operator new, COMDAT

; 33   : 	OBJ_CLASS_DEFINE(OCpjProject, OCpjRes);	

	push	esi
	push	edi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	64					; 00000040H
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	ecx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	mov	esi, eax
	inc	ecx
	xor	eax, eax
	mov	DWORD PTR ?sObjCount@OObject@@1KA, ecx	; OObject::sObjCount
	mov	ecx, 16					; 00000010H
	mov	edi, esi
	rep stosd
	mov	eax, DWORD PTR [esi+40]
	mov	DWORD PTR [esi+4], 305419896		; 12345678H
	test	eax, eax
	jne	SHORT $L37588
	mov	eax, DWORD PTR _inSetClass$[esp+4]
	mov	DWORD PTR [esi+40], eax
$L37588:
	mov	ecx, DWORD PTR _inParent$[esp+4]
	push	ecx
	mov	ecx, esi
	call	?PreConstruct@OObject@@QAEXPAV1@@Z	; OObject::PreConstruct
	mov	eax, esi
	pop	edi
	pop	esi
	ret	0
??2OCpjProject@@CAPAXIPAVOObject@@PAVCObjClass@@@Z ENDP	; OCpjProject::operator new
_TEXT	ENDS
PUBLIC	??3OCpjProject@@CAXPAX@Z			; OCpjProject::operator delete
; Function compile flags: /Ogty
;	COMDAT ??3OCpjProject@@CAXPAX@Z
_TEXT	SEGMENT
_ptr$ = 8
??3OCpjProject@@CAXPAX@Z PROC NEAR			; OCpjProject::operator delete, COMDAT

; 33   : 	OBJ_CLASS_DEFINE(OCpjProject, OCpjRes);	

	push	esi
	mov	esi, DWORD PTR _ptr$[esp]
	mov	DWORD PTR [esi+4], 0
	mov	edx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	dec	edx
	mov	DWORD PTR ?sObjCount@OObject@@1KA, edx	; OObject::sObjCount
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	ecx, eax
	call	DWORD PTR [edx+8]
	pop	esi
	ret	0
??3OCpjProject@@CAXPAX@Z ENDP				; OCpjProject::operator delete
_TEXT	ENDS
PUBLIC	??3OCpjProject@@CAXPAXPAVOObject@@PAVCObjClass@@@Z ; OCpjProject::operator delete
; Function compile flags: /Ogty
;	COMDAT ??3OCpjProject@@CAXPAXPAVOObject@@PAVCObjClass@@@Z
_TEXT	SEGMENT
_ptr$ = 8
??3OCpjProject@@CAXPAXPAVOObject@@PAVCObjClass@@@Z PROC NEAR ; OCpjProject::operator delete, COMDAT

; 33   : 	OBJ_CLASS_DEFINE(OCpjProject, OCpjRes);	

	push	esi
	mov	esi, DWORD PTR _ptr$[esp]
	mov	DWORD PTR [esi+4], 0
	mov	edx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	dec	edx
	mov	DWORD PTR ?sObjCount@OObject@@1KA, edx	; OObject::sObjCount
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	ecx, eax
	call	DWORD PTR [edx+8]
	pop	esi
	ret	0
??3OCpjProject@@CAXPAXPAVOObject@@PAVCObjClass@@@Z ENDP	; OCpjProject::operator delete
_TEXT	ENDS
PUBLIC	?GetStaticClass@OCpjProject@@SAPAVCObjClass@@XZ	; OCpjProject::GetStaticClass
; Function compile flags: /Ogty
;	COMDAT ?GetStaticClass@OCpjProject@@SAPAVCObjClass@@XZ
_TEXT	SEGMENT
?GetStaticClass@OCpjProject@@SAPAVCObjClass@@XZ PROC NEAR ; OCpjProject::GetStaticClass, COMDAT

; 33   : 	OBJ_CLASS_DEFINE(OCpjProject, OCpjRes);	

	mov	eax, DWORD PTR ?staticObjClass@OCpjProject@@0PAVCObjClass@@A ; OCpjProject::staticObjClass
	ret	0
?GetStaticClass@OCpjProject@@SAPAVCObjClass@@XZ ENDP	; OCpjProject::GetStaticClass
_TEXT	ENDS
PUBLIC	?New@OCpjProject@@SAPAV1@PAVOObject@@PAVCObjClass@@@Z ; OCpjProject::New
PUBLIC	?GetClass@OCpjProject@@UAEPAVCObjClass@@XZ	; OCpjProject::GetClass
PUBLIC	?Create@OCpjProject@@UAEXXZ			; OCpjProject::Create
PUBLIC	?Destroy@OCpjProject@@UAEXXZ			; OCpjProject::Destroy
PUBLIC	?GetFileExtension@OCpjProject@@UAEPADXZ		; OCpjProject::GetFileExtension
PUBLIC	?GetFileDescription@OCpjProject@@UAEPADXZ	; OCpjProject::GetFileDescription
PUBLIC	??_7OCpjProject@@6B@				; OCpjProject::`vftable'
PUBLIC	??_EOCpjProject@@UAEPAXI@Z			; OCpjProject::`vector deleting destructor'
EXTRN	?LoadFile@OCpjProject@@UAE_NPAD@Z:NEAR		; OCpjProject::LoadFile
EXTRN	?SaveFile@OCpjProject@@UAE_NPAD@Z:NEAR		; OCpjProject::SaveFile
;	COMDAT xdata$x
; File C:\duke4\Cannibal\CorMain.h
xdata$x	SEGMENT
$T37661	DD	0ffffffffH
	DD	FLAT:$L37617
$T37659	DD	019930520H
	DD	01H
	DD	FLAT:$T37661
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_7OCpjProject@@6B@
CONST	SEGMENT
??_7OCpjProject@@6B@ DD FLAT:?Msg@OObject@@UAE_NPAVIMsg@@@Z ; OCpjProject::`vftable'
	DD	FLAT:?MsgGetChild@OObject@@UAEPAVIMsgTarget@@PAD@Z
	DD	FLAT:?MsgGetParent@OObject@@UAEPAVIMsgTarget@@XZ
	DD	FLAT:?MsgGetRoot@OObject@@UAEPAVIMsgTarget@@XZ
	DD	FLAT:?GetClass@OCpjProject@@UAEPAVCObjClass@@XZ
	DD	FLAT:??_EOCpjProject@@UAEPAXI@Z
	DD	FLAT:?Create@OCpjProject@@UAEXXZ
	DD	FLAT:?Destroy@OCpjProject@@UAEXXZ
	DD	FLAT:?GetParent@OObject@@UAEPAV1@XZ
	DD	FLAT:?SetParent@OObject@@UAEXPAV1@_N@Z
	DD	FLAT:?HasChildren@OObject@@UAE_NXZ
	DD	FLAT:?IsA@OObject@@UAE_NPAVCObjClass@@@Z
	DD	FLAT:?GetFileExtension@OCpjProject@@UAEPADXZ
	DD	FLAT:?GetFileDescription@OCpjProject@@UAEPADXZ
	DD	FLAT:?LoadFile@OCpjProject@@UAE_NPAD@Z
	DD	FLAT:?SaveFile@OCpjProject@@UAE_NPAD@Z
; Function compile flags: /Ogty
; File C:\duke4\Cannibal\CpjProj.h
CONST	ENDS
;	COMDAT ?New@OCpjProject@@SAPAV1@PAVOObject@@PAVCObjClass@@@Z
_TEXT	SEGMENT
$T37614 = -16
__$EHRec$ = -12
_inParent$ = 8
_inSetClass$ = 12
?New@OCpjProject@@SAPAV1@PAVOObject@@PAVCObjClass@@@Z PROC NEAR ; OCpjProject::New, COMDAT

; 33   : 	OBJ_CLASS_DEFINE(OCpjProject, OCpjRes);	

	push	-1
	push	$L37660
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	push	ebx
	mov	ebx, DWORD PTR _inSetClass$[esp+16]
	test	ebx, ebx
	push	esi
	jne	SHORT $L7616
	mov	ebx, DWORD PTR ?staticObjClass@OCpjProject@@0PAVCObjClass@@A ; OCpjProject::staticObjClass
	mov	DWORD PTR _inSetClass$[esp+20], ebx
$L7616:
	push	edi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	64					; 00000040H
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	ecx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	mov	esi, eax
	inc	ecx
	xor	eax, eax
	mov	DWORD PTR ?sObjCount@OObject@@1KA, ecx	; OObject::sObjCount
	mov	ecx, 16					; 00000010H
	mov	edi, esi
	rep stosd
	mov	eax, DWORD PTR [esi+40]
	mov	DWORD PTR [esi+4], 305419896		; 12345678H
	test	eax, eax
	pop	edi
	jne	SHORT $L37637
	mov	DWORD PTR [esi+40], ebx
$L37637:
	mov	eax, DWORD PTR _inParent$[esp+20]
	mov	ecx, esi
	push	eax
	call	?PreConstruct@OObject@@QAEXPAV1@@Z	; OObject::PreConstruct
	mov	DWORD PTR $T37614[esp+24], esi
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+32], 0
	call	??0OObject@@QAE@XZ			; OObject::OObject
	mov	DWORD PTR [esi+56], 0
	mov	DWORD PTR [esi], OFFSET FLAT:??_7OCpjProject@@6B@ ; OCpjProject::`vftable'
	mov	edx, DWORD PTR [esi]
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+32], -1
	call	DWORD PTR [edx+24]
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	eax, esi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L37617:
	mov	eax, DWORD PTR _inSetClass$[ebp-4]
	push	eax
	mov	ecx, DWORD PTR _inParent$[ebp-4]
	push	ecx
	mov	edx, DWORD PTR $T37614[ebp]
	push	edx
	call	??3OCpjProject@@CAXPAXPAVOObject@@PAVCObjClass@@@Z ; OCpjProject::operator delete
	add	esp, 12					; 0000000cH
	ret	0
$L37660:
	mov	eax, OFFSET FLAT:$T37659
	jmp	___CxxFrameHandler
text$x	ENDS
?New@OCpjProject@@SAPAV1@PAVOObject@@PAVCObjClass@@@Z ENDP ; OCpjProject::New
; Function compile flags: /Ogty
;	COMDAT ?GetClass@OCpjProject@@UAEPAVCObjClass@@XZ
_TEXT	SEGMENT
?GetClass@OCpjProject@@UAEPAVCObjClass@@XZ PROC NEAR	; OCpjProject::GetClass, COMDAT
; _this$ = ecx

; 33   : 	OBJ_CLASS_DEFINE(OCpjProject, OCpjRes);	

	mov	eax, DWORD PTR [ecx+40]
	ret	0
?GetClass@OCpjProject@@UAEPAVCObjClass@@XZ ENDP		; OCpjProject::GetClass
_TEXT	ENDS
EXTRN	?SetFileName@OCpjProject@@QAEXPBD@Z:NEAR	; OCpjProject::SetFileName
; Function compile flags: /Ogty
;	COMDAT ?Create@OCpjProject@@UAEXXZ
_TEXT	SEGMENT
?Create@OCpjProject@@UAEXXZ PROC NEAR			; OCpjProject::Create, COMDAT
; _this$ = ecx

; 35   : 	void Create() { Super::Create(); SetFileName(NULL); mIsLocked = 0; }

	push	esi
	mov	esi, ecx
	call	?Create@OObject@@UAEXXZ			; OObject::Create
	push	0
	mov	ecx, esi
	call	?SetFileName@OCpjProject@@QAEXPBD@Z	; OCpjProject::SetFileName
	mov	BYTE PTR [esi+60], 0
	pop	esi
	ret	0
?Create@OCpjProject@@UAEXXZ ENDP			; OCpjProject::Create
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?Destroy@OCpjProject@@UAEXXZ
_TEXT	SEGMENT
?Destroy@OCpjProject@@UAEXXZ PROC NEAR			; OCpjProject::Destroy, COMDAT
; _this$ = ecx

; 36   : 	void Destroy() { SetFileName(NULL); Super::Destroy(); }

	push	esi
	push	0
	mov	esi, ecx
	call	?SetFileName@OCpjProject@@QAEXPBD@Z	; OCpjProject::SetFileName
	mov	ecx, esi
	pop	esi
	jmp	?Destroy@OObject@@UAEXXZ		; OObject::Destroy
?Destroy@OCpjProject@@UAEXXZ ENDP			; OCpjProject::Destroy
_TEXT	ENDS
PUBLIC	?Lock@OCpjProject@@QAE_NXZ			; OCpjProject::Lock
; Function compile flags: /Ogty
;	COMDAT ?Lock@OCpjProject@@QAE_NXZ
_TEXT	SEGMENT
?Lock@OCpjProject@@QAE_NXZ PROC NEAR			; OCpjProject::Lock, COMDAT
; _this$ = ecx

; 38   : 	NBool Lock() { if (mIsLocked) return(0); mIsLocked=1; return(1); }

	mov	al, BYTE PTR [ecx+60]
	test	al, al
	je	SHORT $L7632
	xor	al, al
	ret	0
$L7632:
	mov	al, 1
	mov	BYTE PTR [ecx+60], al
	ret	0
?Lock@OCpjProject@@QAE_NXZ ENDP				; OCpjProject::Lock
_TEXT	ENDS
PUBLIC	?Unlock@OCpjProject@@QAE_NXZ			; OCpjProject::Unlock
; Function compile flags: /Ogty
;	COMDAT ?Unlock@OCpjProject@@QAE_NXZ
_TEXT	SEGMENT
?Unlock@OCpjProject@@QAE_NXZ PROC NEAR			; OCpjProject::Unlock, COMDAT
; _this$ = ecx

; 39   : 	NBool Unlock() { if (!mIsLocked) return(0); mIsLocked=0; return(1); }

	mov	al, BYTE PTR [ecx+60]
	test	al, al
	jne	SHORT $L7635
	xor	al, al
	ret	0
$L7635:
	mov	BYTE PTR [ecx+60], 0
	mov	al, 1
	ret	0
?Unlock@OCpjProject@@QAE_NXZ ENDP			; OCpjProject::Unlock
_TEXT	ENDS
PUBLIC	?IsLocked@OCpjProject@@QAE_NXZ			; OCpjProject::IsLocked
; Function compile flags: /Ogty
;	COMDAT ?IsLocked@OCpjProject@@QAE_NXZ
_TEXT	SEGMENT
?IsLocked@OCpjProject@@QAE_NXZ PROC NEAR		; OCpjProject::IsLocked, COMDAT
; _this$ = ecx

; 40   : 	NBool IsLocked() { return(mIsLocked!=0); }

	mov	dl, BYTE PTR [ecx+60]
	xor	eax, eax
	test	dl, dl
	setne	al
	ret	0
?IsLocked@OCpjProject@@QAE_NXZ ENDP			; OCpjProject::IsLocked
_TEXT	ENDS
PUBLIC	?GetFileName@OCpjProject@@QAEPBDXZ		; OCpjProject::GetFileName
; Function compile flags: /Ogty
;	COMDAT ?GetFileName@OCpjProject@@QAEPBDXZ
_TEXT	SEGMENT
?GetFileName@OCpjProject@@QAEPBDXZ PROC NEAR		; OCpjProject::GetFileName, COMDAT
; _this$ = ecx

; 42   : 	const NChar* GetFileName() { return(*mFileName); }

	mov	eax, DWORD PTR [ecx+56]
	test	eax, eax
	jne	SHORT $L37694
	mov	eax, OFFSET FLAT:??_C@_00A@?$AA@	; `string'
$L37694:
	ret	0
?GetFileName@OCpjProject@@QAEPBDXZ ENDP			; OCpjProject::GetFileName
_TEXT	ENDS
PUBLIC	??_C@_03NCKM@cpj?$AA@				; `string'
;	COMDAT ??_C@_03NCKM@cpj?$AA@
_DATA	SEGMENT
??_C@_03NCKM@cpj?$AA@ DB 'cpj', 00H			; `string'
; Function compile flags: /Ogty
_DATA	ENDS
;	COMDAT ?GetFileExtension@OCpjProject@@UAEPADXZ
_TEXT	SEGMENT
?GetFileExtension@OCpjProject@@UAEPADXZ PROC NEAR	; OCpjProject::GetFileExtension, COMDAT
; _this$ = ecx

; 47   : 	NChar* GetFileExtension() { return("cpj"); }

	mov	eax, OFFSET FLAT:??_C@_03NCKM@cpj?$AA@	; `string'
	ret	0
?GetFileExtension@OCpjProject@@UAEPADXZ ENDP		; OCpjProject::GetFileExtension
_TEXT	ENDS
PUBLIC	??_C@_0BB@DFOH@Cannibal?5Project?$AA@		; `string'
;	COMDAT ??_C@_0BB@DFOH@Cannibal?5Project?$AA@
_DATA	SEGMENT
??_C@_0BB@DFOH@Cannibal?5Project?$AA@ DB 'Cannibal Project', 00H ; `string'
; Function compile flags: /Ogty
_DATA	ENDS
;	COMDAT ?GetFileDescription@OCpjProject@@UAEPADXZ
_TEXT	SEGMENT
?GetFileDescription@OCpjProject@@UAEPADXZ PROC NEAR	; OCpjProject::GetFileDescription, COMDAT
; _this$ = ecx

; 48   : 	NChar* GetFileDescription() { return("Cannibal Project"); }

	mov	eax, OFFSET FLAT:??_C@_0BB@DFOH@Cannibal?5Project?$AA@ ; `string'
	ret	0
?GetFileDescription@OCpjProject@@UAEPADXZ ENDP		; OCpjProject::GetFileDescription
_TEXT	ENDS
PUBLIC	??0OCpjProject@@QAE@XZ				; OCpjProject::OCpjProject
; Function compile flags: /Ogty
;	COMDAT ??0OCpjProject@@QAE@XZ
_TEXT	SEGMENT
??0OCpjProject@@QAE@XZ PROC NEAR			; OCpjProject::OCpjProject, COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??0OObject@@QAE@XZ			; OObject::OObject
	mov	DWORD PTR [esi+56], 0
	mov	DWORD PTR [esi], OFFSET FLAT:??_7OCpjProject@@6B@ ; OCpjProject::`vftable'
	mov	eax, esi
	pop	esi
	ret	0
??0OCpjProject@@QAE@XZ ENDP				; OCpjProject::OCpjProject
_TEXT	ENDS
PUBLIC	??0OCpjProject@@QAE@ABV0@@Z			; OCpjProject::OCpjProject
;	COMDAT xdata$x
xdata$x	SEGMENT
$T37813	DD	0ffffffffH
	DD	FLAT:$L37725
	DD	00H
	DD	FLAT:$L37726
	DD	0ffffffffH
	DD	FLAT:$L37720
$T37808	DD	019930520H
	DD	03H
	DD	FLAT:$T37813
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ??0OCpjProject@@QAE@ABV0@@Z
_TEXT	SEGMENT
__$EHRec$ = -12
___that$ = 8
_this$ = -16
??0OCpjProject@@QAE@ABV0@@Z PROC NEAR			; OCpjProject::OCpjProject, COMDAT
; _this$ = ecx
	push	-1
	push	$L37812
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	push	ebx
	mov	ebx, DWORD PTR ___that$[esp+16]
	push	ebp
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [ebx+8]
	push	edi
	mov	DWORD PTR _this$[esp+32], esi
	mov	DWORD PTR [esi], OFFSET FLAT:??_7IMsgTarget@@6B@ ; IMsgTarget::`vftable'
	mov	eax, DWORD PTR [ebx+4]
	mov	DWORD PTR [esi+4], eax
	mov	eax, DWORD PTR [ecx]
	lea	edx, DWORD PTR [esi+8]
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], ecx
	lea	edx, DWORD PTR [ebx+24]
	lea	ecx, DWORD PTR [esi+24]
	xor	eax, eax
	mov	edi, DWORD PTR [edx]
	mov	DWORD PTR __$EHRec$[esp+40], eax
	mov	DWORD PTR [ecx], edi
	mov	edi, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], edi
	mov	edi, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], edi
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [ecx+12], edx
	mov	ecx, DWORD PTR [ebx+40]
	mov	BYTE PTR __$EHRec$[esp+40], 1
	mov	DWORD PTR [esi+40], ecx
	mov	DWORD PTR [esi+44], eax
	mov	ebp, DWORD PTR [ebx+44]
	cmp	ebp, eax
	je	SHORT $L37777
	cmp	BYTE PTR [ebp], 0
	jne	SHORT $L37777
	xor	ebp, ebp
$L37777:
	cmp	ebp, eax
	mov	DWORD PTR [esi+44], eax
	je	SHORT $L37780
	mov	edi, ebp
	or	ecx, -1
	xor	eax, eax
	repne scasb
	not	ecx
	dec	ecx
	mov	edi, ecx
	inc	edi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	edi
	mov	ecx, eax
	call	DWORD PTR [edx]
	test	eax, eax
	mov	DWORD PTR [esi+44], eax
	je	SHORT $L37811
$L37774:
	mov	cl, BYTE PTR [ebp]
	inc	ebp
	mov	BYTE PTR [eax], cl
	inc	eax
	test	cl, cl
	jne	SHORT $L37774
	add	DWORD PTR ?sMemTotal@CCorString@@0KA, edi ; CCorString::sMemTotal
$L37811:
	xor	eax, eax
$L37780:
	mov	ecx, DWORD PTR [ebx+48]
	mov	DWORD PTR [esi+48], ecx
	mov	edx, DWORD PTR [ebx+52]
	mov	DWORD PTR [esi+52], edx
	mov	DWORD PTR [esi], OFFSET FLAT:??_7OCpjRes@@6B@ ; OCpjRes::`vftable'
	mov	DWORD PTR [esi+56], eax
	mov	ebp, DWORD PTR [ebx+56]
	cmp	ebp, eax
	mov	DWORD PTR __$EHRec$[esp+40], 2
	je	SHORT $L37801
	cmp	BYTE PTR [ebp], 0
	jne	SHORT $L37801
	xor	ebp, ebp
$L37801:
	cmp	ebp, eax
	mov	DWORD PTR [esi+56], eax
	je	SHORT $L37804
	mov	edi, ebp
	or	ecx, -1
	xor	eax, eax
	repne scasb
	not	ecx
	dec	ecx
	mov	edi, ecx
	inc	edi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	edi
	mov	ecx, eax
	call	DWORD PTR [edx]
	test	eax, eax
	mov	DWORD PTR [esi+56], eax
	je	SHORT $L37804
$L37798:
	mov	cl, BYTE PTR [ebp]
	inc	ebp
	mov	BYTE PTR [eax], cl
	inc	eax
	test	cl, cl
	jne	SHORT $L37798
	add	DWORD PTR ?sMemTotal@CCorString@@0KA, edi ; CCorString::sMemTotal
$L37804:
	mov	al, BYTE PTR [ebx+60]
	mov	ecx, DWORD PTR __$EHRec$[esp+32]
	mov	BYTE PTR [esi+60], al
	mov	DWORD PTR [esi], OFFSET FLAT:??_7OCpjProject@@6B@ ; OCpjProject::`vftable'
	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L37725:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1CObjLink@@QAE@XZ			; CObjLink::~CObjLink
$L37726:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	jmp	??1CObjLink@@QAE@XZ			; CObjLink::~CObjLink
$L37720:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1OCpjRes@@UAE@XZ			; OCpjRes::~OCpjRes
$L37812:
	mov	eax, OFFSET FLAT:$T37808
	jmp	___CxxFrameHandler
text$x	ENDS
??0OCpjProject@@QAE@ABV0@@Z ENDP			; OCpjProject::OCpjProject
PUBLIC	??4OCpjProject@@QAEAAV0@ABV0@@Z			; OCpjProject::operator=
; Function compile flags: /Ogty
;	COMDAT ??4OCpjProject@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8
??4OCpjProject@@QAEAAV0@ABV0@@Z PROC NEAR		; OCpjProject::operator=, COMDAT
; _this$ = ecx
	push	ebx
	mov	ebx, DWORD PTR ___that$[esp]
	push	ebp
	push	esi
	mov	eax, DWORD PTR [ebx+4]
	mov	esi, ecx
	lea	ecx, DWORD PTR [ebx+8]
	push	edi
	mov	DWORD PTR [esi+4], eax
	lea	edx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	lea	eax, DWORD PTR [esi+24]
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], ecx
	lea	edx, DWORD PTR [ebx+24]
	mov	ecx, DWORD PTR [ebx+24]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR [ebx+40]
	mov	DWORD PTR [esi+40], eax
	mov	ebp, DWORD PTR [ebx+44]
	test	ebp, ebp
	je	SHORT $L37869
	cmp	BYTE PTR [ebp], 0
	jne	SHORT $L37869
	xor	ebp, ebp
$L37869:
	mov	edi, DWORD PTR [esi+44]
	test	edi, edi
	je	SHORT $L37870
	or	ecx, -1
	xor	eax, eax
	repne scasb
	mov	eax, DWORD PTR ?sMemTotal@CCorString@@0KA ; CCorString::sMemTotal
	or	edx, -1
	not	ecx
	dec	ecx
	sub	edx, ecx
	add	eax, edx
	mov	DWORD PTR ?sMemTotal@CCorString@@0KA, eax ; CCorString::sMemTotal
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+44]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L37870:
	test	ebp, ebp
	mov	DWORD PTR [esi+44], 0
	je	SHORT $L37873
	mov	edi, ebp
	or	ecx, -1
	xor	eax, eax
	repne scasb
	not	ecx
	dec	ecx
	mov	edi, ecx
	inc	edi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	edi
	mov	ecx, eax
	call	DWORD PTR [edx]
	test	eax, eax
	mov	DWORD PTR [esi+44], eax
	je	SHORT $L37873
$L37867:
	mov	cl, BYTE PTR [ebp]
	inc	ebp
	mov	BYTE PTR [eax], cl
	inc	eax
	test	cl, cl
	jne	SHORT $L37867
	add	DWORD PTR ?sMemTotal@CCorString@@0KA, edi ; CCorString::sMemTotal
$L37873:
	mov	eax, DWORD PTR [ebx+48]
	mov	DWORD PTR [esi+48], eax
	mov	ecx, DWORD PTR [ebx+52]
	mov	DWORD PTR [esi+52], ecx
	mov	ebp, DWORD PTR [ebx+56]
	test	ebp, ebp
	je	SHORT $L37893
	cmp	BYTE PTR [ebp], 0
	jne	SHORT $L37893
	xor	ebp, ebp
$L37893:
	mov	edi, DWORD PTR [esi+56]
	test	edi, edi
	je	SHORT $L37894
	or	ecx, -1
	xor	eax, eax
	repne scasb
	mov	eax, DWORD PTR ?sMemTotal@CCorString@@0KA ; CCorString::sMemTotal
	or	edx, -1
	not	ecx
	dec	ecx
	sub	edx, ecx
	add	eax, edx
	mov	DWORD PTR ?sMemTotal@CCorString@@0KA, eax ; CCorString::sMemTotal
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+56]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L37894:
	test	ebp, ebp
	mov	DWORD PTR [esi+56], 0
	je	SHORT $L37897
	mov	edi, ebp
	or	ecx, -1
	xor	eax, eax
	repne scasb
	not	ecx
	dec	ecx
	mov	edi, ecx
	inc	edi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	edi
	mov	ecx, eax
	call	DWORD PTR [edx]
	test	eax, eax
	mov	DWORD PTR [esi+56], eax
	je	SHORT $L37897
$L37891:
	mov	cl, BYTE PTR [ebp]
	inc	ebp
	mov	BYTE PTR [eax], cl
	inc	eax
	test	cl, cl
	jne	SHORT $L37891
	add	DWORD PTR ?sMemTotal@CCorString@@0KA, edi ; CCorString::sMemTotal
$L37897:
	mov	al, BYTE PTR [ebx+60]
	pop	edi
	mov	BYTE PTR [esi+60], al
	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx
	ret	4
??4OCpjProject@@QAEAAV0@ABV0@@Z ENDP			; OCpjProject::operator=
_TEXT	ENDS
PUBLIC	??1OCpjProject@@UAE@XZ				; OCpjProject::~OCpjProject
;	COMDAT xdata$x
xdata$x	SEGMENT
$T37939	DD	0ffffffffH
	DD	FLAT:$L37906
$T37936	DD	019930520H
	DD	01H
	DD	FLAT:$T37939
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ??1OCpjProject@@UAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12
_this$ = -16
??1OCpjProject@@UAE@XZ PROC NEAR			; OCpjProject::~OCpjProject, COMDAT
; _this$ = ecx
	push	-1
	push	$L37938
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	push	esi
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+24], esi
	mov	edi, DWORD PTR [esi+56]
	mov	DWORD PTR __$EHRec$[esp+32], 0
	test	edi, edi
	je	SHORT $L37925
	or	ecx, -1
	xor	eax, eax
	repne scasb
	not	ecx
	dec	ecx
	or	eax, -1
	sub	eax, ecx
	mov	ecx, DWORD PTR ?sMemTotal@CCorString@@0KA ; CCorString::sMemTotal
	add	ecx, eax
	mov	DWORD PTR ?sMemTotal@CCorString@@0KA, ecx ; CCorString::sMemTotal
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+56]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L37925:
	mov	ecx, esi
	mov	DWORD PTR [esi+56], 0
	mov	DWORD PTR __$EHRec$[esp+32], -1
	call	??1OObject@@UAE@XZ			; OObject::~OObject
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L37906:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1OCpjRes@@UAE@XZ			; OCpjRes::~OCpjRes
$L37938:
	mov	eax, OFFSET FLAT:$T37936
	jmp	___CxxFrameHandler
text$x	ENDS
??1OCpjProject@@UAE@XZ ENDP				; OCpjProject::~OCpjProject
PUBLIC	??_GOCpjProject@@UAEPAXI@Z			; OCpjProject::`scalar deleting destructor'
; Function compile flags: /Ogty
;	COMDAT ??_GOCpjProject@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_GOCpjProject@@UAEPAXI@Z PROC NEAR			; OCpjProject::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1OCpjProject@@UAE@XZ			; OCpjProject::~OCpjProject
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $L37957
	mov	DWORD PTR [esi+4], 0
	mov	edx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	dec	edx
	mov	DWORD PTR ?sObjCount@OObject@@1KA, edx	; OObject::sObjCount
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L37957:
	mov	eax, esi
	pop	esi
	ret	4
??_GOCpjProject@@UAEPAXI@Z ENDP				; OCpjProject::`scalar deleting destructor'
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??_EOCpjProject@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_EOCpjProject@@UAEPAXI@Z PROC NEAR			; OCpjProject::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebx
	mov	bl, BYTE PTR ___flags$[esp]
	push	esi
	mov	esi, ecx
	test	bl, 2
	je	SHORT $L7663
	mov	eax, DWORD PTR [esi-4]
	push	edi
	lea	edi, DWORD PTR [esi-4]
	push	OFFSET FLAT:??1OCpjProject@@UAE@XZ	; OCpjProject::~OCpjProject
	push	eax
	push	64					; 00000040H
	push	esi
	call	??_M@YGXPAXIHP6EX0@Z@Z			; `eh vector destructor iterator'
	test	bl, 1
	je	SHORT $L7664
	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L7664:
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	ret	4
$L7663:
	mov	ecx, esi
	call	??1OCpjProject@@UAE@XZ			; OCpjProject::~OCpjProject
	test	bl, 1
	je	SHORT $L37972
	mov	DWORD PTR [esi+4], 0
	mov	edx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	dec	edx
	mov	DWORD PTR ?sObjCount@OObject@@1KA, edx	; OObject::sObjCount
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L37972:
	mov	eax, esi
	pop	esi
	pop	ebx
	ret	4
??_EOCpjProject@@UAEPAXI@Z ENDP				; OCpjProject::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??2OCpjGeometry@@CAPAXIPAVOObject@@PAVCObjClass@@@Z ; OCpjGeometry::operator new
; Function compile flags: /Ogty
; File C:\duke4\Cannibal\CpjGeo.h
;	COMDAT ??2OCpjGeometry@@CAPAXIPAVOObject@@PAVCObjClass@@@Z
_TEXT	SEGMENT
_inParent$ = 12
_inSetClass$ = 16
??2OCpjGeometry@@CAPAXIPAVOObject@@PAVCObjClass@@@Z PROC NEAR ; OCpjGeometry::operator new, COMDAT

; 68   : 	OBJ_CLASS_DEFINE(OCpjGeometry, OCpjChunk);

	push	esi
	push	edi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	136					; 00000088H
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	ecx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	mov	esi, eax
	inc	ecx
	xor	eax, eax
	mov	DWORD PTR ?sObjCount@OObject@@1KA, ecx	; OObject::sObjCount
	mov	ecx, 34					; 00000022H
	mov	edi, esi
	rep stosd
	mov	eax, DWORD PTR [esi+40]
	mov	DWORD PTR [esi+4], 305419896		; 12345678H
	test	eax, eax
	jne	SHORT $L37983
	mov	eax, DWORD PTR _inSetClass$[esp+4]
	mov	DWORD PTR [esi+40], eax
$L37983:
	mov	ecx, DWORD PTR _inParent$[esp+4]
	push	ecx
	mov	ecx, esi
	call	?PreConstruct@OObject@@QAEXPAV1@@Z	; OObject::PreConstruct
	mov	eax, esi
	pop	edi
	pop	esi
	ret	0
??2OCpjGeometry@@CAPAXIPAVOObject@@PAVCObjClass@@@Z ENDP ; OCpjGeometry::operator new
_TEXT	ENDS
PUBLIC	??3OCpjGeometry@@CAXPAX@Z			; OCpjGeometry::operator delete
; Function compile flags: /Ogty
;	COMDAT ??3OCpjGeometry@@CAXPAX@Z
_TEXT	SEGMENT
_ptr$ = 8
??3OCpjGeometry@@CAXPAX@Z PROC NEAR			; OCpjGeometry::operator delete, COMDAT

; 68   : 	OBJ_CLASS_DEFINE(OCpjGeometry, OCpjChunk);

	push	esi
	mov	esi, DWORD PTR _ptr$[esp]
	mov	DWORD PTR [esi+4], 0
	mov	edx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	dec	edx
	mov	DWORD PTR ?sObjCount@OObject@@1KA, edx	; OObject::sObjCount
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	ecx, eax
	call	DWORD PTR [edx+8]
	pop	esi
	ret	0
??3OCpjGeometry@@CAXPAX@Z ENDP				; OCpjGeometry::operator delete
_TEXT	ENDS
PUBLIC	??3OCpjGeometry@@CAXPAXPAVOObject@@PAVCObjClass@@@Z ; OCpjGeometry::operator delete
; Function compile flags: /Ogty
;	COMDAT ??3OCpjGeometry@@CAXPAXPAVOObject@@PAVCObjClass@@@Z
_TEXT	SEGMENT
_ptr$ = 8
??3OCpjGeometry@@CAXPAXPAVOObject@@PAVCObjClass@@@Z PROC NEAR ; OCpjGeometry::operator delete, COMDAT

; 68   : 	OBJ_CLASS_DEFINE(OCpjGeometry, OCpjChunk);

	push	esi
	mov	esi, DWORD PTR _ptr$[esp]
	mov	DWORD PTR [esi+4], 0
	mov	edx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	dec	edx
	mov	DWORD PTR ?sObjCount@OObject@@1KA, edx	; OObject::sObjCount
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	ecx, eax
	call	DWORD PTR [edx+8]
	pop	esi
	ret	0
??3OCpjGeometry@@CAXPAXPAVOObject@@PAVCObjClass@@@Z ENDP ; OCpjGeometry::operator delete
_TEXT	ENDS
PUBLIC	?GetStaticClass@OCpjGeometry@@SAPAVCObjClass@@XZ ; OCpjGeometry::GetStaticClass
; Function compile flags: /Ogty
;	COMDAT ?GetStaticClass@OCpjGeometry@@SAPAVCObjClass@@XZ
_TEXT	SEGMENT
?GetStaticClass@OCpjGeometry@@SAPAVCObjClass@@XZ PROC NEAR ; OCpjGeometry::GetStaticClass, COMDAT

; 68   : 	OBJ_CLASS_DEFINE(OCpjGeometry, OCpjChunk);

	mov	eax, DWORD PTR ?staticObjClass@OCpjGeometry@@0PAVCObjClass@@A ; OCpjGeometry::staticObjClass
	ret	0
?GetStaticClass@OCpjGeometry@@SAPAVCObjClass@@XZ ENDP	; OCpjGeometry::GetStaticClass
_TEXT	ENDS
PUBLIC	?New@OCpjGeometry@@SAPAV1@PAVOObject@@PAVCObjClass@@@Z ; OCpjGeometry::New
PUBLIC	?GetClass@OCpjGeometry@@UAEPAVCObjClass@@XZ	; OCpjGeometry::GetClass
PUBLIC	??1?$TCorArray@VCCpjGeoVert@@@@QAE@XZ		; TCorArray<CCpjGeoVert>::~TCorArray<CCpjGeoVert>
PUBLIC	??1?$TCorArray@VCCpjGeoEdge@@@@QAE@XZ		; TCorArray<CCpjGeoEdge>::~TCorArray<CCpjGeoEdge>
PUBLIC	??1?$TCorArray@VCCpjGeoTri@@@@QAE@XZ		; TCorArray<CCpjGeoTri>::~TCorArray<CCpjGeoTri>
PUBLIC	?GetFileExtension@OCpjGeometry@@UAEPADXZ	; OCpjGeometry::GetFileExtension
PUBLIC	?GetFileDescription@OCpjGeometry@@UAEPADXZ	; OCpjGeometry::GetFileDescription
PUBLIC	??_7OCpjGeometry@@6B@				; OCpjGeometry::`vftable'
PUBLIC	??_EOCpjGeometry@@UAEPAXI@Z			; OCpjGeometry::`vector deleting destructor'
EXTRN	?LoadChunk@OCpjGeometry@@UAE_NPAXK@Z:NEAR	; OCpjGeometry::LoadChunk
EXTRN	?SaveChunk@OCpjGeometry@@UAE_NPAXPAK@Z:NEAR	; OCpjGeometry::SaveChunk
EXTRN	?GetFourCC@OCpjGeometry@@UAEKXZ:NEAR		; OCpjGeometry::GetFourCC
;	COMDAT xdata$x
; File C:\duke4\Cannibal\CorMain.h
xdata$x	SEGMENT
$T38116	DD	0ffffffffH
	DD	FLAT:$L38011
	DD	00H
	DD	FLAT:$L38036
	DD	01H
	DD	FLAT:$L38037
	DD	02H
	DD	FLAT:$L38038
	DD	03H
	DD	FLAT:$L38039
$T38114	DD	019930520H
	DD	05H
	DD	FLAT:$T38116
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_7OCpjGeometry@@6B@
CONST	SEGMENT
??_7OCpjGeometry@@6B@ DD FLAT:?Msg@OObject@@UAE_NPAVIMsg@@@Z ; OCpjGeometry::`vftable'
	DD	FLAT:?MsgGetChild@OObject@@UAEPAVIMsgTarget@@PAD@Z
	DD	FLAT:?MsgGetParent@OObject@@UAEPAVIMsgTarget@@XZ
	DD	FLAT:?MsgGetRoot@OObject@@UAEPAVIMsgTarget@@XZ
	DD	FLAT:?GetClass@OCpjGeometry@@UAEPAVCObjClass@@XZ
	DD	FLAT:??_EOCpjGeometry@@UAEPAXI@Z
	DD	FLAT:?Create@OCpjChunk@@UAEXXZ
	DD	FLAT:?Destroy@OObject@@UAEXXZ
	DD	FLAT:?GetParent@OObject@@UAEPAV1@XZ
	DD	FLAT:?SetParent@OObject@@UAEXPAV1@_N@Z
	DD	FLAT:?HasChildren@OObject@@UAE_NXZ
	DD	FLAT:?IsA@OObject@@UAE_NPAVCObjClass@@@Z
	DD	FLAT:?GetFileExtension@OCpjGeometry@@UAEPADXZ
	DD	FLAT:?GetFileDescription@OCpjGeometry@@UAEPADXZ
	DD	FLAT:?LoadFile@OCpjChunk@@UAE_NPAD@Z
	DD	FLAT:?SaveFile@OCpjChunk@@UAE_NPAD@Z
	DD	FLAT:?GetFourCC@OCpjGeometry@@UAEKXZ
	DD	FLAT:?LoadChunk@OCpjGeometry@@UAE_NPAXK@Z
	DD	FLAT:?SaveChunk@OCpjGeometry@@UAE_NPAXPAK@Z
; Function compile flags: /Ogty
; File C:\duke4\Cannibal\CpjGeo.h
CONST	ENDS
;	COMDAT ?New@OCpjGeometry@@SAPAV1@PAVOObject@@PAVCObjClass@@@Z
_TEXT	SEGMENT
$T38008 = -16
__$EHRec$ = -12
_inParent$ = 8
_inSetClass$ = 12
?New@OCpjGeometry@@SAPAV1@PAVOObject@@PAVCObjClass@@@Z PROC NEAR ; OCpjGeometry::New, COMDAT

; 68   : 	OBJ_CLASS_DEFINE(OCpjGeometry, OCpjChunk);

	push	-1
	push	$L38115
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _inSetClass$[esp+20]
	xor	ebx, ebx
	cmp	ebp, ebx
	push	esi
	jne	SHORT $L8090
	mov	ebp, DWORD PTR ?staticObjClass@OCpjGeometry@@0PAVCObjClass@@A ; OCpjGeometry::staticObjClass
	mov	DWORD PTR _inSetClass$[esp+24], ebp
$L8090:
	push	edi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	136					; 00000088H
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	ecx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	mov	esi, eax
	inc	ecx
	xor	eax, eax
	mov	DWORD PTR ?sObjCount@OObject@@1KA, ecx	; OObject::sObjCount
	mov	ecx, 34					; 00000022H
	mov	edi, esi
	rep stosd
	mov	eax, DWORD PTR [esi+40]
	mov	DWORD PTR [esi+4], 305419896		; 12345678H
	cmp	eax, ebx
	pop	edi
	jne	SHORT $L38031
	mov	DWORD PTR [esi+40], ebp
$L38031:
	mov	eax, DWORD PTR _inParent$[esp+24]
	mov	ecx, esi
	push	eax
	call	?PreConstruct@OObject@@QAEXPAV1@@Z	; OObject::PreConstruct
	mov	DWORD PTR $T38008[esp+28], esi
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+36], ebx
	call	??0OObject@@QAE@XZ			; OObject::OObject
	mov	DWORD PTR [esi], OFFSET FLAT:??_7OCpjChunk@@6B@ ; OCpjChunk::`vftable'
	lea	ecx, DWORD PTR [esi+72]
	push	48					; 00000030H
	mov	BYTE PTR __$EHRec$[esp+40], 1
	mov	DWORD PTR [ecx], ebx
	mov	DWORD PTR [ecx+4], ebx
	mov	DWORD PTR [ecx+8], ebx
	mov	DWORD PTR [ecx+12], 48			; 00000030H
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
	lea	ecx, DWORD PTR [esi+88]
	push	28					; 0000001cH
	mov	BYTE PTR __$EHRec$[esp+40], 2
	mov	DWORD PTR [ecx], ebx
	mov	DWORD PTR [ecx+4], ebx
	mov	DWORD PTR [ecx+8], ebx
	mov	DWORD PTR [ecx+12], 28			; 0000001cH
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
	lea	ecx, DWORD PTR [esi+104]
	push	12					; 0000000cH
	mov	BYTE PTR __$EHRec$[esp+40], 3
	mov	DWORD PTR [ecx], ebx
	mov	DWORD PTR [ecx+4], ebx
	mov	DWORD PTR [ecx+8], ebx
	mov	DWORD PTR [ecx+12], 12			; 0000000cH
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
	lea	ecx, DWORD PTR [esi+120]
	push	140					; 0000008cH
	mov	BYTE PTR __$EHRec$[esp+40], 4
	mov	DWORD PTR [ecx], ebx
	mov	DWORD PTR [ecx+4], ebx
	mov	DWORD PTR [ecx+8], ebx
	mov	DWORD PTR [ecx+12], 140			; 0000008cH
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
	mov	DWORD PTR [esi], OFFSET FLAT:??_7OCpjGeometry@@6B@ ; OCpjGeometry::`vftable'
	mov	edx, DWORD PTR [esi]
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+36], -1
	call	DWORD PTR [edx+24]
	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L38011:
	mov	eax, DWORD PTR _inSetClass$[ebp-4]
	push	eax
	mov	ecx, DWORD PTR _inParent$[ebp-4]
	push	ecx
	mov	edx, DWORD PTR $T38008[ebp]
	push	edx
	call	??3OCpjGeometry@@CAXPAXPAVOObject@@PAVCObjClass@@@Z ; OCpjGeometry::operator delete
	add	esp, 12					; 0000000cH
	ret	0
$L38036:
	mov	ecx, DWORD PTR $T38008[ebp]
	jmp	??1OCpjChunk@@UAE@XZ			; OCpjChunk::~OCpjChunk
$L38037:
	mov	ecx, DWORD PTR $T38008[ebp]
	add	ecx, 72					; 00000048H
	jmp	??1?$TCorArray@VCCpjGeoVert@@@@QAE@XZ	; TCorArray<CCpjGeoVert>::~TCorArray<CCpjGeoVert>
$L38038:
	mov	ecx, DWORD PTR $T38008[ebp]
	add	ecx, 88					; 00000058H
	jmp	??1?$TCorArray@VCCpjGeoEdge@@@@QAE@XZ	; TCorArray<CCpjGeoEdge>::~TCorArray<CCpjGeoEdge>
$L38039:
	mov	ecx, DWORD PTR $T38008[ebp]
	add	ecx, 104				; 00000068H
	jmp	??1?$TCorArray@VCCpjGeoTri@@@@QAE@XZ	; TCorArray<CCpjGeoTri>::~TCorArray<CCpjGeoTri>
$L38115:
	mov	eax, OFFSET FLAT:$T38114
	jmp	___CxxFrameHandler
text$x	ENDS
?New@OCpjGeometry@@SAPAV1@PAVOObject@@PAVCObjClass@@@Z ENDP ; OCpjGeometry::New
PUBLIC	??1?$TCorArray@PAVCCpjGeoEdge@@@@QAE@XZ		; TCorArray<CCpjGeoEdge *>::~TCorArray<CCpjGeoEdge *>
PUBLIC	?Remove@?$TCorArray@PAVCCpjGeoEdge@@@@QAEXKK@Z	; TCorArray<CCpjGeoEdge *>::Remove
PUBLIC	?Remove@?$TCorArray@PAVCCpjGeoTri@@@@QAEXKK@Z	; TCorArray<CCpjGeoTri *>::Remove
;	COMDAT xdata$x
; File C:\duke4\Cannibal\CorMain.h
xdata$x	SEGMENT
$T38240	DD	0ffffffffH
	DD	FLAT:$L38122
	DD	00H
	DD	FLAT:$L38130
	DD	01H
	DD	FLAT:$L38133
	DD	00H
	DD	FLAT:$L38143
$T38236	DD	019930520H
	DD	04H
	DD	FLAT:$T38240
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ??1?$TCorArray@VCCpjGeoVert@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -24
$T38141 = -16
$T38151 = -16
$T38175 = -20
$T38204 = -28
__$EHRec$ = -12
??1?$TCorArray@VCCpjGeoVert@@@@QAE@XZ PROC NEAR		; TCorArray<CCpjGeoVert>::~TCorArray<CCpjGeoVert>, COMDAT
; _this$ = ecx

; 280  : 	{

	push	-1
	push	$L38239
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 20					; 00000014H
	push	ebx
	push	ebp
	mov	ebp, ecx
	push	esi
	mov	DWORD PTR _this$[esp+44], ebp

; 281  : 		Purge();

	mov	esi, DWORD PTR [ebp+4]
	xor	ebx, ebx
	cmp	esi, ebx
	mov	DWORD PTR __$EHRec$[esp+52], ebx
	mov	DWORD PTR $T38204[esp+44], esi
	jbe	SHORT $L38230
	mov	DWORD PTR -32+[esp+44], esi
	push	edi
$L38228:
	mov	esi, DWORD PTR [ebp]
	add	esi, ebx
	mov	DWORD PTR $T38175[esp+48], esi
	lea	edi, DWORD PTR [esi+32]
	mov	DWORD PTR $T38141[esp+48], edi
	mov	eax, DWORD PTR [edi+4]
	mov	ecx, edi
	push	eax
	push	0
	mov	BYTE PTR __$EHRec$[esp+64], 2
	call	?Remove@?$TCorArray@PAVCCpjGeoTri@@@@QAEXKK@Z ; TCorArray<CCpjGeoTri *>::Remove
	mov	ecx, edi
	mov	BYTE PTR __$EHRec$[esp+56], 1
	call	??1CCorArray@@IAE@XZ			; CCorArray::~CCorArray
	add	esi, 16					; 00000010H
	mov	DWORD PTR $T38151[esp+48], esi
	mov	ecx, DWORD PTR [esi+4]
	mov	BYTE PTR __$EHRec$[esp+56], 3
	push	ecx
	push	0
	mov	ecx, esi
	call	?Remove@?$TCorArray@PAVCCpjGeoEdge@@@@QAEXKK@Z ; TCorArray<CCpjGeoEdge *>::Remove
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+56], 0
	call	??1CCorArray@@IAE@XZ			; CCorArray::~CCorArray
	mov	eax, DWORD PTR -32+[esp+48]
	add	ebx, 48					; 00000030H
	dec	eax
	mov	DWORD PTR -32+[esp+48], eax
	jne	SHORT $L38228
	mov	esi, DWORD PTR $T38204[esp+48]
	pop	edi
$L38230:
	test	esi, esi
	je	SHORT $L38224
	mov	edx, DWORD PTR [ebp+4]
	mov	ecx, DWORD PTR [ebp]
	lea	eax, DWORD PTR [esi+esi*2]
	lea	edx, DWORD PTR [edx+edx*2]
	shl	eax, 4
	shl	edx, 4
	sub	edx, eax
	add	eax, ecx
	push	edx
	push	eax
	push	ecx
	call	DWORD PTR __imp__memmove
	mov	eax, DWORD PTR [ebp+4]
	add	esp, 12					; 0000000cH
	sub	eax, esi
	mov	DWORD PTR [ebp+4], eax
$L38224:

; 282  : 	}

	mov	eax, DWORD PTR [ebp]
	mov	DWORD PTR __$EHRec$[esp+52], -1
	test	eax, eax
	je	SHORT $L38234
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [ebp]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L38234:
	mov	ecx, DWORD PTR __$EHRec$[esp+44]
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 32					; 00000020H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L38122:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CCorArray@@IAE@XZ			; CCorArray::~CCorArray
$L38130:
	mov	ecx, DWORD PTR $T38175[ebp]
	add	ecx, 16					; 00000010H
	jmp	??1?$TCorArray@PAVCCpjGeoEdge@@@@QAE@XZ	; TCorArray<CCpjGeoEdge *>::~TCorArray<CCpjGeoEdge *>
$L38133:
	mov	ecx, DWORD PTR $T38141[ebp]
	jmp	??1CCorArray@@IAE@XZ			; CCorArray::~CCorArray
$L38143:
	mov	ecx, DWORD PTR $T38151[ebp]
	jmp	??1CCorArray@@IAE@XZ			; CCorArray::~CCorArray
$L38239:
	mov	eax, OFFSET FLAT:$T38236
	jmp	___CxxFrameHandler
text$x	ENDS
??1?$TCorArray@VCCpjGeoVert@@@@QAE@XZ ENDP		; TCorArray<CCpjGeoVert>::~TCorArray<CCpjGeoVert>
; Function compile flags: /Ogty
;	COMDAT ??1?$TCorArray@PAVCCpjGeoEdge@@@@QAE@XZ
_TEXT	SEGMENT
??1?$TCorArray@PAVCCpjGeoEdge@@@@QAE@XZ PROC NEAR	; TCorArray<CCpjGeoEdge *>::~TCorArray<CCpjGeoEdge *>, COMDAT
; _this$ = ecx

; 280  : 	{

	push	esi
	mov	esi, ecx
	push	edi

; 281  : 		Purge();

	mov	edi, DWORD PTR [esi+4]
	test	edi, edi
	je	SHORT $L38267
	mov	eax, DWORD PTR [esi]
	mov	ecx, edi
	sub	ecx, edi
	shl	ecx, 2
	lea	edx, DWORD PTR [eax+edi*4]
	push	ecx
	push	edx
	push	eax
	call	DWORD PTR __imp__memmove
	mov	eax, DWORD PTR [esi+4]
	add	esp, 12					; 0000000cH
	sub	eax, edi
	mov	DWORD PTR [esi+4], eax
$L38267:

; 282  : 	}

	cmp	DWORD PTR [esi], 0
	je	SHORT $L38277
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L38277:
	pop	edi
	pop	esi
	ret	0
??1?$TCorArray@PAVCCpjGeoEdge@@@@QAE@XZ ENDP		; TCorArray<CCpjGeoEdge *>::~TCorArray<CCpjGeoEdge *>
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
$T38393	DD	0ffffffffH
	DD	FLAT:$L38283
	DD	00H
	DD	FLAT:$L38293
$T38389	DD	019930520H
	DD	02H
	DD	FLAT:$T38393
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ??1?$TCorArray@VCCpjGeoEdge@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20
$T38308 = -16
__$EHRec$ = -12
??1?$TCorArray@VCCpjGeoEdge@@@@QAE@XZ PROC NEAR		; TCorArray<CCpjGeoEdge>::~TCorArray<CCpjGeoEdge>, COMDAT
; _this$ = ecx

; 280  : 	{

	push	-1
	push	$L38392
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, ecx
	mov	DWORD PTR _this$[esp+40], edi

; 281  : 		Purge();

	mov	ebx, DWORD PTR [edi+4]
	xor	ebp, ebp
	cmp	ebx, ebp
	mov	DWORD PTR __$EHRec$[esp+48], ebp
	jbe	SHORT $L38383

; 280  : 	{

	mov	DWORD PTR -24+[esp+40], ebx

; 281  : 		Purge();

$L38381:
	mov	eax, DWORD PTR [edi]
	add	eax, ebp
	lea	esi, DWORD PTR [eax+12]
	mov	DWORD PTR $T38308[esp+40], esi
	mov	eax, DWORD PTR [esi+4]
	mov	ecx, esi
	push	eax
	push	0
	mov	BYTE PTR __$EHRec$[esp+56], 1
	call	?Remove@?$TCorArray@PAVCCpjGeoTri@@@@QAEXKK@Z ; TCorArray<CCpjGeoTri *>::Remove
	mov	eax, DWORD PTR [esi]
	mov	BYTE PTR __$EHRec$[esp+48], 0
	test	eax, eax
	je	SHORT $L38375
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L38375:
	mov	eax, DWORD PTR -24+[esp+40]
	add	ebp, 28					; 0000001cH
	dec	eax
	mov	DWORD PTR -24+[esp+40], eax
	jne	SHORT $L38381
$L38383:
	test	ebx, ebx
	je	SHORT $L38377
	mov	edx, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi]
	lea	eax, DWORD PTR [ebx*8]
	lea	esi, DWORD PTR [edx*8]
	sub	eax, ebx
	sub	esi, edx
	shl	eax, 2
	shl	esi, 2
	sub	esi, eax
	add	eax, ecx
	push	esi
	push	eax
	push	ecx
	call	DWORD PTR __imp__memmove
	mov	eax, DWORD PTR [edi+4]
	add	esp, 12					; 0000000cH
	sub	eax, ebx
	mov	DWORD PTR [edi+4], eax
$L38377:

; 282  : 	}

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR __$EHRec$[esp+48], -1
	test	eax, eax
	je	SHORT $L38387
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L38387:
	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 24					; 00000018H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L38283:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CCorArray@@IAE@XZ			; CCorArray::~CCorArray
$L38293:
	mov	ecx, DWORD PTR $T38308[ebp]
	jmp	??1CCorArray@@IAE@XZ			; CCorArray::~CCorArray
$L38392:
	mov	eax, OFFSET FLAT:$T38389
	jmp	___CxxFrameHandler
text$x	ENDS
??1?$TCorArray@VCCpjGeoEdge@@@@QAE@XZ ENDP		; TCorArray<CCpjGeoEdge>::~TCorArray<CCpjGeoEdge>
; Function compile flags: /Ogty
;	COMDAT ??1?$TCorArray@VCCpjGeoTri@@@@QAE@XZ
_TEXT	SEGMENT
??1?$TCorArray@VCCpjGeoTri@@@@QAE@XZ PROC NEAR		; TCorArray<CCpjGeoTri>::~TCorArray<CCpjGeoTri>, COMDAT
; _this$ = ecx

; 280  : 	{

	push	esi
	mov	esi, ecx
	push	edi

; 281  : 		Purge();

	mov	edi, DWORD PTR [esi+4]
	test	edi, edi
	je	SHORT $L38420
	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [edi+edi*2]
	shl	eax, 2
	mov	edx, eax
	sub	edx, eax
	add	eax, ecx
	push	edx
	push	eax
	push	ecx
	call	DWORD PTR __imp__memmove
	mov	eax, DWORD PTR [esi+4]
	add	esp, 12					; 0000000cH
	sub	eax, edi
	mov	DWORD PTR [esi+4], eax
$L38420:

; 282  : 	}

	cmp	DWORD PTR [esi], 0
	je	SHORT $L38430
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L38430:
	pop	edi
	pop	esi
	ret	0
??1?$TCorArray@VCCpjGeoTri@@@@QAE@XZ ENDP		; TCorArray<CCpjGeoTri>::~TCorArray<CCpjGeoTri>
; Function compile flags: /Ogty
; File C:\duke4\Cannibal\CpjGeo.h
_TEXT	ENDS
;	COMDAT ?GetClass@OCpjGeometry@@UAEPAVCObjClass@@XZ
_TEXT	SEGMENT
?GetClass@OCpjGeometry@@UAEPAVCObjClass@@XZ PROC NEAR	; OCpjGeometry::GetClass, COMDAT
; _this$ = ecx

; 68   : 	OBJ_CLASS_DEFINE(OCpjGeometry, OCpjChunk);

	mov	eax, DWORD PTR [ecx+40]
	ret	0
?GetClass@OCpjGeometry@@UAEPAVCObjClass@@XZ ENDP	; OCpjGeometry::GetClass
_TEXT	ENDS
PUBLIC	??_C@_03LMJE@geo?$AA@				; `string'
;	COMDAT ??_C@_03LMJE@geo?$AA@
_DATA	SEGMENT
??_C@_03LMJE@geo?$AA@ DB 'geo', 00H			; `string'
; Function compile flags: /Ogty
_DATA	ENDS
;	COMDAT ?GetFileExtension@OCpjGeometry@@UAEPADXZ
_TEXT	SEGMENT
?GetFileExtension@OCpjGeometry@@UAEPADXZ PROC NEAR	; OCpjGeometry::GetFileExtension, COMDAT
; _this$ = ecx

; 83   : 	NChar* GetFileExtension() { return("geo"); }

	mov	eax, OFFSET FLAT:??_C@_03LMJE@geo?$AA@	; `string'
	ret	0
?GetFileExtension@OCpjGeometry@@UAEPADXZ ENDP		; OCpjGeometry::GetFileExtension
_TEXT	ENDS
PUBLIC	??_C@_0BC@LDNG@Cannibal?5Geometry?$AA@		; `string'
;	COMDAT ??_C@_0BC@LDNG@Cannibal?5Geometry?$AA@
_DATA	SEGMENT
??_C@_0BC@LDNG@Cannibal?5Geometry?$AA@ DB 'Cannibal Geometry', 00H ; `string'
; Function compile flags: /Ogty
_DATA	ENDS
;	COMDAT ?GetFileDescription@OCpjGeometry@@UAEPADXZ
_TEXT	SEGMENT
?GetFileDescription@OCpjGeometry@@UAEPADXZ PROC NEAR	; OCpjGeometry::GetFileDescription, COMDAT
; _this$ = ecx

; 84   : 	NChar* GetFileDescription() { return("Cannibal Geometry"); }

	mov	eax, OFFSET FLAT:??_C@_0BC@LDNG@Cannibal?5Geometry?$AA@ ; `string'
	ret	0
?GetFileDescription@OCpjGeometry@@UAEPADXZ ENDP		; OCpjGeometry::GetFileDescription
_TEXT	ENDS
PUBLIC	??0OCpjGeometry@@QAE@XZ				; OCpjGeometry::OCpjGeometry
;	COMDAT xdata$x
xdata$x	SEGMENT
$T38565	DD	0ffffffffH
	DD	FLAT:$L38445
	DD	00H
	DD	FLAT:$L38446
	DD	01H
	DD	FLAT:$L38447
	DD	02H
	DD	FLAT:$L38448
$T38563	DD	019930520H
	DD	04H
	DD	FLAT:$T38565
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ??0OCpjGeometry@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12
_this$ = -16
??0OCpjGeometry@@QAE@XZ PROC NEAR			; OCpjGeometry::OCpjGeometry, COMDAT
; _this$ = ecx
	push	-1
	push	$L38564
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	push	esi
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+24], esi
	call	??0OObject@@QAE@XZ			; OObject::OObject
	mov	DWORD PTR [esi], OFFSET FLAT:??_7OCpjChunk@@6B@ ; OCpjChunk::`vftable'
	lea	ecx, DWORD PTR [esi+72]
	xor	edi, edi
	push	48					; 00000030H
	mov	DWORD PTR __$EHRec$[esp+36], edi
	mov	DWORD PTR [ecx], edi
	mov	DWORD PTR [ecx+4], edi
	mov	DWORD PTR [ecx+8], edi
	mov	DWORD PTR [ecx+12], 48			; 00000030H
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
	lea	ecx, DWORD PTR [esi+88]
	push	28					; 0000001cH
	mov	BYTE PTR __$EHRec$[esp+36], 1
	mov	DWORD PTR [ecx], edi
	mov	DWORD PTR [ecx+4], edi
	mov	DWORD PTR [ecx+8], edi
	mov	DWORD PTR [ecx+12], 28			; 0000001cH
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
	mov	DWORD PTR [esi+108], edi
	mov	DWORD PTR [esi+112], edi
	mov	DWORD PTR [esi+116], 12			; 0000000cH
	mov	DWORD PTR [esi+104], edi
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR [esi+124], edi
	mov	DWORD PTR [esi+128], edi
	mov	DWORD PTR [esi+132], 140		; 0000008cH
	mov	DWORD PTR [esi+120], edi
	mov	DWORD PTR [esi], OFFSET FLAT:??_7OCpjGeometry@@6B@ ; OCpjGeometry::`vftable'
	mov	eax, esi
	pop	edi
	pop	esi
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L38445:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1OCpjChunk@@UAE@XZ			; OCpjChunk::~OCpjChunk
$L38446:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 72					; 00000048H
	jmp	??1?$TCorArray@VCCpjGeoVert@@@@QAE@XZ	; TCorArray<CCpjGeoVert>::~TCorArray<CCpjGeoVert>
$L38447:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 88					; 00000058H
	jmp	??1?$TCorArray@VCCpjGeoEdge@@@@QAE@XZ	; TCorArray<CCpjGeoEdge>::~TCorArray<CCpjGeoEdge>
$L38448:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 104				; 00000068H
	jmp	??1?$TCorArray@VCCpjGeoTri@@@@QAE@XZ	; TCorArray<CCpjGeoTri>::~TCorArray<CCpjGeoTri>
$L38564:
	mov	eax, OFFSET FLAT:$T38563
	jmp	___CxxFrameHandler
text$x	ENDS
??0OCpjGeometry@@QAE@XZ ENDP				; OCpjGeometry::OCpjGeometry
PUBLIC	??0CCpjGeoVert@@QAE@AAV0@@Z			; CCpjGeoVert::CCpjGeoVert
PUBLIC	??0CCpjGeoEdge@@QAE@AAV0@@Z			; CCpjGeoEdge::CCpjGeoEdge
PUBLIC	?AddNoConstruct@?$TCorArray@VCCpjGeoEdge@@@@QAEKK@Z ; TCorArray<CCpjGeoEdge>::AddNoConstruct
PUBLIC	?AddNoConstruct@?$TCorArray@VCCpjGeoTri@@@@QAEKK@Z ; TCorArray<CCpjGeoTri>::AddNoConstruct
PUBLIC	??0?$TCorArray@VCCpjGeoMount@@@@QAE@AAV0@@Z	; TCorArray<CCpjGeoMount>::TCorArray<CCpjGeoMount>
PUBLIC	??0OCpjGeometry@@QAE@AAV0@@Z			; OCpjGeometry::OCpjGeometry
;	COMDAT xdata$x
xdata$x	SEGMENT
$T38727	DD	0ffffffffH
	DD	FLAT:$L38571
	DD	00H
	DD	FLAT:$L38592
	DD	01H
	DD	FLAT:$L38593
	DD	00H
	DD	FLAT:$L38572
	DD	03H
	DD	FLAT:$L38643
	DD	04H
	DD	FLAT:$L38644
	DD	03H
	DD	FLAT:$L38573
	DD	06H
	DD	FLAT:$L38686
	DD	06H
	DD	FLAT:$L38574
$T38718	DD	019930520H
	DD	09H
	DD	FLAT:$T38727
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ??0OCpjGeometry@@QAE@AAV0@@Z
_TEXT	SEGMENT
_i$38616 = -32
$T38622 = -16
$T38623 = -20
$T38635 = -24
$T38661 = -24
$T38662 = -20
$T38678 = -16
$T38715 = -16
__$EHRec$ = -12
___that$ = 8
_this$ = -28
??0OCpjGeometry@@QAE@AAV0@@Z PROC NEAR			; OCpjGeometry::OCpjGeometry, COMDAT
; _this$ = ecx
	push	-1
	push	$L38726
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 20					; 00000014H
	push	ebx
	push	ebp
	push	esi
	mov	esi, DWORD PTR ___that$[esp+40]
	push	edi
	mov	ebp, ecx
	push	esi
	mov	DWORD PTR _this$[esp+52], ebp
	call	??0OObject@@QAE@ABV0@@Z			; OObject::OObject
	mov	DWORD PTR [ebp], OFFSET FLAT:??_7OCpjRes@@6B@ ; OCpjRes::`vftable'
	mov	al, BYTE PTR [esi+56]
	mov	BYTE PTR [ebp+56], al
	mov	ecx, DWORD PTR [esi+60]
	mov	DWORD PTR [ebp+60], ecx
	mov	edx, DWORD PTR [esi+64]
	mov	DWORD PTR [ebp+64], edx
	mov	eax, DWORD PTR [esi+68]
	mov	DWORD PTR [ebp+68], eax
	mov	DWORD PTR [ebp], OFFSET FLAT:??_7OCpjChunk@@6B@ ; OCpjChunk::`vftable'
	mov	eax, DWORD PTR [esi+76]
	lea	edi, DWORD PTR [ebp+72]
	xor	ebx, ebx
	push	48					; 00000030H
	mov	ecx, edi
	mov	DWORD PTR __$EHRec$[esp+60], ebx
	mov	DWORD PTR $T38635[esp+52], edi
	mov	DWORD PTR [edi], ebx
	mov	DWORD PTR [edi+4], eax
	mov	DWORD PTR [edi+8], eax
	mov	DWORD PTR [edi+12], 48			; 00000030H
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
	mov	DWORD PTR [edi+4], ebx
	mov	eax, DWORD PTR [esi+76]
	cmp	eax, ebx
	mov	BYTE PTR __$EHRec$[esp+56], 1
	mov	DWORD PTR _i$38616[esp+48], ebx
	jbe	SHORT $L38619
	mov	DWORD PTR 8+[esp+44], ebx
$L38617:
	mov	ebx, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi+8]
	lea	eax, DWORD PTR [ebx+1]
	cmp	eax, ecx
	mov	DWORD PTR [edi+4], eax
	jbe	SHORT $L38630
	mov	ecx, eax
	push	48					; 00000030H
	shr	ecx, 2
	lea	edx, DWORD PTR [ecx+eax+32]
	mov	ecx, edi
	mov	DWORD PTR [edi+8], edx
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
$L38630:
	mov	eax, DWORD PTR [edi]
	lea	ecx, DWORD PTR [ebx+ebx*2]
	shl	ecx, 4
	add	ecx, eax
	mov	DWORD PTR $T38623[esp+48], ecx
	mov	DWORD PTR $T38622[esp+48], ecx
	mov	BYTE PTR __$EHRec$[esp+56], 2
	je	SHORT $L38624
	mov	eax, DWORD PTR [esi+72]
	mov	ebx, DWORD PTR 8+[esp+44]
	add	eax, ebx
	push	eax
	call	??0CCpjGeoVert@@QAE@AAV0@@Z		; CCpjGeoVert::CCpjGeoVert
$L38624:
	mov	eax, DWORD PTR _i$38616[esp+48]
	mov	edx, DWORD PTR 8+[esp+44]
	mov	ecx, DWORD PTR [esi+76]
	inc	eax
	add	edx, 48					; 00000030H
	cmp	eax, ecx
	mov	BYTE PTR __$EHRec$[esp+56], 1
	mov	DWORD PTR _i$38616[esp+48], eax
	mov	DWORD PTR 8+[esp+44], edx
	jb	SHORT $L38617
	xor	ebx, ebx
$L38619:
	mov	eax, DWORD PTR [esi+92]
	lea	edi, DWORD PTR [ebp+88]
	push	28					; 0000001cH
	mov	ecx, edi
	mov	BYTE PTR __$EHRec$[esp+60], 3
	mov	DWORD PTR $T38678[esp+52], edi
	mov	DWORD PTR [edi], ebx
	mov	DWORD PTR [edi+4], eax
	mov	DWORD PTR [edi+8], eax
	mov	DWORD PTR [edi+12], 28			; 0000001cH
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
	mov	DWORD PTR [edi+4], ebx
	mov	eax, DWORD PTR [esi+92]
	test	eax, eax
	mov	BYTE PTR __$EHRec$[esp+56], 4
	jbe	SHORT $L38677
	mov	DWORD PTR 8+[esp+44], 0
$L38675:
	push	1
	mov	ecx, edi
	call	?AddNoConstruct@?$TCorArray@VCCpjGeoEdge@@@@QAEKK@Z ; TCorArray<CCpjGeoEdge>::AddNoConstruct
	mov	edx, DWORD PTR [edi]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	ecx, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR $T38662[esp+48], ecx
	mov	DWORD PTR $T38661[esp+48], ecx
	test	ecx, ecx
	mov	BYTE PTR __$EHRec$[esp+56], 5
	je	SHORT $L38663
	mov	eax, DWORD PTR [esi+88]
	mov	edx, DWORD PTR 8+[esp+44]
	add	eax, edx
	push	eax
	call	??0CCpjGeoEdge@@QAE@AAV0@@Z		; CCpjGeoEdge::CCpjGeoEdge
$L38663:
	mov	ecx, DWORD PTR 8+[esp+44]
	mov	eax, DWORD PTR [esi+92]
	inc	ebx
	add	ecx, 28					; 0000001cH
	cmp	ebx, eax
	mov	BYTE PTR __$EHRec$[esp+56], 4
	mov	DWORD PTR 8+[esp+44], ecx
	jb	SHORT $L38675
$L38677:
	mov	ecx, DWORD PTR [esi+108]
	lea	edi, DWORD PTR [ebp+104]
	push	12					; 0000000cH
	push	ecx
	mov	ecx, edi
	mov	BYTE PTR __$EHRec$[esp+64], 6
	mov	DWORD PTR $T38715[esp+56], edi
	call	??0CCorArray@@IAE@KK@Z			; CCorArray::CCorArray
	xor	ebx, ebx
	mov	BYTE PTR __$EHRec$[esp+56], 7
	mov	DWORD PTR [edi+4], ebx
	mov	eax, DWORD PTR [esi+108]
	cmp	eax, ebx
	jbe	SHORT $L38714
	mov	DWORD PTR 8+[esp+44], ebx
$L38712:
	push	1
	mov	ecx, edi
	call	?AddNoConstruct@?$TCorArray@VCCpjGeoTri@@@@QAEKK@Z ; TCorArray<CCpjGeoTri>::AddNoConstruct
	lea	edx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR [edi]
	lea	eax, DWORD PTR [eax+edx*4]
	test	eax, eax
	je	SHORT $L38702
	mov	ecx, DWORD PTR [esi+104]
	mov	edx, DWORD PTR 8+[esp+44]
	add	ecx, edx
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ecx
$L38702:
	mov	ecx, DWORD PTR 8+[esp+44]
	mov	eax, DWORD PTR [esi+108]
	inc	ebx
	add	ecx, 12					; 0000000cH
	cmp	ebx, eax
	mov	DWORD PTR 8+[esp+44], ecx
	jb	SHORT $L38712
$L38714:
	add	esi, 120				; 00000078H
	lea	ecx, DWORD PTR [ebp+120]
	push	esi
	mov	BYTE PTR __$EHRec$[esp+60], 8
	call	??0?$TCorArray@VCCpjGeoMount@@@@QAE@AAV0@@Z ; TCorArray<CCpjGeoMount>::TCorArray<CCpjGeoMount>
	mov	ecx, DWORD PTR __$EHRec$[esp+48]
	pop	edi
	mov	DWORD PTR [ebp], OFFSET FLAT:??_7OCpjGeometry@@6B@ ; OCpjGeometry::`vftable'
	mov	eax, ebp
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 32					; 00000020H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L38571:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1OCpjChunk@@UAE@XZ			; OCpjChunk::~OCpjChunk
$L38592:
	mov	ecx, DWORD PTR $T38635[ebp]
	jmp	??1CCorArray@@IAE@XZ			; CCorArray::~CCorArray
$L38593:
	mov	eax, DWORD PTR $T38623[ebp]
	push	eax
	mov	ecx, DWORD PTR $T38622[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
$L38572:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 72					; 00000048H
	jmp	??1?$TCorArray@VCCpjGeoVert@@@@QAE@XZ	; TCorArray<CCpjGeoVert>::~TCorArray<CCpjGeoVert>
$L38643:
	mov	ecx, DWORD PTR $T38678[ebp]
	jmp	??1CCorArray@@IAE@XZ			; CCorArray::~CCorArray
$L38644:
	mov	eax, DWORD PTR $T38662[ebp]
	push	eax
	mov	ecx, DWORD PTR $T38661[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
$L38573:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 88					; 00000058H
	jmp	??1?$TCorArray@VCCpjGeoEdge@@@@QAE@XZ	; TCorArray<CCpjGeoEdge>::~TCorArray<CCpjGeoEdge>
$L38686:
	mov	ecx, DWORD PTR $T38715[ebp]
	jmp	??1CCorArray@@IAE@XZ			; CCorArray::~CCorArray
$L38574:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 104				; 00000068H
	jmp	??1?$TCorArray@VCCpjGeoTri@@@@QAE@XZ	; TCorArray<CCpjGeoTri>::~TCorArray<CCpjGeoTri>
$L38726:
	mov	eax, OFFSET FLAT:$T38718
	jmp	___CxxFrameHandler
text$x	ENDS
??0OCpjGeometry@@QAE@AAV0@@Z ENDP			; OCpjGeometry::OCpjGeometry
;	COMDAT xdata$x
; File C:\duke4\Cannibal\VecMain.h
xdata$x	SEGMENT
$T38888	DD	0ffffffffH
	DD	FLAT:$L38738
$T38883	DD	019930520H
	DD	01H
	DD	FLAT:$T38888
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File C:\duke4\Cannibal\CorMain.h
xdata$x	ENDS
;	COMDAT ??0?$TCorArray@VCCpjGeoMount@@@@QAE@AAV0@@Z
_TEXT	SEGMENT
__$EHRec$ = -12
_this$ = -16
_i$ = -20
_inArray$ = 8
??0?$TCorArray@VCCpjGeoMount@@@@QAE@AAV0@@Z PROC NEAR	; TCorArray<CCpjGeoMount>::TCorArray<CCpjGeoMount>, COMDAT
; _this$ = ecx

; 263  : 	{

	push	-1
	push	$L38887
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	ebp
	push	edi
	mov	edi, DWORD PTR _inArray$[esp+32]
	mov	ebx, ecx
	xor	ebp, ebp
	mov	eax, DWORD PTR [edi+4]
	push	140					; 0000008cH
	mov	DWORD PTR _this$[esp+40], ebx
	mov	DWORD PTR [ebx], ebp
	mov	DWORD PTR [ebx+4], eax
	mov	DWORD PTR [ebx+8], eax
	mov	DWORD PTR [ebx+12], 140			; 0000008cH
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc

; 264  : 		m_Count = 0;

	mov	DWORD PTR [ebx+4], ebp

; 265  : 		for (NDword i=0;i<inArray.m_Count;i++)

	mov	eax, DWORD PTR [edi+4]
	cmp	eax, ebp
	mov	DWORD PTR __$EHRec$[esp+44], ebp
	mov	DWORD PTR _i$[esp+36], ebp
	jbe	$L38886
	mov	DWORD PTR -24+[esp+36], ebp
	push	esi
$L13661:

; 266  : 			new(&(*this)[AddNoConstruct()]) T(inArray[i]);

	mov	esi, DWORD PTR [ebx+4]
	mov	ecx, DWORD PTR [ebx+8]
	lea	eax, DWORD PTR [esi+1]
	cmp	eax, ecx
	mov	DWORD PTR [ebx+4], eax
	jbe	SHORT $L38748
	mov	ecx, eax
	push	140					; 0000008cH
	shr	ecx, 2
	lea	edx, DWORD PTR [ecx+eax+32]
	mov	ecx, ebx
	mov	DWORD PTR [ebx+8], edx
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
$L38748:
	mov	ecx, DWORD PTR [ebx]
	lea	eax, DWORD PTR [esi*8]
	sub	eax, esi
	lea	eax, DWORD PTR [eax+eax*4]
	lea	eax, DWORD PTR [ecx+eax*4]
	cmp	eax, ebp
	je	$L38736
	mov	edx, DWORD PTR [edi]
	mov	ecx, DWORD PTR -24+[esp+40]
	add	edx, ecx
	mov	ecx, 16					; 00000010H
	mov	esi, edx
	mov	edi, eax
	rep movsd
	mov	ecx, DWORD PTR [edx+64]
	mov	edi, DWORD PTR _inArray$[esp+36]
	mov	DWORD PTR [eax+64], ecx
	mov	ecx, DWORD PTR [edx+68]
	mov	DWORD PTR [eax+68], ecx
	mov	ecx, DWORD PTR [edx+72]
	mov	DWORD PTR [eax+72], ecx
	mov	ecx, DWORD PTR [edx+76]
	mov	DWORD PTR [eax+76], ecx
	mov	ecx, 1065353216				; 3f800000H
	mov	DWORD PTR [eax+80], ecx
	mov	DWORD PTR [eax+84], ebp
	mov	DWORD PTR [eax+88], ebp
	mov	DWORD PTR [eax+92], ebp
	mov	DWORD PTR [eax+96], ecx
	mov	DWORD PTR [eax+100], ebp
	mov	DWORD PTR [eax+104], ebp
	mov	DWORD PTR [eax+108], ebp
	mov	DWORD PTR [eax+112], ecx
	mov	ecx, DWORD PTR [edx+80]
	mov	DWORD PTR [eax+80], ecx
	mov	ecx, DWORD PTR [edx+84]
	mov	DWORD PTR [eax+84], ecx
	mov	ecx, DWORD PTR [edx+88]
	mov	DWORD PTR [eax+88], ecx
	mov	ecx, DWORD PTR [edx+92]
	mov	DWORD PTR [eax+92], ecx
	mov	ecx, DWORD PTR [edx+96]
	mov	DWORD PTR [eax+96], ecx
	mov	ecx, DWORD PTR [edx+100]
	mov	DWORD PTR [eax+100], ecx
	mov	ecx, DWORD PTR [edx+104]
	mov	DWORD PTR [eax+104], ecx
	mov	ecx, DWORD PTR [edx+108]
	mov	DWORD PTR [eax+108], ecx
	mov	ecx, DWORD PTR [edx+112]
	mov	DWORD PTR [eax+112], ecx
	mov	ecx, DWORD PTR [edx+116]
	mov	DWORD PTR [eax+116], ecx
	mov	ecx, DWORD PTR [edx+120]
	mov	DWORD PTR [eax+120], ecx
	mov	ecx, DWORD PTR [edx+124]
	mov	DWORD PTR [eax+124], ecx
	mov	ecx, DWORD PTR [edx+128]
	mov	DWORD PTR [eax+128], ecx
	mov	ecx, DWORD PTR [edx+132]
	mov	DWORD PTR [eax+132], ecx
	mov	edx, DWORD PTR [edx+136]
	mov	DWORD PTR [eax+136], edx
$L38736:
	mov	eax, DWORD PTR _i$[esp+40]
	mov	edx, DWORD PTR -24+[esp+40]
	mov	ecx, DWORD PTR [edi+4]
	inc	eax
	add	edx, 140				; 0000008cH
	cmp	eax, ecx
	mov	DWORD PTR _i$[esp+40], eax
	mov	DWORD PTR -24+[esp+40], edx
	jb	$L13661
	pop	esi
$L38886:

; 267  : 	}

	mov	ecx, DWORD PTR __$EHRec$[esp+36]
	pop	edi
	mov	eax, ebx
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 24					; 00000018H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L38738:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CCorArray@@IAE@XZ			; CCorArray::~CCorArray
$L38887:
	mov	eax, OFFSET FLAT:$T38883
	jmp	___CxxFrameHandler
text$x	ENDS
??0?$TCorArray@VCCpjGeoMount@@@@QAE@AAV0@@Z ENDP	; TCorArray<CCpjGeoMount>::TCorArray<CCpjGeoMount>
PUBLIC	??4?$TCorArray@VCCpjGeoVert@@@@QAEAAV0@AAV0@@Z	; TCorArray<CCpjGeoVert>::operator=
PUBLIC	??4?$TCorArray@VCCpjGeoEdge@@@@QAEAAV0@AAV0@@Z	; TCorArray<CCpjGeoEdge>::operator=
PUBLIC	??4?$TCorArray@VCCpjGeoTri@@@@QAEAAV0@AAV0@@Z	; TCorArray<CCpjGeoTri>::operator=
PUBLIC	??4?$TCorArray@VCCpjGeoMount@@@@QAEAAV0@AAV0@@Z	; TCorArray<CCpjGeoMount>::operator=
PUBLIC	??4OCpjGeometry@@QAEAAV0@AAV0@@Z		; OCpjGeometry::operator=
; Function compile flags: /Ogty
;	COMDAT ??4OCpjGeometry@@QAEAAV0@AAV0@@Z
_TEXT	SEGMENT
___that$ = 8
??4OCpjGeometry@@QAEAAV0@AAV0@@Z PROC NEAR		; OCpjGeometry::operator=, COMDAT
; _this$ = ecx
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR ___that$[esp+4]
	push	esi
	mov	esi, ecx
	push	edi
	mov	eax, DWORD PTR [ebp+4]
	lea	ecx, DWORD PTR [ebp+8]
	mov	DWORD PTR [esi+4], eax
	lea	edx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	lea	eax, DWORD PTR [esi+24]
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], ecx
	lea	edx, DWORD PTR [ebp+24]
	mov	ecx, DWORD PTR [ebp+24]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR [ebp+40]
	mov	DWORD PTR [esi+40], eax
	mov	ebx, DWORD PTR [ebp+44]
	test	ebx, ebx
	je	SHORT $L38963
	cmp	BYTE PTR [ebx], 0
	jne	SHORT $L38963
	xor	ebx, ebx
$L38963:
	mov	edi, DWORD PTR [esi+44]
	test	edi, edi
	je	SHORT $L38964
	or	ecx, -1
	xor	eax, eax
	repne scasb
	mov	eax, DWORD PTR ?sMemTotal@CCorString@@0KA ; CCorString::sMemTotal
	or	edx, -1
	not	ecx
	dec	ecx
	sub	edx, ecx
	add	eax, edx
	mov	DWORD PTR ?sMemTotal@CCorString@@0KA, eax ; CCorString::sMemTotal
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+44]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L38964:
	test	ebx, ebx
	mov	DWORD PTR [esi+44], 0
	je	SHORT $L38967
	mov	edi, ebx
	or	ecx, -1
	xor	eax, eax
	repne scasb
	not	ecx
	dec	ecx
	mov	edi, ecx
	inc	edi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	edi
	mov	ecx, eax
	call	DWORD PTR [edx]
	test	eax, eax
	mov	DWORD PTR [esi+44], eax
	je	SHORT $L38967
$L38961:
	mov	cl, BYTE PTR [ebx]
	inc	ebx
	mov	BYTE PTR [eax], cl
	inc	eax
	test	cl, cl
	jne	SHORT $L38961
	add	DWORD PTR ?sMemTotal@CCorString@@0KA, edi ; CCorString::sMemTotal
$L38967:
	mov	eax, DWORD PTR [ebp+48]
	mov	DWORD PTR [esi+48], eax
	mov	ecx, DWORD PTR [ebp+52]
	mov	DWORD PTR [esi+52], ecx
	mov	dl, BYTE PTR [ebp+56]
	mov	BYTE PTR [esi+56], dl
	mov	eax, DWORD PTR [ebp+60]
	mov	DWORD PTR [esi+60], eax
	mov	ecx, DWORD PTR [ebp+64]
	mov	DWORD PTR [esi+64], ecx
	mov	edx, DWORD PTR [ebp+68]
	lea	eax, DWORD PTR [ebp+72]
	lea	ecx, DWORD PTR [esi+72]
	push	eax
	mov	DWORD PTR [esi+68], edx
	call	??4?$TCorArray@VCCpjGeoVert@@@@QAEAAV0@AAV0@@Z ; TCorArray<CCpjGeoVert>::operator=
	lea	ecx, DWORD PTR [ebp+88]
	push	ecx
	lea	ecx, DWORD PTR [esi+88]
	call	??4?$TCorArray@VCCpjGeoEdge@@@@QAEAAV0@AAV0@@Z ; TCorArray<CCpjGeoEdge>::operator=
	lea	edx, DWORD PTR [ebp+104]
	lea	ecx, DWORD PTR [esi+104]
	push	edx
	call	??4?$TCorArray@VCCpjGeoTri@@@@QAEAAV0@AAV0@@Z ; TCorArray<CCpjGeoTri>::operator=
	add	ebp, 120				; 00000078H
	lea	ecx, DWORD PTR [esi+120]
	push	ebp
	call	??4?$TCorArray@VCCpjGeoMount@@@@QAEAAV0@AAV0@@Z ; TCorArray<CCpjGeoMount>::operator=
	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	4
??4OCpjGeometry@@QAEAAV0@AAV0@@Z ENDP			; OCpjGeometry::operator=
_TEXT	ENDS
PUBLIC	?AddNoConstruct@?$TCorArray@PAVCCpjGeoTri@@@@QAEKK@Z ; TCorArray<CCpjGeoTri *>::AddNoConstruct
;	COMDAT xdata$x
xdata$x	SEGMENT
$T39167	DD	0ffffffffH
	DD	FLAT:$L38980
	DD	00H
	DD	FLAT:$L39020
	DD	00H
	DD	FLAT:$L39007
	DD	02H
	DD	FLAT:$L39071
$T39156	DD	019930520H
	DD	04H
	DD	FLAT:$T39167
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ??4?$TCorArray@VCCpjGeoVert@@@@QAEAAV0@AAV0@@Z
_TEXT	SEGMENT
_this$ = -28
_i$ = -32
$T38976 = -20
$T38977 = -24
$T39063 = -16
$T39106 = -16
_i$39130 = -36
__$EHRec$ = -12
_inArray$ = 8
??4?$TCorArray@VCCpjGeoVert@@@@QAEAAV0@AAV0@@Z PROC NEAR ; TCorArray<CCpjGeoVert>::operator=, COMDAT
; _this$ = ecx

; 269  : 	{

	push	-1
	push	$L39165
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 28					; 0000001cH
	push	ebx
	push	esi

; 270  : 		if (this == &inArray)

	mov	esi, DWORD PTR _inArray$[esp+44]
	mov	ebx, ecx
	cmp	ebx, esi
	mov	DWORD PTR _this$[esp+48], ebx

; 271  : 			return(*this);

	je	$L39166
	push	edi

; 272  : 		m_Count = 0;

	xor	edi, edi
	mov	DWORD PTR [ebx+4], edi

; 273  : 		m_Limit = inArray.m_Count;

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [ebx+8], eax

; 274  : 		Realloc(sizeof(T));

	mov	eax, DWORD PTR [ebx]
	cmp	eax, edi
	mov	eax, DWORD PTR [ebx+8]
	mov	DWORD PTR [ebx+12], 48			; 00000030H
	je	SHORT $L38984
	cmp	eax, edi
	je	SHORT $L38986
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [ebx+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [ebx+8]
	push	ecx
	mov	ecx, DWORD PTR [ebx]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+4]
	mov	DWORD PTR [ebx], eax
	jmp	SHORT $L38991
$L38986:
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [ebx]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L38990:
	mov	DWORD PTR [ebx], edi
$L38991:

; 275  : 		for (NDword i=0;i<inArray.m_Count;i++)

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR _i$[esp+52], edi
	cmp	eax, edi
	jbe	$L13571
	push	ebp
	mov	DWORD PTR -40+[esp+56], edi
	jmp	SHORT $L13569

; 274  : 		Realloc(sizeof(T));

$L38984:
	cmp	eax, edi
	je	SHORT $L38990
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [ebx+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [ebx+8]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	DWORD PTR [ebx], eax
	jmp	SHORT $L38991
$L39164:

; 275  : 		for (NDword i=0;i<inArray.m_Count;i++)

	xor	edi, edi
$L13569:

; 276  : 			new(&(*this)[AddNoConstruct()]) T(inArray[i]);

	mov	ebp, DWORD PTR [ebx+4]
	mov	ecx, DWORD PTR [ebx+8]
	lea	eax, DWORD PTR [ebp+1]
	cmp	eax, ecx
	mov	DWORD PTR [ebx+4], eax
	jbe	SHORT $L38996
	mov	edx, eax
	push	48					; 00000030H
	shr	edx, 2
	mov	ecx, ebx
	lea	eax, DWORD PTR [edx+eax+32]
	mov	DWORD PTR [ebx+8], eax
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
$L38996:
	mov	eax, DWORD PTR [ebx]
	lea	ebp, DWORD PTR [ebp+ebp*2]
	shl	ebp, 4
	add	ebp, eax
	mov	DWORD PTR $T38977[esp+56], ebp
	mov	DWORD PTR $T38976[esp+56], ebp
	mov	DWORD PTR __$EHRec$[esp+64], edi
	je	$L39153
	mov	esi, DWORD PTR [esi]
	mov	edx, DWORD PTR -40+[esp+56]
	add	esi, edx
	lea	edi, DWORD PTR [ebp+16]
	push	4
	mov	DWORD PTR $T39063[esp+60], edi
	mov	cl, BYTE PTR [esi]
	mov	BYTE PTR [ebp], cl
	mov	dl, BYTE PTR [esi+1]
	mov	BYTE PTR [ebp+1], dl
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [ebp+4], eax
	mov	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR [ebp+8], ecx
	mov	edx, DWORD PTR [esi+12]
	mov	DWORD PTR [ebp+12], edx
	mov	eax, DWORD PTR [esi+20]
	mov	ecx, edi
	mov	DWORD PTR [edi], 0
	mov	DWORD PTR [edi+4], eax
	mov	DWORD PTR [edi+8], eax
	mov	DWORD PTR [edi+12], 4
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
	xor	ecx, ecx
	mov	BYTE PTR __$EHRec$[esp+64], 1
	mov	DWORD PTR [edi+4], ecx
	mov	eax, DWORD PTR [esi+20]
	cmp	eax, ecx
	mov	DWORD PTR _i$39130[esp+56], ecx
	jbe	SHORT $L39133
$L39131:
	mov	ebx, DWORD PTR [edi+4]
	mov	edx, DWORD PTR [edi+8]
	lea	eax, DWORD PTR [ebx+1]
	cmp	eax, edx
	mov	DWORD PTR [edi+4], eax
	jbe	SHORT $L39122
	mov	ecx, eax
	push	4
	shr	ecx, 2
	lea	edx, DWORD PTR [ecx+eax+32]
	mov	ecx, edi
	mov	DWORD PTR [edi+8], edx
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
	mov	ecx, DWORD PTR _i$39130[esp+56]
$L39122:
	mov	eax, DWORD PTR [edi]
	lea	eax, DWORD PTR [eax+ebx*4]
	test	eax, eax
	je	SHORT $L39115
	mov	edx, DWORD PTR [esi+16]
	mov	edx, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR [eax], edx
$L39115:
	mov	eax, DWORD PTR [esi+20]
	inc	ecx
	cmp	ecx, eax
	mov	DWORD PTR _i$39130[esp+56], ecx
	jb	SHORT $L39131
	mov	ebx, DWORD PTR _this$[esp+56]
$L39133:
	mov	eax, DWORD PTR [esi+36]
	lea	edi, DWORD PTR [ebp+32]
	push	4
	mov	ecx, edi
	mov	BYTE PTR __$EHRec$[esp+68], 2
	mov	DWORD PTR $T39106[esp+60], edi
	mov	DWORD PTR [edi], 0
	mov	DWORD PTR [edi+4], eax
	mov	DWORD PTR [edi+8], eax
	mov	DWORD PTR [edi+12], 4
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
	xor	ebp, ebp
	mov	BYTE PTR __$EHRec$[esp+64], 3
	mov	DWORD PTR [edi+4], ebp
	mov	eax, DWORD PTR [esi+36]
	cmp	eax, ebp
	jbe	SHORT $L39163
$L39151:
	push	1
	mov	ecx, edi
	call	?AddNoConstruct@?$TCorArray@PAVCCpjGeoTri@@@@QAEKK@Z ; TCorArray<CCpjGeoTri *>::AddNoConstruct
	mov	ecx, DWORD PTR [edi]
	lea	eax, DWORD PTR [ecx+eax*4]
	test	eax, eax
	je	SHORT $L39139
	mov	edx, DWORD PTR [esi+32]
	mov	ecx, DWORD PTR [edx+ebp*4]
	mov	DWORD PTR [eax], ecx
$L39139:
	mov	eax, DWORD PTR [esi+36]
	inc	ebp
	cmp	ebp, eax
	jb	SHORT $L39151
$L39163:
	mov	esi, DWORD PTR _inArray$[esp+52]
$L39153:
	mov	eax, DWORD PTR _i$[esp+56]
	mov	edx, DWORD PTR -40+[esp+56]
	mov	ecx, DWORD PTR [esi+4]
	inc	eax
	add	edx, 48					; 00000030H
	cmp	eax, ecx
	mov	DWORD PTR __$EHRec$[esp+64], -1
	mov	DWORD PTR _i$[esp+56], eax
	mov	DWORD PTR -40+[esp+56], edx
	jb	$L39164
	pop	ebp
$L13571:
	pop	edi
$L39166:

; 277  : 		return(*this);
; 278  : 	}

	mov	ecx, DWORD PTR __$EHRec$[esp+48]
	mov	eax, ebx
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 40					; 00000028H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L38980:
	mov	eax, DWORD PTR $T38977[ebp]
	push	eax
	mov	ecx, DWORD PTR $T38976[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
$L39020:
	mov	ecx, DWORD PTR $T39063[ebp]
	jmp	??1CCorArray@@IAE@XZ			; CCorArray::~CCorArray
$L39007:
	mov	ecx, DWORD PTR $T38976[ebp]
	add	ecx, 16					; 00000010H
	jmp	??1?$TCorArray@PAVCCpjGeoEdge@@@@QAE@XZ	; TCorArray<CCpjGeoEdge *>::~TCorArray<CCpjGeoEdge *>
$L39071:
	mov	ecx, DWORD PTR $T39106[ebp]
	jmp	??1CCorArray@@IAE@XZ			; CCorArray::~CCorArray
$L39165:
	mov	eax, OFFSET FLAT:$T39156
	jmp	___CxxFrameHandler
text$x	ENDS
??4?$TCorArray@VCCpjGeoVert@@@@QAEAAV0@AAV0@@Z ENDP	; TCorArray<CCpjGeoVert>::operator=
;	COMDAT xdata$x
xdata$x	SEGMENT
$T39293	DD	0ffffffffH
	DD	FLAT:$L39178
	DD	00H
	DD	FLAT:$L39212
$T39284	DD	019930520H
	DD	02H
	DD	FLAT:$T39293
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ??4?$TCorArray@VCCpjGeoEdge@@@@QAEAAV0@AAV0@@Z
_TEXT	SEGMENT
_i$ = -28
$T39174 = -20
$T39175 = -24
$T39255 = -16
_i$39260 = -32
__$EHRec$ = -12
_inArray$ = 8
??4?$TCorArray@VCCpjGeoEdge@@@@QAEAAV0@AAV0@@Z PROC NEAR ; TCorArray<CCpjGeoEdge>::operator=, COMDAT
; _this$ = ecx

; 269  : 	{

	mov	eax, DWORD PTR fs:__except_list
	push	-1
	push	$L39291
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 24					; 00000018H
	push	ebx

; 270  : 		if (this == &inArray)

	mov	ebx, DWORD PTR _inArray$[esp+36]
	push	ebp
	mov	ebp, ecx
	cmp	ebp, ebx

; 271  : 			return(*this);

	je	$L39292
	push	edi

; 272  : 		m_Count = 0;

	xor	edi, edi
	mov	DWORD PTR [ebp+4], edi

; 273  : 		m_Limit = inArray.m_Count;

	mov	eax, DWORD PTR [ebx+4]
	mov	DWORD PTR [ebp+8], eax

; 274  : 		Realloc(sizeof(T));

	mov	eax, DWORD PTR [ebp]
	cmp	eax, edi
	mov	eax, DWORD PTR [ebp+8]
	mov	DWORD PTR [ebp+12], 28			; 0000001cH
	je	SHORT $L39182
	cmp	eax, edi
	je	SHORT $L39184
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [ebp+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [ebp+8]
	push	ecx
	mov	ecx, DWORD PTR [ebp]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+4]
	mov	DWORD PTR [ebp], eax
	jmp	SHORT $L39189
$L39184:
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [ebp]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L39188:
	mov	DWORD PTR [ebp], edi
$L39189:

; 275  : 		for (NDword i=0;i<inArray.m_Count;i++)

	mov	eax, DWORD PTR [ebx+4]
	mov	DWORD PTR _i$[esp+48], edi
	cmp	eax, edi
	jbe	$L13608
	push	esi
	mov	DWORD PTR -36+[esp+52], edi
	jmp	SHORT $L13606

; 274  : 		Realloc(sizeof(T));

$L39182:
	cmp	eax, edi
	je	SHORT $L39188
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [ebp+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [ebp+8]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	DWORD PTR [ebp], eax
	jmp	SHORT $L39189
$L39290:

; 275  : 		for (NDword i=0;i<inArray.m_Count;i++)

	xor	edi, edi
$L13606:

; 276  : 			new(&(*this)[AddNoConstruct()]) T(inArray[i]);

	mov	esi, DWORD PTR [ebp+4]
	mov	ecx, DWORD PTR [ebp+8]
	lea	eax, DWORD PTR [esi+1]
	cmp	eax, ecx
	mov	DWORD PTR [ebp+4], eax
	jbe	SHORT $L39193
	mov	edx, eax
	push	28					; 0000001cH
	shr	edx, 2
	mov	ecx, ebp
	lea	eax, DWORD PTR [edx+eax+32]
	mov	DWORD PTR [ebp+8], eax
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
$L39193:
	mov	edx, DWORD PTR [ebp]
	lea	ecx, DWORD PTR [esi*8]
	sub	ecx, esi
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR $T39175[esp+52], eax
	mov	DWORD PTR $T39174[esp+52], eax
	cmp	eax, edi
	mov	DWORD PTR __$EHRec$[esp+60], edi
	je	$L39263
	mov	edi, DWORD PTR [ebx]
	mov	edx, DWORD PTR -36+[esp+52]
	add	edi, edx
	lea	esi, DWORD PTR [eax+12]
	push	4
	mov	DWORD PTR $T39255[esp+56], esi
	mov	ecx, DWORD PTR [edi]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR [edi+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [edi+8]
	mov	DWORD PTR [eax+8], ecx
	mov	eax, DWORD PTR [edi+16]
	mov	ecx, esi
	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], 4
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
	xor	ecx, ecx
	mov	BYTE PTR __$EHRec$[esp+60], 1
	mov	DWORD PTR [esi+4], ecx
	mov	eax, DWORD PTR [edi+16]
	cmp	eax, ecx
	mov	DWORD PTR _i$39260[esp+52], ecx
	jbe	SHORT $L39263
$L39261:
	mov	ebx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi+8]
	lea	eax, DWORD PTR [ebx+1]
	cmp	eax, edx
	mov	DWORD PTR [esi+4], eax
	jbe	SHORT $L39275
	mov	edx, eax
	push	4
	shr	edx, 2
	mov	ecx, esi
	lea	eax, DWORD PTR [edx+eax+32]
	mov	DWORD PTR [esi+8], eax
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
	mov	ecx, DWORD PTR _i$39260[esp+52]
$L39275:
	mov	edx, DWORD PTR [esi]
	lea	eax, DWORD PTR [edx+ebx*4]
	test	eax, eax
	je	SHORT $L39268
	mov	edx, DWORD PTR [edi+12]
	mov	edx, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR [eax], edx
$L39268:
	mov	eax, DWORD PTR [edi+16]
	inc	ecx
	cmp	ecx, eax
	mov	DWORD PTR _i$39260[esp+52], ecx
	jb	SHORT $L39261
	mov	ebx, DWORD PTR _inArray$[esp+48]
$L39263:
	mov	eax, DWORD PTR _i$[esp+52]
	mov	edx, DWORD PTR -36+[esp+52]
	mov	ecx, DWORD PTR [ebx+4]
	inc	eax
	add	edx, 28					; 0000001cH
	cmp	eax, ecx
	mov	DWORD PTR __$EHRec$[esp+60], -1
	mov	DWORD PTR _i$[esp+52], eax
	mov	DWORD PTR -36+[esp+52], edx
	jb	$L39290
	pop	esi
$L13608:
	pop	edi
$L39292:

; 277  : 		return(*this);
; 278  : 	}

	mov	ecx, DWORD PTR __$EHRec$[esp+44]
	mov	eax, ebp
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 36					; 00000024H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L39178:
	mov	eax, DWORD PTR $T39175[ebp]
	push	eax
	mov	ecx, DWORD PTR $T39174[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
$L39212:
	mov	ecx, DWORD PTR $T39255[ebp]
	jmp	??1CCorArray@@IAE@XZ			; CCorArray::~CCorArray
$L39291:
	mov	eax, OFFSET FLAT:$T39284
	jmp	___CxxFrameHandler
text$x	ENDS
??4?$TCorArray@VCCpjGeoEdge@@@@QAEAAV0@AAV0@@Z ENDP	; TCorArray<CCpjGeoEdge>::operator=
; Function compile flags: /Ogty
;	COMDAT ??4?$TCorArray@VCCpjGeoTri@@@@QAEAAV0@AAV0@@Z
_TEXT	SEGMENT
_i$ = 8
_inArray$ = 8
??4?$TCorArray@VCCpjGeoTri@@@@QAEAAV0@AAV0@@Z PROC NEAR	; TCorArray<CCpjGeoTri>::operator=, COMDAT
; _this$ = ecx

; 269  : 	{

	push	ebp

; 270  : 		if (this == &inArray)

	mov	ebp, DWORD PTR _inArray$[esp]
	push	esi
	mov	esi, ecx
	cmp	esi, ebp

; 271  : 			return(*this);

	je	$L39332
	push	ebx

; 272  : 		m_Count = 0;

	xor	ebx, ebx
	mov	DWORD PTR [esi+4], ebx

; 273  : 		m_Limit = inArray.m_Count;

	mov	eax, DWORD PTR [ebp+4]
	mov	DWORD PTR [esi+8], eax

; 274  : 		Realloc(sizeof(T));

	mov	eax, DWORD PTR [esi]
	cmp	eax, ebx
	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [esi+12], 12			; 0000000cH
	je	$L39308
	cmp	eax, ebx
	je	SHORT $L39310
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [esi+8]
	push	ecx
	mov	ecx, DWORD PTR [esi]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+4]
	mov	DWORD PTR [esi], eax
	jmp	SHORT $L39315
$L39310:
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L39314:
	mov	DWORD PTR [esi], ebx
$L39315:

; 275  : 		for (NDword i=0;i<inArray.m_Count;i++)

	mov	eax, DWORD PTR [ebp+4]
	mov	DWORD PTR _i$[esp+8], ebx
	cmp	eax, ebx
	jbe	SHORT $L13640
	push	edi
$L13638:

; 276  : 			new(&(*this)[AddNoConstruct()]) T(inArray[i]);

	mov	edi, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	lea	eax, DWORD PTR [edi+1]
	cmp	eax, ecx
	mov	DWORD PTR [esi+4], eax
	jbe	SHORT $L39319
	mov	edx, eax
	push	12					; 0000000cH
	shr	edx, 2
	mov	ecx, esi
	lea	eax, DWORD PTR [edx+eax+32]
	mov	DWORD PTR [esi+8], eax
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
$L39319:
	mov	edx, DWORD PTR [esi]
	lea	ecx, DWORD PTR [edi+edi*2]
	lea	eax, DWORD PTR [edx+ecx*4]
	test	eax, eax
	je	SHORT $L39302
	mov	ecx, DWORD PTR [ebp]
	add	ecx, ebx
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ecx
$L39302:
	mov	eax, DWORD PTR _i$[esp+12]
	mov	ecx, DWORD PTR [ebp+4]
	inc	eax
	add	ebx, 12					; 0000000cH
	cmp	eax, ecx
	mov	DWORD PTR _i$[esp+12], eax
	jb	SHORT $L13638
	pop	edi
$L13640:
	pop	ebx
$L39332:

; 277  : 		return(*this);

	mov	eax, esi
	pop	esi
	pop	ebp

; 278  : 	}

	ret	4
$L39308:

; 274  : 		Realloc(sizeof(T));

	cmp	eax, ebx
	je	SHORT $L39314
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [esi+8]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	DWORD PTR [esi], eax
	jmp	$L39315
??4?$TCorArray@VCCpjGeoTri@@@@QAEAAV0@AAV0@@Z ENDP	; TCorArray<CCpjGeoTri>::operator=
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??4?$TCorArray@VCCpjGeoMount@@@@QAEAAV0@AAV0@@Z
_TEXT	SEGMENT
_i$ = -4
_inArray$ = 8
??4?$TCorArray@VCCpjGeoMount@@@@QAEAAV0@AAV0@@Z PROC NEAR ; TCorArray<CCpjGeoMount>::operator=, COMDAT
; _this$ = ecx

; 269  : 	{

	sub	esp, 8
	push	ebx
	push	edi

; 270  : 		if (this == &inArray)

	mov	edi, DWORD PTR _inArray$[esp+12]
	mov	ebx, ecx
	cmp	ebx, edi

; 271  : 			return(*this);

	je	$L39493
	push	ebp

; 272  : 		m_Count = 0;

	xor	ebp, ebp
	mov	DWORD PTR [ebx+4], ebp

; 273  : 		m_Limit = inArray.m_Count;

	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [ebx+8], eax

; 274  : 		Realloc(sizeof(T));

	mov	eax, DWORD PTR [ebx]
	cmp	eax, ebp
	mov	eax, DWORD PTR [ebx+8]
	mov	DWORD PTR [ebx+12], 140			; 0000008cH
	je	$L39345
	cmp	eax, ebp
	je	SHORT $L39347
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [ebx+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [ebx+8]
	push	ecx
	mov	ecx, DWORD PTR [ebx]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+4]
	mov	DWORD PTR [ebx], eax
	jmp	SHORT $L39352
$L39347:
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [ebx]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L39351:
	mov	DWORD PTR [ebx], ebp
$L39352:

; 275  : 		for (NDword i=0;i<inArray.m_Count;i++)

	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR _i$[esp+20], ebp
	cmp	eax, ebp
	jbe	$L13677
	mov	DWORD PTR -8+[esp+20], ebp
	push	esi
$L13675:

; 276  : 			new(&(*this)[AddNoConstruct()]) T(inArray[i]);

	mov	esi, DWORD PTR [ebx+4]
	mov	ecx, DWORD PTR [ebx+8]
	lea	eax, DWORD PTR [esi+1]
	cmp	eax, ecx
	mov	DWORD PTR [ebx+4], eax
	jbe	SHORT $L39356
	mov	edx, eax
	push	140					; 0000008cH
	shr	edx, 2
	mov	ecx, ebx
	lea	eax, DWORD PTR [edx+eax+32]
	mov	DWORD PTR [ebx+8], eax
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
$L39356:
	mov	edx, DWORD PTR [ebx]
	lea	eax, DWORD PTR [esi*8]
	sub	eax, esi
	lea	ecx, DWORD PTR [eax+eax*4]
	lea	eax, DWORD PTR [edx+ecx*4]
	cmp	eax, ebp
	je	$L39339
	mov	edx, DWORD PTR [edi]
	mov	ecx, DWORD PTR -8+[esp+24]
	add	edx, ecx
	mov	ecx, 16					; 00000010H
	mov	esi, edx
	mov	edi, eax
	rep movsd
	mov	ecx, DWORD PTR [edx+64]
	mov	edi, DWORD PTR _inArray$[esp+20]
	mov	DWORD PTR [eax+64], ecx
	mov	ecx, DWORD PTR [edx+68]
	mov	DWORD PTR [eax+68], ecx
	mov	ecx, DWORD PTR [edx+72]
	mov	DWORD PTR [eax+72], ecx
	mov	ecx, DWORD PTR [edx+76]
	mov	DWORD PTR [eax+76], ecx
	mov	ecx, 1065353216				; 3f800000H
	mov	DWORD PTR [eax+80], ecx
	mov	DWORD PTR [eax+84], ebp
	mov	DWORD PTR [eax+88], ebp
	mov	DWORD PTR [eax+92], ebp
	mov	DWORD PTR [eax+96], ecx
	mov	DWORD PTR [eax+100], ebp
	mov	DWORD PTR [eax+104], ebp
	mov	DWORD PTR [eax+108], ebp
	mov	DWORD PTR [eax+112], ecx
	mov	ecx, DWORD PTR [edx+80]
	mov	DWORD PTR [eax+80], ecx
	mov	ecx, DWORD PTR [edx+84]
	mov	DWORD PTR [eax+84], ecx
	mov	ecx, DWORD PTR [edx+88]
	mov	DWORD PTR [eax+88], ecx
	mov	ecx, DWORD PTR [edx+92]
	mov	DWORD PTR [eax+92], ecx
	mov	ecx, DWORD PTR [edx+96]
	mov	DWORD PTR [eax+96], ecx
	mov	ecx, DWORD PTR [edx+100]
	mov	DWORD PTR [eax+100], ecx
	mov	ecx, DWORD PTR [edx+104]
	mov	DWORD PTR [eax+104], ecx
	mov	ecx, DWORD PTR [edx+108]
	mov	DWORD PTR [eax+108], ecx
	mov	ecx, DWORD PTR [edx+112]
	mov	DWORD PTR [eax+112], ecx
	mov	ecx, DWORD PTR [edx+116]
	mov	DWORD PTR [eax+116], ecx
	mov	ecx, DWORD PTR [edx+120]
	mov	DWORD PTR [eax+120], ecx
	mov	ecx, DWORD PTR [edx+124]
	mov	DWORD PTR [eax+124], ecx
	mov	ecx, DWORD PTR [edx+128]
	mov	DWORD PTR [eax+128], ecx
	mov	ecx, DWORD PTR [edx+132]
	mov	DWORD PTR [eax+132], ecx
	mov	edx, DWORD PTR [edx+136]
	mov	DWORD PTR [eax+136], edx
$L39339:
	mov	eax, DWORD PTR _i$[esp+24]
	mov	edx, DWORD PTR -8+[esp+24]
	mov	ecx, DWORD PTR [edi+4]
	inc	eax
	add	edx, 140				; 0000008cH
	cmp	eax, ecx
	mov	DWORD PTR _i$[esp+24], eax
	mov	DWORD PTR -8+[esp+24], edx
	jb	$L13675
	pop	esi
$L13677:
	pop	ebp
$L39493:

; 277  : 		return(*this);

	mov	eax, ebx
	pop	edi
	pop	ebx

; 278  : 	}

	add	esp, 8
	ret	4

; 274  : 		Realloc(sizeof(T));

$L39345:
	cmp	eax, ebp
	je	$L39351
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [ebx+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [ebx+8]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	DWORD PTR [ebx], eax
	jmp	$L39352
??4?$TCorArray@VCCpjGeoMount@@@@QAEAAV0@AAV0@@Z ENDP	; TCorArray<CCpjGeoMount>::operator=
_TEXT	ENDS
PUBLIC	??_GCCpjGeoVert@@QAEPAXI@Z			; CCpjGeoVert::`scalar deleting destructor'
PUBLIC	??_GCCpjGeoEdge@@QAEPAXI@Z			; CCpjGeoEdge::`scalar deleting destructor'
PUBLIC	??1OCpjGeometry@@UAE@XZ				; OCpjGeometry::~OCpjGeometry
;	COMDAT xdata$x
xdata$x	SEGMENT
$T39690	DD	0ffffffffH
	DD	FLAT:$L39497
	DD	00H
	DD	FLAT:$L39498
	DD	01H
	DD	FLAT:$L39499
	DD	02H
	DD	FLAT:$L39500
	DD	01H
	DD	FLAT:$L39577
	DD	00H
	DD	FLAT:$L39623
$T39679	DD	019930520H
	DD	06H
	DD	FLAT:$T39690
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ??1OCpjGeometry@@UAE@XZ
_TEXT	SEGMENT
$T39667 = -16
__$EHRec$ = -12
_this$ = -20
$T39621 = -16
??1OCpjGeometry@@UAE@XZ PROC NEAR			; OCpjGeometry::~OCpjGeometry, COMDAT
; _this$ = ecx
	push	-1
	push	$L39689
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 8
	push	esi
	push	edi
	mov	edi, ecx
	mov	DWORD PTR _this$[esp+28], edi
	mov	eax, DWORD PTR [edi+124]
	lea	esi, DWORD PTR [edi+120]
	push	140					; 0000008cH
	push	eax
	push	0
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+48], 3
	call	?Remove@CCorArray@@QAEXKKK@Z		; CCorArray::Remove
	cmp	DWORD PTR [esi], 0
	je	SHORT $L39536
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L39536:
	mov	eax, DWORD PTR [edi+108]
	lea	esi, DWORD PTR [edi+104]
	push	12					; 0000000cH
	push	eax
	push	0
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+48], 2
	call	?Remove@CCorArray@@QAEXKKK@Z		; CCorArray::Remove
	cmp	DWORD PTR [esi], 0
	je	SHORT $L39573
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L39573:
	lea	esi, DWORD PTR [edi+88]
	push	ebx
	push	ebp
	mov	DWORD PTR $T39621[esp+36], esi
	mov	ebp, DWORD PTR [esi+4]
	mov	BYTE PTR __$EHRec$[esp+44], 4
	test	ebp, ebp
	jbe	SHORT $L39617
	xor	edi, edi
	mov	ebx, ebp
$L39615:
	mov	ecx, DWORD PTR [esi]
	push	0
	add	ecx, edi
	call	??_GCCpjGeoEdge@@QAEPAXI@Z		; CCpjGeoEdge::`scalar deleting destructor'
	add	edi, 28					; 0000001cH
	dec	ebx
	jne	SHORT $L39615
	mov	edi, DWORD PTR _this$[esp+36]
$L39617:
	push	28					; 0000001cH
	push	ebp
	push	0
	mov	ecx, esi
	call	?Remove@CCorArray@@QAEXKKK@Z		; CCorArray::Remove
	mov	eax, DWORD PTR [esi]
	mov	BYTE PTR __$EHRec$[esp+44], 1
	test	eax, eax
	je	SHORT $L39619
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L39619:
	lea	esi, DWORD PTR [edi+72]
	mov	DWORD PTR $T39667[esp+36], esi
	mov	ebp, DWORD PTR [esi+4]
	mov	BYTE PTR __$EHRec$[esp+44], 5
	test	ebp, ebp
	jbe	SHORT $L39660
	xor	edi, edi
	mov	ebx, ebp
$L39658:
	mov	ecx, DWORD PTR [esi]
	push	0
	add	ecx, edi
	call	??_GCCpjGeoVert@@QAEPAXI@Z		; CCpjGeoVert::`scalar deleting destructor'
	add	edi, 48					; 00000030H
	dec	ebx
	jne	SHORT $L39658
$L39660:
	push	48					; 00000030H
	push	ebp
	push	0
	mov	ecx, esi
	call	?Remove@CCorArray@@QAEXKKK@Z		; CCorArray::Remove
	mov	eax, DWORD PTR [esi]
	pop	ebp
	test	eax, eax
	mov	BYTE PTR __$EHRec$[esp+40], 0
	pop	ebx
	je	SHORT $L39664
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L39664:
	mov	ecx, DWORD PTR _this$[esp+28]
	mov	DWORD PTR __$EHRec$[esp+36], -1
	call	??1OObject@@UAE@XZ			; OObject::~OObject
	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 20					; 00000014H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L39497:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1OCpjChunk@@UAE@XZ			; OCpjChunk::~OCpjChunk
$L39498:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 72					; 00000048H
	jmp	??1?$TCorArray@VCCpjGeoVert@@@@QAE@XZ	; TCorArray<CCpjGeoVert>::~TCorArray<CCpjGeoVert>
$L39499:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 88					; 00000058H
	jmp	??1?$TCorArray@VCCpjGeoEdge@@@@QAE@XZ	; TCorArray<CCpjGeoEdge>::~TCorArray<CCpjGeoEdge>
$L39500:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 104				; 00000068H
	jmp	??1?$TCorArray@VCCpjGeoTri@@@@QAE@XZ	; TCorArray<CCpjGeoTri>::~TCorArray<CCpjGeoTri>
$L39577:
	mov	ecx, DWORD PTR $T39621[ebp]
	jmp	??1CCorArray@@IAE@XZ			; CCorArray::~CCorArray
$L39623:
	mov	ecx, DWORD PTR $T39667[ebp]
	jmp	??1CCorArray@@IAE@XZ			; CCorArray::~CCorArray
$L39689:
	mov	eax, OFFSET FLAT:$T39679
	jmp	___CxxFrameHandler
text$x	ENDS
??1OCpjGeometry@@UAE@XZ ENDP				; OCpjGeometry::~OCpjGeometry
PUBLIC	??_GOCpjGeometry@@UAEPAXI@Z			; OCpjGeometry::`scalar deleting destructor'
; Function compile flags: /Ogty
;	COMDAT ??_GOCpjGeometry@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_GOCpjGeometry@@UAEPAXI@Z PROC NEAR			; OCpjGeometry::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1OCpjGeometry@@UAE@XZ			; OCpjGeometry::~OCpjGeometry
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $L39708
	mov	DWORD PTR [esi+4], 0
	mov	edx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	dec	edx
	mov	DWORD PTR ?sObjCount@OObject@@1KA, edx	; OObject::sObjCount
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L39708:
	mov	eax, esi
	pop	esi
	ret	4
??_GOCpjGeometry@@UAEPAXI@Z ENDP			; OCpjGeometry::`scalar deleting destructor'
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??_EOCpjGeometry@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_EOCpjGeometry@@UAEPAXI@Z PROC NEAR			; OCpjGeometry::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebx
	mov	bl, BYTE PTR ___flags$[esp]
	push	esi
	mov	esi, ecx
	test	bl, 2
	je	SHORT $L8123
	mov	eax, DWORD PTR [esi-4]
	push	edi
	lea	edi, DWORD PTR [esi-4]
	push	OFFSET FLAT:??1OCpjGeometry@@UAE@XZ	; OCpjGeometry::~OCpjGeometry
	push	eax
	push	136					; 00000088H
	push	esi
	call	??_M@YGXPAXIHP6EX0@Z@Z			; `eh vector destructor iterator'
	test	bl, 1
	je	SHORT $L8124
	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L8124:
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	ret	4
$L8123:
	mov	ecx, esi
	call	??1OCpjGeometry@@UAE@XZ			; OCpjGeometry::~OCpjGeometry
	test	bl, 1
	je	SHORT $L39723
	mov	DWORD PTR [esi+4], 0
	mov	edx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	dec	edx
	mov	DWORD PTR ?sObjCount@OObject@@1KA, edx	; OObject::sObjCount
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L39723:
	mov	eax, esi
	pop	esi
	pop	ebx
	ret	4
??_EOCpjGeometry@@UAEPAXI@Z ENDP			; OCpjGeometry::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??2OCpjSurface@@CAPAXIPAVOObject@@PAVCObjClass@@@Z ; OCpjSurface::operator new
; Function compile flags: /Ogty
; File C:\duke4\Cannibal\CpjSrf.h
;	COMDAT ??2OCpjSurface@@CAPAXIPAVOObject@@PAVCObjClass@@@Z
_TEXT	SEGMENT
_inParent$ = 12
_inSetClass$ = 16
??2OCpjSurface@@CAPAXIPAVOObject@@PAVCObjClass@@@Z PROC NEAR ; OCpjSurface::operator new, COMDAT

; 56   : 	OBJ_CLASS_DEFINE(OCpjSurface, OCpjChunk);

	push	esi
	push	edi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	120					; 00000078H
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	ecx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	mov	esi, eax
	inc	ecx
	xor	eax, eax
	mov	DWORD PTR ?sObjCount@OObject@@1KA, ecx	; OObject::sObjCount
	mov	ecx, 30					; 0000001eH
	mov	edi, esi
	rep stosd
	mov	eax, DWORD PTR [esi+40]
	mov	DWORD PTR [esi+4], 305419896		; 12345678H
	test	eax, eax
	jne	SHORT $L39734
	mov	eax, DWORD PTR _inSetClass$[esp+4]
	mov	DWORD PTR [esi+40], eax
$L39734:
	mov	ecx, DWORD PTR _inParent$[esp+4]
	push	ecx
	mov	ecx, esi
	call	?PreConstruct@OObject@@QAEXPAV1@@Z	; OObject::PreConstruct
	mov	eax, esi
	pop	edi
	pop	esi
	ret	0
??2OCpjSurface@@CAPAXIPAVOObject@@PAVCObjClass@@@Z ENDP	; OCpjSurface::operator new
_TEXT	ENDS
PUBLIC	??3OCpjSurface@@CAXPAX@Z			; OCpjSurface::operator delete
; Function compile flags: /Ogty
;	COMDAT ??3OCpjSurface@@CAXPAX@Z
_TEXT	SEGMENT
_ptr$ = 8
??3OCpjSurface@@CAXPAX@Z PROC NEAR			; OCpjSurface::operator delete, COMDAT

; 56   : 	OBJ_CLASS_DEFINE(OCpjSurface, OCpjChunk);

	push	esi
	mov	esi, DWORD PTR _ptr$[esp]
	mov	DWORD PTR [esi+4], 0
	mov	edx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	dec	edx
	mov	DWORD PTR ?sObjCount@OObject@@1KA, edx	; OObject::sObjCount
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	ecx, eax
	call	DWORD PTR [edx+8]
	pop	esi
	ret	0
??3OCpjSurface@@CAXPAX@Z ENDP				; OCpjSurface::operator delete
_TEXT	ENDS
PUBLIC	??3OCpjSurface@@CAXPAXPAVOObject@@PAVCObjClass@@@Z ; OCpjSurface::operator delete
; Function compile flags: /Ogty
;	COMDAT ??3OCpjSurface@@CAXPAXPAVOObject@@PAVCObjClass@@@Z
_TEXT	SEGMENT
_ptr$ = 8
??3OCpjSurface@@CAXPAXPAVOObject@@PAVCObjClass@@@Z PROC NEAR ; OCpjSurface::operator delete, COMDAT

; 56   : 	OBJ_CLASS_DEFINE(OCpjSurface, OCpjChunk);

	push	esi
	mov	esi, DWORD PTR _ptr$[esp]
	mov	DWORD PTR [esi+4], 0
	mov	edx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	dec	edx
	mov	DWORD PTR ?sObjCount@OObject@@1KA, edx	; OObject::sObjCount
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	ecx, eax
	call	DWORD PTR [edx+8]
	pop	esi
	ret	0
??3OCpjSurface@@CAXPAXPAVOObject@@PAVCObjClass@@@Z ENDP	; OCpjSurface::operator delete
_TEXT	ENDS
PUBLIC	?GetStaticClass@OCpjSurface@@SAPAVCObjClass@@XZ	; OCpjSurface::GetStaticClass
; Function compile flags: /Ogty
;	COMDAT ?GetStaticClass@OCpjSurface@@SAPAVCObjClass@@XZ
_TEXT	SEGMENT
?GetStaticClass@OCpjSurface@@SAPAVCObjClass@@XZ PROC NEAR ; OCpjSurface::GetStaticClass, COMDAT

; 56   : 	OBJ_CLASS_DEFINE(OCpjSurface, OCpjChunk);

	mov	eax, DWORD PTR ?staticObjClass@OCpjSurface@@0PAVCObjClass@@A ; OCpjSurface::staticObjClass
	ret	0
?GetStaticClass@OCpjSurface@@SAPAVCObjClass@@XZ ENDP	; OCpjSurface::GetStaticClass
_TEXT	ENDS
PUBLIC	?New@OCpjSurface@@SAPAV1@PAVOObject@@PAVCObjClass@@@Z ; OCpjSurface::New
PUBLIC	?GetClass@OCpjSurface@@UAEPAVCObjClass@@XZ	; OCpjSurface::GetClass
PUBLIC	??1?$TCorArray@VCCpjSrfTex@@@@QAE@XZ		; TCorArray<CCpjSrfTex>::~TCorArray<CCpjSrfTex>
PUBLIC	??1?$TCorArray@VCCpjSrfTri@@@@QAE@XZ		; TCorArray<CCpjSrfTri>::~TCorArray<CCpjSrfTri>
PUBLIC	?GetFileExtension@OCpjSurface@@UAEPADXZ		; OCpjSurface::GetFileExtension
PUBLIC	?GetFileDescription@OCpjSurface@@UAEPADXZ	; OCpjSurface::GetFileDescription
PUBLIC	??_7OCpjSurface@@6B@				; OCpjSurface::`vftable'
PUBLIC	??_EOCpjSurface@@UAEPAXI@Z			; OCpjSurface::`vector deleting destructor'
EXTRN	?LoadChunk@OCpjSurface@@UAE_NPAXK@Z:NEAR	; OCpjSurface::LoadChunk
EXTRN	?SaveChunk@OCpjSurface@@UAE_NPAXPAK@Z:NEAR	; OCpjSurface::SaveChunk
EXTRN	?GetFourCC@OCpjSurface@@UAEKXZ:NEAR		; OCpjSurface::GetFourCC
;	COMDAT xdata$x
; File C:\duke4\Cannibal\CorMain.h
xdata$x	SEGMENT
$T39893	DD	0ffffffffH
	DD	FLAT:$L39762
	DD	00H
	DD	FLAT:$L39787
	DD	01H
	DD	FLAT:$L39788
	DD	02H
	DD	FLAT:$L39789
$T39891	DD	019930520H
	DD	04H
	DD	FLAT:$T39893
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_7OCpjSurface@@6B@
CONST	SEGMENT
??_7OCpjSurface@@6B@ DD FLAT:?Msg@OObject@@UAE_NPAVIMsg@@@Z ; OCpjSurface::`vftable'
	DD	FLAT:?MsgGetChild@OObject@@UAEPAVIMsgTarget@@PAD@Z
	DD	FLAT:?MsgGetParent@OObject@@UAEPAVIMsgTarget@@XZ
	DD	FLAT:?MsgGetRoot@OObject@@UAEPAVIMsgTarget@@XZ
	DD	FLAT:?GetClass@OCpjSurface@@UAEPAVCObjClass@@XZ
	DD	FLAT:??_EOCpjSurface@@UAEPAXI@Z
	DD	FLAT:?Create@OCpjChunk@@UAEXXZ
	DD	FLAT:?Destroy@OObject@@UAEXXZ
	DD	FLAT:?GetParent@OObject@@UAEPAV1@XZ
	DD	FLAT:?SetParent@OObject@@UAEXPAV1@_N@Z
	DD	FLAT:?HasChildren@OObject@@UAE_NXZ
	DD	FLAT:?IsA@OObject@@UAE_NPAVCObjClass@@@Z
	DD	FLAT:?GetFileExtension@OCpjSurface@@UAEPADXZ
	DD	FLAT:?GetFileDescription@OCpjSurface@@UAEPADXZ
	DD	FLAT:?LoadFile@OCpjChunk@@UAE_NPAD@Z
	DD	FLAT:?SaveFile@OCpjChunk@@UAE_NPAD@Z
	DD	FLAT:?GetFourCC@OCpjSurface@@UAEKXZ
	DD	FLAT:?LoadChunk@OCpjSurface@@UAE_NPAXK@Z
	DD	FLAT:?SaveChunk@OCpjSurface@@UAE_NPAXPAK@Z
; Function compile flags: /Ogty
; File C:\duke4\Cannibal\CpjSrf.h
CONST	ENDS
;	COMDAT ?New@OCpjSurface@@SAPAV1@PAVOObject@@PAVCObjClass@@@Z
_TEXT	SEGMENT
_inParent$ = 8
_inSetClass$ = 12
$T39759 = -16
__$EHRec$ = -12
?New@OCpjSurface@@SAPAV1@PAVOObject@@PAVCObjClass@@@Z PROC NEAR ; OCpjSurface::New, COMDAT

; 56   : 	OBJ_CLASS_DEFINE(OCpjSurface, OCpjChunk);

	push	-1
	push	$L39892
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _inSetClass$[esp+20]
	xor	ebx, ebx
	cmp	ebp, ebx
	push	esi
	jne	SHORT $L8363
	mov	ebp, DWORD PTR ?staticObjClass@OCpjSurface@@0PAVCObjClass@@A ; OCpjSurface::staticObjClass
	mov	DWORD PTR _inSetClass$[esp+24], ebp
$L8363:
	push	edi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	120					; 00000078H
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	ecx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	mov	esi, eax
	inc	ecx
	xor	eax, eax
	mov	DWORD PTR ?sObjCount@OObject@@1KA, ecx	; OObject::sObjCount
	mov	ecx, 30					; 0000001eH
	mov	edi, esi
	rep stosd
	mov	eax, DWORD PTR [esi+40]
	mov	DWORD PTR [esi+4], 305419896		; 12345678H
	cmp	eax, ebx
	pop	edi
	jne	SHORT $L39782
	mov	DWORD PTR [esi+40], ebp
$L39782:
	mov	eax, DWORD PTR _inParent$[esp+24]
	mov	ecx, esi
	push	eax
	call	?PreConstruct@OObject@@QAEXPAV1@@Z	; OObject::PreConstruct
	mov	DWORD PTR $T39759[esp+28], esi
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+36], ebx
	call	??0OObject@@QAE@XZ			; OObject::OObject
	mov	DWORD PTR [esi], OFFSET FLAT:??_7OCpjChunk@@6B@ ; OCpjChunk::`vftable'
	lea	ecx, DWORD PTR [esi+72]
	push	260					; 00000104H
	mov	BYTE PTR __$EHRec$[esp+40], 1
	mov	DWORD PTR [ecx], ebx
	mov	DWORD PTR [ecx+4], ebx
	mov	DWORD PTR [ecx+8], ebx
	mov	DWORD PTR [ecx+12], 260			; 00000104H
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
	lea	ecx, DWORD PTR [esi+88]
	push	16					; 00000010H
	mov	BYTE PTR __$EHRec$[esp+40], 2
	mov	DWORD PTR [ecx], ebx
	mov	DWORD PTR [ecx+4], ebx
	mov	DWORD PTR [ecx+8], ebx
	mov	DWORD PTR [ecx+12], 16			; 00000010H
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
	mov	DWORD PTR [esi+108], ebx
	mov	DWORD PTR [esi+112], ebx
	mov	DWORD PTR [esi+116], 8
	mov	DWORD PTR [esi+104], ebx
	mov	DWORD PTR [esi], OFFSET FLAT:??_7OCpjSurface@@6B@ ; OCpjSurface::`vftable'
	mov	edx, DWORD PTR [esi]
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+36], -1
	call	DWORD PTR [edx+24]
	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L39762:
	mov	eax, DWORD PTR _inSetClass$[ebp-4]
	push	eax
	mov	ecx, DWORD PTR _inParent$[ebp-4]
	push	ecx
	mov	edx, DWORD PTR $T39759[ebp]
	push	edx
	call	??3OCpjSurface@@CAXPAXPAVOObject@@PAVCObjClass@@@Z ; OCpjSurface::operator delete
	add	esp, 12					; 0000000cH
	ret	0
$L39787:
	mov	ecx, DWORD PTR $T39759[ebp]
	jmp	??1OCpjChunk@@UAE@XZ			; OCpjChunk::~OCpjChunk
$L39788:
	mov	ecx, DWORD PTR $T39759[ebp]
	add	ecx, 72					; 00000048H
	jmp	??1?$TCorArray@VCCpjSrfTex@@@@QAE@XZ	; TCorArray<CCpjSrfTex>::~TCorArray<CCpjSrfTex>
$L39789:
	mov	ecx, DWORD PTR $T39759[ebp]
	add	ecx, 88					; 00000058H
	jmp	??1?$TCorArray@VCCpjSrfTri@@@@QAE@XZ	; TCorArray<CCpjSrfTri>::~TCorArray<CCpjSrfTri>
$L39892:
	mov	eax, OFFSET FLAT:$T39891
	jmp	___CxxFrameHandler
text$x	ENDS
?New@OCpjSurface@@SAPAV1@PAVOObject@@PAVCObjClass@@@Z ENDP ; OCpjSurface::New
; Function compile flags: /Ogty
; File C:\duke4\Cannibal\CorMain.h
;	COMDAT ??1?$TCorArray@VCCpjSrfTex@@@@QAE@XZ
_TEXT	SEGMENT
??1?$TCorArray@VCCpjSrfTex@@@@QAE@XZ PROC NEAR		; TCorArray<CCpjSrfTex>::~TCorArray<CCpjSrfTex>, COMDAT
; _this$ = ecx

; 280  : 	{

	push	esi
	mov	esi, ecx
	push	edi

; 281  : 		Purge();

	mov	edi, DWORD PTR [esi+4]
	test	edi, edi
	je	SHORT $L39919
	mov	eax, edi
	mov	ecx, DWORD PTR [esi]
	shl	eax, 6
	add	eax, edi
	shl	eax, 2
	mov	edx, eax
	sub	edx, eax
	add	eax, ecx
	push	edx
	push	eax
	push	ecx
	call	DWORD PTR __imp__memmove
	mov	eax, DWORD PTR [esi+4]
	add	esp, 12					; 0000000cH
	sub	eax, edi
	mov	DWORD PTR [esi+4], eax
$L39919:

; 282  : 	}

	cmp	DWORD PTR [esi], 0
	je	SHORT $L39930
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L39930:
	pop	edi
	pop	esi
	ret	0
??1?$TCorArray@VCCpjSrfTex@@@@QAE@XZ ENDP		; TCorArray<CCpjSrfTex>::~TCorArray<CCpjSrfTex>
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??1?$TCorArray@VCCpjSrfTri@@@@QAE@XZ
_TEXT	SEGMENT
??1?$TCorArray@VCCpjSrfTri@@@@QAE@XZ PROC NEAR		; TCorArray<CCpjSrfTri>::~TCorArray<CCpjSrfTri>, COMDAT
; _this$ = ecx

; 280  : 	{

	push	esi
	mov	esi, ecx
	push	edi

; 281  : 		Purge();

	mov	edi, DWORD PTR [esi+4]
	test	edi, edi
	je	SHORT $L39956
	mov	eax, DWORD PTR [esi]
	mov	ecx, edi
	mov	edx, edi
	sub	ecx, edi
	shl	edx, 4
	shl	ecx, 4
	add	edx, eax
	push	ecx
	push	edx
	push	eax
	call	DWORD PTR __imp__memmove
	mov	eax, DWORD PTR [esi+4]
	add	esp, 12					; 0000000cH
	sub	eax, edi
	mov	DWORD PTR [esi+4], eax
$L39956:

; 282  : 	}

	cmp	DWORD PTR [esi], 0
	je	SHORT $L39967
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L39967:
	pop	edi
	pop	esi
	ret	0
??1?$TCorArray@VCCpjSrfTri@@@@QAE@XZ ENDP		; TCorArray<CCpjSrfTri>::~TCorArray<CCpjSrfTri>
; Function compile flags: /Ogty
; File C:\duke4\Cannibal\CpjSrf.h
_TEXT	ENDS
;	COMDAT ?GetClass@OCpjSurface@@UAEPAVCObjClass@@XZ
_TEXT	SEGMENT
?GetClass@OCpjSurface@@UAEPAVCObjClass@@XZ PROC NEAR	; OCpjSurface::GetClass, COMDAT
; _this$ = ecx

; 56   : 	OBJ_CLASS_DEFINE(OCpjSurface, OCpjChunk);

	mov	eax, DWORD PTR [ecx+40]
	ret	0
?GetClass@OCpjSurface@@UAEPAVCObjClass@@XZ ENDP		; OCpjSurface::GetClass
_TEXT	ENDS
PUBLIC	??_C@_03CAHH@srf?$AA@				; `string'
;	COMDAT ??_C@_03CAHH@srf?$AA@
_DATA	SEGMENT
??_C@_03CAHH@srf?$AA@ DB 'srf', 00H			; `string'
; Function compile flags: /Ogty
_DATA	ENDS
;	COMDAT ?GetFileExtension@OCpjSurface@@UAEPADXZ
_TEXT	SEGMENT
?GetFileExtension@OCpjSurface@@UAEPADXZ PROC NEAR	; OCpjSurface::GetFileExtension, COMDAT
; _this$ = ecx

; 68   : 	NChar* GetFileExtension() { return("srf"); }

	mov	eax, OFFSET FLAT:??_C@_03CAHH@srf?$AA@	; `string'
	ret	0
?GetFileExtension@OCpjSurface@@UAEPADXZ ENDP		; OCpjSurface::GetFileExtension
_TEXT	ENDS
PUBLIC	??_C@_0BB@HJJD@Cannibal?5Surface?$AA@		; `string'
;	COMDAT ??_C@_0BB@HJJD@Cannibal?5Surface?$AA@
_DATA	SEGMENT
??_C@_0BB@HJJD@Cannibal?5Surface?$AA@ DB 'Cannibal Surface', 00H ; `string'
; Function compile flags: /Ogty
_DATA	ENDS
;	COMDAT ?GetFileDescription@OCpjSurface@@UAEPADXZ
_TEXT	SEGMENT
?GetFileDescription@OCpjSurface@@UAEPADXZ PROC NEAR	; OCpjSurface::GetFileDescription, COMDAT
; _this$ = ecx

; 69   : 	NChar* GetFileDescription() { return("Cannibal Surface"); }

	mov	eax, OFFSET FLAT:??_C@_0BB@HJJD@Cannibal?5Surface?$AA@ ; `string'
	ret	0
?GetFileDescription@OCpjSurface@@UAEPADXZ ENDP		; OCpjSurface::GetFileDescription
_TEXT	ENDS
PUBLIC	??0OCpjSurface@@QAE@XZ				; OCpjSurface::OCpjSurface
;	COMDAT xdata$x
xdata$x	SEGMENT
$T40091	DD	0ffffffffH
	DD	FLAT:$L39982
	DD	00H
	DD	FLAT:$L39983
	DD	01H
	DD	FLAT:$L39984
$T40089	DD	019930520H
	DD	03H
	DD	FLAT:$T40091
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ??0OCpjSurface@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16
__$EHRec$ = -12
??0OCpjSurface@@QAE@XZ PROC NEAR			; OCpjSurface::OCpjSurface, COMDAT
; _this$ = ecx
	push	-1
	push	$L40090
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	push	esi
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+24], esi
	call	??0OObject@@QAE@XZ			; OObject::OObject
	mov	DWORD PTR [esi], OFFSET FLAT:??_7OCpjChunk@@6B@ ; OCpjChunk::`vftable'
	xor	edi, edi
	mov	DWORD PTR [esi+84], 260			; 00000104H
	mov	DWORD PTR __$EHRec$[esp+32], edi
	mov	DWORD PTR [esi+76], edi
	mov	DWORD PTR [esi+80], edi
	mov	DWORD PTR [esi+72], edi
	lea	ecx, DWORD PTR [esi+88]
	push	16					; 00000010H
	mov	BYTE PTR __$EHRec$[esp+36], 1
	mov	DWORD PTR [ecx], edi
	mov	DWORD PTR [ecx+4], edi
	mov	DWORD PTR [ecx+8], edi
	mov	DWORD PTR [ecx+12], 16			; 00000010H
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR [esi+108], edi
	mov	DWORD PTR [esi+112], edi
	mov	DWORD PTR [esi+116], 8
	mov	DWORD PTR [esi+104], edi
	mov	DWORD PTR [esi], OFFSET FLAT:??_7OCpjSurface@@6B@ ; OCpjSurface::`vftable'
	mov	eax, esi
	pop	edi
	pop	esi
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L39982:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1OCpjChunk@@UAE@XZ			; OCpjChunk::~OCpjChunk
$L39983:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 72					; 00000048H
	jmp	??1?$TCorArray@VCCpjSrfTex@@@@QAE@XZ	; TCorArray<CCpjSrfTex>::~TCorArray<CCpjSrfTex>
$L39984:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 88					; 00000058H
	jmp	??1?$TCorArray@VCCpjSrfTri@@@@QAE@XZ	; TCorArray<CCpjSrfTri>::~TCorArray<CCpjSrfTri>
$L40090:
	mov	eax, OFFSET FLAT:$T40089
	jmp	___CxxFrameHandler
text$x	ENDS
??0OCpjSurface@@QAE@XZ ENDP				; OCpjSurface::OCpjSurface
PUBLIC	?AddNoConstruct@?$TCorArray@VVVec2@@@@QAEKK@Z	; TCorArray<VVec2>::AddNoConstruct
PUBLIC	??0OCpjSurface@@QAE@AAV0@@Z			; OCpjSurface::OCpjSurface
;	COMDAT xdata$x
xdata$x	SEGMENT
$T40267	DD	0ffffffffH
	DD	FLAT:$L40097
	DD	00H
	DD	FLAT:$L40117
	DD	00H
	DD	FLAT:$L40098
	DD	02H
	DD	FLAT:$L40168
	DD	02H
	DD	FLAT:$L40099
	DD	04H
	DD	FLAT:$L40219
$T40257	DD	019930520H
	DD	06H
	DD	FLAT:$T40267
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ??0OCpjSurface@@QAE@AAV0@@Z
_TEXT	SEGMENT
___that$ = 8
_this$ = -20
_i$40138 = -24
$T40160 = -16
_i$40189 = -24
$T40211 = -16
$T40254 = 8
__$EHRec$ = -12
??0OCpjSurface@@QAE@AAV0@@Z PROC NEAR			; OCpjSurface::OCpjSurface, COMDAT
; _this$ = ecx
	push	-1
	push	$L40266
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	mov	ebx, DWORD PTR ___that$[esp+24]
	push	ebp
	push	esi
	push	edi
	mov	edi, ecx
	push	ebx
	mov	DWORD PTR _this$[esp+44], edi
	call	??0OObject@@QAE@ABV0@@Z			; OObject::OObject
	mov	DWORD PTR [edi], OFFSET FLAT:??_7OCpjRes@@6B@ ; OCpjRes::`vftable'
	mov	al, BYTE PTR [ebx+56]
	mov	BYTE PTR [edi+56], al
	mov	ecx, DWORD PTR [ebx+60]
	mov	DWORD PTR [edi+60], ecx
	mov	edx, DWORD PTR [ebx+64]
	mov	DWORD PTR [edi+64], edx
	mov	eax, DWORD PTR [ebx+68]
	mov	DWORD PTR [edi+68], eax
	mov	DWORD PTR [edi], OFFSET FLAT:??_7OCpjChunk@@6B@ ; OCpjChunk::`vftable'
	mov	eax, DWORD PTR [ebx+76]
	lea	ebp, DWORD PTR [edi+72]
	xor	esi, esi
	push	260					; 00000104H
	mov	ecx, ebp
	mov	DWORD PTR __$EHRec$[esp+52], esi
	mov	DWORD PTR $T40160[esp+44], ebp
	mov	DWORD PTR [ebp], esi
	mov	DWORD PTR [ebp+4], eax
	mov	DWORD PTR [ebp+8], eax
	mov	DWORD PTR [ebp+12], 260			; 00000104H
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
	mov	DWORD PTR [ebp+4], esi
	mov	eax, DWORD PTR [ebx+76]
	cmp	eax, esi
	mov	BYTE PTR __$EHRec$[esp+48], 1
	mov	DWORD PTR _i$40138[esp+40], esi
	jbe	SHORT $L40142
	mov	DWORD PTR 8+[esp+36], esi
$L40139:
	mov	esi, DWORD PTR [ebp+4]
	mov	ecx, DWORD PTR [ebp+8]
	lea	eax, DWORD PTR [esi+1]
	cmp	eax, ecx
	mov	DWORD PTR [ebp+4], eax
	jbe	SHORT $L40153
	mov	ecx, eax
	push	260					; 00000104H
	shr	ecx, 2
	lea	edx, DWORD PTR [ecx+eax+32]
	mov	ecx, ebp
	mov	DWORD PTR [ebp+8], edx
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
$L40153:
	mov	ecx, DWORD PTR [ebp]
	mov	eax, esi
	shl	eax, 6
	add	eax, esi
	lea	eax, DWORD PTR [ecx+eax*4]
	test	eax, eax
	je	SHORT $L40146
	mov	esi, DWORD PTR [ebx+72]
	mov	ecx, DWORD PTR 8+[esp+36]
	add	esi, ecx
	mov	ecx, 65					; 00000041H
	mov	edi, eax
	rep movsd
	mov	edi, DWORD PTR _this$[esp+40]
$L40146:
	mov	eax, DWORD PTR _i$40138[esp+40]
	mov	edx, DWORD PTR 8+[esp+36]
	mov	ecx, DWORD PTR [ebx+76]
	inc	eax
	add	edx, 260				; 00000104H
	cmp	eax, ecx
	mov	DWORD PTR _i$40138[esp+40], eax
	mov	DWORD PTR 8+[esp+36], edx
	jb	SHORT $L40139
$L40142:
	mov	eax, DWORD PTR [ebx+92]
	lea	esi, DWORD PTR [edi+88]
	xor	ebp, ebp
	push	16					; 00000010H
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+52], 2
	mov	DWORD PTR $T40211[esp+44], esi
	mov	DWORD PTR [esi], ebp
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], 16			; 00000010H
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
	mov	DWORD PTR [esi+4], ebp
	mov	eax, DWORD PTR [ebx+92]
	cmp	eax, ebp
	mov	BYTE PTR __$EHRec$[esp+48], 3
	mov	DWORD PTR _i$40189[esp+40], ebp
	jbe	SHORT $L40192
	mov	DWORD PTR 8+[esp+36], ebp
$L40190:
	mov	ebp, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	lea	eax, DWORD PTR [ebp+1]
	cmp	eax, ecx
	mov	DWORD PTR [esi+4], eax
	jbe	SHORT $L40204
	mov	edx, eax
	push	16					; 00000010H
	shr	edx, 2
	mov	ecx, esi
	lea	eax, DWORD PTR [edx+eax+32]
	mov	DWORD PTR [esi+8], eax
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
$L40204:
	mov	eax, DWORD PTR [esi]
	shl	ebp, 4
	add	ebp, eax
	je	SHORT $L40197
	mov	ecx, DWORD PTR [ebx+88]
	mov	eax, DWORD PTR 8+[esp+36]
	add	ecx, eax
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [ebp], edx
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ebp+4], eax
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [ebp+8], edx
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [ebp+12], eax
$L40197:
	mov	eax, DWORD PTR _i$40189[esp+40]
	mov	edx, DWORD PTR 8+[esp+36]
	mov	ecx, DWORD PTR [ebx+92]
	inc	eax
	add	edx, 16					; 00000010H
	cmp	eax, ecx
	mov	DWORD PTR _i$40189[esp+40], eax
	mov	DWORD PTR 8+[esp+36], edx
	jb	SHORT $L40190
	xor	ebp, ebp
$L40192:
	mov	ecx, DWORD PTR [ebx+108]
	lea	esi, DWORD PTR [edi+104]
	push	8
	push	ecx
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+56], 4
	mov	DWORD PTR $T40254[esp+44], esi
	call	??0CCorArray@@IAE@KK@Z			; CCorArray::CCorArray
	mov	DWORD PTR [esi+4], ebp
	mov	eax, DWORD PTR [ebx+108]
	test	eax, eax
	mov	BYTE PTR __$EHRec$[esp+48], 5
	jbe	SHORT $L40264
$L40237:
	push	1
	mov	ecx, esi
	call	?AddNoConstruct@?$TCorArray@VVVec2@@@@QAEKK@Z ; TCorArray<VVec2>::AddNoConstruct
	mov	edx, DWORD PTR [esi]
	lea	eax, DWORD PTR [edx+eax*8]
	test	eax, eax
	je	SHORT $L40244
	mov	ecx, DWORD PTR [ebx+104]
	mov	edx, DWORD PTR [ecx+ebp*8]
	lea	ecx, DWORD PTR [ecx+ebp*8]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx
$L40244:
	mov	eax, DWORD PTR [ebx+108]
	inc	ebp
	cmp	ebp, eax
	jb	SHORT $L40237
$L40264:
	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR [edi], OFFSET FLAT:??_7OCpjSurface@@6B@ ; OCpjSurface::`vftable'
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 24					; 00000018H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L40097:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1OCpjChunk@@UAE@XZ			; OCpjChunk::~OCpjChunk
$L40117:
	mov	ecx, DWORD PTR $T40160[ebp]
	jmp	??1CCorArray@@IAE@XZ			; CCorArray::~CCorArray
$L40098:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 72					; 00000048H
	jmp	??1?$TCorArray@VCCpjSrfTex@@@@QAE@XZ	; TCorArray<CCpjSrfTex>::~TCorArray<CCpjSrfTex>
$L40168:
	mov	ecx, DWORD PTR $T40211[ebp]
	jmp	??1CCorArray@@IAE@XZ			; CCorArray::~CCorArray
$L40099:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 88					; 00000058H
	jmp	??1?$TCorArray@VCCpjSrfTri@@@@QAE@XZ	; TCorArray<CCpjSrfTri>::~TCorArray<CCpjSrfTri>
$L40219:
	mov	ecx, DWORD PTR $T40254[ebp-4]
	jmp	??1CCorArray@@IAE@XZ			; CCorArray::~CCorArray
$L40266:
	mov	eax, OFFSET FLAT:$T40257
	jmp	___CxxFrameHandler
text$x	ENDS
??0OCpjSurface@@QAE@AAV0@@Z ENDP			; OCpjSurface::OCpjSurface
; Function compile flags: /Ogty
; File C:\duke4\Cannibal\CorMain.h
;	COMDAT ?AddItem@?$TCorArray@PAVOCpjFrames@@@@QAEKABQAVOCpjFrames@@@Z
_TEXT	SEGMENT
_inItem$ = 8
?AddItem@?$TCorArray@PAVOCpjFrames@@@@QAEKABQAVOCpjFrames@@@Z PROC NEAR ; TCorArray<OCpjFrames *>::AddItem, COMDAT
; _this$ = ecx

; 315  : 	{

	push	esi
	mov	esi, ecx
	push	edi

; 316  : 		NDword i = Add();

	mov	edi, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	lea	eax, DWORD PTR [edi+1]
	cmp	eax, ecx
	mov	DWORD PTR [esi+4], eax
	jbe	SHORT $L40291
	mov	ecx, eax
	push	4
	shr	ecx, 2
	lea	edx, DWORD PTR [ecx+eax+32]
	mov	ecx, esi
	mov	DWORD PTR [esi+8], edx
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
$L40291:

; 317  : 		(*this)[i] = inItem;

	mov	ecx, DWORD PTR _inItem$[esp+4]
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+edi*4], edx

; 318  : 		return(i);

	mov	eax, edi
	pop	edi
	pop	esi

; 319  : 	}

	ret	4
?AddItem@?$TCorArray@PAVOCpjFrames@@@@QAEKABQAVOCpjFrames@@@Z ENDP ; TCorArray<OCpjFrames *>::AddItem
_TEXT	ENDS
PUBLIC	??4?$TCorArray@VCCpjSrfTex@@@@QAEAAV0@AAV0@@Z	; TCorArray<CCpjSrfTex>::operator=
PUBLIC	??4?$TCorArray@VCCpjSrfTri@@@@QAEAAV0@AAV0@@Z	; TCorArray<CCpjSrfTri>::operator=
PUBLIC	??4?$TCorArray@VVVec2@@@@QAEAAV0@AAV0@@Z	; TCorArray<VVec2>::operator=
PUBLIC	??4OCpjSurface@@QAEAAV0@AAV0@@Z			; OCpjSurface::operator=
; Function compile flags: /Ogty
;	COMDAT ??4OCpjSurface@@QAEAAV0@AAV0@@Z
_TEXT	SEGMENT
___that$ = 8
??4OCpjSurface@@QAEAAV0@AAV0@@Z PROC NEAR		; OCpjSurface::operator=, COMDAT
; _this$ = ecx
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR ___that$[esp+4]
	push	esi
	mov	esi, ecx
	push	edi
	mov	eax, DWORD PTR [ebp+4]
	lea	ecx, DWORD PTR [ebp+8]
	mov	DWORD PTR [esi+4], eax
	lea	edx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	lea	eax, DWORD PTR [esi+24]
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], ecx
	lea	edx, DWORD PTR [ebp+24]
	mov	ecx, DWORD PTR [ebp+24]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR [ebp+40]
	mov	DWORD PTR [esi+40], eax
	mov	ebx, DWORD PTR [ebp+44]
	test	ebx, ebx
	je	SHORT $L40378
	cmp	BYTE PTR [ebx], 0
	jne	SHORT $L40378
	xor	ebx, ebx
$L40378:
	mov	edi, DWORD PTR [esi+44]
	test	edi, edi
	je	SHORT $L40379
	or	ecx, -1
	xor	eax, eax
	repne scasb
	mov	eax, DWORD PTR ?sMemTotal@CCorString@@0KA ; CCorString::sMemTotal
	or	edx, -1
	not	ecx
	dec	ecx
	sub	edx, ecx
	add	eax, edx
	mov	DWORD PTR ?sMemTotal@CCorString@@0KA, eax ; CCorString::sMemTotal
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+44]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L40379:
	test	ebx, ebx
	mov	DWORD PTR [esi+44], 0
	je	SHORT $L40382
	mov	edi, ebx
	or	ecx, -1
	xor	eax, eax
	repne scasb
	not	ecx
	dec	ecx
	mov	edi, ecx
	inc	edi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	edi
	mov	ecx, eax
	call	DWORD PTR [edx]
	test	eax, eax
	mov	DWORD PTR [esi+44], eax
	je	SHORT $L40382
$L40384:
	mov	cl, BYTE PTR [ebx]
	inc	ebx
	mov	BYTE PTR [eax], cl
	inc	eax
	test	cl, cl
	jne	SHORT $L40384
	add	DWORD PTR ?sMemTotal@CCorString@@0KA, edi ; CCorString::sMemTotal
$L40382:
	mov	eax, DWORD PTR [ebp+48]
	mov	DWORD PTR [esi+48], eax
	mov	ecx, DWORD PTR [ebp+52]
	mov	DWORD PTR [esi+52], ecx
	mov	dl, BYTE PTR [ebp+56]
	mov	BYTE PTR [esi+56], dl
	mov	eax, DWORD PTR [ebp+60]
	mov	DWORD PTR [esi+60], eax
	mov	ecx, DWORD PTR [ebp+64]
	mov	DWORD PTR [esi+64], ecx
	mov	edx, DWORD PTR [ebp+68]
	lea	eax, DWORD PTR [ebp+72]
	lea	ecx, DWORD PTR [esi+72]
	push	eax
	mov	DWORD PTR [esi+68], edx
	call	??4?$TCorArray@VCCpjSrfTex@@@@QAEAAV0@AAV0@@Z ; TCorArray<CCpjSrfTex>::operator=
	lea	ecx, DWORD PTR [ebp+88]
	push	ecx
	lea	ecx, DWORD PTR [esi+88]
	call	??4?$TCorArray@VCCpjSrfTri@@@@QAEAAV0@AAV0@@Z ; TCorArray<CCpjSrfTri>::operator=
	add	ebp, 104				; 00000068H
	lea	ecx, DWORD PTR [esi+104]
	push	ebp
	call	??4?$TCorArray@VVVec2@@@@QAEAAV0@AAV0@@Z ; TCorArray<VVec2>::operator=
	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	4
??4OCpjSurface@@QAEAAV0@AAV0@@Z ENDP			; OCpjSurface::operator=
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??4?$TCorArray@VCCpjSrfTex@@@@QAEAAV0@AAV0@@Z
_TEXT	SEGMENT
_inArray$ = 8
_i$ = -4
??4?$TCorArray@VCCpjSrfTex@@@@QAEAAV0@AAV0@@Z PROC NEAR	; TCorArray<CCpjSrfTex>::operator=, COMDAT
; _this$ = ecx

; 269  : 	{

	push	ecx
	push	ebx
	push	esi

; 270  : 		if (this == &inArray)

	mov	esi, DWORD PTR _inArray$[esp+8]
	mov	ebx, ecx
	cmp	ebx, esi

; 271  : 			return(*this);

	je	$L40426
	push	ebp

; 272  : 		m_Count = 0;

	xor	ebp, ebp
	mov	DWORD PTR [ebx+4], ebp

; 273  : 		m_Limit = inArray.m_Count;

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [ebx+8], eax

; 274  : 		Realloc(sizeof(T));

	mov	eax, DWORD PTR [ebx]
	cmp	eax, ebp
	mov	eax, DWORD PTR [ebx+8]
	mov	DWORD PTR [ebx+12], 260			; 00000104H
	je	$L40400
	cmp	eax, ebp
	je	SHORT $L40402
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [ebx+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [ebx+8]
	push	ecx
	mov	ecx, DWORD PTR [ebx]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+4]
	mov	DWORD PTR [ebx], eax
	jmp	SHORT $L40407
$L40402:
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [ebx]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L40406:
	mov	DWORD PTR [ebx], ebp
$L40407:

; 275  : 		for (NDword i=0;i<inArray.m_Count;i++)

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR _i$[esp+16], ebp
	cmp	eax, ebp
	jbe	SHORT $L13709
	push	edi
$L13707:

; 276  : 			new(&(*this)[AddNoConstruct()]) T(inArray[i]);

	mov	esi, DWORD PTR [ebx+4]
	mov	ecx, DWORD PTR [ebx+8]
	lea	eax, DWORD PTR [esi+1]
	cmp	eax, ecx
	mov	DWORD PTR [ebx+4], eax
	jbe	SHORT $L40411
	mov	edx, eax
	push	260					; 00000104H
	shr	edx, 2
	mov	ecx, ebx
	lea	eax, DWORD PTR [edx+eax+32]
	mov	DWORD PTR [ebx+8], eax
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
$L40411:
	mov	edx, DWORD PTR [ebx]
	mov	ecx, esi
	shl	ecx, 6
	add	ecx, esi
	lea	edi, DWORD PTR [edx+ecx*4]
	test	edi, edi
	je	SHORT $L40394
	mov	eax, DWORD PTR _inArray$[esp+16]
	mov	ecx, 65					; 00000041H
	mov	esi, DWORD PTR [eax]
	add	esi, ebp
	rep movsd
$L40394:
	mov	ecx, DWORD PTR _inArray$[esp+16]
	mov	eax, DWORD PTR _i$[esp+20]
	inc	eax
	add	ebp, 260				; 00000104H
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _i$[esp+20], eax
	cmp	eax, edx
	jb	SHORT $L13707
	pop	edi
$L13709:
	pop	ebp
$L40426:

; 277  : 		return(*this);

	mov	eax, ebx
	pop	esi
	pop	ebx

; 278  : 	}

	pop	ecx
	ret	4

; 274  : 		Realloc(sizeof(T));

$L40400:
	cmp	eax, ebp
	je	SHORT $L40406
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [ebx+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [ebx+8]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	DWORD PTR [ebx], eax
	jmp	$L40407
??4?$TCorArray@VCCpjSrfTex@@@@QAEAAV0@AAV0@@Z ENDP	; TCorArray<CCpjSrfTex>::operator=
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??4?$TCorArray@VCCpjSrfTri@@@@QAEAAV0@AAV0@@Z
_TEXT	SEGMENT
_inArray$ = 8
_i$ = 8
??4?$TCorArray@VCCpjSrfTri@@@@QAEAAV0@AAV0@@Z PROC NEAR	; TCorArray<CCpjSrfTri>::operator=, COMDAT
; _this$ = ecx

; 269  : 	{

	push	ebp

; 270  : 		if (this == &inArray)

	mov	ebp, DWORD PTR _inArray$[esp]
	push	esi
	mov	esi, ecx
	cmp	esi, ebp

; 271  : 			return(*this);

	je	$L40463
	push	ebx

; 272  : 		m_Count = 0;

	xor	ebx, ebx
	mov	DWORD PTR [esi+4], ebx

; 273  : 		m_Limit = inArray.m_Count;

	mov	eax, DWORD PTR [ebp+4]
	mov	DWORD PTR [esi+8], eax

; 274  : 		Realloc(sizeof(T));

	mov	eax, DWORD PTR [esi]
	cmp	eax, ebx
	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [esi+12], 16			; 00000010H
	je	$L40439
	cmp	eax, ebx
	je	SHORT $L40441
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [esi+8]
	push	ecx
	mov	ecx, DWORD PTR [esi]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+4]
	mov	DWORD PTR [esi], eax
	jmp	SHORT $L40446
$L40441:
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L40445:
	mov	DWORD PTR [esi], ebx
$L40446:

; 275  : 		for (NDword i=0;i<inArray.m_Count;i++)

	mov	eax, DWORD PTR [ebp+4]
	mov	DWORD PTR _i$[esp+8], ebx
	cmp	eax, ebx
	jbe	SHORT $L13746
	push	edi
$L13744:

; 276  : 			new(&(*this)[AddNoConstruct()]) T(inArray[i]);

	mov	edi, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	lea	eax, DWORD PTR [edi+1]
	cmp	eax, ecx
	mov	DWORD PTR [esi+4], eax
	jbe	SHORT $L40450
	mov	edx, eax
	push	16					; 00000010H
	shr	edx, 2
	mov	ecx, esi
	lea	eax, DWORD PTR [edx+eax+32]
	mov	DWORD PTR [esi+8], eax
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
$L40450:
	mov	eax, DWORD PTR [esi]
	shl	edi, 4
	add	edi, eax
	je	SHORT $L40433
	mov	ecx, DWORD PTR [ebp]
	add	ecx, ebx
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [edi], edx
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edi+4], eax
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [edi+8], edx
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [edi+12], eax
$L40433:
	mov	eax, DWORD PTR _i$[esp+12]
	mov	ecx, DWORD PTR [ebp+4]
	inc	eax
	add	ebx, 16					; 00000010H
	cmp	eax, ecx
	mov	DWORD PTR _i$[esp+12], eax
	jb	SHORT $L13744
	pop	edi
$L13746:
	pop	ebx
$L40463:

; 277  : 		return(*this);

	mov	eax, esi
	pop	esi
	pop	ebp

; 278  : 	}

	ret	4
$L40439:

; 274  : 		Realloc(sizeof(T));

	cmp	eax, ebx
	je	SHORT $L40445
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [esi+8]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	DWORD PTR [esi], eax
	jmp	$L40446
??4?$TCorArray@VCCpjSrfTri@@@@QAEAAV0@AAV0@@Z ENDP	; TCorArray<CCpjSrfTri>::operator=
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??4?$TCorArray@VVVec2@@@@QAEAAV0@AAV0@@Z
_TEXT	SEGMENT
_inArray$ = 8
??4?$TCorArray@VVVec2@@@@QAEAAV0@AAV0@@Z PROC NEAR	; TCorArray<VVec2>::operator=, COMDAT
; _this$ = ecx

; 269  : 	{

	push	ebp

; 270  : 		if (this == &inArray)

	mov	ebp, DWORD PTR _inArray$[esp]
	push	esi
	mov	esi, ecx
	cmp	esi, ebp

; 271  : 			return(*this);

	je	$L40504
	push	ebx

; 272  : 		m_Count = 0;

	xor	ebx, ebx
	mov	DWORD PTR [esi+4], ebx

; 273  : 		m_Limit = inArray.m_Count;

	mov	eax, DWORD PTR [ebp+4]
	mov	DWORD PTR [esi+8], eax

; 274  : 		Realloc(sizeof(T));

	mov	eax, DWORD PTR [esi]
	cmp	eax, ebx
	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [esi+12], 8
	je	$L40476
	cmp	eax, ebx
	je	SHORT $L40478
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [esi+8]
	push	ecx
	mov	ecx, DWORD PTR [esi]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+4]
	mov	DWORD PTR [esi], eax
	jmp	SHORT $L40483
$L40478:
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L40482:
	mov	DWORD PTR [esi], ebx
$L40483:

; 275  : 		for (NDword i=0;i<inArray.m_Count;i++)

	cmp	DWORD PTR [ebp+4], ebx
	jbe	SHORT $L13783
	push	edi
$L13781:

; 276  : 			new(&(*this)[AddNoConstruct()]) T(inArray[i]);

	mov	edi, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	lea	eax, DWORD PTR [edi+1]
	cmp	eax, ecx
	mov	DWORD PTR [esi+4], eax
	jbe	SHORT $L40487
	mov	edx, eax
	push	8
	shr	edx, 2
	mov	ecx, esi
	lea	eax, DWORD PTR [edx+eax+32]
	mov	DWORD PTR [esi+8], eax
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
$L40487:
	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ecx+edi*8]
	test	eax, eax
	je	SHORT $L40470
	mov	edx, DWORD PTR [ebp]
	lea	ecx, DWORD PTR [edx+ebx*8]
	mov	edx, DWORD PTR [edx+ebx*8]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx
$L40470:
	mov	eax, DWORD PTR [ebp+4]
	inc	ebx
	cmp	ebx, eax
	jb	SHORT $L13781
	pop	edi
$L13783:
	pop	ebx
$L40504:

; 277  : 		return(*this);

	mov	eax, esi
	pop	esi
	pop	ebp

; 278  : 	}

	ret	4
$L40476:

; 274  : 		Realloc(sizeof(T));

	cmp	eax, ebx
	je	SHORT $L40482
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [esi+8]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	DWORD PTR [esi], eax
	jmp	SHORT $L40483
??4?$TCorArray@VVVec2@@@@QAEAAV0@AAV0@@Z ENDP		; TCorArray<VVec2>::operator=
_TEXT	ENDS
PUBLIC	??1OCpjSurface@@UAE@XZ				; OCpjSurface::~OCpjSurface
;	COMDAT xdata$x
xdata$x	SEGMENT
$T40642	DD	0ffffffffH
	DD	FLAT:$L40508
	DD	00H
	DD	FLAT:$L40509
	DD	01H
	DD	FLAT:$L40510
$T40634	DD	019930520H
	DD	03H
	DD	FLAT:$T40642
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ??1OCpjSurface@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16
__$EHRec$ = -12
??1OCpjSurface@@UAE@XZ PROC NEAR			; OCpjSurface::~OCpjSurface, COMDAT
; _this$ = ecx
	push	-1
	push	$L40641
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	push	esi
	push	edi
	mov	edi, ecx
	mov	DWORD PTR _this$[esp+24], edi
	mov	eax, DWORD PTR [edi+108]
	lea	esi, DWORD PTR [edi+104]
	push	8
	push	eax
	push	0
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+44], 2
	call	?Remove@CCorArray@@QAEXKKK@Z		; CCorArray::Remove
	cmp	DWORD PTR [esi], 0
	je	SHORT $L40546
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L40546:
	mov	eax, DWORD PTR [edi+92]
	lea	esi, DWORD PTR [edi+88]
	push	16					; 00000010H
	push	eax
	push	0
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+44], 1
	call	?Remove@CCorArray@@QAEXKKK@Z		; CCorArray::Remove
	cmp	DWORD PTR [esi], 0
	je	SHORT $L40583
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L40583:
	mov	eax, DWORD PTR [edi+76]
	lea	esi, DWORD PTR [edi+72]
	push	260					; 00000104H
	push	eax
	push	0
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+44], 0
	call	?Remove@CCorArray@@QAEXKKK@Z		; CCorArray::Remove
	cmp	DWORD PTR [esi], 0
	je	SHORT $L40620
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L40620:
	mov	ecx, edi
	mov	DWORD PTR __$EHRec$[esp+32], -1
	call	??1OObject@@UAE@XZ			; OObject::~OObject
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L40508:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1OCpjChunk@@UAE@XZ			; OCpjChunk::~OCpjChunk
$L40509:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 72					; 00000048H
	jmp	??1?$TCorArray@VCCpjSrfTex@@@@QAE@XZ	; TCorArray<CCpjSrfTex>::~TCorArray<CCpjSrfTex>
$L40510:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 88					; 00000058H
	jmp	??1?$TCorArray@VCCpjSrfTri@@@@QAE@XZ	; TCorArray<CCpjSrfTri>::~TCorArray<CCpjSrfTri>
$L40641:
	mov	eax, OFFSET FLAT:$T40634
	jmp	___CxxFrameHandler
text$x	ENDS
??1OCpjSurface@@UAE@XZ ENDP				; OCpjSurface::~OCpjSurface
PUBLIC	??_GOCpjSurface@@UAEPAXI@Z			; OCpjSurface::`scalar deleting destructor'
; Function compile flags: /Ogty
;	COMDAT ??_GOCpjSurface@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_GOCpjSurface@@UAEPAXI@Z PROC NEAR			; OCpjSurface::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1OCpjSurface@@UAE@XZ			; OCpjSurface::~OCpjSurface
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $L40660
	mov	DWORD PTR [esi+4], 0
	mov	edx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	dec	edx
	mov	DWORD PTR ?sObjCount@OObject@@1KA, edx	; OObject::sObjCount
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L40660:
	mov	eax, esi
	pop	esi
	ret	4
??_GOCpjSurface@@UAEPAXI@Z ENDP				; OCpjSurface::`scalar deleting destructor'
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??_EOCpjSurface@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_EOCpjSurface@@UAEPAXI@Z PROC NEAR			; OCpjSurface::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebx
	mov	bl, BYTE PTR ___flags$[esp]
	push	esi
	mov	esi, ecx
	test	bl, 2
	je	SHORT $L8396
	mov	eax, DWORD PTR [esi-4]
	push	edi
	lea	edi, DWORD PTR [esi-4]
	push	OFFSET FLAT:??1OCpjSurface@@UAE@XZ	; OCpjSurface::~OCpjSurface
	push	eax
	push	120					; 00000078H
	push	esi
	call	??_M@YGXPAXIHP6EX0@Z@Z			; `eh vector destructor iterator'
	test	bl, 1
	je	SHORT $L8397
	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L8397:
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	ret	4
$L8396:
	mov	ecx, esi
	call	??1OCpjSurface@@UAE@XZ			; OCpjSurface::~OCpjSurface
	test	bl, 1
	je	SHORT $L40675
	mov	DWORD PTR [esi+4], 0
	mov	edx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	dec	edx
	mov	DWORD PTR ?sObjCount@OObject@@1KA, edx	; OObject::sObjCount
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L40675:
	mov	eax, esi
	pop	esi
	pop	ebx
	ret	4
??_EOCpjSurface@@UAEPAXI@Z ENDP				; OCpjSurface::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??2OCpjLodData@@CAPAXIPAVOObject@@PAVCObjClass@@@Z ; OCpjLodData::operator new
; Function compile flags: /Ogty
; File C:\duke4\Cannibal\CpjLod.h
;	COMDAT ??2OCpjLodData@@CAPAXIPAVOObject@@PAVCObjClass@@@Z
_TEXT	SEGMENT
_inParent$ = 12
_inSetClass$ = 16
??2OCpjLodData@@CAPAXIPAVOObject@@PAVCObjClass@@@Z PROC NEAR ; OCpjLodData::operator new, COMDAT

; 42   : 	OBJ_CLASS_DEFINE(OCpjLodData, OCpjChunk);

	push	esi
	push	edi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	88					; 00000058H
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	ecx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	mov	esi, eax
	inc	ecx
	xor	eax, eax
	mov	DWORD PTR ?sObjCount@OObject@@1KA, ecx	; OObject::sObjCount
	mov	ecx, 22					; 00000016H
	mov	edi, esi
	rep stosd
	mov	eax, DWORD PTR [esi+40]
	mov	DWORD PTR [esi+4], 305419896		; 12345678H
	test	eax, eax
	jne	SHORT $L40686
	mov	eax, DWORD PTR _inSetClass$[esp+4]
	mov	DWORD PTR [esi+40], eax
$L40686:
	mov	ecx, DWORD PTR _inParent$[esp+4]
	push	ecx
	mov	ecx, esi
	call	?PreConstruct@OObject@@QAEXPAV1@@Z	; OObject::PreConstruct
	mov	eax, esi
	pop	edi
	pop	esi
	ret	0
??2OCpjLodData@@CAPAXIPAVOObject@@PAVCObjClass@@@Z ENDP	; OCpjLodData::operator new
_TEXT	ENDS
PUBLIC	??3OCpjLodData@@CAXPAX@Z			; OCpjLodData::operator delete
; Function compile flags: /Ogty
;	COMDAT ??3OCpjLodData@@CAXPAX@Z
_TEXT	SEGMENT
_ptr$ = 8
??3OCpjLodData@@CAXPAX@Z PROC NEAR			; OCpjLodData::operator delete, COMDAT

; 42   : 	OBJ_CLASS_DEFINE(OCpjLodData, OCpjChunk);

	push	esi
	mov	esi, DWORD PTR _ptr$[esp]
	mov	DWORD PTR [esi+4], 0
	mov	edx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	dec	edx
	mov	DWORD PTR ?sObjCount@OObject@@1KA, edx	; OObject::sObjCount
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	ecx, eax
	call	DWORD PTR [edx+8]
	pop	esi
	ret	0
??3OCpjLodData@@CAXPAX@Z ENDP				; OCpjLodData::operator delete
_TEXT	ENDS
PUBLIC	??3OCpjLodData@@CAXPAXPAVOObject@@PAVCObjClass@@@Z ; OCpjLodData::operator delete
; Function compile flags: /Ogty
;	COMDAT ??3OCpjLodData@@CAXPAXPAVOObject@@PAVCObjClass@@@Z
_TEXT	SEGMENT
_ptr$ = 8
??3OCpjLodData@@CAXPAXPAVOObject@@PAVCObjClass@@@Z PROC NEAR ; OCpjLodData::operator delete, COMDAT

; 42   : 	OBJ_CLASS_DEFINE(OCpjLodData, OCpjChunk);

	push	esi
	mov	esi, DWORD PTR _ptr$[esp]
	mov	DWORD PTR [esi+4], 0
	mov	edx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	dec	edx
	mov	DWORD PTR ?sObjCount@OObject@@1KA, edx	; OObject::sObjCount
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	ecx, eax
	call	DWORD PTR [edx+8]
	pop	esi
	ret	0
??3OCpjLodData@@CAXPAXPAVOObject@@PAVCObjClass@@@Z ENDP	; OCpjLodData::operator delete
_TEXT	ENDS
PUBLIC	?GetStaticClass@OCpjLodData@@SAPAVCObjClass@@XZ	; OCpjLodData::GetStaticClass
; Function compile flags: /Ogty
;	COMDAT ?GetStaticClass@OCpjLodData@@SAPAVCObjClass@@XZ
_TEXT	SEGMENT
?GetStaticClass@OCpjLodData@@SAPAVCObjClass@@XZ PROC NEAR ; OCpjLodData::GetStaticClass, COMDAT

; 42   : 	OBJ_CLASS_DEFINE(OCpjLodData, OCpjChunk);

	mov	eax, DWORD PTR ?staticObjClass@OCpjLodData@@0PAVCObjClass@@A ; OCpjLodData::staticObjClass
	ret	0
?GetStaticClass@OCpjLodData@@SAPAVCObjClass@@XZ ENDP	; OCpjLodData::GetStaticClass
; Function compile flags: /Ogty
; File C:\duke4\Cannibal\CorMain.h
_TEXT	ENDS
;	COMDAT ?AddItem@?$TCorArray@PAVOCpjSequence@@@@QAEKABQAVOCpjSequence@@@Z
_TEXT	SEGMENT
_inItem$ = 8
?AddItem@?$TCorArray@PAVOCpjSequence@@@@QAEKABQAVOCpjSequence@@@Z PROC NEAR ; TCorArray<OCpjSequence *>::AddItem, COMDAT
; _this$ = ecx

; 315  : 	{

	push	esi
	mov	esi, ecx
	push	edi

; 316  : 		NDword i = Add();

	mov	edi, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	lea	eax, DWORD PTR [edi+1]
	cmp	eax, ecx
	mov	DWORD PTR [esi+4], eax
	jbe	SHORT $L40728
	mov	ecx, eax
	push	4
	shr	ecx, 2
	lea	edx, DWORD PTR [ecx+eax+32]
	mov	ecx, esi
	mov	DWORD PTR [esi+8], edx
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
$L40728:

; 317  : 		(*this)[i] = inItem;

	mov	ecx, DWORD PTR _inItem$[esp+4]
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+edi*4], edx

; 318  : 		return(i);

	mov	eax, edi
	pop	edi
	pop	esi

; 319  : 	}

	ret	4
?AddItem@?$TCorArray@PAVOCpjSequence@@@@QAEKABQAVOCpjSequence@@@Z ENDP ; TCorArray<OCpjSequence *>::AddItem
_TEXT	ENDS
PUBLIC	?New@OCpjLodData@@SAPAV1@PAVOObject@@PAVCObjClass@@@Z ; OCpjLodData::New
PUBLIC	?GetClass@OCpjLodData@@UAEPAVCObjClass@@XZ	; OCpjLodData::GetClass
PUBLIC	?GetFileExtension@OCpjLodData@@UAEPADXZ		; OCpjLodData::GetFileExtension
PUBLIC	?GetFileDescription@OCpjLodData@@UAEPADXZ	; OCpjLodData::GetFileDescription
PUBLIC	??_7OCpjLodData@@6B@				; OCpjLodData::`vftable'
PUBLIC	??_EOCpjLodData@@UAEPAXI@Z			; OCpjLodData::`vector deleting destructor'
EXTRN	?LoadChunk@OCpjLodData@@UAE_NPAXK@Z:NEAR	; OCpjLodData::LoadChunk
EXTRN	?SaveChunk@OCpjLodData@@UAE_NPAXPAK@Z:NEAR	; OCpjLodData::SaveChunk
EXTRN	?GetFourCC@OCpjLodData@@UAEKXZ:NEAR		; OCpjLodData::GetFourCC
;	COMDAT xdata$x
xdata$x	SEGMENT
$T40852	DD	0ffffffffH
	DD	FLAT:$L40751
	DD	00H
	DD	FLAT:$L40776
$T40850	DD	019930520H
	DD	02H
	DD	FLAT:$T40852
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_7OCpjLodData@@6B@
CONST	SEGMENT
??_7OCpjLodData@@6B@ DD FLAT:?Msg@OObject@@UAE_NPAVIMsg@@@Z ; OCpjLodData::`vftable'
	DD	FLAT:?MsgGetChild@OObject@@UAEPAVIMsgTarget@@PAD@Z
	DD	FLAT:?MsgGetParent@OObject@@UAEPAVIMsgTarget@@XZ
	DD	FLAT:?MsgGetRoot@OObject@@UAEPAVIMsgTarget@@XZ
	DD	FLAT:?GetClass@OCpjLodData@@UAEPAVCObjClass@@XZ
	DD	FLAT:??_EOCpjLodData@@UAEPAXI@Z
	DD	FLAT:?Create@OCpjChunk@@UAEXXZ
	DD	FLAT:?Destroy@OObject@@UAEXXZ
	DD	FLAT:?GetParent@OObject@@UAEPAV1@XZ
	DD	FLAT:?SetParent@OObject@@UAEXPAV1@_N@Z
	DD	FLAT:?HasChildren@OObject@@UAE_NXZ
	DD	FLAT:?IsA@OObject@@UAE_NPAVCObjClass@@@Z
	DD	FLAT:?GetFileExtension@OCpjLodData@@UAEPADXZ
	DD	FLAT:?GetFileDescription@OCpjLodData@@UAEPADXZ
	DD	FLAT:?LoadFile@OCpjChunk@@UAE_NPAD@Z
	DD	FLAT:?SaveFile@OCpjChunk@@UAE_NPAD@Z
	DD	FLAT:?GetFourCC@OCpjLodData@@UAEKXZ
	DD	FLAT:?LoadChunk@OCpjLodData@@UAE_NPAXK@Z
	DD	FLAT:?SaveChunk@OCpjLodData@@UAE_NPAXPAK@Z
; Function compile flags: /Ogty
; File C:\duke4\Cannibal\CpjLod.h
CONST	ENDS
;	COMDAT ?New@OCpjLodData@@SAPAV1@PAVOObject@@PAVCObjClass@@@Z
_TEXT	SEGMENT
$T40748 = -16
__$EHRec$ = -12
_inParent$ = 8
_inSetClass$ = 12
?New@OCpjLodData@@SAPAV1@PAVOObject@@PAVCObjClass@@@Z PROC NEAR ; OCpjLodData::New, COMDAT

; 42   : 	OBJ_CLASS_DEFINE(OCpjLodData, OCpjChunk);

	push	-1
	push	$L40851
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	push	ebx
	mov	ebx, DWORD PTR _inSetClass$[esp+16]
	push	ebp
	xor	ebp, ebp
	cmp	ebx, ebp
	push	esi
	jne	SHORT $L8628
	mov	ebx, DWORD PTR ?staticObjClass@OCpjLodData@@0PAVCObjClass@@A ; OCpjLodData::staticObjClass
	mov	DWORD PTR _inSetClass$[esp+24], ebx
$L8628:
	push	edi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	88					; 00000058H
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	ecx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	mov	esi, eax
	inc	ecx
	xor	eax, eax
	mov	DWORD PTR ?sObjCount@OObject@@1KA, ecx	; OObject::sObjCount
	mov	ecx, 22					; 00000016H
	mov	edi, esi
	rep stosd
	mov	eax, DWORD PTR [esi+40]
	mov	DWORD PTR [esi+4], 305419896		; 12345678H
	cmp	eax, ebp
	pop	edi
	jne	SHORT $L40771
	mov	DWORD PTR [esi+40], ebx
$L40771:
	mov	eax, DWORD PTR _inParent$[esp+24]
	mov	ecx, esi
	push	eax
	call	?PreConstruct@OObject@@QAEXPAV1@@Z	; OObject::PreConstruct
	mov	DWORD PTR $T40748[esp+28], esi
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+36], ebp
	call	??0OObject@@QAE@XZ			; OObject::OObject
	mov	DWORD PTR [esi+76], ebp
	mov	DWORD PTR [esi+80], ebp
	mov	DWORD PTR [esi+84], 36			; 00000024H
	mov	DWORD PTR [esi+72], ebp
	mov	DWORD PTR [esi], OFFSET FLAT:??_7OCpjLodData@@6B@ ; OCpjLodData::`vftable'
	mov	edx, DWORD PTR [esi]
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+36], -1
	call	DWORD PTR [edx+24]
	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L40751:
	mov	eax, DWORD PTR _inSetClass$[ebp-4]
	push	eax
	mov	ecx, DWORD PTR _inParent$[ebp-4]
	push	ecx
	mov	edx, DWORD PTR $T40748[ebp]
	push	edx
	call	??3OCpjLodData@@CAXPAXPAVOObject@@PAVCObjClass@@@Z ; OCpjLodData::operator delete
	add	esp, 12					; 0000000cH
	ret	0
$L40776:
	mov	ecx, DWORD PTR $T40748[ebp]
	jmp	??1OCpjChunk@@UAE@XZ			; OCpjChunk::~OCpjChunk
$L40851:
	mov	eax, OFFSET FLAT:$T40850
	jmp	___CxxFrameHandler
text$x	ENDS
?New@OCpjLodData@@SAPAV1@PAVOObject@@PAVCObjClass@@@Z ENDP ; OCpjLodData::New
; Function compile flags: /Ogty
;	COMDAT ?GetClass@OCpjLodData@@UAEPAVCObjClass@@XZ
_TEXT	SEGMENT
?GetClass@OCpjLodData@@UAEPAVCObjClass@@XZ PROC NEAR	; OCpjLodData::GetClass, COMDAT
; _this$ = ecx

; 42   : 	OBJ_CLASS_DEFINE(OCpjLodData, OCpjChunk);

	mov	eax, DWORD PTR [ecx+40]
	ret	0
?GetClass@OCpjLodData@@UAEPAVCObjClass@@XZ ENDP		; OCpjLodData::GetClass
_TEXT	ENDS
PUBLIC	??_C@_03OJBK@lod?$AA@				; `string'
;	COMDAT ??_C@_03OJBK@lod?$AA@
_DATA	SEGMENT
??_C@_03OJBK@lod?$AA@ DB 'lod', 00H			; `string'
; Function compile flags: /Ogty
_DATA	ENDS
;	COMDAT ?GetFileExtension@OCpjLodData@@UAEPADXZ
_TEXT	SEGMENT
?GetFileExtension@OCpjLodData@@UAEPADXZ PROC NEAR	; OCpjLodData::GetFileExtension, COMDAT
; _this$ = ecx

; 54   : 	NChar* GetFileExtension() { return("lod"); }

	mov	eax, OFFSET FLAT:??_C@_03OJBK@lod?$AA@	; `string'
	ret	0
?GetFileExtension@OCpjLodData@@UAEPADXZ ENDP		; OCpjLodData::GetFileExtension
_TEXT	ENDS
PUBLIC	??_C@_0BC@GAMJ@Cannibal?5LOD?5Data?$AA@		; `string'
;	COMDAT ??_C@_0BC@GAMJ@Cannibal?5LOD?5Data?$AA@
_DATA	SEGMENT
??_C@_0BC@GAMJ@Cannibal?5LOD?5Data?$AA@ DB 'Cannibal LOD Data', 00H ; `string'
; Function compile flags: /Ogty
_DATA	ENDS
;	COMDAT ?GetFileDescription@OCpjLodData@@UAEPADXZ
_TEXT	SEGMENT
?GetFileDescription@OCpjLodData@@UAEPADXZ PROC NEAR	; OCpjLodData::GetFileDescription, COMDAT
; _this$ = ecx

; 55   : 	NChar* GetFileDescription() { return("Cannibal LOD Data"); }

	mov	eax, OFFSET FLAT:??_C@_0BC@GAMJ@Cannibal?5LOD?5Data?$AA@ ; `string'
	ret	0
?GetFileDescription@OCpjLodData@@UAEPADXZ ENDP		; OCpjLodData::GetFileDescription
_TEXT	ENDS
PUBLIC	??0OCpjLodData@@QAE@XZ				; OCpjLodData::OCpjLodData
;	COMDAT xdata$x
xdata$x	SEGMENT
$T40923	DD	0ffffffffH
	DD	FLAT:$L40867
$T40921	DD	019930520H
	DD	01H
	DD	FLAT:$T40923
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ??0OCpjLodData@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12
_this$ = -20
??0OCpjLodData@@QAE@XZ PROC NEAR			; OCpjLodData::OCpjLodData, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR fs:__except_list
	push	-1
	push	$L40922
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	esi
	mov	esi, ecx
	call	??0OObject@@QAE@XZ			; OObject::OObject
	mov	ecx, DWORD PTR __$EHRec$[esp+16]
	xor	eax, eax
	mov	DWORD PTR [esi+76], eax
	mov	DWORD PTR [esi+80], eax
	mov	DWORD PTR [esi+84], 36			; 00000024H
	mov	DWORD PTR [esi+72], eax
	mov	DWORD PTR [esi], OFFSET FLAT:??_7OCpjLodData@@6B@ ; OCpjLodData::`vftable'
	mov	eax, esi
	mov	DWORD PTR fs:__except_list, ecx
	pop	esi
	add	esp, 12					; 0000000cH
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L40867:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1OCpjChunk@@UAE@XZ			; OCpjChunk::~OCpjChunk
$L40922:
	mov	eax, OFFSET FLAT:$T40921
	jmp	___CxxFrameHandler
text$x	ENDS
??0OCpjLodData@@QAE@XZ ENDP				; OCpjLodData::OCpjLodData
PUBLIC	??1?$TCorArray@G@@QAE@XZ			; TCorArray<unsigned short>::~TCorArray<unsigned short>
PUBLIC	?AddNoConstruct@?$TCorArray@G@@QAEKK@Z		; TCorArray<unsigned short>::AddNoConstruct
PUBLIC	??0?$TCorArray@VCCpjLodTri@@@@QAE@AAV0@@Z	; TCorArray<CCpjLodTri>::TCorArray<CCpjLodTri>
PUBLIC	??0OCpjLodData@@QAE@AAV0@@Z			; OCpjLodData::OCpjLodData
;	COMDAT xdata$x
xdata$x	SEGMENT
$T41110	DD	0ffffffffH
	DD	FLAT:$L40936
	DD	00H
	DD	FLAT:$L40937
	DD	0ffffffffH
	DD	FLAT:$L40929
	DD	02H
	DD	FLAT:$L40976
	DD	03H
	DD	FLAT:$L40977
	DD	04H
	DD	FLAT:$L41005
	DD	04H
	DD	FLAT:$L40997
$T41101	DD	019930520H
	DD	07H
	DD	FLAT:$T41110
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ??0OCpjLodData@@QAE@AAV0@@Z
_TEXT	SEGMENT
$T41034 = -16
$T41058 = -20
$T41059 = -32
_i$41088 = 8
_i$41094 = -36
$T41098 = -28
__$EHRec$ = -12
___that$ = 8
_this$ = -24
??0OCpjLodData@@QAE@AAV0@@Z PROC NEAR			; OCpjLodData::OCpjLodData, COMDAT
; _this$ = ecx
	push	-1
	push	$L41109
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 28					; 0000001cH
	push	ebx
	push	ebp
	push	esi
	mov	esi, DWORD PTR ___that$[esp+48]
	push	edi
	mov	edi, ecx
	lea	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR _this$[esp+56], edi
	mov	DWORD PTR [edi], OFFSET FLAT:??_7IMsgTarget@@6B@ ; IMsgTarget::`vftable'
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [edi+4], eax
	mov	eax, DWORD PTR [ecx]
	lea	edx, DWORD PTR [edi+8]
	mov	DWORD PTR [edi+8], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], ecx
	lea	edx, DWORD PTR [esi+24]
	lea	eax, DWORD PTR [edi+24]
	xor	ebx, ebx
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR __$EHRec$[esp+64], ebx
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR [esi+40]
	lea	ecx, DWORD PTR [edi+44]
	mov	DWORD PTR [edi+40], eax
	mov	BYTE PTR __$EHRec$[esp+64], 1
	mov	DWORD PTR [ecx], ebx
	mov	edx, DWORD PTR [esi+44]
	push	edx
	call	?Set@CCorString@@QAEXPAD@Z		; CCorString::Set
	mov	eax, DWORD PTR [esi+48]
	mov	DWORD PTR [edi+48], eax
	mov	ecx, DWORD PTR [esi+52]
	mov	DWORD PTR [edi+52], ecx
	mov	DWORD PTR [edi], OFFSET FLAT:??_7OCpjRes@@6B@ ; OCpjRes::`vftable'
	mov	dl, BYTE PTR [esi+56]
	mov	BYTE PTR [edi+56], dl
	mov	eax, DWORD PTR [esi+60]
	mov	DWORD PTR [edi+60], eax
	mov	ecx, DWORD PTR [esi+64]
	mov	DWORD PTR [edi+64], ecx
	mov	edx, DWORD PTR [esi+68]
	mov	DWORD PTR [edi+68], edx
	mov	DWORD PTR [edi], OFFSET FLAT:??_7OCpjChunk@@6B@ ; OCpjChunk::`vftable'
	mov	eax, DWORD PTR [esi+76]
	lea	ebp, DWORD PTR [edi+72]
	push	36					; 00000024H
	mov	ecx, ebp
	mov	DWORD PTR __$EHRec$[esp+68], 2
	mov	DWORD PTR $T41098[esp+60], ebp
	mov	DWORD PTR [ebp], ebx
	mov	DWORD PTR [ebp+4], eax
	mov	DWORD PTR [ebp+8], eax
	mov	DWORD PTR [ebp+12], 36			; 00000024H
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
	mov	DWORD PTR [ebp+4], ebx
	mov	eax, DWORD PTR [esi+76]
	cmp	eax, ebx
	mov	BYTE PTR __$EHRec$[esp+64], 3
	mov	DWORD PTR _i$41094[esp+56], ebx
	jbe	$L41106
	mov	DWORD PTR -40+[esp+56], ebx
$L41095:
	mov	ebx, DWORD PTR [ebp+4]
	mov	ecx, DWORD PTR [ebp+8]
	lea	eax, DWORD PTR [ebx+1]
	cmp	eax, ecx
	mov	DWORD PTR [ebp+4], eax
	jbe	SHORT $L41067
	mov	ecx, eax
	push	36					; 00000024H
	shr	ecx, 2
	lea	edx, DWORD PTR [ecx+eax+32]
	mov	ecx, ebp
	mov	DWORD PTR [ebp+8], edx
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
$L41067:
	mov	ecx, DWORD PTR [ebp]
	lea	eax, DWORD PTR [ebx+ebx*8]
	lea	ebx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR $T41059[esp+56], ebx
	mov	DWORD PTR $T41058[esp+56], ebx
	test	ebx, ebx
	mov	BYTE PTR __$EHRec$[esp+64], 4
	je	$L41060
	mov	ebp, DWORD PTR [esi+72]
	mov	ecx, DWORD PTR -40+[esp+56]
	add	ebp, ecx
	add	ebx, 4
	push	2
	mov	ecx, ebx
	mov	edx, DWORD PTR [ebp]
	mov	DWORD PTR $T41034[esp+60], ebx
	mov	DWORD PTR [ebx-4], edx
	mov	eax, DWORD PTR [ebp+8]
	push	eax
	call	??0CCorArray@@IAE@KK@Z			; CCorArray::CCorArray
	xor	eax, eax
	mov	BYTE PTR __$EHRec$[esp+64], 5
	mov	DWORD PTR [ebx+4], eax
	mov	ecx, DWORD PTR [ebp+8]
	cmp	ecx, eax
	mov	DWORD PTR _i$41088[esp+52], eax
	jbe	SHORT $L41091
$L41089:
	push	1
	mov	ecx, ebx
	call	?AddNoConstruct@?$TCorArray@G@@QAEKK@Z	; TCorArray<unsigned short>::AddNoConstruct
	mov	ecx, DWORD PTR [ebx]
	lea	eax, DWORD PTR [ecx+eax*2]
	test	eax, eax
	je	SHORT $L41079
	mov	edx, DWORD PTR [ebp+4]
	mov	ecx, DWORD PTR _i$41088[esp+52]
	mov	dx, WORD PTR [edx+ecx*2]
	mov	WORD PTR [eax], dx
$L41079:
	mov	eax, DWORD PTR _i$41088[esp+52]
	mov	ecx, DWORD PTR [ebp+8]
	inc	eax
	cmp	eax, ecx
	mov	DWORD PTR _i$41088[esp+52], eax
	jb	SHORT $L41089
$L41091:
	mov	eax, DWORD PTR $T41059[esp+56]
	add	ebp, 20					; 00000014H
	push	ebp
	mov	BYTE PTR __$EHRec$[esp+68], 6
	lea	ecx, DWORD PTR [eax+20]
	call	??0?$TCorArray@VCCpjLodTri@@@@QAE@AAV0@@Z ; TCorArray<CCpjLodTri>::TCorArray<CCpjLodTri>
	mov	ebp, DWORD PTR $T41098[esp+56]
$L41060:
	mov	eax, DWORD PTR _i$41094[esp+56]
	mov	edx, DWORD PTR -40+[esp+56]
	mov	ecx, DWORD PTR [esi+76]
	inc	eax
	add	edx, 36					; 00000024H
	cmp	eax, ecx
	mov	BYTE PTR __$EHRec$[esp+64], 3
	mov	DWORD PTR _i$41094[esp+56], eax
	mov	DWORD PTR -40+[esp+56], edx
	jb	$L41095
$L41106:
	mov	ecx, DWORD PTR __$EHRec$[esp+56]
	mov	DWORD PTR [edi], OFFSET FLAT:??_7OCpjLodData@@6B@ ; OCpjLodData::`vftable'
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 40					; 00000028H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L40936:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1CObjLink@@QAE@XZ			; CObjLink::~CObjLink
$L40937:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	jmp	??1CObjLink@@QAE@XZ			; CObjLink::~CObjLink
$L40929:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1OCpjChunk@@UAE@XZ			; OCpjChunk::~OCpjChunk
$L40976:
	mov	ecx, DWORD PTR $T41098[ebp]
	jmp	??1CCorArray@@IAE@XZ			; CCorArray::~CCorArray
$L40977:
	mov	eax, DWORD PTR $T41059[ebp]
	push	eax
	mov	ecx, DWORD PTR $T41058[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
$L41005:
	mov	ecx, DWORD PTR $T41034[ebp]
	jmp	??1CCorArray@@IAE@XZ			; CCorArray::~CCorArray
$L40997:
	mov	ecx, DWORD PTR $T41058[ebp]
	add	ecx, 4
	jmp	??1?$TCorArray@G@@QAE@XZ		; TCorArray<unsigned short>::~TCorArray<unsigned short>
$L41109:
	mov	eax, OFFSET FLAT:$T41101
	jmp	___CxxFrameHandler
text$x	ENDS
??0OCpjLodData@@QAE@AAV0@@Z ENDP			; OCpjLodData::OCpjLodData
; Function compile flags: /Ogty
; File C:\duke4\Cannibal\CorMain.h
;	COMDAT ??1?$TCorArray@G@@QAE@XZ
_TEXT	SEGMENT
??1?$TCorArray@G@@QAE@XZ PROC NEAR			; TCorArray<unsigned short>::~TCorArray<unsigned short>, COMDAT
; _this$ = ecx

; 280  : 	{

	push	esi
	mov	esi, ecx
	push	edi

; 281  : 		Purge();

	mov	edi, DWORD PTR [esi+4]
	test	edi, edi
	je	SHORT $L41141
	mov	eax, DWORD PTR [esi]
	mov	ecx, edi
	sub	ecx, edi
	add	ecx, ecx
	lea	edx, DWORD PTR [eax+edi*2]
	push	ecx
	push	edx
	push	eax
	call	DWORD PTR __imp__memmove
	mov	eax, DWORD PTR [esi+4]
	add	esp, 12					; 0000000cH
	sub	eax, edi
	mov	DWORD PTR [esi+4], eax
$L41141:

; 282  : 	}

	cmp	DWORD PTR [esi], 0
	je	SHORT $L41147
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L41147:
	pop	edi
	pop	esi
	ret	0
??1?$TCorArray@G@@QAE@XZ ENDP				; TCorArray<unsigned short>::~TCorArray<unsigned short>
_TEXT	ENDS
PUBLIC	??4?$TCorArray@VCCpjLodLevel@@@@QAEAAV0@AAV0@@Z	; TCorArray<CCpjLodLevel>::operator=
PUBLIC	??4OCpjLodData@@QAEAAV0@AAV0@@Z			; OCpjLodData::operator=
; Function compile flags: /Ogty
;	COMDAT ??4OCpjLodData@@QAEAAV0@AAV0@@Z
_TEXT	SEGMENT
___that$ = 8
??4OCpjLodData@@QAEAAV0@AAV0@@Z PROC NEAR		; OCpjLodData::operator=, COMDAT
; _this$ = ecx
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR ___that$[esp+4]
	push	esi
	mov	esi, ecx
	push	edi
	mov	eax, DWORD PTR [ebp+4]
	lea	ecx, DWORD PTR [ebp+8]
	mov	DWORD PTR [esi+4], eax
	lea	edx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	lea	eax, DWORD PTR [esi+24]
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], ecx
	lea	edx, DWORD PTR [ebp+24]
	mov	ecx, DWORD PTR [ebp+24]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR [ebp+40]
	mov	DWORD PTR [esi+40], eax
	mov	ebx, DWORD PTR [ebp+44]
	test	ebx, ebx
	je	SHORT $L41222
	cmp	BYTE PTR [ebx], 0
	jne	SHORT $L41222
	xor	ebx, ebx
$L41222:
	mov	edi, DWORD PTR [esi+44]
	test	edi, edi
	je	SHORT $L41223
	or	ecx, -1
	xor	eax, eax
	repne scasb
	mov	eax, DWORD PTR ?sMemTotal@CCorString@@0KA ; CCorString::sMemTotal
	or	edx, -1
	not	ecx
	dec	ecx
	sub	edx, ecx
	add	eax, edx
	mov	DWORD PTR ?sMemTotal@CCorString@@0KA, eax ; CCorString::sMemTotal
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+44]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L41223:
	test	ebx, ebx
	mov	DWORD PTR [esi+44], 0
	je	SHORT $L41226
	mov	edi, ebx
	or	ecx, -1
	xor	eax, eax
	repne scasb
	not	ecx
	dec	ecx
	mov	edi, ecx
	inc	edi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	edi
	mov	ecx, eax
	call	DWORD PTR [edx]
	test	eax, eax
	mov	DWORD PTR [esi+44], eax
	je	SHORT $L41226
$L41220:
	mov	cl, BYTE PTR [ebx]
	inc	ebx
	mov	BYTE PTR [eax], cl
	inc	eax
	test	cl, cl
	jne	SHORT $L41220
	add	DWORD PTR ?sMemTotal@CCorString@@0KA, edi ; CCorString::sMemTotal
$L41226:
	mov	eax, DWORD PTR [ebp+48]
	add	ebp, 72					; 00000048H
	mov	DWORD PTR [esi+48], eax
	mov	ecx, DWORD PTR [ebp-20]
	mov	DWORD PTR [esi+52], ecx
	mov	dl, BYTE PTR [ebp-16]
	mov	BYTE PTR [esi+56], dl
	mov	eax, DWORD PTR [ebp-12]
	mov	DWORD PTR [esi+60], eax
	mov	ecx, DWORD PTR [ebp-8]
	mov	DWORD PTR [esi+64], ecx
	mov	edx, DWORD PTR [ebp-4]
	push	ebp
	lea	ecx, DWORD PTR [esi+72]
	mov	DWORD PTR [esi+68], edx
	call	??4?$TCorArray@VCCpjLodLevel@@@@QAEAAV0@AAV0@@Z ; TCorArray<CCpjLodLevel>::operator=
	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	4
??4OCpjLodData@@QAEAAV0@AAV0@@Z ENDP			; OCpjLodData::operator=
_TEXT	ENDS
PUBLIC	?AddNoConstruct@?$TCorArray@VCCpjLodTri@@@@QAEKK@Z ; TCorArray<CCpjLodTri>::AddNoConstruct
;	COMDAT xdata$x
xdata$x	SEGMENT
$T41419	DD	0ffffffffH
	DD	FLAT:$L41239
	DD	00H
	DD	FLAT:$L41274
	DD	00H
	DD	FLAT:$L41266
	DD	02H
	DD	FLAT:$L41325
$T41408	DD	019930520H
	DD	04H
	DD	FLAT:$T41419
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ??4?$TCorArray@VCCpjLodLevel@@@@QAEAAV0@AAV0@@Z
_TEXT	SEGMENT
_inArray$ = 8
$T41235 = -20
$T41236 = -24
_this$ = -28
_i$ = -32
$T41317 = -16
$T41360 = -16
_i$41365 = -40
__$EHRec$ = -12
??4?$TCorArray@VCCpjLodLevel@@@@QAEAAV0@AAV0@@Z PROC NEAR ; TCorArray<CCpjLodLevel>::operator=, COMDAT
; _this$ = ecx

; 269  : 	{

	push	-1
	push	$L41417
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 28					; 0000001cH
	push	ebx
	push	edi

; 270  : 		if (this == &inArray)

	mov	edi, DWORD PTR _inArray$[esp+44]
	mov	ebx, ecx
	cmp	ebx, edi
	mov	DWORD PTR _this$[esp+48], ebx

; 271  : 			return(*this);

	je	$L41418
	push	esi

; 272  : 		m_Count = 0;

	xor	esi, esi
	mov	DWORD PTR [ebx+4], esi

; 273  : 		m_Limit = inArray.m_Count;

	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [ebx+8], eax

; 274  : 		Realloc(sizeof(T));

	mov	eax, DWORD PTR [ebx]
	cmp	eax, esi
	mov	eax, DWORD PTR [ebx+8]
	mov	DWORD PTR [ebx+12], 36			; 00000024H
	je	$L41243
	cmp	eax, esi
	je	SHORT $L41245
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [ebx+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [ebx+8]
	push	ecx
	mov	ecx, DWORD PTR [ebx]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+4]
	mov	DWORD PTR [ebx], eax
	jmp	SHORT $L41250
$L41245:
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [ebx]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L41249:
	mov	DWORD PTR [ebx], esi
$L41250:

; 275  : 		for (NDword i=0;i<inArray.m_Count;i++)

	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR _i$[esp+52], esi
	cmp	eax, esi
	jbe	$L13838
	push	ebp
	mov	DWORD PTR -36+[esp+56], esi
$L13836:

; 276  : 			new(&(*this)[AddNoConstruct()]) T(inArray[i]);

	mov	esi, DWORD PTR [ebx+4]
	mov	ecx, DWORD PTR [ebx+8]
	lea	eax, DWORD PTR [esi+1]
	cmp	eax, ecx
	mov	DWORD PTR [ebx+4], eax
	jbe	SHORT $L41255
	mov	edx, eax
	push	36					; 00000024H
	shr	edx, 2
	mov	ecx, ebx
	lea	eax, DWORD PTR [edx+eax+32]
	mov	DWORD PTR [ebx+8], eax
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
$L41255:
	mov	edx, DWORD PTR [ebx]
	lea	ecx, DWORD PTR [esi+esi*8]
	lea	ebp, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR $T41236[esp+56], ebp
	mov	DWORD PTR $T41235[esp+56], ebp
	test	ebp, ebp
	mov	DWORD PTR __$EHRec$[esp+64], 0
	je	$L41391
	mov	edi, DWORD PTR [edi]
	mov	edx, DWORD PTR -36+[esp+56]
	add	edi, edx
	lea	esi, DWORD PTR [ebp+4]
	push	2
	mov	ecx, esi
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR $T41317[esp+60], esi
	mov	DWORD PTR [ebp], eax
	mov	eax, DWORD PTR [edi+8]
	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], 2
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
	xor	ecx, ecx
	mov	BYTE PTR __$EHRec$[esp+64], 1
	mov	DWORD PTR [esi+4], ecx
	mov	eax, DWORD PTR [edi+8]
	cmp	eax, ecx
	mov	DWORD PTR _i$41365[esp+56], ecx
	jbe	SHORT $L41368
$L41366:
	mov	ebx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi+8]
	lea	eax, DWORD PTR [ebx+1]
	cmp	eax, edx
	mov	DWORD PTR [esi+4], eax
	jbe	SHORT $L41379
	mov	ecx, eax
	push	2
	shr	ecx, 2
	lea	edx, DWORD PTR [ecx+eax+32]
	mov	ecx, esi
	mov	DWORD PTR [esi+8], edx
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
	mov	ecx, DWORD PTR _i$41365[esp+56]
$L41379:
	mov	eax, DWORD PTR [esi]
	lea	eax, DWORD PTR [eax+ebx*2]
	test	eax, eax
	je	SHORT $L41373
	mov	edx, DWORD PTR [edi+4]
	mov	dx, WORD PTR [edx+ecx*2]
	mov	WORD PTR [eax], dx
$L41373:
	mov	eax, DWORD PTR [edi+8]
	inc	ecx
	cmp	ecx, eax
	mov	DWORD PTR _i$41365[esp+56], ecx
	jb	SHORT $L41366
	mov	ebx, DWORD PTR _this$[esp+56]
$L41368:
	mov	eax, DWORD PTR [edi+24]
	lea	esi, DWORD PTR [ebp+20]
	push	16					; 00000010H
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+68], 2
	mov	DWORD PTR $T41360[esp+60], esi
	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], 16			; 00000010H
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
	xor	ebp, ebp
	mov	BYTE PTR __$EHRec$[esp+64], 3
	mov	DWORD PTR [esi+4], ebp
	mov	eax, DWORD PTR [edi+24]
	cmp	eax, ebp
	jbe	SHORT $L41415
	mov	DWORD PTR -40+[esp+56], ebp
$L41389:
	push	1
	mov	ecx, esi
	call	?AddNoConstruct@?$TCorArray@VCCpjLodTri@@@@QAEKK@Z ; TCorArray<CCpjLodTri>::AddNoConstruct
	mov	ecx, DWORD PTR [esi]
	shl	eax, 4
	add	eax, ecx
	je	SHORT $L41396
	mov	ecx, DWORD PTR [edi+20]
	mov	edx, DWORD PTR -40+[esp+56]
	add	ecx, edx
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], ecx
$L41396:
	mov	ecx, DWORD PTR -40+[esp+56]
	mov	eax, DWORD PTR [edi+24]
	inc	ebp
	add	ecx, 16					; 00000010H
	cmp	ebp, eax
	mov	DWORD PTR -40+[esp+56], ecx
	jb	SHORT $L41389
$L41415:
	mov	edi, DWORD PTR _inArray$[esp+52]
$L41391:
	mov	eax, DWORD PTR _i$[esp+56]
	mov	edx, DWORD PTR -36+[esp+56]
	mov	ecx, DWORD PTR [edi+4]
	inc	eax
	add	edx, 36					; 00000024H
	cmp	eax, ecx
	mov	DWORD PTR __$EHRec$[esp+64], -1
	mov	DWORD PTR _i$[esp+56], eax
	mov	DWORD PTR -36+[esp+56], edx
	jb	$L13836
	pop	ebp
$L13838:
	pop	esi
$L41418:

; 277  : 		return(*this);
; 278  : 	}

	mov	ecx, DWORD PTR __$EHRec$[esp+48]
	mov	eax, ebx
	pop	edi
	pop	ebx
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 40					; 00000028H
	ret	4

; 274  : 		Realloc(sizeof(T));

$L41243:
	cmp	eax, esi
	je	$L41249
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [ebx+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [ebx+8]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	DWORD PTR [ebx], eax
	jmp	$L41250
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L41239:
	mov	eax, DWORD PTR $T41236[ebp]
	push	eax
	mov	ecx, DWORD PTR $T41235[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
$L41274:
	mov	ecx, DWORD PTR $T41317[ebp]
	jmp	??1CCorArray@@IAE@XZ			; CCorArray::~CCorArray
$L41266:
	mov	ecx, DWORD PTR $T41235[ebp]
	add	ecx, 4
	jmp	??1?$TCorArray@G@@QAE@XZ		; TCorArray<unsigned short>::~TCorArray<unsigned short>
$L41325:
	mov	ecx, DWORD PTR $T41360[ebp]
	jmp	??1CCorArray@@IAE@XZ			; CCorArray::~CCorArray
$L41417:
	mov	eax, OFFSET FLAT:$T41408
	jmp	___CxxFrameHandler
text$x	ENDS
??4?$TCorArray@VCCpjLodLevel@@@@QAEAAV0@AAV0@@Z ENDP	; TCorArray<CCpjLodLevel>::operator=
PUBLIC	??1?$TCorArray@VCCpjLodTri@@@@QAE@XZ		; TCorArray<CCpjLodTri>::~TCorArray<CCpjLodTri>
PUBLIC	??1OCpjLodData@@UAE@XZ				; OCpjLodData::~OCpjLodData
;	COMDAT xdata$x
xdata$x	SEGMENT
$T41515	DD	0ffffffffH
	DD	FLAT:$L41425
	DD	00H
	DD	FLAT:$L41428
	DD	01H
	DD	FLAT:$L41436
$T41511	DD	019930520H
	DD	03H
	DD	FLAT:$T41515
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ??1OCpjLodData@@UAE@XZ
_TEXT	SEGMENT
_this$ = -28
$T41445 = -16
$T41459 = -24
$T41499 = -20
__$EHRec$ = -12
??1OCpjLodData@@UAE@XZ PROC NEAR			; OCpjLodData::~OCpjLodData, COMDAT
; _this$ = ecx
	push	-1
	push	$L41514
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 16					; 00000010H
	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+44], esi
	xor	edi, edi
	lea	ebp, DWORD PTR [esi+72]
	mov	DWORD PTR __$EHRec$[esp+52], edi
	mov	DWORD PTR $T41499[esp+44], ebp
	mov	ebx, DWORD PTR [ebp+4]
	cmp	ebx, edi
	mov	DWORD PTR $T41459[esp+44], ebx
	jbe	SHORT $L41487
$L41485:
	mov	esi, DWORD PTR [ebp]
	add	esi, edi
	mov	DWORD PTR $T41445[esp+44], esi
	lea	ecx, DWORD PTR [esi+20]
	mov	BYTE PTR __$EHRec$[esp+52], 2
	call	??1?$TCorArray@VCCpjLodTri@@@@QAE@XZ	; TCorArray<CCpjLodTri>::~TCorArray<CCpjLodTri>
	lea	ecx, DWORD PTR [esi+4]
	mov	BYTE PTR __$EHRec$[esp+52], 1
	call	??1?$TCorArray@G@@QAE@XZ		; TCorArray<unsigned short>::~TCorArray<unsigned short>
	add	edi, 36					; 00000024H
	dec	ebx
	jne	SHORT $L41485
	mov	esi, DWORD PTR _this$[esp+44]
	mov	ebx, DWORD PTR $T41459[esp+44]
$L41487:
	push	36					; 00000024H
	push	ebx
	push	0
	mov	ecx, ebp
	call	?Remove@CCorArray@@QAEXKKK@Z		; CCorArray::Remove
	mov	eax, DWORD PTR [ebp]
	mov	BYTE PTR __$EHRec$[esp+52], 0
	test	eax, eax
	je	SHORT $L41498
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [ebp]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L41498:
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+52], -1
	call	??1OObject@@UAE@XZ			; OObject::~OObject
	mov	ecx, DWORD PTR __$EHRec$[esp+44]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 28					; 0000001cH
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L41425:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1OCpjChunk@@UAE@XZ			; OCpjChunk::~OCpjChunk
$L41428:
	mov	ecx, DWORD PTR $T41499[ebp]
	jmp	??1CCorArray@@IAE@XZ			; CCorArray::~CCorArray
$L41436:
	mov	ecx, DWORD PTR $T41445[ebp]
	add	ecx, 4
	jmp	??1?$TCorArray@G@@QAE@XZ		; TCorArray<unsigned short>::~TCorArray<unsigned short>
$L41514:
	mov	eax, OFFSET FLAT:$T41511
	jmp	___CxxFrameHandler
text$x	ENDS
??1OCpjLodData@@UAE@XZ ENDP				; OCpjLodData::~OCpjLodData
; Function compile flags: /Ogty
;	COMDAT ??1?$TCorArray@VCCpjLodTri@@@@QAE@XZ
_TEXT	SEGMENT
??1?$TCorArray@VCCpjLodTri@@@@QAE@XZ PROC NEAR		; TCorArray<CCpjLodTri>::~TCorArray<CCpjLodTri>, COMDAT
; _this$ = ecx

; 280  : 	{

	push	esi
	mov	esi, ecx
	push	edi

; 281  : 		Purge();

	mov	edi, DWORD PTR [esi+4]
	test	edi, edi
	je	SHORT $L41547
	mov	eax, DWORD PTR [esi]
	mov	ecx, edi
	mov	edx, edi
	sub	ecx, edi
	shl	edx, 4
	shl	ecx, 4
	add	edx, eax
	push	ecx
	push	edx
	push	eax
	call	DWORD PTR __imp__memmove
	mov	eax, DWORD PTR [esi+4]
	add	esp, 12					; 0000000cH
	sub	eax, edi
	mov	DWORD PTR [esi+4], eax
$L41547:

; 282  : 	}

	cmp	DWORD PTR [esi], 0
	je	SHORT $L41551
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L41551:
	pop	edi
	pop	esi
	ret	0
??1?$TCorArray@VCCpjLodTri@@@@QAE@XZ ENDP		; TCorArray<CCpjLodTri>::~TCorArray<CCpjLodTri>
_TEXT	ENDS
PUBLIC	??_GOCpjLodData@@UAEPAXI@Z			; OCpjLodData::`scalar deleting destructor'
; Function compile flags: /Ogty
;	COMDAT ??_GOCpjLodData@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_GOCpjLodData@@UAEPAXI@Z PROC NEAR			; OCpjLodData::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1OCpjLodData@@UAE@XZ			; OCpjLodData::~OCpjLodData
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $L41570
	mov	DWORD PTR [esi+4], 0
	mov	edx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	dec	edx
	mov	DWORD PTR ?sObjCount@OObject@@1KA, edx	; OObject::sObjCount
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L41570:
	mov	eax, esi
	pop	esi
	ret	4
??_GOCpjLodData@@UAEPAXI@Z ENDP				; OCpjLodData::`scalar deleting destructor'
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??_EOCpjLodData@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_EOCpjLodData@@UAEPAXI@Z PROC NEAR			; OCpjLodData::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebx
	mov	bl, BYTE PTR ___flags$[esp]
	push	esi
	mov	esi, ecx
	test	bl, 2
	je	SHORT $L8661
	mov	eax, DWORD PTR [esi-4]
	push	edi
	lea	edi, DWORD PTR [esi-4]
	push	OFFSET FLAT:??1OCpjLodData@@UAE@XZ	; OCpjLodData::~OCpjLodData
	push	eax
	push	88					; 00000058H
	push	esi
	call	??_M@YGXPAXIHP6EX0@Z@Z			; `eh vector destructor iterator'
	test	bl, 1
	je	SHORT $L8662
	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L8662:
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	ret	4
$L8661:
	mov	ecx, esi
	call	??1OCpjLodData@@UAE@XZ			; OCpjLodData::~OCpjLodData
	test	bl, 1
	je	SHORT $L41580
	mov	DWORD PTR [esi+4], 0
	mov	edx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	dec	edx
	mov	DWORD PTR ?sObjCount@OObject@@1KA, edx	; OObject::sObjCount
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L41580:
	mov	eax, esi
	pop	esi
	pop	ebx
	ret	4
??_EOCpjLodData@@UAEPAXI@Z ENDP				; OCpjLodData::`vector deleting destructor'
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?Add@?$TCorArray@VCMacBone@@@@QAEKK@Z
_TEXT	SEGMENT
_inCount$ = 8
?Add@?$TCorArray@VCMacBone@@@@QAEKK@Z PROC NEAR		; TCorArray<CMacBone>::Add, COMDAT
; _this$ = ecx

; 332  : 		NDword index = AddNoConstruct(inCount);

	mov	eax, DWORD PTR _inCount$[esp-4]
	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx
	push	edi
	xor	ebx, ebx
	mov	ebp, DWORD PTR [esi+4]
	lea	edi, DWORD PTR [eax+ebp]
	mov	eax, DWORD PTR [esi+8]
	cmp	edi, eax
	mov	DWORD PTR [esi+4], edi
	jbe	SHORT $L41619
	mov	ecx, edi
	mov	DWORD PTR [esi+12], 140			; 0000008cH
	shr	ecx, 2
	lea	eax, DWORD PTR [ecx+edi+32]
	mov	ecx, DWORD PTR [esi]
	cmp	ecx, ebx
	mov	DWORD PTR [esi+8], eax
	je	$L41612
	cmp	eax, ebx
	je	SHORT $L41614
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [esi+8]
	push	ecx
	mov	ecx, DWORD PTR [esi]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+4]
	mov	DWORD PTR [esi], eax
	jmp	SHORT $L41619
$L41614:
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L41618:
	mov	DWORD PTR [esi], ebx
$L41619:

; 333  : 		for (NDword i=index; i<index+inCount; i++)

	cmp	ebp, edi
	jae	$L41747
	lea	eax, DWORD PTR [ebp*8]
	mov	ecx, 1065353216				; 3f800000H
	sub	eax, ebp
	lea	edx, DWORD PTR [eax+eax*4]
	shl	edx, 2
	sub	edi, ebp
$L14528:

; 334  : 			new(&(*this)[i]) T;

	mov	eax, DWORD PTR [esi]
	add	eax, edx
	je	SHORT $L41592
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	DWORD PTR [eax+16], ecx
	mov	DWORD PTR [eax+20], ebx
	mov	DWORD PTR [eax+24], ebx
	mov	DWORD PTR [eax+28], ebx
	mov	DWORD PTR [eax+32], ecx
	mov	DWORD PTR [eax+36], ebx
	mov	DWORD PTR [eax+40], ebx
	mov	DWORD PTR [eax+44], ebx
	mov	DWORD PTR [eax+48], ecx
	mov	DWORD PTR [eax+52], ecx
	mov	DWORD PTR [eax+56], ecx
	mov	DWORD PTR [eax+60], ecx
	mov	DWORD PTR [eax+64], ebx
	mov	DWORD PTR [eax+68], ebx
	mov	DWORD PTR [eax+72], ebx
	mov	DWORD PTR [eax+76], ecx
	mov	DWORD PTR [eax+80], ebx
	mov	DWORD PTR [eax+84], ebx
	mov	DWORD PTR [eax+88], ebx
	mov	DWORD PTR [eax+92], ecx
	mov	DWORD PTR [eax+96], ebx
	mov	DWORD PTR [eax+100], ebx
	mov	DWORD PTR [eax+104], ebx
	mov	DWORD PTR [eax+108], ecx
	mov	DWORD PTR [eax+112], ecx
	mov	DWORD PTR [eax+116], ecx
	mov	DWORD PTR [eax+124], ebx
	mov	DWORD PTR [eax+136], ebx
	mov	DWORD PTR [eax+132], ebx
	mov	DWORD PTR [eax+128], ebx
	mov	BYTE PTR [eax+120], bl
$L41592:
	add	edx, 140				; 0000008cH
	dec	edi
	jne	SHORT $L14528
$L41747:
	pop	edi

; 335  : 		return(index);

	mov	eax, ebp
	pop	esi
	pop	ebp
	pop	ebx

; 336  : 	}

	ret	4
$L41612:

; 332  : 		NDword index = AddNoConstruct(inCount);

	cmp	eax, ebx
	je	$L41618
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [esi+8]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	DWORD PTR [esi], eax
	jmp	$L41619
?Add@?$TCorArray@VCMacBone@@@@QAEKK@Z ENDP		; TCorArray<CMacBone>::Add
_TEXT	ENDS
PUBLIC	??2OCpjSkeleton@@CAPAXIPAVOObject@@PAVCObjClass@@@Z ; OCpjSkeleton::operator new
; Function compile flags: /Ogty
; File C:\duke4\Cannibal\CpjSkl.h
;	COMDAT ??2OCpjSkeleton@@CAPAXIPAVOObject@@PAVCObjClass@@@Z
_TEXT	SEGMENT
_inParent$ = 12
_inSetClass$ = 16
??2OCpjSkeleton@@CAPAXIPAVOObject@@PAVCObjClass@@@Z PROC NEAR ; OCpjSkeleton::operator new, COMDAT

; 62   : 	OBJ_CLASS_DEFINE(OCpjSkeleton, OCpjChunk);

	push	esi
	push	edi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	120					; 00000078H
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	ecx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	mov	esi, eax
	inc	ecx
	xor	eax, eax
	mov	DWORD PTR ?sObjCount@OObject@@1KA, ecx	; OObject::sObjCount
	mov	ecx, 30					; 0000001eH
	mov	edi, esi
	rep stosd
	mov	eax, DWORD PTR [esi+40]
	mov	DWORD PTR [esi+4], 305419896		; 12345678H
	test	eax, eax
	jne	SHORT $L41758
	mov	eax, DWORD PTR _inSetClass$[esp+4]
	mov	DWORD PTR [esi+40], eax
$L41758:
	mov	ecx, DWORD PTR _inParent$[esp+4]
	push	ecx
	mov	ecx, esi
	call	?PreConstruct@OObject@@QAEXPAV1@@Z	; OObject::PreConstruct
	mov	eax, esi
	pop	edi
	pop	esi
	ret	0
??2OCpjSkeleton@@CAPAXIPAVOObject@@PAVCObjClass@@@Z ENDP ; OCpjSkeleton::operator new
_TEXT	ENDS
PUBLIC	??3OCpjSkeleton@@CAXPAX@Z			; OCpjSkeleton::operator delete
; Function compile flags: /Ogty
;	COMDAT ??3OCpjSkeleton@@CAXPAX@Z
_TEXT	SEGMENT
_ptr$ = 8
??3OCpjSkeleton@@CAXPAX@Z PROC NEAR			; OCpjSkeleton::operator delete, COMDAT

; 62   : 	OBJ_CLASS_DEFINE(OCpjSkeleton, OCpjChunk);

	push	esi
	mov	esi, DWORD PTR _ptr$[esp]
	mov	DWORD PTR [esi+4], 0
	mov	edx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	dec	edx
	mov	DWORD PTR ?sObjCount@OObject@@1KA, edx	; OObject::sObjCount
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	ecx, eax
	call	DWORD PTR [edx+8]
	pop	esi
	ret	0
??3OCpjSkeleton@@CAXPAX@Z ENDP				; OCpjSkeleton::operator delete
_TEXT	ENDS
PUBLIC	??3OCpjSkeleton@@CAXPAXPAVOObject@@PAVCObjClass@@@Z ; OCpjSkeleton::operator delete
; Function compile flags: /Ogty
;	COMDAT ??3OCpjSkeleton@@CAXPAXPAVOObject@@PAVCObjClass@@@Z
_TEXT	SEGMENT
_ptr$ = 8
??3OCpjSkeleton@@CAXPAXPAVOObject@@PAVCObjClass@@@Z PROC NEAR ; OCpjSkeleton::operator delete, COMDAT

; 62   : 	OBJ_CLASS_DEFINE(OCpjSkeleton, OCpjChunk);

	push	esi
	mov	esi, DWORD PTR _ptr$[esp]
	mov	DWORD PTR [esi+4], 0
	mov	edx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	dec	edx
	mov	DWORD PTR ?sObjCount@OObject@@1KA, edx	; OObject::sObjCount
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	ecx, eax
	call	DWORD PTR [edx+8]
	pop	esi
	ret	0
??3OCpjSkeleton@@CAXPAXPAVOObject@@PAVCObjClass@@@Z ENDP ; OCpjSkeleton::operator delete
_TEXT	ENDS
PUBLIC	?GetStaticClass@OCpjSkeleton@@SAPAVCObjClass@@XZ ; OCpjSkeleton::GetStaticClass
; Function compile flags: /Ogty
;	COMDAT ?GetStaticClass@OCpjSkeleton@@SAPAVCObjClass@@XZ
_TEXT	SEGMENT
?GetStaticClass@OCpjSkeleton@@SAPAVCObjClass@@XZ PROC NEAR ; OCpjSkeleton::GetStaticClass, COMDAT

; 62   : 	OBJ_CLASS_DEFINE(OCpjSkeleton, OCpjChunk);

	mov	eax, DWORD PTR ?staticObjClass@OCpjSkeleton@@0PAVCObjClass@@A ; OCpjSkeleton::staticObjClass
	ret	0
?GetStaticClass@OCpjSkeleton@@SAPAVCObjClass@@XZ ENDP	; OCpjSkeleton::GetStaticClass
_TEXT	ENDS
PUBLIC	?New@OCpjSkeleton@@SAPAV1@PAVOObject@@PAVCObjClass@@@Z ; OCpjSkeleton::New
PUBLIC	?GetClass@OCpjSkeleton@@UAEPAVCObjClass@@XZ	; OCpjSkeleton::GetClass
PUBLIC	??1?$TCorArray@VCCpjSklBone@@@@QAE@XZ		; TCorArray<CCpjSklBone>::~TCorArray<CCpjSklBone>
PUBLIC	??1?$TCorArray@VCCpjSklVert@@@@QAE@XZ		; TCorArray<CCpjSklVert>::~TCorArray<CCpjSklVert>
PUBLIC	?GetFileExtension@OCpjSkeleton@@UAEPADXZ	; OCpjSkeleton::GetFileExtension
PUBLIC	?GetFileDescription@OCpjSkeleton@@UAEPADXZ	; OCpjSkeleton::GetFileDescription
PUBLIC	??_7OCpjSkeleton@@6B@				; OCpjSkeleton::`vftable'
PUBLIC	??_EOCpjSkeleton@@UAEPAXI@Z			; OCpjSkeleton::`vector deleting destructor'
EXTRN	?LoadChunk@OCpjSkeleton@@UAE_NPAXK@Z:NEAR	; OCpjSkeleton::LoadChunk
EXTRN	?SaveChunk@OCpjSkeleton@@UAE_NPAXPAK@Z:NEAR	; OCpjSkeleton::SaveChunk
EXTRN	?GetFourCC@OCpjSkeleton@@UAEKXZ:NEAR		; OCpjSkeleton::GetFourCC
;	COMDAT xdata$x
; File C:\duke4\Cannibal\CorMain.h
xdata$x	SEGMENT
$T41917	DD	0ffffffffH
	DD	FLAT:$L41786
	DD	00H
	DD	FLAT:$L41811
	DD	01H
	DD	FLAT:$L41812
	DD	02H
	DD	FLAT:$L41813
$T41915	DD	019930520H
	DD	04H
	DD	FLAT:$T41917
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_7OCpjSkeleton@@6B@
CONST	SEGMENT
??_7OCpjSkeleton@@6B@ DD FLAT:?Msg@OObject@@UAE_NPAVIMsg@@@Z ; OCpjSkeleton::`vftable'
	DD	FLAT:?MsgGetChild@OObject@@UAEPAVIMsgTarget@@PAD@Z
	DD	FLAT:?MsgGetParent@OObject@@UAEPAVIMsgTarget@@XZ
	DD	FLAT:?MsgGetRoot@OObject@@UAEPAVIMsgTarget@@XZ
	DD	FLAT:?GetClass@OCpjSkeleton@@UAEPAVCObjClass@@XZ
	DD	FLAT:??_EOCpjSkeleton@@UAEPAXI@Z
	DD	FLAT:?Create@OCpjChunk@@UAEXXZ
	DD	FLAT:?Destroy@OObject@@UAEXXZ
	DD	FLAT:?GetParent@OObject@@UAEPAV1@XZ
	DD	FLAT:?SetParent@OObject@@UAEXPAV1@_N@Z
	DD	FLAT:?HasChildren@OObject@@UAE_NXZ
	DD	FLAT:?IsA@OObject@@UAE_NPAVCObjClass@@@Z
	DD	FLAT:?GetFileExtension@OCpjSkeleton@@UAEPADXZ
	DD	FLAT:?GetFileDescription@OCpjSkeleton@@UAEPADXZ
	DD	FLAT:?LoadFile@OCpjChunk@@UAE_NPAD@Z
	DD	FLAT:?SaveFile@OCpjChunk@@UAE_NPAD@Z
	DD	FLAT:?GetFourCC@OCpjSkeleton@@UAEKXZ
	DD	FLAT:?LoadChunk@OCpjSkeleton@@UAE_NPAXK@Z
	DD	FLAT:?SaveChunk@OCpjSkeleton@@UAE_NPAXPAK@Z
; Function compile flags: /Ogty
; File C:\duke4\Cannibal\CpjSkl.h
CONST	ENDS
;	COMDAT ?New@OCpjSkeleton@@SAPAV1@PAVOObject@@PAVCObjClass@@@Z
_TEXT	SEGMENT
$T41783 = -16
__$EHRec$ = -12
_inParent$ = 8
_inSetClass$ = 12
?New@OCpjSkeleton@@SAPAV1@PAVOObject@@PAVCObjClass@@@Z PROC NEAR ; OCpjSkeleton::New, COMDAT

; 62   : 	OBJ_CLASS_DEFINE(OCpjSkeleton, OCpjChunk);

	push	-1
	push	$L41916
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _inSetClass$[esp+20]
	xor	ebx, ebx
	cmp	ebp, ebx
	push	esi
	jne	SHORT $L8973
	mov	ebp, DWORD PTR ?staticObjClass@OCpjSkeleton@@0PAVCObjClass@@A ; OCpjSkeleton::staticObjClass
	mov	DWORD PTR _inSetClass$[esp+24], ebp
$L8973:
	push	edi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	120					; 00000078H
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	ecx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	mov	esi, eax
	inc	ecx
	xor	eax, eax
	mov	DWORD PTR ?sObjCount@OObject@@1KA, ecx	; OObject::sObjCount
	mov	ecx, 30					; 0000001eH
	mov	edi, esi
	rep stosd
	mov	eax, DWORD PTR [esi+40]
	mov	DWORD PTR [esi+4], 305419896		; 12345678H
	cmp	eax, ebx
	pop	edi
	jne	SHORT $L41806
	mov	DWORD PTR [esi+40], ebp
$L41806:
	mov	eax, DWORD PTR _inParent$[esp+24]
	mov	ecx, esi
	push	eax
	call	?PreConstruct@OObject@@QAEXPAV1@@Z	; OObject::PreConstruct
	mov	DWORD PTR $T41783[esp+28], esi
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+36], ebx
	call	??0OObject@@QAE@XZ			; OObject::OObject
	mov	DWORD PTR [esi], OFFSET FLAT:??_7OCpjChunk@@6B@ ; OCpjChunk::`vftable'
	lea	ecx, DWORD PTR [esi+72]
	push	76					; 0000004cH
	mov	BYTE PTR __$EHRec$[esp+40], 1
	mov	DWORD PTR [ecx], ebx
	mov	DWORD PTR [ecx+4], ebx
	mov	DWORD PTR [ecx+8], ebx
	mov	DWORD PTR [ecx+12], 76			; 0000004cH
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
	lea	ecx, DWORD PTR [esi+88]
	push	16					; 00000010H
	mov	BYTE PTR __$EHRec$[esp+40], 2
	mov	DWORD PTR [ecx], ebx
	mov	DWORD PTR [ecx+4], ebx
	mov	DWORD PTR [ecx+8], ebx
	mov	DWORD PTR [ecx+12], 16			; 00000010H
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
	mov	DWORD PTR [esi+108], ebx
	mov	DWORD PTR [esi+112], ebx
	mov	DWORD PTR [esi+116], 68			; 00000044H
	mov	DWORD PTR [esi+104], ebx
	mov	DWORD PTR [esi], OFFSET FLAT:??_7OCpjSkeleton@@6B@ ; OCpjSkeleton::`vftable'
	mov	edx, DWORD PTR [esi]
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+36], -1
	call	DWORD PTR [edx+24]
	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L41786:
	mov	eax, DWORD PTR _inSetClass$[ebp-4]
	push	eax
	mov	ecx, DWORD PTR _inParent$[ebp-4]
	push	ecx
	mov	edx, DWORD PTR $T41783[ebp]
	push	edx
	call	??3OCpjSkeleton@@CAXPAXPAVOObject@@PAVCObjClass@@@Z ; OCpjSkeleton::operator delete
	add	esp, 12					; 0000000cH
	ret	0
$L41811:
	mov	ecx, DWORD PTR $T41783[ebp]
	jmp	??1OCpjChunk@@UAE@XZ			; OCpjChunk::~OCpjChunk
$L41812:
	mov	ecx, DWORD PTR $T41783[ebp]
	add	ecx, 72					; 00000048H
	jmp	??1?$TCorArray@VCCpjSklBone@@@@QAE@XZ	; TCorArray<CCpjSklBone>::~TCorArray<CCpjSklBone>
$L41813:
	mov	ecx, DWORD PTR $T41783[ebp]
	add	ecx, 88					; 00000058H
	jmp	??1?$TCorArray@VCCpjSklVert@@@@QAE@XZ	; TCorArray<CCpjSklVert>::~TCorArray<CCpjSklVert>
$L41916:
	mov	eax, OFFSET FLAT:$T41915
	jmp	___CxxFrameHandler
text$x	ENDS
?New@OCpjSkeleton@@SAPAV1@PAVOObject@@PAVCObjClass@@@Z ENDP ; OCpjSkeleton::New
;	COMDAT xdata$x
; File C:\duke4\Cannibal\CorMain.h
xdata$x	SEGMENT
$T42051	DD	0ffffffffH
	DD	FLAT:$L41923
$T42046	DD	019930520H
	DD	01H
	DD	FLAT:$T42051
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ??1?$TCorArray@VCCpjSklBone@@@@QAE@XZ
_TEXT	SEGMENT
$T42012 = -20
__$EHRec$ = -12
_this$ = -16
??1?$TCorArray@VCCpjSklBone@@@@QAE@XZ PROC NEAR		; TCorArray<CCpjSklBone>::~TCorArray<CCpjSklBone>, COMDAT
; _this$ = ecx

; 280  : 	{

	push	-1
	push	$L42050
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	ebp
	mov	ebx, ecx
	push	esi
	push	edi
	mov	DWORD PTR _this$[esp+40], ebx

; 281  : 		Purge();

	mov	esi, DWORD PTR [ebx+4]
	xor	ebp, ebp
	cmp	esi, ebp
	mov	DWORD PTR __$EHRec$[esp+48], ebp
	mov	DWORD PTR $T42012[esp+40], esi
	jbe	SHORT $L42018

; 280  : 	{

	mov	DWORD PTR -24+[esp+40], esi

; 281  : 		Purge();

$L42016:
	mov	esi, DWORD PTR [ebx]
	add	esi, ebp
	mov	edi, DWORD PTR [esi]
	test	edi, edi
	je	SHORT $L42032
	or	ecx, -1
	xor	eax, eax
	repne scasb
	not	ecx
	dec	ecx
	or	eax, -1
	sub	eax, ecx
	mov	ecx, DWORD PTR ?sMemTotal@CCorString@@0KA ; CCorString::sMemTotal
	add	ecx, eax
	mov	DWORD PTR ?sMemTotal@CCorString@@0KA, ecx ; CCorString::sMemTotal
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L42032:
	mov	eax, DWORD PTR -24+[esp+40]
	add	ebp, 76					; 0000004cH
	dec	eax
	mov	DWORD PTR [esi], 0
	mov	DWORD PTR -24+[esp+40], eax
	jne	SHORT $L42016
	mov	esi, DWORD PTR $T42012[esp+40]
$L42018:
	test	esi, esi
	je	SHORT $L42038
	mov	ecx, DWORD PTR [ebx+4]
	lea	edx, DWORD PTR [esi+esi*8]
	lea	edi, DWORD PTR [ecx+ecx*8]
	lea	eax, DWORD PTR [esi+edx*2]
	mov	edx, DWORD PTR [ebx]
	lea	ecx, DWORD PTR [ecx+edi*2]
	shl	eax, 2
	shl	ecx, 2
	sub	ecx, eax
	add	eax, edx
	push	ecx
	push	eax
	push	edx
	call	DWORD PTR __imp__memmove
	mov	eax, DWORD PTR [ebx+4]
	add	esp, 12					; 0000000cH
	sub	eax, esi
	mov	DWORD PTR [ebx+4], eax
$L42038:

; 282  : 	}

	mov	eax, DWORD PTR [ebx]
	mov	DWORD PTR __$EHRec$[esp+48], -1
	test	eax, eax
	je	SHORT $L42044
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [ebx]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L42044:
	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 24					; 00000018H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L41923:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CCorArray@@IAE@XZ			; CCorArray::~CCorArray
$L42050:
	mov	eax, OFFSET FLAT:$T42046
	jmp	___CxxFrameHandler
text$x	ENDS
??1?$TCorArray@VCCpjSklBone@@@@QAE@XZ ENDP		; TCorArray<CCpjSklBone>::~TCorArray<CCpjSklBone>
PUBLIC	?Remove@?$TCorArray@VCCpjSklWeight@@@@QAEXKK@Z	; TCorArray<CCpjSklWeight>::Remove
;	COMDAT xdata$x
xdata$x	SEGMENT
$T42166	DD	0ffffffffH
	DD	FLAT:$L42057
	DD	00H
	DD	FLAT:$L42067
$T42162	DD	019930520H
	DD	02H
	DD	FLAT:$T42166
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ??1?$TCorArray@VCCpjSklVert@@@@QAE@XZ
_TEXT	SEGMENT
$T42103 = -16
__$EHRec$ = -12
_this$ = -20
??1?$TCorArray@VCCpjSklVert@@@@QAE@XZ PROC NEAR		; TCorArray<CCpjSklVert>::~TCorArray<CCpjSklVert>, COMDAT
; _this$ = ecx

; 280  : 	{

	push	-1
	push	$L42165
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	ebp
	push	edi
	mov	edi, ecx
	mov	DWORD PTR _this$[esp+36], edi

; 281  : 		Purge();

	mov	ebx, DWORD PTR [edi+4]
	xor	ebp, ebp
	cmp	ebx, ebp
	mov	DWORD PTR __$EHRec$[esp+44], ebp
	jbe	SHORT $L42137
	mov	DWORD PTR -24+[esp+36], ebx
	push	esi
$L42135:
	mov	esi, DWORD PTR [edi]
	add	esi, ebp
	mov	DWORD PTR $T42103[esp+40], esi
	mov	eax, DWORD PTR [esi+4]
	mov	ecx, esi
	push	eax
	push	0
	mov	BYTE PTR __$EHRec$[esp+56], 1
	call	?Remove@?$TCorArray@VCCpjSklWeight@@@@QAEXKK@Z ; TCorArray<CCpjSklWeight>::Remove
	mov	eax, DWORD PTR [esi]
	mov	BYTE PTR __$EHRec$[esp+48], 0
	test	eax, eax
	je	SHORT $L42151
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L42151:
	mov	eax, DWORD PTR -24+[esp+40]
	add	ebp, 16					; 00000010H
	dec	eax
	mov	DWORD PTR -24+[esp+40], eax
	jne	SHORT $L42135
	pop	esi
$L42137:
	test	ebx, ebx
	je	SHORT $L42154
	mov	edx, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [edi]
	mov	ecx, ebx
	sub	edx, ebx
	shl	ecx, 4
	shl	edx, 4
	add	ecx, eax
	push	edx
	push	ecx
	push	eax
	call	DWORD PTR __imp__memmove
	mov	eax, DWORD PTR [edi+4]
	add	esp, 12					; 0000000cH
	sub	eax, ebx
	mov	DWORD PTR [edi+4], eax
$L42154:

; 282  : 	}

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR __$EHRec$[esp+44], -1
	test	eax, eax
	je	SHORT $L42160
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L42160:
	mov	ecx, DWORD PTR __$EHRec$[esp+36]
	pop	edi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 24					; 00000018H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L42057:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CCorArray@@IAE@XZ			; CCorArray::~CCorArray
$L42067:
	mov	ecx, DWORD PTR $T42103[ebp]
	jmp	??1CCorArray@@IAE@XZ			; CCorArray::~CCorArray
$L42165:
	mov	eax, OFFSET FLAT:$T42162
	jmp	___CxxFrameHandler
text$x	ENDS
??1?$TCorArray@VCCpjSklVert@@@@QAE@XZ ENDP		; TCorArray<CCpjSklVert>::~TCorArray<CCpjSklVert>
; Function compile flags: /Ogty
; File C:\duke4\Cannibal\CpjSkl.h
;	COMDAT ?GetClass@OCpjSkeleton@@UAEPAVCObjClass@@XZ
_TEXT	SEGMENT
?GetClass@OCpjSkeleton@@UAEPAVCObjClass@@XZ PROC NEAR	; OCpjSkeleton::GetClass, COMDAT
; _this$ = ecx

; 62   : 	OBJ_CLASS_DEFINE(OCpjSkeleton, OCpjChunk);

	mov	eax, DWORD PTR [ecx+40]
	ret	0
?GetClass@OCpjSkeleton@@UAEPAVCObjClass@@XZ ENDP	; OCpjSkeleton::GetClass
_TEXT	ENDS
PUBLIC	??_C@_03OILG@skl?$AA@				; `string'
;	COMDAT ??_C@_03OILG@skl?$AA@
_DATA	SEGMENT
??_C@_03OILG@skl?$AA@ DB 'skl', 00H			; `string'
; Function compile flags: /Ogty
_DATA	ENDS
;	COMDAT ?GetFileExtension@OCpjSkeleton@@UAEPADXZ
_TEXT	SEGMENT
?GetFileExtension@OCpjSkeleton@@UAEPADXZ PROC NEAR	; OCpjSkeleton::GetFileExtension, COMDAT
; _this$ = ecx

; 74   : 	NChar* GetFileExtension() { return("skl"); }

	mov	eax, OFFSET FLAT:??_C@_03OILG@skl?$AA@	; `string'
	ret	0
?GetFileExtension@OCpjSkeleton@@UAEPADXZ ENDP		; OCpjSkeleton::GetFileExtension
_TEXT	ENDS
PUBLIC	??_C@_0BC@MLFJ@Cannibal?5Skeleton?$AA@		; `string'
;	COMDAT ??_C@_0BC@MLFJ@Cannibal?5Skeleton?$AA@
_DATA	SEGMENT
??_C@_0BC@MLFJ@Cannibal?5Skeleton?$AA@ DB 'Cannibal Skeleton', 00H ; `string'
; Function compile flags: /Ogty
_DATA	ENDS
;	COMDAT ?GetFileDescription@OCpjSkeleton@@UAEPADXZ
_TEXT	SEGMENT
?GetFileDescription@OCpjSkeleton@@UAEPADXZ PROC NEAR	; OCpjSkeleton::GetFileDescription, COMDAT
; _this$ = ecx

; 75   : 	NChar* GetFileDescription() { return("Cannibal Skeleton"); }

	mov	eax, OFFSET FLAT:??_C@_0BC@MLFJ@Cannibal?5Skeleton?$AA@ ; `string'
	ret	0
?GetFileDescription@OCpjSkeleton@@UAEPADXZ ENDP		; OCpjSkeleton::GetFileDescription
_TEXT	ENDS
PUBLIC	??0OCpjSkeleton@@QAE@XZ				; OCpjSkeleton::OCpjSkeleton
;	COMDAT xdata$x
xdata$x	SEGMENT
$T42290	DD	0ffffffffH
	DD	FLAT:$L42181
	DD	00H
	DD	FLAT:$L42182
	DD	01H
	DD	FLAT:$L42183
$T42288	DD	019930520H
	DD	03H
	DD	FLAT:$T42290
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ??0OCpjSkeleton@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12
_this$ = -16
??0OCpjSkeleton@@QAE@XZ PROC NEAR			; OCpjSkeleton::OCpjSkeleton, COMDAT
; _this$ = ecx
	push	-1
	push	$L42289
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	push	esi
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+24], esi
	call	??0OObject@@QAE@XZ			; OObject::OObject
	mov	DWORD PTR [esi], OFFSET FLAT:??_7OCpjChunk@@6B@ ; OCpjChunk::`vftable'
	xor	edi, edi
	mov	DWORD PTR [esi+84], 76			; 0000004cH
	mov	DWORD PTR __$EHRec$[esp+32], edi
	mov	DWORD PTR [esi+76], edi
	mov	DWORD PTR [esi+80], edi
	mov	DWORD PTR [esi+72], edi
	lea	ecx, DWORD PTR [esi+88]
	push	16					; 00000010H
	mov	BYTE PTR __$EHRec$[esp+36], 1
	mov	DWORD PTR [ecx], edi
	mov	DWORD PTR [ecx+4], edi
	mov	DWORD PTR [ecx+8], edi
	mov	DWORD PTR [ecx+12], 16			; 00000010H
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR [esi+108], edi
	mov	DWORD PTR [esi+112], edi
	mov	DWORD PTR [esi+116], 68			; 00000044H
	mov	DWORD PTR [esi+104], edi
	mov	DWORD PTR [esi], OFFSET FLAT:??_7OCpjSkeleton@@6B@ ; OCpjSkeleton::`vftable'
	mov	eax, esi
	pop	edi
	pop	esi
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L42181:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1OCpjChunk@@UAE@XZ			; OCpjChunk::~OCpjChunk
$L42182:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 72					; 00000048H
	jmp	??1?$TCorArray@VCCpjSklBone@@@@QAE@XZ	; TCorArray<CCpjSklBone>::~TCorArray<CCpjSklBone>
$L42183:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 88					; 00000058H
	jmp	??1?$TCorArray@VCCpjSklVert@@@@QAE@XZ	; TCorArray<CCpjSklVert>::~TCorArray<CCpjSklVert>
$L42289:
	mov	eax, OFFSET FLAT:$T42288
	jmp	___CxxFrameHandler
text$x	ENDS
??0OCpjSkeleton@@QAE@XZ ENDP				; OCpjSkeleton::OCpjSkeleton
; Function compile flags: /Ogty
; File C:\duke4\Cannibal\CorMain.h
;	COMDAT ??1?$TCorArray@PAVOMacChannel@@@@QAE@XZ
_TEXT	SEGMENT
??1?$TCorArray@PAVOMacChannel@@@@QAE@XZ PROC NEAR	; TCorArray<OMacChannel *>::~TCorArray<OMacChannel *>, COMDAT
; _this$ = ecx

; 280  : 	{

	push	esi
	mov	esi, ecx
	push	edi

; 281  : 		Purge();

	mov	edi, DWORD PTR [esi+4]
	test	edi, edi
	je	SHORT $L42317
	mov	eax, DWORD PTR [esi]
	mov	ecx, edi
	sub	ecx, edi
	shl	ecx, 2
	lea	edx, DWORD PTR [eax+edi*4]
	push	ecx
	push	edx
	push	eax
	call	DWORD PTR __imp__memmove
	mov	eax, DWORD PTR [esi+4]
	add	esp, 12					; 0000000cH
	sub	eax, edi
	mov	DWORD PTR [esi+4], eax
$L42317:

; 282  : 	}

	cmp	DWORD PTR [esi], 0
	je	SHORT $L42327
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L42327:
	pop	edi
	pop	esi
	ret	0
??1?$TCorArray@PAVOMacChannel@@@@QAE@XZ ENDP		; TCorArray<OMacChannel *>::~TCorArray<OMacChannel *>
_TEXT	ENDS
PUBLIC	??0CCpjSklBone@@QAE@ABV0@@Z			; CCpjSklBone::CCpjSklBone
PUBLIC	??0CCpjSklVert@@QAE@AAV0@@Z			; CCpjSklVert::CCpjSklVert
PUBLIC	??0CCpjSklMount@@QAE@ABV0@@Z			; CCpjSklMount::CCpjSklMount
PUBLIC	?AddNoConstruct@?$TCorArray@VCCpjSklMount@@@@QAEKK@Z ; TCorArray<CCpjSklMount>::AddNoConstruct
PUBLIC	??0OCpjSkeleton@@QAE@AAV0@@Z			; OCpjSkeleton::OCpjSkeleton
;	COMDAT xdata$x
xdata$x	SEGMENT
$T42496	DD	0ffffffffH
	DD	FLAT:$L42333
	DD	00H
	DD	FLAT:$L42353
	DD	01H
	DD	FLAT:$L42354
	DD	00H
	DD	FLAT:$L42334
	DD	03H
	DD	FLAT:$L42404
	DD	04H
	DD	FLAT:$L42405
	DD	03H
	DD	FLAT:$L42335
	DD	06H
	DD	FLAT:$L42455
	DD	07H
	DD	FLAT:$L42456
$T42487	DD	019930520H
	DD	09H
	DD	FLAT:$T42496
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ??0OCpjSkeleton@@QAE@AAV0@@Z
_TEXT	SEGMENT
_i$42374 = -32
$T42380 = -16
$T42381 = -20
$T42396 = -24
_i$42425 = -32
$T42431 = -24
$T42432 = -20
$T42447 = -16
$T42474 = -24
$T42475 = -20
$T42484 = -16
__$EHRec$ = -12
___that$ = 8
_this$ = -28
??0OCpjSkeleton@@QAE@AAV0@@Z PROC NEAR			; OCpjSkeleton::OCpjSkeleton, COMDAT
; _this$ = ecx
	push	-1
	push	$L42495
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 20					; 00000014H
	push	ebx
	push	ebp
	push	esi
	mov	esi, DWORD PTR ___that$[esp+40]
	push	edi
	mov	ebx, ecx
	push	esi
	mov	DWORD PTR _this$[esp+52], ebx
	call	??0OObject@@QAE@ABV0@@Z			; OObject::OObject
	mov	DWORD PTR [ebx], OFFSET FLAT:??_7OCpjRes@@6B@ ; OCpjRes::`vftable'
	mov	al, BYTE PTR [esi+56]
	mov	BYTE PTR [ebx+56], al
	mov	ecx, DWORD PTR [esi+60]
	mov	DWORD PTR [ebx+60], ecx
	mov	edx, DWORD PTR [esi+64]
	mov	DWORD PTR [ebx+64], edx
	mov	eax, DWORD PTR [esi+68]
	mov	DWORD PTR [ebx+68], eax
	mov	DWORD PTR [ebx], OFFSET FLAT:??_7OCpjChunk@@6B@ ; OCpjChunk::`vftable'
	mov	eax, DWORD PTR [esi+76]
	lea	edi, DWORD PTR [ebx+72]
	xor	ebp, ebp
	push	76					; 0000004cH
	mov	ecx, edi
	mov	DWORD PTR __$EHRec$[esp+60], ebp
	mov	DWORD PTR $T42396[esp+52], edi
	mov	DWORD PTR [edi], ebp
	mov	DWORD PTR [edi+4], eax
	mov	DWORD PTR [edi+8], eax
	mov	DWORD PTR [edi+12], 76			; 0000004cH
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
	mov	DWORD PTR [edi+4], ebp
	mov	eax, DWORD PTR [esi+76]
	cmp	eax, ebp
	mov	BYTE PTR __$EHRec$[esp+56], 1
	mov	DWORD PTR _i$42374[esp+48], ebp
	jbe	SHORT $L42377
	mov	DWORD PTR 8+[esp+44], ebp
$L42375:
	mov	ebp, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi+8]
	lea	eax, DWORD PTR [ebp+1]
	cmp	eax, ecx
	mov	DWORD PTR [edi+4], eax
	jbe	SHORT $L42388
	mov	ecx, eax
	push	76					; 0000004cH
	shr	ecx, 2
	lea	edx, DWORD PTR [ecx+eax+32]
	mov	ecx, edi
	mov	DWORD PTR [edi+8], edx
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
$L42388:
	mov	edx, DWORD PTR [edi]
	lea	eax, DWORD PTR [ebp+ebp*8]
	lea	ecx, DWORD PTR [ebp+eax*2]
	lea	ecx, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR $T42381[esp+48], ecx
	mov	DWORD PTR $T42380[esp+48], ecx
	test	ecx, ecx
	mov	BYTE PTR __$EHRec$[esp+56], 2
	je	SHORT $L42382
	mov	eax, DWORD PTR [esi+72]
	mov	ebp, DWORD PTR 8+[esp+44]
	add	eax, ebp
	push	eax
	call	??0CCpjSklBone@@QAE@ABV0@@Z		; CCpjSklBone::CCpjSklBone
$L42382:
	mov	eax, DWORD PTR _i$42374[esp+48]
	mov	edx, DWORD PTR 8+[esp+44]
	mov	ecx, DWORD PTR [esi+76]
	inc	eax
	add	edx, 76					; 0000004cH
	cmp	eax, ecx
	mov	BYTE PTR __$EHRec$[esp+56], 1
	mov	DWORD PTR _i$42374[esp+48], eax
	mov	DWORD PTR 8+[esp+44], edx
	jb	SHORT $L42375
	xor	ebp, ebp
$L42377:
	mov	eax, DWORD PTR [esi+92]
	lea	edi, DWORD PTR [ebx+88]
	push	16					; 00000010H
	mov	ecx, edi
	mov	BYTE PTR __$EHRec$[esp+60], 3
	mov	DWORD PTR $T42447[esp+52], edi
	mov	DWORD PTR [edi], ebp
	mov	DWORD PTR [edi+4], eax
	mov	DWORD PTR [edi+8], eax
	mov	DWORD PTR [edi+12], 16			; 00000010H
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
	mov	DWORD PTR [edi+4], ebp
	mov	eax, DWORD PTR [esi+92]
	cmp	eax, ebp
	mov	BYTE PTR __$EHRec$[esp+56], 4
	mov	DWORD PTR _i$42425[esp+48], ebp
	jbe	SHORT $L42428
	mov	DWORD PTR 8+[esp+44], ebp
$L42426:
	mov	ebp, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi+8]
	lea	eax, DWORD PTR [ebp+1]
	cmp	eax, ecx
	mov	DWORD PTR [edi+4], eax
	jbe	SHORT $L42439
	mov	ecx, eax
	push	16					; 00000010H
	shr	ecx, 2
	lea	edx, DWORD PTR [ecx+eax+32]
	mov	ecx, edi
	mov	DWORD PTR [edi+8], edx
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
$L42439:
	mov	eax, DWORD PTR [edi]
	shl	ebp, 4
	add	ebp, eax
	mov	DWORD PTR $T42432[esp+48], ebp
	mov	DWORD PTR $T42431[esp+48], ebp
	mov	BYTE PTR __$EHRec$[esp+56], 5
	je	SHORT $L42433
	mov	eax, DWORD PTR [esi+88]
	mov	edx, DWORD PTR 8+[esp+44]
	add	eax, edx
	mov	ecx, ebp
	push	eax
	call	??0CCpjSklVert@@QAE@AAV0@@Z		; CCpjSklVert::CCpjSklVert
$L42433:
	mov	eax, DWORD PTR _i$42425[esp+48]
	mov	edx, DWORD PTR 8+[esp+44]
	mov	ecx, DWORD PTR [esi+92]
	inc	eax
	add	edx, 16					; 00000010H
	cmp	eax, ecx
	mov	BYTE PTR __$EHRec$[esp+56], 4
	mov	DWORD PTR _i$42425[esp+48], eax
	mov	DWORD PTR 8+[esp+44], edx
	jb	SHORT $L42426
	xor	ebp, ebp
$L42428:
	mov	ecx, DWORD PTR [esi+108]
	lea	edi, DWORD PTR [ebx+104]
	push	68					; 00000044H
	push	ecx
	mov	ecx, edi
	mov	BYTE PTR __$EHRec$[esp+64], 6
	mov	DWORD PTR $T42484[esp+56], edi
	call	??0CCorArray@@IAE@KK@Z			; CCorArray::CCorArray
	mov	DWORD PTR [edi+4], ebp
	mov	eax, DWORD PTR [esi+108]
	test	eax, eax
	mov	BYTE PTR __$EHRec$[esp+56], 7
	jbe	SHORT $L42494
	mov	DWORD PTR 8+[esp+44], 0
$L42469:
	push	1
	mov	ecx, edi
	call	?AddNoConstruct@?$TCorArray@VCCpjSklMount@@@@QAEKK@Z ; TCorArray<CCpjSklMount>::AddNoConstruct
	mov	edx, eax
	shl	edx, 4
	add	edx, eax
	mov	eax, DWORD PTR [edi]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR $T42475[esp+48], ecx
	mov	DWORD PTR $T42474[esp+48], ecx
	test	ecx, ecx
	mov	BYTE PTR __$EHRec$[esp+56], 8
	je	SHORT $L42476
	mov	edx, DWORD PTR [esi+104]
	mov	eax, DWORD PTR 8+[esp+44]
	add	edx, eax
	push	edx
	call	??0CCpjSklMount@@QAE@ABV0@@Z		; CCpjSklMount::CCpjSklMount
$L42476:
	mov	ecx, DWORD PTR 8+[esp+44]
	mov	eax, DWORD PTR [esi+108]
	inc	ebp
	add	ecx, 68					; 00000044H
	cmp	ebp, eax
	mov	BYTE PTR __$EHRec$[esp+56], 7
	mov	DWORD PTR 8+[esp+44], ecx
	jb	SHORT $L42469
$L42494:
	mov	ecx, DWORD PTR __$EHRec$[esp+48]
	pop	edi
	pop	esi
	mov	DWORD PTR [ebx], OFFSET FLAT:??_7OCpjSkeleton@@6B@ ; OCpjSkeleton::`vftable'
	mov	eax, ebx
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 32					; 00000020H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L42333:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1OCpjChunk@@UAE@XZ			; OCpjChunk::~OCpjChunk
$L42353:
	mov	ecx, DWORD PTR $T42396[ebp]
	jmp	??1CCorArray@@IAE@XZ			; CCorArray::~CCorArray
$L42354:
	mov	eax, DWORD PTR $T42381[ebp]
	push	eax
	mov	ecx, DWORD PTR $T42380[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
$L42334:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 72					; 00000048H
	jmp	??1?$TCorArray@VCCpjSklBone@@@@QAE@XZ	; TCorArray<CCpjSklBone>::~TCorArray<CCpjSklBone>
$L42404:
	mov	ecx, DWORD PTR $T42447[ebp]
	jmp	??1CCorArray@@IAE@XZ			; CCorArray::~CCorArray
$L42405:
	mov	eax, DWORD PTR $T42432[ebp]
	push	eax
	mov	ecx, DWORD PTR $T42431[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
$L42335:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 88					; 00000058H
	jmp	??1?$TCorArray@VCCpjSklVert@@@@QAE@XZ	; TCorArray<CCpjSklVert>::~TCorArray<CCpjSklVert>
$L42455:
	mov	ecx, DWORD PTR $T42484[ebp]
	jmp	??1CCorArray@@IAE@XZ			; CCorArray::~CCorArray
$L42456:
	mov	eax, DWORD PTR $T42475[ebp]
	push	eax
	mov	ecx, DWORD PTR $T42474[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
$L42495:
	mov	eax, OFFSET FLAT:$T42487
	jmp	___CxxFrameHandler
text$x	ENDS
??0OCpjSkeleton@@QAE@AAV0@@Z ENDP			; OCpjSkeleton::OCpjSkeleton
PUBLIC	??4?$TCorArray@VCCpjSklBone@@@@QAEAAV0@AAV0@@Z	; TCorArray<CCpjSklBone>::operator=
PUBLIC	??4?$TCorArray@VCCpjSklVert@@@@QAEAAV0@AAV0@@Z	; TCorArray<CCpjSklVert>::operator=
PUBLIC	??4?$TCorArray@VCCpjSklMount@@@@QAEAAV0@AAV0@@Z	; TCorArray<CCpjSklMount>::operator=
PUBLIC	??4OCpjSkeleton@@QAEAAV0@AAV0@@Z		; OCpjSkeleton::operator=
; Function compile flags: /Ogty
;	COMDAT ??4OCpjSkeleton@@QAEAAV0@AAV0@@Z
_TEXT	SEGMENT
___that$ = 8
??4OCpjSkeleton@@QAEAAV0@AAV0@@Z PROC NEAR		; OCpjSkeleton::operator=, COMDAT
; _this$ = ecx
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR ___that$[esp+4]
	push	esi
	mov	esi, ecx
	push	edi
	mov	eax, DWORD PTR [ebp+4]
	lea	ecx, DWORD PTR [ebp+8]
	mov	DWORD PTR [esi+4], eax
	lea	edx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	lea	eax, DWORD PTR [esi+24]
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], ecx
	lea	edx, DWORD PTR [ebp+24]
	mov	ecx, DWORD PTR [ebp+24]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR [ebp+40]
	mov	DWORD PTR [esi+40], eax
	mov	ebx, DWORD PTR [ebp+44]
	test	ebx, ebx
	je	SHORT $L42571
	cmp	BYTE PTR [ebx], 0
	jne	SHORT $L42571
	xor	ebx, ebx
$L42571:
	mov	edi, DWORD PTR [esi+44]
	test	edi, edi
	je	SHORT $L42572
	or	ecx, -1
	xor	eax, eax
	repne scasb
	mov	eax, DWORD PTR ?sMemTotal@CCorString@@0KA ; CCorString::sMemTotal
	or	edx, -1
	not	ecx
	dec	ecx
	sub	edx, ecx
	add	eax, edx
	mov	DWORD PTR ?sMemTotal@CCorString@@0KA, eax ; CCorString::sMemTotal
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+44]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L42572:
	test	ebx, ebx
	mov	DWORD PTR [esi+44], 0
	je	SHORT $L42575
	mov	edi, ebx
	or	ecx, -1
	xor	eax, eax
	repne scasb
	not	ecx
	dec	ecx
	mov	edi, ecx
	inc	edi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	edi
	mov	ecx, eax
	call	DWORD PTR [edx]
	test	eax, eax
	mov	DWORD PTR [esi+44], eax
	je	SHORT $L42575
$L42577:
	mov	cl, BYTE PTR [ebx]
	inc	ebx
	mov	BYTE PTR [eax], cl
	inc	eax
	test	cl, cl
	jne	SHORT $L42577
	add	DWORD PTR ?sMemTotal@CCorString@@0KA, edi ; CCorString::sMemTotal
$L42575:
	mov	eax, DWORD PTR [ebp+48]
	mov	DWORD PTR [esi+48], eax
	mov	ecx, DWORD PTR [ebp+52]
	mov	DWORD PTR [esi+52], ecx
	mov	dl, BYTE PTR [ebp+56]
	mov	BYTE PTR [esi+56], dl
	mov	eax, DWORD PTR [ebp+60]
	mov	DWORD PTR [esi+60], eax
	mov	ecx, DWORD PTR [ebp+64]
	mov	DWORD PTR [esi+64], ecx
	mov	edx, DWORD PTR [ebp+68]
	lea	eax, DWORD PTR [ebp+72]
	lea	ecx, DWORD PTR [esi+72]
	push	eax
	mov	DWORD PTR [esi+68], edx
	call	??4?$TCorArray@VCCpjSklBone@@@@QAEAAV0@AAV0@@Z ; TCorArray<CCpjSklBone>::operator=
	lea	ecx, DWORD PTR [ebp+88]
	push	ecx
	lea	ecx, DWORD PTR [esi+88]
	call	??4?$TCorArray@VCCpjSklVert@@@@QAEAAV0@AAV0@@Z ; TCorArray<CCpjSklVert>::operator=
	add	ebp, 104				; 00000068H
	lea	ecx, DWORD PTR [esi+104]
	push	ebp
	call	??4?$TCorArray@VCCpjSklMount@@@@QAEAAV0@AAV0@@Z ; TCorArray<CCpjSklMount>::operator=
	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	4
??4OCpjSkeleton@@QAEAAV0@AAV0@@Z ENDP			; OCpjSkeleton::operator=
_TEXT	ENDS
;	COMDAT xdata$x
; File C:\duke4\Cannibal\VecMain.h
xdata$x	SEGMENT
$T42772	DD	0ffffffffH
	DD	FLAT:$L42588
$T42765	DD	019930520H
	DD	01H
	DD	FLAT:$T42772
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File C:\duke4\Cannibal\CorMain.h
xdata$x	ENDS
;	COMDAT ??4?$TCorArray@VCCpjSklBone@@@@QAEAAV0@AAV0@@Z
_TEXT	SEGMENT
__$EHRec$ = -12
_this$ = -28
_i$ = -24
_inArray$ = 8
$T42584 = -16
$T42585 = -20
??4?$TCorArray@VCCpjSklBone@@@@QAEAAV0@AAV0@@Z PROC NEAR ; TCorArray<CCpjSklBone>::operator=, COMDAT
; _this$ = ecx

; 269  : 	{

	push	-1
	push	$L42770
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 20					; 00000014H
	push	ebx

; 270  : 		if (this == &inArray)

	mov	ebx, DWORD PTR _inArray$[esp+32]
	push	edi
	mov	edi, ecx
	cmp	edi, ebx
	mov	DWORD PTR _this$[esp+40], edi

; 271  : 			return(*this);

	je	$L42771
	push	ebp

; 272  : 		m_Count = 0;

	xor	ebp, ebp
	mov	DWORD PTR [edi+4], ebp

; 273  : 		m_Limit = inArray.m_Count;

	mov	eax, DWORD PTR [ebx+4]
	mov	DWORD PTR [edi+8], eax

; 274  : 		Realloc(sizeof(T));

	mov	eax, DWORD PTR [edi]
	cmp	eax, ebp
	mov	eax, DWORD PTR [edi+8]
	mov	DWORD PTR [edi+12], 76			; 0000004cH
	je	$L42591
	cmp	eax, ebp
	je	SHORT $L42593
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [edi+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [edi+8]
	push	ecx
	mov	ecx, DWORD PTR [edi]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+4]
	mov	DWORD PTR [edi], eax
	jmp	SHORT $L42598
$L42593:
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L42597:
	mov	DWORD PTR [edi], ebp
$L42598:

; 275  : 		for (NDword i=0;i<inArray.m_Count;i++)

	mov	eax, DWORD PTR [ebx+4]
	mov	DWORD PTR _i$[esp+44], ebp
	cmp	eax, ebp
	jbe	$L13885
	mov	DWORD PTR -32+[esp+44], ebp
	push	esi
$L13883:

; 276  : 			new(&(*this)[AddNoConstruct()]) T(inArray[i]);

	mov	esi, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi+8]
	lea	eax, DWORD PTR [esi+1]
	cmp	eax, ecx
	mov	DWORD PTR [edi+4], eax
	jbe	SHORT $L42603
	mov	edx, eax
	push	76					; 0000004cH
	shr	edx, 2
	mov	ecx, edi
	lea	eax, DWORD PTR [edx+eax+32]
	mov	DWORD PTR [edi+8], eax
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
$L42603:
	mov	eax, DWORD PTR [edi]
	lea	ecx, DWORD PTR [esi+esi*8]
	lea	edx, DWORD PTR [esi+ecx*2]
	lea	esi, DWORD PTR [eax+edx*4]
	mov	DWORD PTR $T42585[esp+48], esi
	mov	DWORD PTR $T42584[esp+48], esi
	cmp	esi, ebp
	mov	DWORD PTR __$EHRec$[esp+56], ebp
	je	$L42586
	mov	ebp, DWORD PTR [ebx]
	mov	edx, DWORD PTR -32+[esp+48]
	add	ebp, edx
	mov	DWORD PTR [esi], 0
	xor	eax, eax
	mov	ebx, DWORD PTR [ebp]
	cmp	ebx, eax
	je	SHORT $L42757
	cmp	BYTE PTR [ebx], 0
	jne	SHORT $L42757
	xor	ebx, ebx
$L42757:
	cmp	ebx, eax
	mov	DWORD PTR [esi], eax
	je	SHORT $L42760
	mov	edi, ebx
	or	ecx, -1
	xor	eax, eax
	repne scasb
	not	ecx
	dec	ecx
	mov	edi, ecx
	inc	edi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	edi
	mov	ecx, eax
	call	DWORD PTR [edx]
	test	eax, eax
	mov	DWORD PTR [esi], eax
	je	SHORT $L42769
$L42762:
	mov	cl, BYTE PTR [ebx]
	inc	ebx
	mov	BYTE PTR [eax], cl
	inc	eax
	test	cl, cl
	jne	SHORT $L42762
	add	DWORD PTR ?sMemTotal@CCorString@@0KA, edi ; CCorString::sMemTotal
$L42769:
	mov	edi, DWORD PTR _this$[esp+48]
	xor	eax, eax
$L42760:
	mov	ecx, DWORD PTR [ebp+4]
	mov	ebx, DWORD PTR _inArray$[esp+44]
	mov	DWORD PTR [esi+4], ecx
	mov	edx, DWORD PTR [ebp+8]
	mov	ecx, 1065353216				; 3f800000H
	mov	DWORD PTR [esi+8], edx
	mov	DWORD PTR [esi+12], ecx
	mov	DWORD PTR [esi+16], eax
	mov	DWORD PTR [esi+20], eax
	mov	DWORD PTR [esi+24], eax
	mov	DWORD PTR [esi+28], ecx
	mov	DWORD PTR [esi+32], eax
	mov	DWORD PTR [esi+36], eax
	mov	DWORD PTR [esi+40], eax
	mov	DWORD PTR [esi+44], ecx
	mov	eax, DWORD PTR [ebp+12]
	mov	DWORD PTR [esi+12], eax
	mov	ecx, DWORD PTR [ebp+16]
	mov	DWORD PTR [esi+16], ecx
	mov	edx, DWORD PTR [ebp+20]
	mov	DWORD PTR [esi+20], edx
	mov	eax, DWORD PTR [ebp+24]
	mov	DWORD PTR [esi+24], eax
	mov	ecx, DWORD PTR [ebp+28]
	mov	DWORD PTR [esi+28], ecx
	mov	edx, DWORD PTR [ebp+32]
	mov	DWORD PTR [esi+32], edx
	mov	eax, DWORD PTR [ebp+36]
	mov	DWORD PTR [esi+36], eax
	mov	ecx, DWORD PTR [ebp+40]
	mov	DWORD PTR [esi+40], ecx
	mov	edx, DWORD PTR [ebp+44]
	mov	DWORD PTR [esi+44], edx
	mov	eax, DWORD PTR [ebp+48]
	mov	DWORD PTR [esi+48], eax
	mov	ecx, DWORD PTR [ebp+52]
	mov	DWORD PTR [esi+52], ecx
	mov	edx, DWORD PTR [ebp+56]
	mov	DWORD PTR [esi+56], edx
	mov	eax, DWORD PTR [ebp+60]
	mov	DWORD PTR [esi+60], eax
	mov	ecx, DWORD PTR [ebp+64]
	mov	DWORD PTR [esi+64], ecx
	mov	edx, DWORD PTR [ebp+68]
	mov	DWORD PTR [esi+68], edx
	mov	eax, DWORD PTR [ebp+72]
	mov	DWORD PTR [esi+72], eax
	xor	ebp, ebp
$L42586:
	mov	eax, DWORD PTR _i$[esp+48]
	mov	edx, DWORD PTR -32+[esp+48]
	mov	ecx, DWORD PTR [ebx+4]
	inc	eax
	add	edx, 76					; 0000004cH
	cmp	eax, ecx
	mov	DWORD PTR __$EHRec$[esp+56], -1
	mov	DWORD PTR _i$[esp+48], eax
	mov	DWORD PTR -32+[esp+48], edx
	jb	$L13883
	pop	esi
$L13885:
	pop	ebp
$L42771:

; 277  : 		return(*this);
; 278  : 	}

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	eax, edi
	pop	edi
	pop	ebx
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 32					; 00000020H
	ret	4

; 274  : 		Realloc(sizeof(T));

$L42591:
	cmp	eax, ebp
	je	$L42597
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [edi+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [edi+8]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	DWORD PTR [edi], eax
	jmp	$L42598
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L42588:
	mov	eax, DWORD PTR $T42585[ebp]
	push	eax
	mov	ecx, DWORD PTR $T42584[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
$L42770:
	mov	eax, OFFSET FLAT:$T42765
	jmp	___CxxFrameHandler
text$x	ENDS
??4?$TCorArray@VCCpjSklBone@@@@QAEAAV0@AAV0@@Z ENDP	; TCorArray<CCpjSklBone>::operator=
;	COMDAT xdata$x
; File C:\duke4\Cannibal\VecMain.h
xdata$x	SEGMENT
$T42916	DD	0ffffffffH
	DD	FLAT:$L42783
	DD	00H
	DD	FLAT:$L42817
$T42906	DD	019930520H
	DD	02H
	DD	FLAT:$T42916
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File C:\duke4\Cannibal\CorMain.h
xdata$x	ENDS
;	COMDAT ??4?$TCorArray@VCCpjSklVert@@@@QAEAAV0@AAV0@@Z
_TEXT	SEGMENT
$T42779 = -16
$T42780 = -20
_i$42899 = -28
__$EHRec$ = -12
_i$ = -24
_inArray$ = 8
??4?$TCorArray@VCCpjSklVert@@@@QAEAAV0@AAV0@@Z PROC NEAR ; TCorArray<CCpjSklVert>::operator=, COMDAT
; _this$ = ecx

; 269  : 	{

	mov	eax, DWORD PTR fs:__except_list
	push	-1
	push	$L42914
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 24					; 00000018H
	push	ebx
	push	ebp

; 270  : 		if (this == &inArray)

	mov	ebp, DWORD PTR _inArray$[esp+40]
	mov	ebx, ecx
	cmp	ebx, ebp

; 271  : 			return(*this);

	je	$L42915
	push	edi

; 272  : 		m_Count = 0;

	xor	edi, edi
	mov	DWORD PTR [ebx+4], edi

; 273  : 		m_Limit = inArray.m_Count;

	mov	eax, DWORD PTR [ebp+4]
	mov	DWORD PTR [ebx+8], eax

; 274  : 		Realloc(sizeof(T));

	mov	eax, DWORD PTR [ebx]
	cmp	eax, edi
	mov	eax, DWORD PTR [ebx+8]
	mov	DWORD PTR [ebx+12], 16			; 00000010H
	je	SHORT $L42787
	cmp	eax, edi
	je	SHORT $L42789
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [ebx+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [ebx+8]
	push	ecx
	mov	ecx, DWORD PTR [ebx]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+4]
	mov	DWORD PTR [ebx], eax
	jmp	SHORT $L42794
$L42789:
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [ebx]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L42793:
	mov	DWORD PTR [ebx], edi
$L42794:

; 275  : 		for (NDword i=0;i<inArray.m_Count;i++)

	mov	eax, DWORD PTR [ebp+4]
	mov	DWORD PTR _i$[esp+48], edi
	cmp	eax, edi
	jbe	$L13922
	push	esi
	mov	DWORD PTR -32+[esp+52], edi
	jmp	SHORT $L13920

; 274  : 		Realloc(sizeof(T));

$L42787:
	cmp	eax, edi
	je	SHORT $L42793
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [ebx+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [ebx+8]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	DWORD PTR [ebx], eax
	jmp	SHORT $L42794
$L42913:

; 275  : 		for (NDword i=0;i<inArray.m_Count;i++)

	xor	edi, edi
$L13920:

; 276  : 			new(&(*this)[AddNoConstruct()]) T(inArray[i]);

	mov	esi, DWORD PTR [ebx+4]
	mov	ecx, DWORD PTR [ebx+8]
	lea	eax, DWORD PTR [esi+1]
	cmp	eax, ecx
	mov	DWORD PTR [ebx+4], eax
	jbe	SHORT $L42799
	mov	edx, eax
	push	16					; 00000010H
	shr	edx, 2
	mov	ecx, ebx
	lea	eax, DWORD PTR [edx+eax+32]
	mov	DWORD PTR [ebx+8], eax
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
$L42799:
	mov	eax, DWORD PTR [ebx]
	shl	esi, 4
	add	esi, eax
	mov	DWORD PTR $T42780[esp+52], esi
	mov	DWORD PTR $T42779[esp+52], esi
	mov	DWORD PTR __$EHRec$[esp+60], edi
	je	$L42902
	mov	edi, DWORD PTR [ebp]
	mov	eax, DWORD PTR -32+[esp+52]
	add	edi, eax
	push	20					; 00000014H
	mov	ecx, esi
	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], 20			; 00000014H
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
	xor	eax, eax
	mov	BYTE PTR __$EHRec$[esp+60], 1
	mov	DWORD PTR [esi+4], eax
	mov	ecx, DWORD PTR [edi+4]
	cmp	ecx, eax
	mov	DWORD PTR _i$42899[esp+52], eax
	jbe	SHORT $L42902
	mov	DWORD PTR -36+[esp+52], eax
$L42900:
	mov	ebp, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	lea	eax, DWORD PTR [ebp+1]
	cmp	eax, ecx
	mov	DWORD PTR [esi+4], eax
	jbe	SHORT $L42886
	mov	ecx, eax
	push	20					; 00000014H
	shr	ecx, 2
	lea	edx, DWORD PTR [ecx+eax+32]
	mov	ecx, esi
	mov	DWORD PTR [esi+8], edx
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
$L42886:
	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ebp+ebp*4]
	lea	ecx, DWORD PTR [ecx+eax*4]
	test	ecx, ecx
	je	SHORT $L42880
	mov	eax, DWORD PTR [edi]
	mov	edx, DWORD PTR -36+[esp+52]
	add	eax, edx
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], edx
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+16], eax
$L42880:
	mov	eax, DWORD PTR _i$42899[esp+52]
	mov	edx, DWORD PTR -36+[esp+52]
	mov	ecx, DWORD PTR [edi+4]
	inc	eax
	add	edx, 20					; 00000014H
	cmp	eax, ecx
	mov	DWORD PTR _i$42899[esp+52], eax
	mov	DWORD PTR -36+[esp+52], edx
	jb	SHORT $L42900
	mov	ebp, DWORD PTR _inArray$[esp+48]
$L42902:
	mov	eax, DWORD PTR _i$[esp+52]
	mov	edx, DWORD PTR -32+[esp+52]
	mov	ecx, DWORD PTR [ebp+4]
	inc	eax
	add	edx, 16					; 00000010H
	cmp	eax, ecx
	mov	DWORD PTR __$EHRec$[esp+60], -1
	mov	DWORD PTR _i$[esp+52], eax
	mov	DWORD PTR -32+[esp+52], edx
	jb	$L42913
	pop	esi
$L13922:
	pop	edi
$L42915:

; 277  : 		return(*this);
; 278  : 	}

	mov	ecx, DWORD PTR __$EHRec$[esp+44]
	mov	eax, ebx
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 36					; 00000024H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L42783:
	mov	eax, DWORD PTR $T42780[ebp]
	push	eax
	mov	ecx, DWORD PTR $T42779[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
$L42817:
	mov	ecx, DWORD PTR $T42779[ebp]
	jmp	??1CCorArray@@IAE@XZ			; CCorArray::~CCorArray
$L42914:
	mov	eax, OFFSET FLAT:$T42906
	jmp	___CxxFrameHandler
text$x	ENDS
??4?$TCorArray@VCCpjSklVert@@@@QAEAAV0@AAV0@@Z ENDP	; TCorArray<CCpjSklVert>::operator=
;	COMDAT xdata$x
; File C:\duke4\Cannibal\VecMain.h
xdata$x	SEGMENT
$T43111	DD	0ffffffffH
	DD	FLAT:$L42927
$T43104	DD	019930520H
	DD	01H
	DD	FLAT:$T43111
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File C:\duke4\Cannibal\CorMain.h
xdata$x	ENDS
;	COMDAT ??4?$TCorArray@VCCpjSklMount@@@@QAEAAV0@AAV0@@Z
_TEXT	SEGMENT
$T42923 = -16
$T42924 = -20
__$EHRec$ = -12
_this$ = -28
_i$ = -24
_inArray$ = 8
??4?$TCorArray@VCCpjSklMount@@@@QAEAAV0@AAV0@@Z PROC NEAR ; TCorArray<CCpjSklMount>::operator=, COMDAT
; _this$ = ecx

; 269  : 	{

	push	-1
	push	$L43109
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 20					; 00000014H
	push	ebx

; 270  : 		if (this == &inArray)

	mov	ebx, DWORD PTR _inArray$[esp+32]
	push	edi
	mov	edi, ecx
	cmp	edi, ebx
	mov	DWORD PTR _this$[esp+40], edi

; 271  : 			return(*this);

	je	$L43110
	push	ebp

; 272  : 		m_Count = 0;

	xor	ebp, ebp
	mov	DWORD PTR [edi+4], ebp

; 273  : 		m_Limit = inArray.m_Count;

	mov	eax, DWORD PTR [ebx+4]
	mov	DWORD PTR [edi+8], eax

; 274  : 		Realloc(sizeof(T));

	mov	eax, DWORD PTR [edi]
	cmp	eax, ebp
	mov	eax, DWORD PTR [edi+8]
	mov	DWORD PTR [edi+12], 68			; 00000044H
	je	$L42931
	cmp	eax, ebp
	je	SHORT $L42933
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [edi+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [edi+8]
	push	ecx
	mov	ecx, DWORD PTR [edi]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+4]
	mov	DWORD PTR [edi], eax
	jmp	SHORT $L42938
$L42933:
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L42937:
	mov	DWORD PTR [edi], ebp
$L42938:

; 275  : 		for (NDword i=0;i<inArray.m_Count;i++)

	mov	eax, DWORD PTR [ebx+4]
	mov	DWORD PTR _i$[esp+44], ebp
	cmp	eax, ebp
	jbe	$L13959
	mov	DWORD PTR -32+[esp+44], ebp
	push	esi
$L13957:

; 276  : 			new(&(*this)[AddNoConstruct()]) T(inArray[i]);

	mov	esi, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi+8]
	lea	eax, DWORD PTR [esi+1]
	cmp	eax, ecx
	mov	DWORD PTR [edi+4], eax
	jbe	SHORT $L42943
	mov	edx, eax
	push	68					; 00000044H
	shr	edx, 2
	mov	ecx, edi
	lea	eax, DWORD PTR [edx+eax+32]
	mov	DWORD PTR [edi+8], eax
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
$L42943:
	mov	edx, DWORD PTR [edi]
	mov	ecx, esi
	shl	ecx, 4
	add	ecx, esi
	lea	esi, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR $T42924[esp+48], esi
	mov	DWORD PTR $T42923[esp+48], esi
	cmp	esi, ebp
	mov	DWORD PTR __$EHRec$[esp+56], ebp
	je	$L42925
	mov	ebp, DWORD PTR [ebx]
	mov	edx, DWORD PTR -32+[esp+48]
	add	ebp, edx
	mov	DWORD PTR [esi], 0
	xor	eax, eax
	mov	ebx, DWORD PTR [ebp]
	cmp	ebx, eax
	je	SHORT $L43070
	cmp	BYTE PTR [ebx], 0
	jne	SHORT $L43070
	xor	ebx, ebx
$L43070:
	cmp	ebx, eax
	mov	DWORD PTR [esi], eax
	je	SHORT $L43073
	mov	edi, ebx
	or	ecx, -1
	xor	eax, eax
	repne scasb
	not	ecx
	dec	ecx
	mov	edi, ecx
	inc	edi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	edi
	mov	ecx, eax
	call	DWORD PTR [edx]
	test	eax, eax
	mov	DWORD PTR [esi], eax
	je	SHORT $L43108
$L43067:
	mov	cl, BYTE PTR [ebx]
	inc	ebx
	mov	BYTE PTR [eax], cl
	inc	eax
	test	cl, cl
	jne	SHORT $L43067
	add	DWORD PTR ?sMemTotal@CCorString@@0KA, edi ; CCorString::sMemTotal
$L43108:
	mov	edi, DWORD PTR _this$[esp+48]
	xor	eax, eax
$L43073:
	mov	ecx, DWORD PTR [ebp+4]
	mov	ebx, DWORD PTR _inArray$[esp+44]
	mov	DWORD PTR [esi+4], ecx
	mov	ecx, 1065353216				; 3f800000H
	mov	DWORD PTR [esi+8], ecx
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+16], eax
	mov	DWORD PTR [esi+20], eax
	mov	DWORD PTR [esi+24], ecx
	mov	DWORD PTR [esi+28], eax
	mov	DWORD PTR [esi+32], eax
	mov	DWORD PTR [esi+36], eax
	mov	DWORD PTR [esi+40], ecx
	mov	edx, DWORD PTR [ebp+8]
	mov	DWORD PTR [esi+8], edx
	mov	eax, DWORD PTR [ebp+12]
	mov	DWORD PTR [esi+12], eax
	mov	ecx, DWORD PTR [ebp+16]
	mov	DWORD PTR [esi+16], ecx
	mov	edx, DWORD PTR [ebp+20]
	mov	DWORD PTR [esi+20], edx
	mov	eax, DWORD PTR [ebp+24]
	mov	DWORD PTR [esi+24], eax
	mov	ecx, DWORD PTR [ebp+28]
	mov	DWORD PTR [esi+28], ecx
	mov	edx, DWORD PTR [ebp+32]
	mov	DWORD PTR [esi+32], edx
	mov	eax, DWORD PTR [ebp+36]
	mov	DWORD PTR [esi+36], eax
	mov	ecx, DWORD PTR [ebp+40]
	mov	DWORD PTR [esi+40], ecx
	mov	edx, DWORD PTR [ebp+44]
	mov	DWORD PTR [esi+44], edx
	mov	eax, DWORD PTR [ebp+48]
	mov	DWORD PTR [esi+48], eax
	mov	ecx, DWORD PTR [ebp+52]
	mov	DWORD PTR [esi+52], ecx
	mov	edx, DWORD PTR [ebp+56]
	mov	DWORD PTR [esi+56], edx
	mov	eax, DWORD PTR [ebp+60]
	mov	DWORD PTR [esi+60], eax
	mov	ecx, DWORD PTR [ebp+64]
	mov	DWORD PTR [esi+64], ecx
	xor	ebp, ebp
$L42925:
	mov	eax, DWORD PTR _i$[esp+48]
	mov	edx, DWORD PTR -32+[esp+48]
	mov	ecx, DWORD PTR [ebx+4]
	inc	eax
	add	edx, 68					; 00000044H
	cmp	eax, ecx
	mov	DWORD PTR __$EHRec$[esp+56], -1
	mov	DWORD PTR _i$[esp+48], eax
	mov	DWORD PTR -32+[esp+48], edx
	jb	$L13957
	pop	esi
$L13959:
	pop	ebp
$L43110:

; 277  : 		return(*this);
; 278  : 	}

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	eax, edi
	pop	edi
	pop	ebx
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 32					; 00000020H
	ret	4

; 274  : 		Realloc(sizeof(T));

$L42931:
	cmp	eax, ebp
	je	$L42937
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [edi+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [edi+8]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	DWORD PTR [edi], eax
	jmp	$L42938
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L42927:
	mov	eax, DWORD PTR $T42924[ebp]
	push	eax
	mov	ecx, DWORD PTR $T42923[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
$L43109:
	mov	eax, OFFSET FLAT:$T43104
	jmp	___CxxFrameHandler
text$x	ENDS
??4?$TCorArray@VCCpjSklMount@@@@QAEAAV0@AAV0@@Z ENDP	; TCorArray<CCpjSklMount>::operator=
PUBLIC	??_GCCpjSklVert@@QAEPAXI@Z			; CCpjSklVert::`scalar deleting destructor'
PUBLIC	??_GCCpjSklMount@@QAEPAXI@Z			; CCpjSklMount::`scalar deleting destructor'
PUBLIC	??1OCpjSkeleton@@UAE@XZ				; OCpjSkeleton::~OCpjSkeleton
;	COMDAT xdata$x
xdata$x	SEGMENT
$T43319	DD	0ffffffffH
	DD	FLAT:$L43117
	DD	00H
	DD	FLAT:$L43118
	DD	01H
	DD	FLAT:$L43119
	DD	02H
	DD	FLAT:$L43122
	DD	01H
	DD	FLAT:$L43168
	DD	00H
	DD	FLAT:$L43214
$T43309	DD	019930520H
	DD	06H
	DD	FLAT:$T43319
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ??1OCpjSkeleton@@UAE@XZ
_TEXT	SEGMENT
$T43166 = -16
$T43212 = -16
$T43297 = -16
__$EHRec$ = -12
_this$ = -20
??1OCpjSkeleton@@UAE@XZ PROC NEAR			; OCpjSkeleton::~OCpjSkeleton, COMDAT
; _this$ = ecx
	push	-1
	push	$L43318
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 8
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	DWORD PTR _this$[esp+36], ecx
	xor	edi, edi
	mov	DWORD PTR __$EHRec$[esp+44], edi
	lea	esi, DWORD PTR [ecx+104]
	mov	DWORD PTR $T43166[esp+36], esi
	mov	ebx, DWORD PTR [esi+4]
	mov	BYTE PTR __$EHRec$[esp+44], 3
	cmp	ebx, edi
	jbe	SHORT $L43157
	mov	ebp, ebx
$L43155:
	mov	ecx, DWORD PTR [esi]
	push	0
	add	ecx, edi
	call	??_GCCpjSklMount@@QAEPAXI@Z		; CCpjSklMount::`scalar deleting destructor'
	add	edi, 68					; 00000044H
	dec	ebp
	jne	SHORT $L43155
$L43157:
	push	68					; 00000044H
	push	ebx
	push	0
	mov	ecx, esi
	call	?Remove@CCorArray@@QAEXKKK@Z		; CCorArray::Remove
	mov	eax, DWORD PTR [esi]
	mov	BYTE PTR __$EHRec$[esp+44], 2
	test	eax, eax
	je	SHORT $L43164
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L43164:
	mov	edx, DWORD PTR _this$[esp+36]
	lea	esi, DWORD PTR [edx+88]
	mov	DWORD PTR $T43212[esp+36], esi
	mov	ebx, DWORD PTR [esi+4]
	mov	BYTE PTR __$EHRec$[esp+44], 4
	test	ebx, ebx
	jbe	SHORT $L43203
	xor	edi, edi
	mov	ebp, ebx
$L43201:
	mov	ecx, DWORD PTR [esi]
	push	0
	add	ecx, edi
	call	??_GCCpjSklVert@@QAEPAXI@Z		; CCpjSklVert::`scalar deleting destructor'
	add	edi, 16					; 00000010H
	dec	ebp
	jne	SHORT $L43201
$L43203:
	push	16					; 00000010H
	push	ebx
	push	0
	mov	ecx, esi
	call	?Remove@CCorArray@@QAEXKKK@Z		; CCorArray::Remove
	mov	eax, DWORD PTR [esi]
	mov	BYTE PTR __$EHRec$[esp+44], 1
	test	eax, eax
	je	SHORT $L43210
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L43210:
	mov	edx, DWORD PTR _this$[esp+36]
	lea	esi, DWORD PTR [edx+72]
	mov	DWORD PTR $T43297[esp+36], esi
	mov	ebx, DWORD PTR [esi+4]
	mov	BYTE PTR __$EHRec$[esp+44], 5
	test	ebx, ebx
	jbe	SHORT $L43281
	xor	edi, edi
	mov	ebp, ebx
$L43279:
	mov	ecx, DWORD PTR [esi]
	push	0
	add	ecx, edi
	call	?Set@CCorString@@QAEXPAD@Z		; CCorString::Set
	add	edi, 76					; 0000004cH
	dec	ebp
	jne	SHORT $L43279
$L43281:
	push	76					; 0000004cH
	push	ebx
	push	0
	mov	ecx, esi
	call	?Remove@CCorArray@@QAEXKKK@Z		; CCorArray::Remove
	mov	eax, DWORD PTR [esi]
	mov	BYTE PTR __$EHRec$[esp+44], 0
	test	eax, eax
	je	SHORT $L43295
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L43295:
	mov	ecx, DWORD PTR _this$[esp+36]
	mov	DWORD PTR __$EHRec$[esp+44], -1
	call	??1OObject@@UAE@XZ			; OObject::~OObject
	mov	ecx, DWORD PTR __$EHRec$[esp+36]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 20					; 00000014H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L43117:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1OCpjChunk@@UAE@XZ			; OCpjChunk::~OCpjChunk
$L43118:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 72					; 00000048H
	jmp	??1?$TCorArray@VCCpjSklBone@@@@QAE@XZ	; TCorArray<CCpjSklBone>::~TCorArray<CCpjSklBone>
$L43119:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 88					; 00000058H
	jmp	??1?$TCorArray@VCCpjSklVert@@@@QAE@XZ	; TCorArray<CCpjSklVert>::~TCorArray<CCpjSklVert>
$L43122:
	mov	ecx, DWORD PTR $T43166[ebp]
	jmp	??1CCorArray@@IAE@XZ			; CCorArray::~CCorArray
$L43168:
	mov	ecx, DWORD PTR $T43212[ebp]
	jmp	??1CCorArray@@IAE@XZ			; CCorArray::~CCorArray
$L43214:
	mov	ecx, DWORD PTR $T43297[ebp]
	jmp	??1CCorArray@@IAE@XZ			; CCorArray::~CCorArray
$L43318:
	mov	eax, OFFSET FLAT:$T43309
	jmp	___CxxFrameHandler
text$x	ENDS
??1OCpjSkeleton@@UAE@XZ ENDP				; OCpjSkeleton::~OCpjSkeleton
; Function compile flags: /Ogty
;	COMDAT ??0?$TCorArray@VCMacTraceInfo@@@@QAE@K@Z
_TEXT	SEGMENT
_inCount$ = 8
??0?$TCorArray@VCMacTraceInfo@@@@QAE@K@Z PROC NEAR	; TCorArray<CMacTraceInfo>::TCorArray<CMacTraceInfo>, COMDAT
; _this$ = ecx

; 259  : 	{

	mov	eax, DWORD PTR _inCount$[esp-4]
	push	esi
	mov	esi, ecx
	test	eax, eax
	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], 40			; 00000028H
	je	SHORT $L43347
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+8]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [esi+12]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	DWORD PTR [esi], eax

; 260  : 	}

	mov	eax, esi
	pop	esi
	ret	4

; 259  : 	{

$L43347:
	mov	DWORD PTR [esi], 0

; 260  : 	}

	mov	eax, esi
	pop	esi
	ret	4
??0?$TCorArray@VCMacTraceInfo@@@@QAE@K@Z ENDP		; TCorArray<CMacTraceInfo>::TCorArray<CMacTraceInfo>
_TEXT	ENDS
PUBLIC	??1?$TCorArray@E@@QAE@XZ			; TCorArray<unsigned char>::~TCorArray<unsigned char>
PUBLIC	?Remove@?$TCorArray@VVBox3@@@@QAEXKK@Z		; TCorArray<VBox3>::Remove
;	COMDAT xdata$x
xdata$x	SEGMENT
$T43472	DD	0ffffffffH
	DD	FLAT:$L43354
	DD	00H
	DD	FLAT:$L43362
	DD	01H
	DD	FLAT:$L43365
	DD	00H
	DD	FLAT:$L43375
$T43468	DD	019930520H
	DD	04H
	DD	FLAT:$T43472
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ??1?$TCorArray@VCMacTraceInfo@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -24
$T43373 = -16
$T43383 = -16
$T43407 = -20
$T43436 = -28
__$EHRec$ = -12
??1?$TCorArray@VCMacTraceInfo@@@@QAE@XZ PROC NEAR	; TCorArray<CMacTraceInfo>::~TCorArray<CMacTraceInfo>, COMDAT
; _this$ = ecx

; 280  : 	{

	push	-1
	push	$L43471
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 20					; 00000014H
	push	ebx
	push	ebp
	mov	ebp, ecx
	push	esi
	mov	DWORD PTR _this$[esp+44], ebp

; 281  : 		Purge();

	mov	esi, DWORD PTR [ebp+4]
	xor	ebx, ebx
	cmp	esi, ebx
	mov	DWORD PTR __$EHRec$[esp+52], ebx
	mov	DWORD PTR $T43436[esp+44], esi
	jbe	SHORT $L43442
	mov	DWORD PTR -32+[esp+44], esi
	push	edi
$L43440:
	mov	esi, DWORD PTR [ebp]
	add	esi, ebx
	mov	DWORD PTR $T43407[esp+48], esi
	lea	edi, DWORD PTR [esi+24]
	mov	DWORD PTR $T43373[esp+48], edi
	mov	eax, DWORD PTR [edi+4]
	mov	ecx, edi
	push	eax
	push	0
	mov	BYTE PTR __$EHRec$[esp+64], 2
	call	?Remove@?$TCorArray@VVBox3@@@@QAEXKK@Z	; TCorArray<VBox3>::Remove
	mov	ecx, edi
	mov	BYTE PTR __$EHRec$[esp+56], 1
	call	??1CCorArray@@IAE@XZ			; CCorArray::~CCorArray
	add	esi, 8
	mov	DWORD PTR $T43383[esp+48], esi
	mov	ecx, DWORD PTR [esi+4]
	mov	BYTE PTR __$EHRec$[esp+56], 3
	push	ecx
	push	0
	mov	ecx, esi
	call	?Remove@?$TCorArray@E@@QAEXKK@Z		; TCorArray<unsigned char>::Remove
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+56], 0
	call	??1CCorArray@@IAE@XZ			; CCorArray::~CCorArray
	mov	eax, DWORD PTR -32+[esp+48]
	add	ebx, 40					; 00000028H
	dec	eax
	mov	DWORD PTR -32+[esp+48], eax
	jne	SHORT $L43440
	mov	esi, DWORD PTR $T43436[esp+48]
	pop	edi
$L43442:
	test	esi, esi
	je	SHORT $L43460
	mov	edx, DWORD PTR [ebp+4]
	mov	ecx, DWORD PTR [ebp]
	lea	eax, DWORD PTR [esi+esi*4]
	lea	edx, DWORD PTR [edx+edx*4]
	shl	eax, 3
	shl	edx, 3
	sub	edx, eax
	add	eax, ecx
	push	edx
	push	eax
	push	ecx
	call	DWORD PTR __imp__memmove
	mov	eax, DWORD PTR [ebp+4]
	add	esp, 12					; 0000000cH
	sub	eax, esi
	mov	DWORD PTR [ebp+4], eax
$L43460:

; 282  : 	}

	mov	eax, DWORD PTR [ebp]
	mov	DWORD PTR __$EHRec$[esp+52], -1
	test	eax, eax
	je	SHORT $L43466
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [ebp]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L43466:
	mov	ecx, DWORD PTR __$EHRec$[esp+44]
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 32					; 00000020H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L43354:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CCorArray@@IAE@XZ			; CCorArray::~CCorArray
$L43362:
	mov	ecx, DWORD PTR $T43407[ebp]
	add	ecx, 8
	jmp	??1?$TCorArray@E@@QAE@XZ		; TCorArray<unsigned char>::~TCorArray<unsigned char>
$L43365:
	mov	ecx, DWORD PTR $T43373[ebp]
	jmp	??1CCorArray@@IAE@XZ			; CCorArray::~CCorArray
$L43375:
	mov	ecx, DWORD PTR $T43383[ebp]
	jmp	??1CCorArray@@IAE@XZ			; CCorArray::~CCorArray
$L43471:
	mov	eax, OFFSET FLAT:$T43468
	jmp	___CxxFrameHandler
text$x	ENDS
??1?$TCorArray@VCMacTraceInfo@@@@QAE@XZ ENDP		; TCorArray<CMacTraceInfo>::~TCorArray<CMacTraceInfo>
; Function compile flags: /Ogty
;	COMDAT ??1?$TCorArray@E@@QAE@XZ
_TEXT	SEGMENT
??1?$TCorArray@E@@QAE@XZ PROC NEAR			; TCorArray<unsigned char>::~TCorArray<unsigned char>, COMDAT
; _this$ = ecx

; 280  : 	{

	push	esi
	mov	esi, ecx
	push	edi

; 281  : 		Purge();

	mov	edi, DWORD PTR [esi+4]
	test	edi, edi
	je	SHORT $L43504
	mov	eax, DWORD PTR [esi]
	mov	ecx, edi
	sub	ecx, edi
	lea	edx, DWORD PTR [eax+edi]
	push	ecx
	push	edx
	push	eax
	call	DWORD PTR __imp__memmove
	mov	eax, DWORD PTR [esi+4]
	add	esp, 12					; 0000000cH
	sub	eax, edi
	mov	DWORD PTR [esi+4], eax
$L43504:

; 282  : 	}

	cmp	DWORD PTR [esi], 0
	je	SHORT $L43509
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L43509:
	pop	edi
	pop	esi
	ret	0
??1?$TCorArray@E@@QAE@XZ ENDP				; TCorArray<unsigned char>::~TCorArray<unsigned char>
_TEXT	ENDS
PUBLIC	??_GOCpjSkeleton@@UAEPAXI@Z			; OCpjSkeleton::`scalar deleting destructor'
; Function compile flags: /Ogty
;	COMDAT ??_GOCpjSkeleton@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_GOCpjSkeleton@@UAEPAXI@Z PROC NEAR			; OCpjSkeleton::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1OCpjSkeleton@@UAE@XZ			; OCpjSkeleton::~OCpjSkeleton
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $L43527
	mov	DWORD PTR [esi+4], 0
	mov	edx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	dec	edx
	mov	DWORD PTR ?sObjCount@OObject@@1KA, edx	; OObject::sObjCount
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L43527:
	mov	eax, esi
	pop	esi
	ret	4
??_GOCpjSkeleton@@UAEPAXI@Z ENDP			; OCpjSkeleton::`scalar deleting destructor'
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??_EOCpjSkeleton@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_EOCpjSkeleton@@UAEPAXI@Z PROC NEAR			; OCpjSkeleton::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebx
	mov	bl, BYTE PTR ___flags$[esp]
	push	esi
	mov	esi, ecx
	test	bl, 2
	je	SHORT $L9006
	mov	eax, DWORD PTR [esi-4]
	push	edi
	lea	edi, DWORD PTR [esi-4]
	push	OFFSET FLAT:??1OCpjSkeleton@@UAE@XZ	; OCpjSkeleton::~OCpjSkeleton
	push	eax
	push	120					; 00000078H
	push	esi
	call	??_M@YGXPAXIHP6EX0@Z@Z			; `eh vector destructor iterator'
	test	bl, 1
	je	SHORT $L9007
	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L9007:
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	ret	4
$L9006:
	mov	ecx, esi
	call	??1OCpjSkeleton@@UAE@XZ			; OCpjSkeleton::~OCpjSkeleton
	test	bl, 1
	je	SHORT $L43537
	mov	DWORD PTR [esi+4], 0
	mov	edx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	dec	edx
	mov	DWORD PTR ?sObjCount@OObject@@1KA, edx	; OObject::sObjCount
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L43537:
	mov	eax, esi
	pop	esi
	pop	ebx
	ret	4
??_EOCpjSkeleton@@UAEPAXI@Z ENDP			; OCpjSkeleton::`vector deleting destructor'
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
$T43706	DD	0ffffffffH
	DD	FLAT:$L43551
	DD	00H
	DD	FLAT:$L43585
$T43700	DD	019930520H
	DD	02H
	DD	FLAT:$T43706
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ?Add@?$TCorArray@VCMacTraceInfo@@@@QAEKK@Z
_TEXT	SEGMENT
__$EHRec$ = -12
_inCount$ = 8
$T43547 = -16
$T43548 = -20
?Add@?$TCorArray@VCMacTraceInfo@@@@QAEKK@Z PROC NEAR	; TCorArray<CMacTraceInfo>::Add, COMDAT
; _this$ = ecx

; 331  : 	{

	mov	eax, DWORD PTR fs:__except_list
	push	-1
	push	$L43705
	push	eax

; 332  : 		NDword index = AddNoConstruct(inCount);

	mov	eax, DWORD PTR _inCount$[esp+8]
	mov	DWORD PTR fs:__except_list, esp
	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx
	push	edi
	xor	ebx, ebx
	mov	ebp, DWORD PTR [esi+4]
	lea	edi, DWORD PTR [eax+ebp]
	mov	eax, DWORD PTR [esi+8]
	cmp	edi, eax
	mov	DWORD PTR [esi+4], edi
	jbe	SHORT $L43577
	mov	ecx, edi
	mov	DWORD PTR [esi+12], 40			; 00000028H
	shr	ecx, 2
	lea	eax, DWORD PTR [ecx+edi+32]
	mov	ecx, DWORD PTR [esi]
	cmp	ecx, ebx
	mov	DWORD PTR [esi+8], eax
	je	$L43567
	cmp	eax, ebx
	je	SHORT $L43572
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [esi+8]
	push	ecx
	mov	ecx, DWORD PTR [esi]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+4]
	mov	DWORD PTR [esi], eax
	jmp	SHORT $L43577
$L43572:
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L43576:
	mov	DWORD PTR [esi], ebx
$L43577:

; 333  : 		for (NDword i=index; i<index+inCount; i++)

	cmp	ebp, edi
	jae	SHORT $L43703
	lea	ecx, DWORD PTR [ebp+ebp*4]
	mov	edx, 60					; 0000003cH
	shl	ecx, 3
	sub	edi, ebp
$L14598:

; 334  : 			new(&(*this)[i]) T;

	mov	eax, DWORD PTR [esi]
	add	eax, ecx
	je	SHORT $L43697
	mov	DWORD PTR [eax+12], ebx
	mov	DWORD PTR [eax+16], ebx
	mov	DWORD PTR [eax+20], 1
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+28], ebx
	mov	DWORD PTR [eax+32], ebx
	mov	DWORD PTR [eax+36], edx
	mov	DWORD PTR [eax+24], ebx
$L43697:
	add	ecx, 40					; 00000028H
	dec	edi
	jne	SHORT $L14598
$L43703:

; 335  : 		return(index);
; 336  : 	}

	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	pop	edi
	mov	eax, ebp
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:__except_list, ecx
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	4

; 332  : 		NDword index = AddNoConstruct(inCount);

$L43567:
	cmp	eax, ebx
	je	SHORT $L43576
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [esi+8]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	DWORD PTR [esi], eax
	jmp	SHORT $L43577
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L43551:
	mov	eax, DWORD PTR $T43548[ebp]
	push	eax
	mov	ecx, DWORD PTR $T43547[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
$L43585:
	mov	ecx, DWORD PTR $T43547[ebp]
	add	ecx, 8
	jmp	??1?$TCorArray@E@@QAE@XZ		; TCorArray<unsigned char>::~TCorArray<unsigned char>
$L43705:
	mov	eax, OFFSET FLAT:$T43700
	jmp	___CxxFrameHandler
text$x	ENDS
?Add@?$TCorArray@VCMacTraceInfo@@@@QAEKK@Z ENDP		; TCorArray<CMacTraceInfo>::Add
PUBLIC	??0CCpjFrmFrame@@QAE@XZ				; CCpjFrmFrame::CCpjFrmFrame
PUBLIC	??1?$TCorArray@VCCpjFrmGroup@@@@QAE@XZ		; TCorArray<CCpjFrmGroup>::~TCorArray<CCpjFrmGroup>
PUBLIC	??1?$TCorArray@VCCpjFrmBytePos@@@@QAE@XZ	; TCorArray<CCpjFrmBytePos>::~TCorArray<CCpjFrmBytePos>
;	COMDAT xdata$x
; File C:\duke4\Cannibal\VecMain.h
xdata$x	SEGMENT
$T43783	DD	0ffffffffH
	DD	FLAT:$L43714
	DD	00H
	DD	FLAT:$L43715
	DD	01H
	DD	FLAT:$L43716
$T43779	DD	019930520H
	DD	03H
	DD	FLAT:$T43783
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File C:\duke4\Cannibal\CpjFrm.h
xdata$x	ENDS
;	COMDAT ??0CCpjFrmFrame@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16
__$EHRec$ = -12
??0CCpjFrmFrame@@QAE@XZ PROC NEAR			; CCpjFrmFrame::CCpjFrmFrame, COMDAT
; _this$ = ecx

; 50   : 	CCpjFrmFrame()

	push	-1
	push	$L43782
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	push	ebx
	push	esi
	mov	esi, ecx
	xor	ebx, ebx
	mov	DWORD PTR _this$[esp+24], esi
	mov	DWORD PTR [esi], ebx
	lea	ecx, DWORD PTR [esi+12]
	push	24					; 00000018H
	mov	DWORD PTR __$EHRec$[esp+36], ebx
	mov	DWORD PTR [ecx], ebx
	mov	DWORD PTR [ecx+4], ebx
	mov	DWORD PTR [ecx+8], ebx
	mov	DWORD PTR [ecx+12], 24			; 00000018H
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
	lea	ecx, DWORD PTR [esi+28]
	push	4
	mov	BYTE PTR __$EHRec$[esp+36], 1
	mov	DWORD PTR [ecx], ebx
	mov	DWORD PTR [ecx+4], ebx
	mov	DWORD PTR [ecx+8], ebx
	mov	DWORD PTR [ecx+12], 4
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
	lea	ecx, DWORD PTR [esi+44]
	push	12					; 0000000cH
	mov	BYTE PTR __$EHRec$[esp+36], 2
	mov	DWORD PTR [ecx], ebx
	mov	DWORD PTR [ecx+4], ebx
	mov	DWORD PTR [ecx+8], ebx
	mov	DWORD PTR [ecx+12], 12			; 0000000cH
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc

; 51   : 	{
; 52   : 		m_NameHash = 0;
; 53   : 		m_isCompressed = 0;
; 54   : 		m_Bounds[0] = VVec3(FLT_MAX,FLT_MAX,FLT_MAX);
; 55   : 		m_Bounds[1] = VVec3(-FLT_MAX,-FLT_MAX,-FLT_MAX);
; 56   : 	}

	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	eax, 2139095039				; 7f7fffffH
	mov	DWORD PTR [esi+4], ebx
	mov	BYTE PTR [esi+8], bl
	mov	DWORD PTR [esi+60], eax
	mov	DWORD PTR [esi+64], eax
	mov	DWORD PTR [esi+68], eax
	mov	eax, -8388609				; ff7fffffH
	mov	DWORD PTR [esi+72], eax
	mov	DWORD PTR [esi+76], eax
	mov	DWORD PTR [esi+80], eax
	mov	eax, esi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L43714:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CCorString@@QAE@XZ			; CCorString::~CCorString
$L43715:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	jmp	??1?$TCorArray@VCCpjFrmGroup@@@@QAE@XZ	; TCorArray<CCpjFrmGroup>::~TCorArray<CCpjFrmGroup>
$L43716:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	jmp	??1?$TCorArray@VCCpjFrmBytePos@@@@QAE@XZ ; TCorArray<CCpjFrmBytePos>::~TCorArray<CCpjFrmBytePos>
$L43782:
	mov	eax, OFFSET FLAT:$T43779
	jmp	___CxxFrameHandler
text$x	ENDS
??0CCpjFrmFrame@@QAE@XZ ENDP				; CCpjFrmFrame::CCpjFrmFrame
; Function compile flags: /Ogty
; File C:\duke4\Cannibal\CorMain.h
;	COMDAT ??1?$TCorArray@VCCpjFrmGroup@@@@QAE@XZ
_TEXT	SEGMENT
??1?$TCorArray@VCCpjFrmGroup@@@@QAE@XZ PROC NEAR	; TCorArray<CCpjFrmGroup>::~TCorArray<CCpjFrmGroup>, COMDAT
; _this$ = ecx

; 280  : 	{

	push	esi
	mov	esi, ecx
	push	edi

; 281  : 		Purge();

	mov	edi, DWORD PTR [esi+4]
	test	edi, edi
	je	SHORT $L43814
	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [edi+edi*2]
	shl	eax, 3
	mov	edx, eax
	sub	edx, eax
	add	eax, ecx
	push	edx
	push	eax
	push	ecx
	call	DWORD PTR __imp__memmove
	mov	eax, DWORD PTR [esi+4]
	add	esp, 12					; 0000000cH
	sub	eax, edi
	mov	DWORD PTR [esi+4], eax
$L43814:

; 282  : 	}

	cmp	DWORD PTR [esi], 0
	je	SHORT $L43820
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L43820:
	pop	edi
	pop	esi
	ret	0
??1?$TCorArray@VCCpjFrmGroup@@@@QAE@XZ ENDP		; TCorArray<CCpjFrmGroup>::~TCorArray<CCpjFrmGroup>
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??1?$TCorArray@VCCpjFrmBytePos@@@@QAE@XZ
_TEXT	SEGMENT
??1?$TCorArray@VCCpjFrmBytePos@@@@QAE@XZ PROC NEAR	; TCorArray<CCpjFrmBytePos>::~TCorArray<CCpjFrmBytePos>, COMDAT
; _this$ = ecx

; 280  : 	{

	push	esi
	mov	esi, ecx
	push	edi

; 281  : 		Purge();

	mov	edi, DWORD PTR [esi+4]
	test	edi, edi
	je	SHORT $L43851
	mov	eax, DWORD PTR [esi]
	mov	ecx, edi
	sub	ecx, edi
	shl	ecx, 2
	lea	edx, DWORD PTR [eax+edi*4]
	push	ecx
	push	edx
	push	eax
	call	DWORD PTR __imp__memmove
	mov	eax, DWORD PTR [esi+4]
	add	esp, 12					; 0000000cH
	sub	eax, edi
	mov	DWORD PTR [esi+4], eax
$L43851:

; 282  : 	}

	cmp	DWORD PTR [esi], 0
	je	SHORT $L43857
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L43857:
	pop	edi
	pop	esi
	ret	0
??1?$TCorArray@VCCpjFrmBytePos@@@@QAE@XZ ENDP		; TCorArray<CCpjFrmBytePos>::~TCorArray<CCpjFrmBytePos>
_TEXT	ENDS
PUBLIC	?AddNoConstruct@?$TCorArray@VVVec3@@@@QAEKK@Z	; TCorArray<VVec3>::AddNoConstruct
PUBLIC	??0CCpjFrmFrame@@QAE@AAV0@@Z			; CCpjFrmFrame::CCpjFrmFrame
PUBLIC	??0CCpjFrmGroup@@QAE@ABV0@@Z			; CCpjFrmGroup::CCpjFrmGroup
PUBLIC	?AddNoConstruct@?$TCorArray@VCCpjFrmBytePos@@@@QAEKK@Z ; TCorArray<CCpjFrmBytePos>::AddNoConstruct
;	COMDAT xdata$x
xdata$x	SEGMENT
$T44042	DD	0ffffffffH
	DD	FLAT:$L43863
	DD	00H
	DD	FLAT:$L43895
	DD	01H
	DD	FLAT:$L43896
	DD	00H
	DD	FLAT:$L43864
	DD	03H
	DD	FLAT:$L43946
	DD	03H
	DD	FLAT:$L43865
	DD	05H
	DD	FLAT:$L43989
$T44030	DD	019930520H
	DD	07H
	DD	FLAT:$T44042
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ??0CCpjFrmFrame@@QAE@AAV0@@Z
_TEXT	SEGMENT
___that$ = 8
_this$ = -28
$T43917 = -16
$T43918 = -20
_i$43934 = -32
$T43938 = -24
$T43981 = 8
_i$44020 = 8
$T44024 = -16
__$EHRec$ = -12
??0CCpjFrmFrame@@QAE@AAV0@@Z PROC NEAR			; CCpjFrmFrame::CCpjFrmFrame, COMDAT
; _this$ = ecx
	push	-1
	push	$L44041
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 20					; 00000014H
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR ___that$[esp+36]
	push	esi
	push	edi
	mov	ebx, ecx
	xor	edi, edi
	mov	DWORD PTR _this$[esp+48], ebx
	mov	DWORD PTR [ebx], edi
	mov	esi, DWORD PTR [ebp]
	cmp	esi, edi
	je	SHORT $L43884
	cmp	BYTE PTR [esi], 0
	jne	SHORT $L43884
	xor	esi, esi
$L43884:
	cmp	esi, edi
	mov	DWORD PTR [ebx], edi
	je	SHORT $L43887
	mov	edi, esi
	or	ecx, -1
	xor	eax, eax
	repne scasb
	not	ecx
	dec	ecx
	mov	edi, ecx
	inc	edi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	edi
	mov	ecx, eax
	call	DWORD PTR [edx]
	test	eax, eax
	mov	DWORD PTR [ebx], eax
	je	SHORT $L44039
	mov	ecx, eax
$L43881:
	mov	al, BYTE PTR [esi]
	inc	esi
	mov	BYTE PTR [ecx], al
	inc	ecx
	test	al, al
	jne	SHORT $L43881
	add	DWORD PTR ?sMemTotal@CCorString@@0KA, edi ; CCorString::sMemTotal
$L44039:
	xor	edi, edi
$L43887:
	mov	eax, DWORD PTR [ebp+4]
	lea	esi, DWORD PTR [ebx+12]
	mov	DWORD PTR [ebx+4], eax
	mov	cl, BYTE PTR [ebp+8]
	mov	BYTE PTR [ebx+8], cl
	mov	eax, DWORD PTR [ebp+16]
	push	24					; 00000018H
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+60], edi
	mov	DWORD PTR $T43938[esp+52], esi
	mov	DWORD PTR [esi], edi
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], 24			; 00000018H
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
	mov	DWORD PTR [esi+4], edi
	mov	eax, DWORD PTR [ebp+16]
	cmp	eax, edi
	mov	BYTE PTR __$EHRec$[esp+56], 1
	mov	DWORD PTR _i$43934[esp+48], edi
	jbe	SHORT $L43937
	mov	DWORD PTR 8+[esp+44], edi
$L43935:
	mov	edi, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	lea	eax, DWORD PTR [edi+1]
	cmp	eax, ecx
	mov	DWORD PTR [esi+4], eax
	jbe	SHORT $L43926
	mov	edx, eax
	push	24					; 00000018H
	shr	edx, 2
	mov	ecx, esi
	lea	eax, DWORD PTR [edx+eax+32]
	mov	DWORD PTR [esi+8], eax
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
$L43926:
	mov	edx, DWORD PTR [esi]
	lea	ecx, DWORD PTR [edi+edi*2]
	lea	ecx, DWORD PTR [edx+ecx*8]
	mov	DWORD PTR $T43918[esp+48], ecx
	mov	DWORD PTR $T43917[esp+48], ecx
	test	ecx, ecx
	mov	BYTE PTR __$EHRec$[esp+56], 2
	je	SHORT $L43919
	mov	eax, DWORD PTR [ebp+12]
	mov	edi, DWORD PTR 8+[esp+44]
	add	eax, edi
	push	eax
	call	??0CCpjFrmGroup@@QAE@ABV0@@Z		; CCpjFrmGroup::CCpjFrmGroup
$L43919:
	mov	eax, DWORD PTR _i$43934[esp+48]
	mov	edx, DWORD PTR 8+[esp+44]
	mov	ecx, DWORD PTR [ebp+16]
	inc	eax
	add	edx, 24					; 00000018H
	cmp	eax, ecx
	mov	BYTE PTR __$EHRec$[esp+56], 1
	mov	DWORD PTR _i$43934[esp+48], eax
	mov	DWORD PTR 8+[esp+44], edx
	jb	SHORT $L43935
	xor	edi, edi
$L43937:
	mov	eax, DWORD PTR [ebp+32]
	lea	esi, DWORD PTR [ebx+28]
	push	4
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+60], 3
	mov	DWORD PTR $T43981[esp+48], esi
	mov	DWORD PTR [esi], edi
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], 4
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
	mov	DWORD PTR [esi+4], edi
	mov	eax, DWORD PTR [ebp+32]
	test	eax, eax
	mov	BYTE PTR __$EHRec$[esp+56], 4
	jbe	SHORT $L43980
$L43978:
	push	1
	mov	ecx, esi
	call	?AddNoConstruct@?$TCorArray@VCCpjFrmBytePos@@@@QAEKK@Z ; TCorArray<CCpjFrmBytePos>::AddNoConstruct
	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ecx+eax*4]
	test	eax, eax
	je	SHORT $L43966
	mov	edx, DWORD PTR [ebp+28]
	mov	ecx, DWORD PTR [edx+edi*4]
	mov	DWORD PTR [eax], ecx
$L43966:
	mov	eax, DWORD PTR [ebp+32]
	inc	edi
	cmp	edi, eax
	jb	SHORT $L43978
$L43980:
	mov	edx, DWORD PTR [ebp+48]
	lea	esi, DWORD PTR [ebx+44]
	push	12					; 0000000cH
	push	edx
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+64], 5
	mov	DWORD PTR $T44024[esp+56], esi
	call	??0CCorArray@@IAE@KK@Z			; CCorArray::CCorArray
	xor	edi, edi
	mov	BYTE PTR __$EHRec$[esp+56], 6
	mov	DWORD PTR [esi+4], edi
	mov	eax, DWORD PTR [ebp+48]
	cmp	eax, edi
	mov	DWORD PTR _i$44020[esp+44], edi
	jbe	SHORT $L44023
$L44021:
	push	1
	mov	ecx, esi
	call	?AddNoConstruct@?$TCorArray@VVVec3@@@@QAEKK@Z ; TCorArray<VVec3>::AddNoConstruct
	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [eax+eax*2]
	lea	ecx, DWORD PTR [ecx+eax*4]
	test	ecx, ecx
	je	SHORT $L44009
	mov	eax, DWORD PTR [ebp+44]
	add	eax, edi
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
$L44009:
	mov	eax, DWORD PTR _i$44020[esp+44]
	mov	ecx, DWORD PTR [ebp+48]
	inc	eax
	add	edi, 12					; 0000000cH
	cmp	eax, ecx
	mov	DWORD PTR _i$44020[esp+44], eax
	jb	SHORT $L44021
$L44023:
	lea	ecx, DWORD PTR [ebx+60]
	mov	esi, 2
	mov	edx, ecx
	sub	edx, ebx
	lea	eax, DWORD PTR [edx+ebp+8]
	mov	edx, ebx
	sub	edx, ebp
$L9213:
	mov	edi, DWORD PTR [eax-8]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR [ecx], edi
	mov	edi, DWORD PTR [eax-16]
	mov	DWORD PTR [ecx+4], edi
	mov	edi, DWORD PTR [eax-12]
	mov	DWORD PTR [edx+eax-12], edi
	add	ecx, 12					; 0000000cH
	dec	esi
	jne	SHORT $L9213
	mov	ecx, DWORD PTR __$EHRec$[esp+48]
	pop	edi
	pop	esi
	mov	eax, ebx
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 32					; 00000020H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L43863:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CCorString@@QAE@XZ			; CCorString::~CCorString
$L43895:
	mov	ecx, DWORD PTR $T43938[ebp]
	jmp	??1CCorArray@@IAE@XZ			; CCorArray::~CCorArray
$L43896:
	mov	eax, DWORD PTR $T43918[ebp]
	push	eax
	mov	ecx, DWORD PTR $T43917[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
$L43864:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	jmp	??1?$TCorArray@VCCpjFrmGroup@@@@QAE@XZ	; TCorArray<CCpjFrmGroup>::~TCorArray<CCpjFrmGroup>
$L43946:
	mov	ecx, DWORD PTR $T43981[ebp-4]
	jmp	??1CCorArray@@IAE@XZ			; CCorArray::~CCorArray
$L43865:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	jmp	??1?$TCorArray@VCCpjFrmBytePos@@@@QAE@XZ ; TCorArray<CCpjFrmBytePos>::~TCorArray<CCpjFrmBytePos>
$L43989:
	mov	ecx, DWORD PTR $T44024[ebp]
	jmp	??1CCorArray@@IAE@XZ			; CCorArray::~CCorArray
$L44041:
	mov	eax, OFFSET FLAT:$T44030
	jmp	___CxxFrameHandler
text$x	ENDS
??0CCpjFrmFrame@@QAE@AAV0@@Z ENDP			; CCpjFrmFrame::CCpjFrmFrame
PUBLIC	??4CCpjFrmFrame@@QAEAAV0@AAV0@@Z		; CCpjFrmFrame::operator=
PUBLIC	??4?$TCorArray@VCCpjFrmGroup@@@@QAEAAV0@AAV0@@Z	; TCorArray<CCpjFrmGroup>::operator=
PUBLIC	??4?$TCorArray@VCCpjFrmBytePos@@@@QAEAAV0@AAV0@@Z ; TCorArray<CCpjFrmBytePos>::operator=
PUBLIC	??4?$TCorArray@VVVec3@@@@QAEAAV0@AAV0@@Z	; TCorArray<VVec3>::operator=
; Function compile flags: /Ogty
;	COMDAT ??4CCpjFrmFrame@@QAEAAV0@AAV0@@Z
_TEXT	SEGMENT
___that$ = 8
??4CCpjFrmFrame@@QAEAAV0@AAV0@@Z PROC NEAR		; CCpjFrmFrame::operator=, COMDAT
; _this$ = ecx
	push	ebx
	mov	ebx, DWORD PTR ___that$[esp]
	push	ebp
	push	esi
	mov	ebp, DWORD PTR [ebx]
	push	edi
	test	ebp, ebp
	mov	esi, ecx
	je	SHORT $L44064
	cmp	BYTE PTR [ebp], 0
	jne	SHORT $L44064
	xor	ebp, ebp
$L44064:
	mov	edi, DWORD PTR [esi]
	test	edi, edi
	je	SHORT $L44065
	or	ecx, -1
	xor	eax, eax
	repne scasb
	not	ecx
	dec	ecx
	or	eax, -1
	sub	eax, ecx
	mov	ecx, DWORD PTR ?sMemTotal@CCorString@@0KA ; CCorString::sMemTotal
	add	ecx, eax
	mov	DWORD PTR ?sMemTotal@CCorString@@0KA, ecx ; CCorString::sMemTotal
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L44065:
	test	ebp, ebp
	mov	DWORD PTR [esi], 0
	je	SHORT $L44068
	mov	edi, ebp
	or	ecx, -1
	xor	eax, eax
	repne scasb
	not	ecx
	dec	ecx
	mov	edi, ecx
	inc	edi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	edi
	mov	ecx, eax
	call	DWORD PTR [edx]
	test	eax, eax
	mov	DWORD PTR [esi], eax
	je	SHORT $L44068
$L44062:
	mov	cl, BYTE PTR [ebp]
	inc	ebp
	mov	BYTE PTR [eax], cl
	inc	eax
	test	cl, cl
	jne	SHORT $L44062
	add	DWORD PTR ?sMemTotal@CCorString@@0KA, edi ; CCorString::sMemTotal
$L44068:
	mov	eax, DWORD PTR [ebx+4]
	lea	edx, DWORD PTR [ebx+12]
	mov	DWORD PTR [esi+4], eax
	mov	cl, BYTE PTR [ebx+8]
	mov	BYTE PTR [esi+8], cl
	push	edx
	lea	ecx, DWORD PTR [esi+12]
	call	??4?$TCorArray@VCCpjFrmGroup@@@@QAEAAV0@AAV0@@Z ; TCorArray<CCpjFrmGroup>::operator=
	lea	eax, DWORD PTR [ebx+28]
	lea	ecx, DWORD PTR [esi+28]
	push	eax
	call	??4?$TCorArray@VCCpjFrmBytePos@@@@QAEAAV0@AAV0@@Z ; TCorArray<CCpjFrmBytePos>::operator=
	lea	ecx, DWORD PTR [ebx+44]
	push	ecx
	lea	ecx, DWORD PTR [esi+44]
	call	??4?$TCorArray@VVVec3@@@@QAEAAV0@AAV0@@Z ; TCorArray<VVec3>::operator=
	lea	ecx, DWORD PTR [ebx+60]
	lea	eax, DWORD PTR [esi+64]
	sub	ebx, esi
	mov	edx, 2
$L9217:
	mov	edi, DWORD PTR [ecx]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR [eax-4], edi
	mov	edi, DWORD PTR [ebx+eax]
	mov	DWORD PTR [eax], edi
	mov	edi, DWORD PTR [ecx-4]
	mov	DWORD PTR [eax+4], edi
	add	eax, 12					; 0000000cH
	dec	edx
	jne	SHORT $L9217
	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	4
??4CCpjFrmFrame@@QAEAAV0@AAV0@@Z ENDP			; CCpjFrmFrame::operator=
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??4?$TCorArray@VCCpjFrmGroup@@@@QAEAAV0@AAV0@@Z
_TEXT	SEGMENT
_i$ = 8
_inArray$ = 8
??4?$TCorArray@VCCpjFrmGroup@@@@QAEAAV0@AAV0@@Z PROC NEAR ; TCorArray<CCpjFrmGroup>::operator=, COMDAT
; _this$ = ecx

; 269  : 	{

	push	ebp

; 270  : 		if (this == &inArray)

	mov	ebp, DWORD PTR _inArray$[esp]
	push	esi
	mov	esi, ecx
	cmp	esi, ebp

; 271  : 			return(*this);

	je	$L44130
	push	ebx

; 272  : 		m_Count = 0;

	xor	ebx, ebx
	mov	DWORD PTR [esi+4], ebx

; 273  : 		m_Limit = inArray.m_Count;

	mov	eax, DWORD PTR [ebp+4]
	mov	DWORD PTR [esi+8], eax

; 274  : 		Realloc(sizeof(T));

	mov	eax, DWORD PTR [esi]
	cmp	eax, ebx
	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [esi+12], 24			; 00000018H
	je	$L44090
	cmp	eax, ebx
	je	SHORT $L44092
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [esi+8]
	push	ecx
	mov	ecx, DWORD PTR [esi]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+4]
	mov	DWORD PTR [esi], eax
	jmp	SHORT $L44097
$L44092:
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L44096:
	mov	DWORD PTR [esi], ebx
$L44097:

; 275  : 		for (NDword i=0;i<inArray.m_Count;i++)

	mov	eax, DWORD PTR [ebp+4]
	mov	DWORD PTR _i$[esp+8], ebx
	cmp	eax, ebx
	jbe	SHORT $L13991
	push	edi
$L13989:

; 276  : 			new(&(*this)[AddNoConstruct()]) T(inArray[i]);

	mov	edi, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	lea	eax, DWORD PTR [edi+1]
	cmp	eax, ecx
	mov	DWORD PTR [esi+4], eax
	jbe	SHORT $L44102
	mov	edx, eax
	push	24					; 00000018H
	shr	edx, 2
	mov	ecx, esi
	lea	eax, DWORD PTR [edx+eax+32]
	mov	DWORD PTR [esi+8], eax
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
$L44102:
	mov	edx, DWORD PTR [esi]
	lea	ecx, DWORD PTR [edi+edi*2]
	lea	ecx, DWORD PTR [edx+ecx*8]
	test	ecx, ecx
	je	SHORT $L44084
	mov	eax, DWORD PTR [ebp]
	add	eax, ebx
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], edx
	mov	edx, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+16], edx
	mov	eax, DWORD PTR [eax+20]
	mov	DWORD PTR [ecx+20], eax
$L44084:
	mov	eax, DWORD PTR _i$[esp+12]
	mov	ecx, DWORD PTR [ebp+4]
	inc	eax
	add	ebx, 24					; 00000018H
	cmp	eax, ecx
	mov	DWORD PTR _i$[esp+12], eax
	jb	SHORT $L13989
	pop	edi
$L13991:
	pop	ebx
$L44130:

; 277  : 		return(*this);

	mov	eax, esi
	pop	esi
	pop	ebp

; 278  : 	}

	ret	4
$L44090:

; 274  : 		Realloc(sizeof(T));

	cmp	eax, ebx
	je	$L44096
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [esi+8]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	DWORD PTR [esi], eax
	jmp	$L44097
??4?$TCorArray@VCCpjFrmGroup@@@@QAEAAV0@AAV0@@Z ENDP	; TCorArray<CCpjFrmGroup>::operator=
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??4?$TCorArray@VCCpjFrmBytePos@@@@QAEAAV0@AAV0@@Z
_TEXT	SEGMENT
_inArray$ = 8
??4?$TCorArray@VCCpjFrmBytePos@@@@QAEAAV0@AAV0@@Z PROC NEAR ; TCorArray<CCpjFrmBytePos>::operator=, COMDAT
; _this$ = ecx

; 269  : 	{

	push	ebp

; 270  : 		if (this == &inArray)

	mov	ebp, DWORD PTR _inArray$[esp]
	push	esi
	mov	esi, ecx
	cmp	esi, ebp

; 271  : 			return(*this);

	je	$L44167
	push	ebx

; 272  : 		m_Count = 0;

	xor	ebx, ebx
	mov	DWORD PTR [esi+4], ebx

; 273  : 		m_Limit = inArray.m_Count;

	mov	eax, DWORD PTR [ebp+4]
	mov	DWORD PTR [esi+8], eax

; 274  : 		Realloc(sizeof(T));

	mov	eax, DWORD PTR [esi]
	cmp	eax, ebx
	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [esi+12], 4
	je	SHORT $L44143
	cmp	eax, ebx
	je	SHORT $L44145
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [esi+8]
	push	ecx
	mov	ecx, DWORD PTR [esi]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+4]
	mov	DWORD PTR [esi], eax
	jmp	SHORT $L44150
$L44145:
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L44149:
	mov	DWORD PTR [esi], ebx
$L44150:

; 275  : 		for (NDword i=0;i<inArray.m_Count;i++)

	cmp	DWORD PTR [ebp+4], ebx
	jbe	SHORT $L14026
	push	edi
$L14024:

; 276  : 			new(&(*this)[AddNoConstruct()]) T(inArray[i]);

	mov	edi, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	lea	eax, DWORD PTR [edi+1]
	cmp	eax, ecx
	mov	DWORD PTR [esi+4], eax
	jbe	SHORT $L44155
	mov	edx, eax
	push	4
	shr	edx, 2
	mov	ecx, esi
	lea	eax, DWORD PTR [edx+eax+32]
	mov	DWORD PTR [esi+8], eax
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
$L44155:
	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ecx+edi*4]
	test	eax, eax
	je	SHORT $L44137
	mov	edx, DWORD PTR [ebp]
	mov	ecx, DWORD PTR [edx+ebx*4]
	mov	DWORD PTR [eax], ecx
$L44137:
	mov	eax, DWORD PTR [ebp+4]
	inc	ebx
	cmp	ebx, eax
	jb	SHORT $L14024
	pop	edi
$L14026:
	pop	ebx
$L44167:

; 277  : 		return(*this);

	mov	eax, esi
	pop	esi
	pop	ebp

; 278  : 	}

	ret	4
$L44143:

; 274  : 		Realloc(sizeof(T));

	cmp	eax, ebx
	je	SHORT $L44149
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [esi+8]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	DWORD PTR [esi], eax
	jmp	SHORT $L44150
??4?$TCorArray@VCCpjFrmBytePos@@@@QAEAAV0@AAV0@@Z ENDP	; TCorArray<CCpjFrmBytePos>::operator=
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??4?$TCorArray@VVVec3@@@@QAEAAV0@AAV0@@Z
_TEXT	SEGMENT
_i$ = 8
_inArray$ = 8
??4?$TCorArray@VVVec3@@@@QAEAAV0@AAV0@@Z PROC NEAR	; TCorArray<VVec3>::operator=, COMDAT
; _this$ = ecx

; 269  : 	{

	push	ebp

; 270  : 		if (this == &inArray)

	mov	ebp, DWORD PTR _inArray$[esp]
	push	esi
	mov	esi, ecx
	cmp	esi, ebp

; 271  : 			return(*this);

	je	$L44208
	push	ebx

; 272  : 		m_Count = 0;

	xor	ebx, ebx
	mov	DWORD PTR [esi+4], ebx

; 273  : 		m_Limit = inArray.m_Count;

	mov	eax, DWORD PTR [ebp+4]
	mov	DWORD PTR [esi+8], eax

; 274  : 		Realloc(sizeof(T));

	mov	eax, DWORD PTR [esi]
	cmp	eax, ebx
	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [esi+12], 12			; 0000000cH
	je	$L44180
	cmp	eax, ebx
	je	SHORT $L44182
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [esi+8]
	push	ecx
	mov	ecx, DWORD PTR [esi]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+4]
	mov	DWORD PTR [esi], eax
	jmp	SHORT $L44187
$L44182:
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L44186:
	mov	DWORD PTR [esi], ebx
$L44187:

; 275  : 		for (NDword i=0;i<inArray.m_Count;i++)

	mov	eax, DWORD PTR [ebp+4]
	mov	DWORD PTR _i$[esp+8], ebx
	cmp	eax, ebx
	jbe	SHORT $L14061
	push	edi
$L14059:

; 276  : 			new(&(*this)[AddNoConstruct()]) T(inArray[i]);

	mov	edi, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	lea	eax, DWORD PTR [edi+1]
	cmp	eax, ecx
	mov	DWORD PTR [esi+4], eax
	jbe	SHORT $L44192
	mov	edx, eax
	push	12					; 0000000cH
	shr	edx, 2
	mov	ecx, esi
	lea	eax, DWORD PTR [edx+eax+32]
	mov	DWORD PTR [esi+8], eax
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
$L44192:
	mov	edx, DWORD PTR [esi]
	lea	ecx, DWORD PTR [edi+edi*2]
	lea	ecx, DWORD PTR [edx+ecx*4]
	test	ecx, ecx
	je	SHORT $L44174
	mov	eax, DWORD PTR [ebp]
	add	eax, ebx
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
$L44174:
	mov	eax, DWORD PTR _i$[esp+12]
	mov	ecx, DWORD PTR [ebp+4]
	inc	eax
	add	ebx, 12					; 0000000cH
	cmp	eax, ecx
	mov	DWORD PTR _i$[esp+12], eax
	jb	SHORT $L14059
	pop	edi
$L14061:
	pop	ebx
$L44208:

; 277  : 		return(*this);

	mov	eax, esi
	pop	esi
	pop	ebp

; 278  : 	}

	ret	4
$L44180:

; 274  : 		Realloc(sizeof(T));

	cmp	eax, ebx
	je	SHORT $L44186
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [esi+8]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	DWORD PTR [esi], eax
	jmp	$L44187
??4?$TCorArray@VVVec3@@@@QAEAAV0@AAV0@@Z ENDP		; TCorArray<VVec3>::operator=
_TEXT	ENDS
PUBLIC	??1CCpjFrmFrame@@QAE@XZ				; CCpjFrmFrame::~CCpjFrmFrame
;	COMDAT xdata$x
xdata$x	SEGMENT
$T44360	DD	0ffffffffH
	DD	FLAT:$L44212
	DD	00H
	DD	FLAT:$L44213
	DD	01H
	DD	FLAT:$L44214
$T44350	DD	019930520H
	DD	03H
	DD	FLAT:$T44360
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ??1CCpjFrmFrame@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16
__$EHRec$ = -12
??1CCpjFrmFrame@@QAE@XZ PROC NEAR			; CCpjFrmFrame::~CCpjFrmFrame, COMDAT
; _this$ = ecx
	push	-1
	push	$L44359
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	push	esi
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+24], esi
	mov	eax, DWORD PTR [esi+48]
	lea	edi, DWORD PTR [esi+44]
	push	12					; 0000000cH
	push	eax
	push	0
	mov	ecx, edi
	mov	DWORD PTR __$EHRec$[esp+44], 2
	call	?Remove@CCorArray@@QAEXKKK@Z		; CCorArray::Remove
	cmp	DWORD PTR [edi], 0
	je	SHORT $L44250
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L44250:
	mov	eax, DWORD PTR [esi+32]
	lea	edi, DWORD PTR [esi+28]
	push	4
	push	eax
	push	0
	mov	ecx, edi
	mov	BYTE PTR __$EHRec$[esp+44], 1
	call	?Remove@CCorArray@@QAEXKKK@Z		; CCorArray::Remove
	cmp	DWORD PTR [edi], 0
	je	SHORT $L44287
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L44287:
	mov	eax, DWORD PTR [esi+16]
	lea	edi, DWORD PTR [esi+12]
	push	24					; 00000018H
	push	eax
	push	0
	mov	ecx, edi
	mov	BYTE PTR __$EHRec$[esp+44], 0
	call	?Remove@CCorArray@@QAEXKKK@Z		; CCorArray::Remove
	cmp	DWORD PTR [edi], 0
	je	SHORT $L44324
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L44324:
	mov	edi, DWORD PTR [esi]
	mov	DWORD PTR __$EHRec$[esp+32], -1
	test	edi, edi
	je	SHORT $L44358
	or	ecx, -1
	xor	eax, eax
	repne scasb
	mov	eax, DWORD PTR ?sMemTotal@CCorString@@0KA ; CCorString::sMemTotal
	or	edx, -1
	not	ecx
	dec	ecx
	sub	edx, ecx
	add	eax, edx
	mov	DWORD PTR ?sMemTotal@CCorString@@0KA, eax ; CCorString::sMemTotal
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L44358:
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR [esi], 0
	pop	edi
	pop	esi
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L44212:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CCorString@@QAE@XZ			; CCorString::~CCorString
$L44213:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	jmp	??1?$TCorArray@VCCpjFrmGroup@@@@QAE@XZ	; TCorArray<CCpjFrmGroup>::~TCorArray<CCpjFrmGroup>
$L44214:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	jmp	??1?$TCorArray@VCCpjFrmBytePos@@@@QAE@XZ ; TCorArray<CCpjFrmBytePos>::~TCorArray<CCpjFrmBytePos>
$L44359:
	mov	eax, OFFSET FLAT:$T44350
	jmp	___CxxFrameHandler
text$x	ENDS
??1CCpjFrmFrame@@QAE@XZ ENDP				; CCpjFrmFrame::~CCpjFrmFrame
PUBLIC	??_H@YGXPAXIHP6EX0@Z@Z				; `vector constructor iterator'
; Function compile flags: /Ogty
;	COMDAT ??_H@YGXPAXIHP6EX0@Z@Z
_TEXT	SEGMENT
___t$ = 8
___s$ = 12
___n$ = 16
___f$ = 20
??_H@YGXPAXIHP6EX0@Z@Z PROC NEAR			; `vector constructor iterator', COMDAT
	mov	eax, DWORD PTR ___n$[esp-4]
	dec	eax
	js	SHORT $L9231
	push	ebx
	mov	ebx, DWORD PTR ___f$[esp]
	push	ebp
	mov	ebp, DWORD PTR ___s$[esp+4]
	push	esi
	mov	esi, DWORD PTR ___t$[esp+8]
	push	edi
	lea	edi, DWORD PTR [eax+1]
$L9230:
	mov	ecx, esi
	call	ebx
	add	esi, ebp
	dec	edi
	jne	SHORT $L9230
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
$L9231:
	ret	16					; 00000010H
??_H@YGXPAXIHP6EX0@Z@Z ENDP				; `vector constructor iterator'
; Function compile flags: /Ogty
; File C:\duke4\Cannibal\ObjMain.h
_TEXT	ENDS
;	COMDAT ??0?$TObjIter@VOCpjFrames@@@@QAE@PAVOObject@@_N@Z
_TEXT	SEGMENT
_inObj$ = 8
_inReverse$ = 12
??0?$TObjIter@VOCpjFrames@@@@QAE@PAVOObject@@_N@Z PROC NEAR ; TObjIter<OCpjFrames>::TObjIter<OCpjFrames>, COMDAT
; _this$ = ecx

; 392  : 	inline TObjIter(OObject* inObj, bool inReverse=false) : CObjIter(inObj, inReverse) { Reset(inObj,inReverse); }

	mov	edx, DWORD PTR _inObj$[esp-4]
	mov	al, BYTE PTR _inReverse$[esp-4]
	push	esi
	mov	esi, ecx
	test	edx, edx
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi], 0
	je	SHORT $L44457
	lea	ecx, DWORD PTR [edx+24]
	mov	BYTE PTR [esi+8], al
	test	al, al
	mov	DWORD PTR [esi], ecx
	je	SHORT $L44447
	mov	ecx, DWORD PTR [ecx+12]
	jmp	SHORT $L44667
$L44447:
	mov	ecx, DWORD PTR [ecx+8]
$L44667:
	test	al, al
	mov	DWORD PTR [esi+4], ecx
	mov	DWORD PTR [esi], ecx
	je	SHORT $L44456
	mov	ecx, DWORD PTR [ecx+12]
	jmp	SHORT $L44668
$L44456:
	mov	ecx, DWORD PTR [ecx+8]
$L44668:
	mov	DWORD PTR [esi+4], ecx
$L44457:
	test	edx, edx
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi], 0
	je	SHORT $L44657
	lea	ecx, DWORD PTR [edx+24]
	mov	BYTE PTR [esi+8], al
	test	al, al
	mov	DWORD PTR [esi], ecx
	je	SHORT $L44618
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [esi+4], edx
	jmp	SHORT $L44619
$L44618:
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [esi+4], ecx
$L44619:
	mov	ecx, DWORD PTR [esi+4]
	test	al, al
	mov	DWORD PTR [esi], ecx
	je	SHORT $L44627
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [esi+4], edx
	jmp	SHORT $L44657
$L44627:
	mov	eax, DWORD PTR [ecx+8]
$L44669:
	mov	DWORD PTR [esi+4], eax
$L44657:
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $L44666
	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $L44666
	mov	ecx, DWORD PTR ?staticObjClass@OCpjFrames@@0PAVCObjClass@@A ; OCpjFrames::staticObjClass
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+44]
	test	al, al
	jne	SHORT $L44666
	mov	cl, BYTE PTR [esi+8]
	mov	eax, DWORD PTR [esi+4]
	test	cl, cl
	mov	DWORD PTR [esi], eax
	je	SHORT $L44649
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [esi+4], edx
	jmp	SHORT $L44657
$L44649:
	mov	eax, DWORD PTR [eax+8]
	jmp	SHORT $L44669
$L44666:
	mov	eax, esi
	pop	esi
	ret	8
??0?$TObjIter@VOCpjFrames@@@@QAE@PAVOObject@@_N@Z ENDP	; TObjIter<OCpjFrames>::TObjIter<OCpjFrames>
_TEXT	ENDS
PUBLIC	??2OCpjFrames@@CAPAXIPAVOObject@@PAVCObjClass@@@Z ; OCpjFrames::operator new
; Function compile flags: /Ogty
; File C:\duke4\Cannibal\CpjFrm.h
;	COMDAT ??2OCpjFrames@@CAPAXIPAVOObject@@PAVCObjClass@@@Z
_TEXT	SEGMENT
_inParent$ = 12
_inSetClass$ = 16
??2OCpjFrames@@CAPAXIPAVOObject@@PAVCObjClass@@@Z PROC NEAR ; OCpjFrames::operator new, COMDAT

; 69   : 	OBJ_CLASS_DEFINE(OCpjFrames, OCpjChunk);

	push	esi
	push	edi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	112					; 00000070H
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	ecx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	mov	esi, eax
	inc	ecx
	xor	eax, eax
	mov	DWORD PTR ?sObjCount@OObject@@1KA, ecx	; OObject::sObjCount
	mov	ecx, 28					; 0000001cH
	mov	edi, esi
	rep stosd
	mov	eax, DWORD PTR [esi+40]
	mov	DWORD PTR [esi+4], 305419896		; 12345678H
	test	eax, eax
	jne	SHORT $L44679
	mov	eax, DWORD PTR _inSetClass$[esp+4]
	mov	DWORD PTR [esi+40], eax
$L44679:
	mov	ecx, DWORD PTR _inParent$[esp+4]
	push	ecx
	mov	ecx, esi
	call	?PreConstruct@OObject@@QAEXPAV1@@Z	; OObject::PreConstruct
	mov	eax, esi
	pop	edi
	pop	esi
	ret	0
??2OCpjFrames@@CAPAXIPAVOObject@@PAVCObjClass@@@Z ENDP	; OCpjFrames::operator new
_TEXT	ENDS
PUBLIC	??3OCpjFrames@@CAXPAX@Z				; OCpjFrames::operator delete
; Function compile flags: /Ogty
;	COMDAT ??3OCpjFrames@@CAXPAX@Z
_TEXT	SEGMENT
_ptr$ = 8
??3OCpjFrames@@CAXPAX@Z PROC NEAR			; OCpjFrames::operator delete, COMDAT

; 69   : 	OBJ_CLASS_DEFINE(OCpjFrames, OCpjChunk);

	push	esi
	mov	esi, DWORD PTR _ptr$[esp]
	mov	DWORD PTR [esi+4], 0
	mov	edx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	dec	edx
	mov	DWORD PTR ?sObjCount@OObject@@1KA, edx	; OObject::sObjCount
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	ecx, eax
	call	DWORD PTR [edx+8]
	pop	esi
	ret	0
??3OCpjFrames@@CAXPAX@Z ENDP				; OCpjFrames::operator delete
_TEXT	ENDS
PUBLIC	??3OCpjFrames@@CAXPAXPAVOObject@@PAVCObjClass@@@Z ; OCpjFrames::operator delete
; Function compile flags: /Ogty
;	COMDAT ??3OCpjFrames@@CAXPAXPAVOObject@@PAVCObjClass@@@Z
_TEXT	SEGMENT
_ptr$ = 8
??3OCpjFrames@@CAXPAXPAVOObject@@PAVCObjClass@@@Z PROC NEAR ; OCpjFrames::operator delete, COMDAT

; 69   : 	OBJ_CLASS_DEFINE(OCpjFrames, OCpjChunk);

	push	esi
	mov	esi, DWORD PTR _ptr$[esp]
	mov	DWORD PTR [esi+4], 0
	mov	edx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	dec	edx
	mov	DWORD PTR ?sObjCount@OObject@@1KA, edx	; OObject::sObjCount
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	ecx, eax
	call	DWORD PTR [edx+8]
	pop	esi
	ret	0
??3OCpjFrames@@CAXPAXPAVOObject@@PAVCObjClass@@@Z ENDP	; OCpjFrames::operator delete
; Function compile flags: /Ogty
; File C:\duke4\Cannibal\ObjMain.h
_TEXT	ENDS
;	COMDAT ??0?$TObjIter@VOCpjSequence@@@@QAE@PAVOObject@@_N@Z
_TEXT	SEGMENT
_inObj$ = 8
_inReverse$ = 12
??0?$TObjIter@VOCpjSequence@@@@QAE@PAVOObject@@_N@Z PROC NEAR ; TObjIter<OCpjSequence>::TObjIter<OCpjSequence>, COMDAT
; _this$ = ecx

; 392  : 	inline TObjIter(OObject* inObj, bool inReverse=false) : CObjIter(inObj, inReverse) { Reset(inObj,inReverse); }

	mov	edx, DWORD PTR _inObj$[esp-4]
	mov	al, BYTE PTR _inReverse$[esp-4]
	push	esi
	mov	esi, ecx
	test	edx, edx
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi], 0
	je	SHORT $L44785
	lea	ecx, DWORD PTR [edx+24]
	mov	BYTE PTR [esi+8], al
	test	al, al
	mov	DWORD PTR [esi], ecx
	je	SHORT $L44774
	mov	ecx, DWORD PTR [ecx+12]
	jmp	SHORT $L44997
$L44774:
	mov	ecx, DWORD PTR [ecx+8]
$L44997:
	test	al, al
	mov	DWORD PTR [esi+4], ecx
	mov	DWORD PTR [esi], ecx
	je	SHORT $L44784
	mov	ecx, DWORD PTR [ecx+12]
	jmp	SHORT $L44998
$L44784:
	mov	ecx, DWORD PTR [ecx+8]
$L44998:
	mov	DWORD PTR [esi+4], ecx
$L44785:
	test	edx, edx
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi], 0
	je	SHORT $L44986
	lea	ecx, DWORD PTR [edx+24]
	mov	BYTE PTR [esi+8], al
	test	al, al
	mov	DWORD PTR [esi], ecx
	je	SHORT $L44948
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [esi+4], edx
	jmp	SHORT $L44949
$L44948:
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [esi+4], ecx
$L44949:
	mov	ecx, DWORD PTR [esi+4]
	test	al, al
	mov	DWORD PTR [esi], ecx
	je	SHORT $L44957
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [esi+4], edx
	jmp	SHORT $L44986
$L44957:
	mov	eax, DWORD PTR [ecx+8]
$L44999:
	mov	DWORD PTR [esi+4], eax
$L44986:
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $L44996
	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $L44996
	mov	ecx, DWORD PTR ?staticObjClass@OCpjSequence@@0PAVCObjClass@@A ; OCpjSequence::staticObjClass
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+44]
	test	al, al
	jne	SHORT $L44996
	mov	cl, BYTE PTR [esi+8]
	mov	eax, DWORD PTR [esi+4]
	test	cl, cl
	mov	DWORD PTR [esi], eax
	je	SHORT $L44982
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [esi+4], edx
	jmp	SHORT $L44986
$L44982:
	mov	eax, DWORD PTR [eax+8]
	jmp	SHORT $L44999
$L44996:
	mov	eax, esi
	pop	esi
	ret	8
??0?$TObjIter@VOCpjSequence@@@@QAE@PAVOObject@@_N@Z ENDP ; TObjIter<OCpjSequence>::TObjIter<OCpjSequence>
_TEXT	ENDS
PUBLIC	?GetStaticClass@OCpjFrames@@SAPAVCObjClass@@XZ	; OCpjFrames::GetStaticClass
; Function compile flags: /Ogty
; File C:\duke4\Cannibal\CpjFrm.h
;	COMDAT ?GetStaticClass@OCpjFrames@@SAPAVCObjClass@@XZ
_TEXT	SEGMENT
?GetStaticClass@OCpjFrames@@SAPAVCObjClass@@XZ PROC NEAR ; OCpjFrames::GetStaticClass, COMDAT

; 69   : 	OBJ_CLASS_DEFINE(OCpjFrames, OCpjChunk);

	mov	eax, DWORD PTR ?staticObjClass@OCpjFrames@@0PAVCObjClass@@A ; OCpjFrames::staticObjClass
	ret	0
?GetStaticClass@OCpjFrames@@SAPAVCObjClass@@XZ ENDP	; OCpjFrames::GetStaticClass
_TEXT	ENDS
PUBLIC	?New@OCpjFrames@@SAPAV1@PAVOObject@@PAVCObjClass@@@Z ; OCpjFrames::New
PUBLIC	?GetClass@OCpjFrames@@UAEPAVCObjClass@@XZ	; OCpjFrames::GetClass
PUBLIC	?Create@OCpjFrames@@UAEXXZ			; OCpjFrames::Create
PUBLIC	?GetFileExtension@OCpjFrames@@UAEPADXZ		; OCpjFrames::GetFileExtension
PUBLIC	?GetFileDescription@OCpjFrames@@UAEPADXZ	; OCpjFrames::GetFileDescription
PUBLIC	??_7OCpjFrames@@6B@				; OCpjFrames::`vftable'
PUBLIC	??_EOCpjFrames@@UAEPAXI@Z			; OCpjFrames::`vector deleting destructor'
EXTRN	?LoadChunk@OCpjFrames@@UAE_NPAXK@Z:NEAR		; OCpjFrames::LoadChunk
EXTRN	?SaveChunk@OCpjFrames@@UAE_NPAXPAK@Z:NEAR	; OCpjFrames::SaveChunk
EXTRN	?GetFourCC@OCpjFrames@@UAEKXZ:NEAR		; OCpjFrames::GetFourCC
;	COMDAT xdata$x
; File C:\duke4\Cannibal\CorMain.h
xdata$x	SEGMENT
$T45132	DD	0ffffffffH
	DD	FLAT:$L45010
	DD	00H
	DD	FLAT:$L45035
$T45128	DD	019930520H
	DD	02H
	DD	FLAT:$T45132
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_7OCpjFrames@@6B@
CONST	SEGMENT
??_7OCpjFrames@@6B@ DD FLAT:?Msg@OObject@@UAE_NPAVIMsg@@@Z ; OCpjFrames::`vftable'
	DD	FLAT:?MsgGetChild@OObject@@UAEPAVIMsgTarget@@PAD@Z
	DD	FLAT:?MsgGetParent@OObject@@UAEPAVIMsgTarget@@XZ
	DD	FLAT:?MsgGetRoot@OObject@@UAEPAVIMsgTarget@@XZ
	DD	FLAT:?GetClass@OCpjFrames@@UAEPAVCObjClass@@XZ
	DD	FLAT:??_EOCpjFrames@@UAEPAXI@Z
	DD	FLAT:?Create@OCpjFrames@@UAEXXZ
	DD	FLAT:?Destroy@OObject@@UAEXXZ
	DD	FLAT:?GetParent@OObject@@UAEPAV1@XZ
	DD	FLAT:?SetParent@OObject@@UAEXPAV1@_N@Z
	DD	FLAT:?HasChildren@OObject@@UAE_NXZ
	DD	FLAT:?IsA@OObject@@UAE_NPAVCObjClass@@@Z
	DD	FLAT:?GetFileExtension@OCpjFrames@@UAEPADXZ
	DD	FLAT:?GetFileDescription@OCpjFrames@@UAEPADXZ
	DD	FLAT:?LoadFile@OCpjChunk@@UAE_NPAD@Z
	DD	FLAT:?SaveFile@OCpjChunk@@UAE_NPAD@Z
	DD	FLAT:?GetFourCC@OCpjFrames@@UAEKXZ
	DD	FLAT:?LoadChunk@OCpjFrames@@UAE_NPAXK@Z
	DD	FLAT:?SaveChunk@OCpjFrames@@UAE_NPAXPAK@Z
; Function compile flags: /Ogty
; File C:\duke4\Cannibal\CpjFrm.h
CONST	ENDS
;	COMDAT ?New@OCpjFrames@@SAPAV1@PAVOObject@@PAVCObjClass@@@Z
_TEXT	SEGMENT
_inParent$ = 8
_inSetClass$ = 12
$T45007 = -16
__$EHRec$ = -12
?New@OCpjFrames@@SAPAV1@PAVOObject@@PAVCObjClass@@@Z PROC NEAR ; OCpjFrames::New, COMDAT

; 69   : 	OBJ_CLASS_DEFINE(OCpjFrames, OCpjChunk);

	push	-1
	push	$L45131
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	push	ebx
	mov	ebx, DWORD PTR _inSetClass$[esp+16]
	push	ebp
	xor	ebp, ebp
	cmp	ebx, ebp
	push	esi
	jne	SHORT $L9338
	mov	ebx, DWORD PTR ?staticObjClass@OCpjFrames@@0PAVCObjClass@@A ; OCpjFrames::staticObjClass
	mov	DWORD PTR _inSetClass$[esp+24], ebx
$L9338:
	push	edi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	112					; 00000070H
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	ecx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	mov	esi, eax
	inc	ecx
	xor	eax, eax
	mov	DWORD PTR ?sObjCount@OObject@@1KA, ecx	; OObject::sObjCount
	mov	ecx, 28					; 0000001cH
	mov	edi, esi
	rep stosd
	mov	eax, DWORD PTR [esi+40]
	mov	DWORD PTR [esi+4], 305419896		; 12345678H
	cmp	eax, ebp
	pop	edi
	jne	SHORT $L45032
	mov	DWORD PTR [esi+40], ebx
$L45032:
	mov	eax, DWORD PTR _inParent$[esp+24]
	mov	ecx, esi
	push	eax
	call	?PreConstruct@OObject@@QAEXPAV1@@Z	; OObject::PreConstruct
	mov	DWORD PTR $T45007[esp+28], esi
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+36], ebp
	call	??0OObject@@QAE@XZ			; OObject::OObject
	mov	DWORD PTR [esi+100], ebp
	mov	DWORD PTR [esi+104], ebp
	mov	DWORD PTR [esi+108], 84			; 00000054H
	mov	DWORD PTR [esi+96], ebp
	mov	DWORD PTR [esi], OFFSET FLAT:??_7OCpjFrames@@6B@ ; OCpjFrames::`vftable'
	mov	edx, DWORD PTR [esi]
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+36], -1
	call	DWORD PTR [edx+24]
	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L45010:
	mov	eax, DWORD PTR _inSetClass$[ebp-4]
	push	eax
	mov	ecx, DWORD PTR _inParent$[ebp-4]
	push	ecx
	mov	edx, DWORD PTR $T45007[ebp]
	push	edx
	call	??3OCpjFrames@@CAXPAXPAVOObject@@PAVCObjClass@@@Z ; OCpjFrames::operator delete
	add	esp, 12					; 0000000cH
	ret	0
$L45035:
	mov	ecx, DWORD PTR $T45007[ebp]
	jmp	??1OCpjChunk@@UAE@XZ			; OCpjChunk::~OCpjChunk
$L45131:
	mov	eax, OFFSET FLAT:$T45128
	jmp	___CxxFrameHandler
text$x	ENDS
?New@OCpjFrames@@SAPAV1@PAVOObject@@PAVCObjClass@@@Z ENDP ; OCpjFrames::New
; Function compile flags: /Ogty
;	COMDAT ?GetClass@OCpjFrames@@UAEPAVCObjClass@@XZ
_TEXT	SEGMENT
?GetClass@OCpjFrames@@UAEPAVCObjClass@@XZ PROC NEAR	; OCpjFrames::GetClass, COMDAT
; _this$ = ecx

; 69   : 	OBJ_CLASS_DEFINE(OCpjFrames, OCpjChunk);

	mov	eax, DWORD PTR [ecx+40]
	ret	0
?GetClass@OCpjFrames@@UAEPAVCObjClass@@XZ ENDP		; OCpjFrames::GetClass
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?Create@OCpjFrames@@UAEXXZ
_TEXT	SEGMENT
?Create@OCpjFrames@@UAEXXZ PROC NEAR			; OCpjFrames::Create, COMDAT
; _this$ = ecx

; 75   : 	{

	push	esi
	mov	esi, ecx

; 76   : 		Super::Create();

	call	?Create@OObject@@UAEXXZ			; OObject::Create
	xor	eax, eax
	mov	BYTE PTR [esi+56], al
	mov	DWORD PTR [esi+64], eax
	mov	DWORD PTR [esi+60], eax
	mov	DWORD PTR [esi+68], eax

; 77   : 
; 78   : 		m_Bounds[0] = VVec3(FLT_MAX,FLT_MAX,FLT_MAX);

	mov	eax, 2139095039				; 7f7fffffH
	mov	DWORD PTR [esi+72], eax
	mov	DWORD PTR [esi+76], eax
	mov	DWORD PTR [esi+80], eax

; 79   : 		m_Bounds[1] = VVec3(-FLT_MAX,-FLT_MAX,-FLT_MAX);

	mov	eax, -8388609				; ff7fffffH
	mov	DWORD PTR [esi+84], eax
	mov	DWORD PTR [esi+88], eax
	mov	DWORD PTR [esi+92], eax
	pop	esi

; 80   : 	}

	ret	0
?Create@OCpjFrames@@UAEXXZ ENDP				; OCpjFrames::Create
; Function compile flags: /Ogty
; File C:\duke4\Cannibal\CorMain.h
_TEXT	ENDS
;	COMDAT ??1?$TCorArray@PAVOCpjProject@@@@QAE@XZ
_TEXT	SEGMENT
??1?$TCorArray@PAVOCpjProject@@@@QAE@XZ PROC NEAR	; TCorArray<OCpjProject *>::~TCorArray<OCpjProject *>, COMDAT
; _this$ = ecx

; 280  : 	{

	push	esi
	mov	esi, ecx
	push	edi

; 281  : 		Purge();

	mov	edi, DWORD PTR [esi+4]
	test	edi, edi
	je	SHORT $L45188
	mov	eax, DWORD PTR [esi]
	mov	ecx, edi
	sub	ecx, edi
	shl	ecx, 2
	lea	edx, DWORD PTR [eax+edi*4]
	push	ecx
	push	edx
	push	eax
	call	DWORD PTR __imp__memmove
	mov	eax, DWORD PTR [esi+4]
	add	esp, 12					; 0000000cH
	sub	eax, edi
	mov	DWORD PTR [esi+4], eax
$L45188:

; 282  : 	}

	cmp	DWORD PTR [esi], 0
	je	SHORT $L45194
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L45194:
	pop	edi
	pop	esi
	ret	0
??1?$TCorArray@PAVOCpjProject@@@@QAE@XZ ENDP		; TCorArray<OCpjProject *>::~TCorArray<OCpjProject *>
_TEXT	ENDS
PUBLIC	??_C@_03LAFA@frm?$AA@				; `string'
;	COMDAT ??_C@_03LAFA@frm?$AA@
; File C:\duke4\Cannibal\CpjFrm.h
_DATA	SEGMENT
??_C@_03LAFA@frm?$AA@ DB 'frm', 00H			; `string'
; Function compile flags: /Ogty
_DATA	ENDS
;	COMDAT ?GetFileExtension@OCpjFrames@@UAEPADXZ
_TEXT	SEGMENT
?GetFileExtension@OCpjFrames@@UAEPADXZ PROC NEAR	; OCpjFrames::GetFileExtension, COMDAT
; _this$ = ecx

; 90   : 	NChar* GetFileExtension() { return("frm"); }

	mov	eax, OFFSET FLAT:??_C@_03LAFA@frm?$AA@	; `string'
	ret	0
?GetFileExtension@OCpjFrames@@UAEPADXZ ENDP		; OCpjFrames::GetFileExtension
_TEXT	ENDS
PUBLIC	??_C@_0BH@NIOG@Cannibal?5Vertex?5Frames?$AA@	; `string'
;	COMDAT ??_C@_0BH@NIOG@Cannibal?5Vertex?5Frames?$AA@
_DATA	SEGMENT
??_C@_0BH@NIOG@Cannibal?5Vertex?5Frames?$AA@ DB 'Cannibal Vertex Frames', 00H ; `string'
; Function compile flags: /Ogty
_DATA	ENDS
;	COMDAT ?GetFileDescription@OCpjFrames@@UAEPADXZ
_TEXT	SEGMENT
?GetFileDescription@OCpjFrames@@UAEPADXZ PROC NEAR	; OCpjFrames::GetFileDescription, COMDAT
; _this$ = ecx

; 91   : 	NChar* GetFileDescription() { return("Cannibal Vertex Frames"); }

	mov	eax, OFFSET FLAT:??_C@_0BH@NIOG@Cannibal?5Vertex?5Frames?$AA@ ; `string'
	ret	0
?GetFileDescription@OCpjFrames@@UAEPADXZ ENDP		; OCpjFrames::GetFileDescription
_TEXT	ENDS
PUBLIC	??0OCpjFrames@@QAE@XZ				; OCpjFrames::OCpjFrames
;	COMDAT xdata$x
xdata$x	SEGMENT
$T45277	DD	0ffffffffH
	DD	FLAT:$L45206
$T45273	DD	019930520H
	DD	01H
	DD	FLAT:$T45277
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ??0OCpjFrames@@QAE@XZ
_TEXT	SEGMENT
_this$ = -32
__$EHRec$ = -12
??0OCpjFrames@@QAE@XZ PROC NEAR				; OCpjFrames::OCpjFrames, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR fs:__except_list
	push	-1
	push	$L45276
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	esi
	mov	esi, ecx
	call	??0OObject@@QAE@XZ			; OObject::OObject
	mov	ecx, DWORD PTR __$EHRec$[esp+16]
	xor	eax, eax
	mov	DWORD PTR [esi+100], eax
	mov	DWORD PTR [esi+104], eax
	mov	DWORD PTR [esi+108], 84			; 00000054H
	mov	DWORD PTR [esi+96], eax
	mov	DWORD PTR [esi], OFFSET FLAT:??_7OCpjFrames@@6B@ ; OCpjFrames::`vftable'
	mov	eax, esi
	mov	DWORD PTR fs:__except_list, ecx
	pop	esi
	add	esp, 12					; 0000000cH
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L45206:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1OCpjChunk@@UAE@XZ			; OCpjChunk::~OCpjChunk
$L45276:
	mov	eax, OFFSET FLAT:$T45273
	jmp	___CxxFrameHandler
text$x	ENDS
??0OCpjFrames@@QAE@XZ ENDP				; OCpjFrames::OCpjFrames
;	COMDAT xdata$x
xdata$x	SEGMENT
$T45400	DD	0ffffffffH
	DD	FLAT:$L45296
	DD	0ffffffffH
	DD	FLAT:$L45283
	DD	01H
	DD	FLAT:$L45347
$T45393	DD	019930520H
	DD	03H
	DD	FLAT:$T45400
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ??0CCpjGeoVert@@QAE@AAV0@@Z
_TEXT	SEGMENT
___that$ = 8
_this$ = -20
_i$45317 = 8
$T45339 = -16
_i$45368 = 8
$T45390 = -16
__$EHRec$ = -12
??0CCpjGeoVert@@QAE@AAV0@@Z PROC NEAR			; CCpjGeoVert::CCpjGeoVert, COMDAT
; _this$ = ecx
	push	-1
	push	$L45399
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 8
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, DWORD PTR ___that$[esp+32]
	mov	ebx, ecx
	xor	ebp, ebp
	push	4
	mov	al, BYTE PTR [edi]
	lea	esi, DWORD PTR [ebx+16]
	mov	BYTE PTR [ebx], al
	mov	cl, BYTE PTR [edi+1]
	mov	BYTE PTR [ebx+1], cl
	mov	edx, DWORD PTR [edi+4]
	mov	DWORD PTR [ebx+4], edx
	mov	eax, DWORD PTR [edi+8]
	mov	DWORD PTR [ebx+8], eax
	mov	ecx, DWORD PTR [edi+12]
	mov	DWORD PTR [ebx+12], ecx
	mov	eax, DWORD PTR [edi+20]
	mov	ecx, esi
	mov	DWORD PTR _this$[esp+40], ebx
	mov	DWORD PTR $T45339[esp+40], esi
	mov	DWORD PTR [esi], ebp
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], 4
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
	mov	DWORD PTR [esi+4], ebp
	mov	eax, DWORD PTR [edi+20]
	xor	ecx, ecx
	cmp	eax, ebp
	mov	DWORD PTR __$EHRec$[esp+44], ebp
	mov	DWORD PTR _i$45317[esp+32], ecx
	jbe	SHORT $L45320
$L45318:
	mov	ebp, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi+8]
	lea	eax, DWORD PTR [ebp+1]
	cmp	eax, edx
	mov	DWORD PTR [esi+4], eax
	jbe	SHORT $L45332
	mov	edx, eax
	push	4
	shr	edx, 2
	mov	ecx, esi
	lea	eax, DWORD PTR [edx+eax+32]
	mov	DWORD PTR [esi+8], eax
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
	mov	ecx, DWORD PTR _i$45317[esp+32]
$L45332:
	mov	edx, DWORD PTR [esi]
	lea	eax, DWORD PTR [edx+ebp*4]
	test	eax, eax
	je	SHORT $L45325
	mov	edx, DWORD PTR [edi+16]
	mov	edx, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR [eax], edx
$L45325:
	mov	eax, DWORD PTR [edi+20]
	inc	ecx
	cmp	ecx, eax
	mov	DWORD PTR _i$45317[esp+32], ecx
	jb	SHORT $L45318
	xor	ebp, ebp
$L45320:
	mov	eax, DWORD PTR [edi+36]
	lea	esi, DWORD PTR [ebx+32]
	push	4
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+48], 1
	mov	DWORD PTR $T45390[esp+40], esi
	mov	DWORD PTR [esi], ebp
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], 4
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
	mov	DWORD PTR [esi+4], ebp
	mov	eax, DWORD PTR [edi+36]
	xor	ecx, ecx
	cmp	eax, ebp
	mov	BYTE PTR __$EHRec$[esp+44], 2
	mov	DWORD PTR _i$45368[esp+32], ecx
	jbe	SHORT $L45398
$L45369:
	mov	ebp, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi+8]
	lea	eax, DWORD PTR [ebp+1]
	cmp	eax, edx
	mov	DWORD PTR [esi+4], eax
	jbe	SHORT $L45383
	mov	ecx, eax
	push	4
	shr	ecx, 2
	lea	edx, DWORD PTR [ecx+eax+32]
	mov	ecx, esi
	mov	DWORD PTR [esi+8], edx
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
	mov	ecx, DWORD PTR _i$45368[esp+32]
$L45383:
	mov	eax, DWORD PTR [esi]
	lea	eax, DWORD PTR [eax+ebp*4]
	test	eax, eax
	je	SHORT $L45376
	mov	edx, DWORD PTR [edi+32]
	mov	edx, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR [eax], edx
$L45376:
	mov	eax, DWORD PTR [edi+36]
	inc	ecx
	cmp	ecx, eax
	mov	DWORD PTR _i$45368[esp+32], ecx
	jb	SHORT $L45369
$L45398:
	mov	ecx, DWORD PTR __$EHRec$[esp+36]
	pop	edi
	pop	esi
	mov	eax, ebx
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 20					; 00000014H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L45296:
	mov	ecx, DWORD PTR $T45339[ebp]
	jmp	??1CCorArray@@IAE@XZ			; CCorArray::~CCorArray
$L45283:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	jmp	??1?$TCorArray@PAVCCpjGeoEdge@@@@QAE@XZ	; TCorArray<CCpjGeoEdge *>::~TCorArray<CCpjGeoEdge *>
$L45347:
	mov	ecx, DWORD PTR $T45390[ebp]
	jmp	??1CCorArray@@IAE@XZ			; CCorArray::~CCorArray
$L45399:
	mov	eax, OFFSET FLAT:$T45393
	jmp	___CxxFrameHandler
text$x	ENDS
??0CCpjGeoVert@@QAE@AAV0@@Z ENDP			; CCpjGeoVert::CCpjGeoVert
PUBLIC	??0OCpjFrames@@QAE@AAV0@@Z			; OCpjFrames::OCpjFrames
PUBLIC	??0?$TCorArray@VCCpjFrmGroup@@@@QAE@AAV0@@Z	; TCorArray<CCpjFrmGroup>::TCorArray<CCpjFrmGroup>
PUBLIC	??0?$TCorArray@VCCpjFrmBytePos@@@@QAE@AAV0@@Z	; TCorArray<CCpjFrmBytePos>::TCorArray<CCpjFrmBytePos>
PUBLIC	??0?$TCorArray@VVVec3@@@@QAE@AAV0@@Z		; TCorArray<VVec3>::TCorArray<VVec3>
;	COMDAT xdata$x
xdata$x	SEGMENT
$T45542	DD	0ffffffffH
	DD	FLAT:$L45413
	DD	00H
	DD	FLAT:$L45414
	DD	0ffffffffH
	DD	FLAT:$L45406
	DD	02H
	DD	FLAT:$L45456
	DD	03H
	DD	FLAT:$L45457
	DD	04H
	DD	FLAT:$L45477
	DD	05H
	DD	FLAT:$L45478
	DD	06H
	DD	FLAT:$L45479
$T45534	DD	019930520H
	DD	08H
	DD	FLAT:$T45542
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ??0OCpjFrames@@QAE@AAV0@@Z
_TEXT	SEGMENT
___that$ = 8
_this$ = -24
$T45500 = -16
$T45501 = -20
_i$45527 = -32
$T45531 = -28
__$EHRec$ = -12
??0OCpjFrames@@QAE@AAV0@@Z PROC NEAR			; OCpjFrames::OCpjFrames, COMDAT
; _this$ = ecx
	push	-1
	push	$L45541
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 20					; 00000014H
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR ___that$[esp+36]
	mov	ebx, ecx
	push	esi
	push	edi
	mov	DWORD PTR [ebx], OFFSET FLAT:??_7IMsgTarget@@6B@ ; IMsgTarget::`vftable'
	mov	eax, DWORD PTR [ebp+4]
	lea	ecx, DWORD PTR [ebp+8]
	mov	DWORD PTR [ebx+4], eax
	lea	edx, DWORD PTR [ebx+8]
	mov	DWORD PTR _this$[esp+48], ebx
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], ecx
	lea	edx, DWORD PTR [ebp+24]
	lea	eax, DWORD PTR [ebx+24]
	mov	DWORD PTR __$EHRec$[esp+56], 0
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR [ebp+40]
	lea	ecx, DWORD PTR [ebx+44]
	mov	DWORD PTR [ebx+40], eax
	mov	BYTE PTR __$EHRec$[esp+56], 1
	mov	DWORD PTR [ecx], 0
	mov	edx, DWORD PTR [ebp+44]
	push	edx
	call	?Set@CCorString@@QAEXPAD@Z		; CCorString::Set
	mov	eax, DWORD PTR [ebp+48]
	mov	DWORD PTR [ebx+48], eax
	mov	ecx, DWORD PTR [ebp+52]
	mov	DWORD PTR [ebx+52], ecx
	mov	DWORD PTR [ebx], OFFSET FLAT:??_7OCpjRes@@6B@ ; OCpjRes::`vftable'
	mov	dl, BYTE PTR [ebp+56]
	mov	BYTE PTR [ebx+56], dl
	mov	eax, DWORD PTR [ebp+60]
	mov	DWORD PTR [ebx+60], eax
	mov	ecx, DWORD PTR [ebp+64]
	mov	DWORD PTR [ebx+64], ecx
	mov	edx, DWORD PTR [ebp+68]
	mov	DWORD PTR [ebx+68], edx
	mov	DWORD PTR [ebx], OFFSET FLAT:??_7OCpjChunk@@6B@ ; OCpjChunk::`vftable'
	lea	ecx, DWORD PTR [ebx+72]
	mov	edi, 2
	mov	eax, ecx
	mov	edx, ebx
	sub	eax, ebx
	mov	DWORD PTR __$EHRec$[esp+56], edi
	sub	edx, ebp
	lea	eax, DWORD PTR [eax+ebp+8]
$L9368:
	mov	esi, DWORD PTR [eax-8]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR [ecx], esi
	mov	esi, DWORD PTR [eax-16]
	mov	DWORD PTR [ecx+4], esi
	mov	esi, DWORD PTR [eax-12]
	mov	DWORD PTR [edx+eax-12], esi
	add	ecx, 12					; 0000000cH
	dec	edi
	jne	SHORT $L9368
	mov	eax, DWORD PTR [ebp+100]
	lea	edi, DWORD PTR [ebx+96]
	xor	esi, esi
	push	84					; 00000054H
	mov	ecx, edi
	mov	DWORD PTR $T45531[esp+52], edi
	mov	DWORD PTR [edi], esi
	mov	DWORD PTR [edi+4], eax
	mov	DWORD PTR [edi+8], eax
	mov	DWORD PTR [edi+12], 84			; 00000054H
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
	mov	DWORD PTR [edi+4], esi
	mov	eax, DWORD PTR [ebp+100]
	cmp	eax, esi
	mov	BYTE PTR __$EHRec$[esp+56], 3
	mov	DWORD PTR _i$45527[esp+48], esi
	jbe	$L45539
	mov	DWORD PTR 8+[esp+44], esi
$L45528:
	mov	esi, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi+8]
	lea	eax, DWORD PTR [esi+1]
	cmp	eax, ecx
	mov	DWORD PTR [edi+4], eax
	jbe	SHORT $L45508
	mov	ecx, eax
	push	84					; 00000054H
	shr	ecx, 2
	lea	edx, DWORD PTR [ecx+eax+32]
	mov	ecx, edi
	mov	DWORD PTR [edi+8], edx
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
$L45508:
	mov	ecx, DWORD PTR [edi]
	lea	eax, DWORD PTR [esi*8]
	sub	eax, esi
	lea	eax, DWORD PTR [eax+eax*2]
	lea	esi, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR $T45501[esp+48], esi
	mov	DWORD PTR $T45500[esp+48], esi
	test	esi, esi
	mov	BYTE PTR __$EHRec$[esp+56], 4
	je	$L45502
	mov	edi, DWORD PTR [ebp+96]
	mov	edx, DWORD PTR 8+[esp+44]
	add	edi, edx
	mov	DWORD PTR [esi], 0
	mov	ecx, esi
	mov	edx, DWORD PTR [edi]
	push	edx
	call	?Set@CCorString@@QAEXPAD@Z		; CCorString::Set
	mov	eax, DWORD PTR [edi+4]
	lea	edx, DWORD PTR [edi+12]
	mov	DWORD PTR [esi+4], eax
	mov	cl, BYTE PTR [edi+8]
	mov	BYTE PTR [esi+8], cl
	push	edx
	lea	ecx, DWORD PTR [esi+12]
	mov	BYTE PTR __$EHRec$[esp+60], 5
	call	??0?$TCorArray@VCCpjFrmGroup@@@@QAE@AAV0@@Z ; TCorArray<CCpjFrmGroup>::TCorArray<CCpjFrmGroup>
	lea	eax, DWORD PTR [edi+28]
	lea	ecx, DWORD PTR [esi+28]
	push	eax
	mov	BYTE PTR __$EHRec$[esp+60], 6
	call	??0?$TCorArray@VCCpjFrmBytePos@@@@QAE@AAV0@@Z ; TCorArray<CCpjFrmBytePos>::TCorArray<CCpjFrmBytePos>
	lea	ecx, DWORD PTR [edi+44]
	mov	BYTE PTR __$EHRec$[esp+56], 7
	push	ecx
	lea	ecx, DWORD PTR [esi+44]
	call	??0?$TCorArray@VVVec3@@@@QAE@AAV0@@Z	; TCorArray<VVec3>::TCorArray<VVec3>
	lea	ecx, DWORD PTR [esi+60]
	mov	edx, ecx
	sub	edx, esi
	sub	esi, edi
	lea	eax, DWORD PTR [edx+edi+8]
	mov	edx, 2
$L45520:
	mov	edi, DWORD PTR [eax-8]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR [ecx], edi
	mov	edi, DWORD PTR [eax-16]
	mov	DWORD PTR [ecx+4], edi
	mov	edi, DWORD PTR [eax-12]
	mov	DWORD PTR [esi+eax-12], edi
	add	ecx, 12					; 0000000cH
	dec	edx
	jne	SHORT $L45520
	mov	edi, DWORD PTR $T45531[esp+48]
$L45502:
	mov	eax, DWORD PTR _i$45527[esp+48]
	mov	edx, DWORD PTR 8+[esp+44]
	mov	ecx, DWORD PTR [ebp+100]
	inc	eax
	add	edx, 84					; 00000054H
	cmp	eax, ecx
	mov	BYTE PTR __$EHRec$[esp+56], 3
	mov	DWORD PTR _i$45527[esp+48], eax
	mov	DWORD PTR 8+[esp+44], edx
	jb	$L45528
$L45539:
	mov	ecx, DWORD PTR __$EHRec$[esp+48]
	pop	edi
	pop	esi
	mov	DWORD PTR [ebx], OFFSET FLAT:??_7OCpjFrames@@6B@ ; OCpjFrames::`vftable'
	mov	eax, ebx
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 32					; 00000020H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L45413:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1CObjLink@@QAE@XZ			; CObjLink::~CObjLink
$L45414:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	jmp	??1CObjLink@@QAE@XZ			; CObjLink::~CObjLink
$L45406:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1OCpjChunk@@UAE@XZ			; OCpjChunk::~OCpjChunk
$L45456:
	mov	ecx, DWORD PTR $T45531[ebp]
	jmp	??1CCorArray@@IAE@XZ			; CCorArray::~CCorArray
$L45457:
	mov	eax, DWORD PTR $T45501[ebp]
	push	eax
	mov	ecx, DWORD PTR $T45500[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
$L45477:
	mov	ecx, DWORD PTR $T45500[ebp]
	jmp	??1CCorString@@QAE@XZ			; CCorString::~CCorString
$L45478:
	mov	ecx, DWORD PTR $T45500[ebp]
	add	ecx, 12					; 0000000cH
	jmp	??1?$TCorArray@VCCpjFrmGroup@@@@QAE@XZ	; TCorArray<CCpjFrmGroup>::~TCorArray<CCpjFrmGroup>
$L45479:
	mov	ecx, DWORD PTR $T45500[ebp]
	add	ecx, 28					; 0000001cH
	jmp	??1?$TCorArray@VCCpjFrmBytePos@@@@QAE@XZ ; TCorArray<CCpjFrmBytePos>::~TCorArray<CCpjFrmBytePos>
$L45541:
	mov	eax, OFFSET FLAT:$T45534
	jmp	___CxxFrameHandler
text$x	ENDS
??0OCpjFrames@@QAE@AAV0@@Z ENDP				; OCpjFrames::OCpjFrames
;	COMDAT xdata$x
; File C:\duke4\Cannibal\VecMain.h
xdata$x	SEGMENT
$T45595	DD	0ffffffffH
	DD	FLAT:$L45553
$T45590	DD	019930520H
	DD	01H
	DD	FLAT:$T45595
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File C:\duke4\Cannibal\CorMain.h
xdata$x	ENDS
;	COMDAT ??0?$TCorArray@VCCpjFrmGroup@@@@QAE@AAV0@@Z
_TEXT	SEGMENT
_this$ = -16
_i$ = 8
__$EHRec$ = -12
_inArray$ = 8
??0?$TCorArray@VCCpjFrmGroup@@@@QAE@AAV0@@Z PROC NEAR	; TCorArray<CCpjFrmGroup>::TCorArray<CCpjFrmGroup>, COMDAT
; _this$ = ecx

; 263  : 	{

	push	-1
	push	$L45594
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	push	ebx
	mov	ebx, DWORD PTR _inArray$[esp+16]
	push	ebp
	push	esi
	mov	eax, DWORD PTR [ebx+4]
	mov	esi, ecx
	xor	ebp, ebp
	push	24					; 00000018H
	mov	DWORD PTR _this$[esp+32], esi
	mov	DWORD PTR [esi], ebp
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], 24			; 00000018H
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc

; 264  : 		m_Count = 0;

	mov	DWORD PTR [esi+4], ebp

; 265  : 		for (NDword i=0;i<inArray.m_Count;i++)

	mov	eax, DWORD PTR [ebx+4]
	cmp	eax, ebp
	mov	DWORD PTR __$EHRec$[esp+36], ebp
	mov	DWORD PTR _i$[esp+24], ebp
	jbe	SHORT $L45593
	push	edi
$L13975:

; 266  : 			new(&(*this)[AddNoConstruct()]) T(inArray[i]);

	mov	edi, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	lea	eax, DWORD PTR [edi+1]
	cmp	eax, ecx
	mov	DWORD PTR [esi+4], eax
	jbe	SHORT $L45562
	mov	ecx, eax
	push	24					; 00000018H
	shr	ecx, 2
	lea	edx, DWORD PTR [ecx+eax+32]
	mov	ecx, esi
	mov	DWORD PTR [esi+8], edx
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
$L45562:
	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [edi+edi*2]
	lea	ecx, DWORD PTR [ecx+eax*8]
	test	ecx, ecx
	je	SHORT $L45551
	mov	eax, DWORD PTR [ebx]
	add	eax, ebp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], edx
	mov	edx, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+16], edx
	mov	eax, DWORD PTR [eax+20]
	mov	DWORD PTR [ecx+20], eax
$L45551:
	mov	eax, DWORD PTR _i$[esp+28]
	mov	ecx, DWORD PTR [ebx+4]
	inc	eax
	add	ebp, 24					; 00000018H
	cmp	eax, ecx
	mov	DWORD PTR _i$[esp+28], eax
	jb	SHORT $L13975
	pop	edi
$L45593:

; 267  : 	}

	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L45553:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CCorArray@@IAE@XZ			; CCorArray::~CCorArray
$L45594:
	mov	eax, OFFSET FLAT:$T45590
	jmp	___CxxFrameHandler
text$x	ENDS
??0?$TCorArray@VCCpjFrmGroup@@@@QAE@AAV0@@Z ENDP	; TCorArray<CCpjFrmGroup>::TCorArray<CCpjFrmGroup>
;	COMDAT xdata$x
xdata$x	SEGMENT
$T45654	DD	0ffffffffH
	DD	FLAT:$L45606
$T45648	DD	019930520H
	DD	01H
	DD	FLAT:$T45654
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ??0?$TCorArray@VCCpjFrmBytePos@@@@QAE@AAV0@@Z
_TEXT	SEGMENT
_this$ = -16
__$EHRec$ = -12
_inArray$ = 8
??0?$TCorArray@VCCpjFrmBytePos@@@@QAE@AAV0@@Z PROC NEAR	; TCorArray<CCpjFrmBytePos>::TCorArray<CCpjFrmBytePos>, COMDAT
; _this$ = ecx

; 263  : 	{

	push	-1
	push	$L45653
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	push	ebx
	mov	ebx, DWORD PTR _inArray$[esp+16]
	push	ebp
	push	esi
	mov	eax, DWORD PTR [ebx+4]
	mov	esi, ecx
	xor	ebp, ebp
	push	4
	mov	DWORD PTR _this$[esp+32], esi
	mov	DWORD PTR [esi], ebp
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], 4
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc

; 264  : 		m_Count = 0;

	mov	DWORD PTR [esi+4], ebp

; 265  : 		for (NDword i=0;i<inArray.m_Count;i++)

	mov	eax, DWORD PTR [ebx+4]
	cmp	eax, ebp
	mov	DWORD PTR __$EHRec$[esp+36], ebp
	jbe	SHORT $L45651
	push	edi
$L14010:

; 266  : 			new(&(*this)[AddNoConstruct()]) T(inArray[i]);

	mov	edi, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	lea	eax, DWORD PTR [edi+1]
	cmp	eax, ecx
	mov	DWORD PTR [esi+4], eax
	jbe	SHORT $L45636
	mov	ecx, eax
	mov	DWORD PTR [esi+12], 4
	shr	ecx, 2
	lea	eax, DWORD PTR [ecx+eax+32]
	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	mov	DWORD PTR [esi+8], eax
	je	SHORT $L45629
	test	eax, eax
	je	SHORT $L45631
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+8]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [esi+12]
	push	ecx
	mov	ecx, DWORD PTR [esi]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+4]
	mov	DWORD PTR [esi], eax
	jmp	SHORT $L45636
$L45631:
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L45635:
	mov	DWORD PTR [esi], 0
$L45636:
	mov	edx, DWORD PTR [esi]
	lea	eax, DWORD PTR [edx+edi*4]
	test	eax, eax
	je	SHORT $L45604
	mov	ecx, DWORD PTR [ebx]
	mov	edx, DWORD PTR [ecx+ebp*4]
	mov	DWORD PTR [eax], edx
$L45604:
	mov	eax, DWORD PTR [ebx+4]
	inc	ebp
	cmp	ebp, eax
	jb	SHORT $L14010
	pop	edi
$L45651:

; 267  : 	}

	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	ret	4

; 266  : 			new(&(*this)[AddNoConstruct()]) T(inArray[i]);

$L45629:
	test	eax, eax
	je	SHORT $L45635
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+8]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [esi+12]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	DWORD PTR [esi], eax
	jmp	SHORT $L45636
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L45606:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CCorArray@@IAE@XZ			; CCorArray::~CCorArray
$L45653:
	mov	eax, OFFSET FLAT:$T45648
	jmp	___CxxFrameHandler
text$x	ENDS
??0?$TCorArray@VCCpjFrmBytePos@@@@QAE@AAV0@@Z ENDP	; TCorArray<CCpjFrmBytePos>::TCorArray<CCpjFrmBytePos>
;	COMDAT xdata$x
; File C:\duke4\Cannibal\VecMain.h
xdata$x	SEGMENT
$T45695	DD	0ffffffffH
	DD	FLAT:$L45665
$T45690	DD	019930520H
	DD	01H
	DD	FLAT:$T45695
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File C:\duke4\Cannibal\CorMain.h
xdata$x	ENDS
;	COMDAT ??0?$TCorArray@VVVec3@@@@QAE@AAV0@@Z
_TEXT	SEGMENT
_this$ = -16
_i$ = 8
__$EHRec$ = -12
_inArray$ = 8
??0?$TCorArray@VVVec3@@@@QAE@AAV0@@Z PROC NEAR		; TCorArray<VVec3>::TCorArray<VVec3>, COMDAT
; _this$ = ecx

; 263  : 	{

	push	-1
	push	$L45694
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	push	ebx
	mov	ebx, DWORD PTR _inArray$[esp+16]
	push	ebp
	push	esi
	mov	eax, DWORD PTR [ebx+4]
	mov	esi, ecx
	xor	ebp, ebp
	push	12					; 0000000cH
	mov	DWORD PTR _this$[esp+32], esi
	mov	DWORD PTR [esi], ebp
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], 12			; 0000000cH
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc

; 264  : 		m_Count = 0;

	mov	DWORD PTR [esi+4], ebp

; 265  : 		for (NDword i=0;i<inArray.m_Count;i++)

	mov	eax, DWORD PTR [ebx+4]
	cmp	eax, ebp
	mov	DWORD PTR __$EHRec$[esp+36], ebp
	mov	DWORD PTR _i$[esp+24], ebp
	jbe	SHORT $L45693
	push	edi
$L14045:

; 266  : 			new(&(*this)[AddNoConstruct()]) T(inArray[i]);

	mov	edi, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	lea	eax, DWORD PTR [edi+1]
	cmp	eax, ecx
	mov	DWORD PTR [esi+4], eax
	jbe	SHORT $L45674
	mov	ecx, eax
	push	12					; 0000000cH
	shr	ecx, 2
	lea	edx, DWORD PTR [ecx+eax+32]
	mov	ecx, esi
	mov	DWORD PTR [esi+8], edx
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
$L45674:
	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [edi+edi*2]
	lea	ecx, DWORD PTR [ecx+eax*4]
	test	ecx, ecx
	je	SHORT $L45663
	mov	eax, DWORD PTR [ebx]
	add	eax, ebp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
$L45663:
	mov	eax, DWORD PTR _i$[esp+28]
	mov	ecx, DWORD PTR [ebx+4]
	inc	eax
	add	ebp, 12					; 0000000cH
	cmp	eax, ecx
	mov	DWORD PTR _i$[esp+28], eax
	jb	SHORT $L14045
	pop	edi
$L45693:

; 267  : 	}

	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L45665:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CCorArray@@IAE@XZ			; CCorArray::~CCorArray
$L45694:
	mov	eax, OFFSET FLAT:$T45690
	jmp	___CxxFrameHandler
text$x	ENDS
??0?$TCorArray@VVVec3@@@@QAE@AAV0@@Z ENDP		; TCorArray<VVec3>::TCorArray<VVec3>
;	COMDAT xdata$x
xdata$x	SEGMENT
$T45759	DD	0ffffffffH
	DD	FLAT:$L45708
$T45754	DD	019930520H
	DD	01H
	DD	FLAT:$T45759
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ??0CCpjGeoEdge@@QAE@AAV0@@Z
_TEXT	SEGMENT
_i$45735 = 8
$T45751 = -16
__$EHRec$ = -12
___that$ = 8
??0CCpjGeoEdge@@QAE@AAV0@@Z PROC NEAR			; CCpjGeoEdge::CCpjGeoEdge, COMDAT
; _this$ = ecx
	push	-1
	push	$L45758
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, DWORD PTR ___that$[esp+28]
	mov	ebx, ecx
	xor	ebp, ebp
	push	4
	mov	eax, DWORD PTR [edi]
	lea	esi, DWORD PTR [ebx+12]
	mov	DWORD PTR [ebx], eax
	mov	ecx, DWORD PTR [edi+4]
	mov	DWORD PTR [ebx+4], ecx
	mov	edx, DWORD PTR [edi+8]
	mov	DWORD PTR [ebx+8], edx
	mov	eax, DWORD PTR [edi+16]
	mov	ecx, esi
	mov	DWORD PTR $T45751[esp+36], esi
	mov	DWORD PTR [esi], ebp
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], 4
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
	mov	DWORD PTR [esi+4], ebp
	mov	eax, DWORD PTR [edi+16]
	xor	ecx, ecx
	cmp	eax, ebp
	mov	DWORD PTR __$EHRec$[esp+40], ebp
	mov	DWORD PTR _i$45735[esp+28], ecx
	jbe	SHORT $L45757
$L45736:
	mov	ebp, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi+8]
	lea	eax, DWORD PTR [ebp+1]
	cmp	eax, edx
	mov	DWORD PTR [esi+4], eax
	jbe	SHORT $L45749
	mov	ecx, eax
	push	4
	shr	ecx, 2
	lea	edx, DWORD PTR [ecx+eax+32]
	mov	ecx, esi
	mov	DWORD PTR [esi+8], edx
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
	mov	ecx, DWORD PTR _i$45735[esp+28]
$L45749:
	mov	eax, DWORD PTR [esi]
	lea	eax, DWORD PTR [eax+ebp*4]
	test	eax, eax
	je	SHORT $L45743
	mov	edx, DWORD PTR [edi+12]
	mov	edx, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR [eax], edx
$L45743:
	mov	eax, DWORD PTR [edi+16]
	inc	ecx
	cmp	ecx, eax
	mov	DWORD PTR _i$45735[esp+28], ecx
	jb	SHORT $L45736
$L45757:
	mov	ecx, DWORD PTR __$EHRec$[esp+32]
	pop	edi
	pop	esi
	mov	eax, ebx
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L45708:
	mov	ecx, DWORD PTR $T45751[ebp]
	jmp	??1CCorArray@@IAE@XZ			; CCorArray::~CCorArray
$L45758:
	mov	eax, OFFSET FLAT:$T45754
	jmp	___CxxFrameHandler
text$x	ENDS
??0CCpjGeoEdge@@QAE@AAV0@@Z ENDP			; CCpjGeoEdge::CCpjGeoEdge
PUBLIC	??4?$TCorArray@VCCpjFrmFrame@@@@QAEAAV0@AAV0@@Z	; TCorArray<CCpjFrmFrame>::operator=
PUBLIC	??4OCpjFrames@@QAEAAV0@AAV0@@Z			; OCpjFrames::operator=
; Function compile flags: /Ogty
;	COMDAT ??4OCpjFrames@@QAEAAV0@AAV0@@Z
_TEXT	SEGMENT
___that$ = 8
??4OCpjFrames@@QAEAAV0@AAV0@@Z PROC NEAR		; OCpjFrames::operator=, COMDAT
; _this$ = ecx
	push	ebx
	mov	ebx, DWORD PTR ___that$[esp]
	push	ebp
	push	esi
	mov	eax, DWORD PTR [ebx+4]
	mov	esi, ecx
	lea	ecx, DWORD PTR [ebx+8]
	push	edi
	mov	DWORD PTR [esi+4], eax
	lea	edx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	lea	eax, DWORD PTR [esi+24]
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], ecx
	lea	edx, DWORD PTR [ebx+24]
	mov	ecx, DWORD PTR [ebx+24]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR [ebx+40]
	mov	DWORD PTR [esi+40], eax
	mov	ebp, DWORD PTR [ebx+44]
	test	ebp, ebp
	je	SHORT $L45833
	cmp	BYTE PTR [ebp], 0
	jne	SHORT $L45833
	xor	ebp, ebp
$L45833:
	mov	edi, DWORD PTR [esi+44]
	test	edi, edi
	je	SHORT $L45834
	or	ecx, -1
	xor	eax, eax
	repne scasb
	mov	eax, DWORD PTR ?sMemTotal@CCorString@@0KA ; CCorString::sMemTotal
	or	edx, -1
	not	ecx
	dec	ecx
	sub	edx, ecx
	add	eax, edx
	mov	DWORD PTR ?sMemTotal@CCorString@@0KA, eax ; CCorString::sMemTotal
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+44]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L45834:
	test	ebp, ebp
	mov	DWORD PTR [esi+44], 0
	je	SHORT $L45838
	mov	edi, ebp
	or	ecx, -1
	xor	eax, eax
	repne scasb
	not	ecx
	dec	ecx
	mov	edi, ecx
	inc	edi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	edi
	mov	ecx, eax
	call	DWORD PTR [edx]
	test	eax, eax
	mov	DWORD PTR [esi+44], eax
	je	SHORT $L45838
$L45831:
	mov	cl, BYTE PTR [ebp]
	inc	ebp
	mov	BYTE PTR [eax], cl
	inc	eax
	test	cl, cl
	jne	SHORT $L45831
	add	DWORD PTR ?sMemTotal@CCorString@@0KA, edi ; CCorString::sMemTotal
$L45838:
	mov	eax, DWORD PTR [ebx+48]
	mov	edi, 2
	mov	DWORD PTR [esi+48], eax
	mov	ecx, DWORD PTR [ebx+52]
	mov	DWORD PTR [esi+52], ecx
	mov	dl, BYTE PTR [ebx+56]
	mov	BYTE PTR [esi+56], dl
	mov	eax, DWORD PTR [ebx+60]
	mov	DWORD PTR [esi+60], eax
	mov	ecx, DWORD PTR [ebx+64]
	mov	DWORD PTR [esi+64], ecx
	mov	edx, DWORD PTR [ebx+68]
	mov	DWORD PTR [esi+68], edx
	mov	edx, ebx
	lea	ecx, DWORD PTR [ebx+72]
	lea	eax, DWORD PTR [esi+76]
	sub	edx, esi
$L9372:
	mov	ebp, DWORD PTR [ecx]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR [eax-4], ebp
	mov	ebp, DWORD PTR [edx+eax]
	mov	DWORD PTR [eax], ebp
	mov	ebp, DWORD PTR [ecx-4]
	mov	DWORD PTR [eax+4], ebp
	add	eax, 12					; 0000000cH
	dec	edi
	jne	SHORT $L9372
	add	ebx, 96					; 00000060H
	lea	ecx, DWORD PTR [esi+96]
	push	ebx
	call	??4?$TCorArray@VCCpjFrmFrame@@@@QAEAAV0@AAV0@@Z ; TCorArray<CCpjFrmFrame>::operator=
	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	4
??4OCpjFrames@@QAEAAV0@AAV0@@Z ENDP			; OCpjFrames::operator=
_TEXT	ENDS
PUBLIC	?AddNoConstruct@?$TCorArray@VCCpjFrmGroup@@@@QAEKK@Z ; TCorArray<CCpjFrmGroup>::AddNoConstruct
;	COMDAT xdata$x
; File C:\duke4\Cannibal\VecMain.h
xdata$x	SEGMENT
$T46034	DD	0ffffffffH
	DD	FLAT:$L45858
	DD	00H
	DD	FLAT:$L45885
	DD	01H
	DD	FLAT:$L45898
	DD	02H
	DD	FLAT:$L45899
	DD	01H
	DD	FLAT:$L45886
	DD	04H
	DD	FLAT:$L45941
	DD	04H
	DD	FLAT:$L45887
$T46023	DD	019930520H
	DD	07H
	DD	FLAT:$T46034
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File C:\duke4\Cannibal\CorMain.h
xdata$x	ENDS
;	COMDAT ??4?$TCorArray@VCCpjFrmFrame@@@@QAEAAV0@AAV0@@Z
_TEXT	SEGMENT
_inArray$ = 8
$T45854 = -28
$T45855 = -32
$T45933 = -24
$T45970 = -16
$T45985 = -16
$T45986 = -20
__$EHRec$ = -12
_this$ = -36
_i$ = -40
??4?$TCorArray@VCCpjFrmFrame@@@@QAEAAV0@AAV0@@Z PROC NEAR ; TCorArray<CCpjFrmFrame>::operator=, COMDAT
; _this$ = ecx

; 269  : 	{

	push	-1
	push	$L46032
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 36					; 00000024H
	push	ebx

; 270  : 		if (this == &inArray)

	mov	ebx, DWORD PTR _inArray$[esp+48]
	push	esi
	mov	esi, ecx
	cmp	esi, ebx
	mov	DWORD PTR _this$[esp+56], esi

; 271  : 			return(*this);

	je	$L46033
	push	edi

; 272  : 		m_Count = 0;

	xor	edi, edi
	mov	DWORD PTR [esi+4], edi

; 273  : 		m_Limit = inArray.m_Count;

	mov	eax, DWORD PTR [ebx+4]
	mov	DWORD PTR [esi+8], eax

; 274  : 		Realloc(sizeof(T));

	mov	eax, DWORD PTR [esi]
	cmp	eax, edi
	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [esi+12], 84			; 00000054H
	je	$L45862
	cmp	eax, edi
	je	SHORT $L45864
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [esi+8]
	push	ecx
	mov	ecx, DWORD PTR [esi]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+4]
	mov	DWORD PTR [esi], eax
	jmp	SHORT $L45869
$L45864:
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L45868:
	mov	DWORD PTR [esi], edi
$L45869:

; 275  : 		for (NDword i=0;i<inArray.m_Count;i++)

	mov	eax, DWORD PTR [ebx+4]
	mov	DWORD PTR _i$[esp+60], edi
	cmp	eax, edi
	jbe	$L14096
	push	ebp
	mov	DWORD PTR -44+[esp+64], edi
$L14094:

; 276  : 			new(&(*this)[AddNoConstruct()]) T(inArray[i]);

	mov	edi, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	lea	eax, DWORD PTR [edi+1]
	cmp	eax, ecx
	mov	DWORD PTR [esi+4], eax
	jbe	SHORT $L45874
	mov	edx, eax
	push	84					; 00000054H
	shr	edx, 2
	mov	ecx, esi
	lea	eax, DWORD PTR [edx+eax+32]
	mov	DWORD PTR [esi+8], eax
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
$L45874:
	mov	edx, DWORD PTR [esi]
	lea	eax, DWORD PTR [edi*8]
	sub	eax, edi
	lea	ecx, DWORD PTR [eax+eax*2]
	lea	ebp, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR $T45855[esp+64], ebp
	mov	DWORD PTR $T45854[esp+64], ebp
	test	ebp, ebp
	mov	DWORD PTR __$EHRec$[esp+72], 0
	je	$L45856
	mov	esi, DWORD PTR [ebx]
	mov	edi, DWORD PTR -44+[esp+64]
	add	esi, edi
	mov	DWORD PTR [ebp], 0
	mov	ecx, ebp
	mov	eax, DWORD PTR [esi]
	push	eax
	call	?Set@CCorString@@QAEXPAD@Z		; CCorString::Set
	mov	ecx, DWORD PTR [esi+4]
	lea	edi, DWORD PTR [ebp+12]
	mov	DWORD PTR [ebp+4], ecx
	mov	dl, BYTE PTR [esi+8]
	mov	BYTE PTR [ebp+8], dl
	mov	eax, DWORD PTR [esi+16]
	xor	ebx, ebx
	push	24					; 00000018H
	mov	ecx, edi
	mov	BYTE PTR __$EHRec$[esp+76], 1
	mov	DWORD PTR $T45933[esp+68], edi
	mov	DWORD PTR [edi], ebx
	mov	DWORD PTR [edi+4], eax
	mov	DWORD PTR [edi+8], eax
	mov	DWORD PTR [edi+12], 24			; 00000018H
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
	mov	DWORD PTR [edi+4], ebx
	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
	mov	BYTE PTR __$EHRec$[esp+72], 2
	jbe	SHORT $L46001
	mov	DWORD PTR -48+[esp+64], ebx
$L45999:
	push	1
	mov	ecx, edi
	call	?AddNoConstruct@?$TCorArray@VCCpjFrmGroup@@@@QAEKK@Z ; TCorArray<CCpjFrmGroup>::AddNoConstruct
	mov	ecx, DWORD PTR [edi]
	lea	eax, DWORD PTR [eax+eax*2]
	lea	ecx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR $T45986[esp+64], ecx
	mov	DWORD PTR $T45985[esp+64], ecx
	test	ecx, ecx
	mov	BYTE PTR __$EHRec$[esp+72], 3
	je	SHORT $L45987
	mov	edx, DWORD PTR [esi+12]
	mov	eax, DWORD PTR -48+[esp+64]
	add	edx, eax
	push	edx
	call	??0CCpjFrmGroup@@QAE@ABV0@@Z		; CCpjFrmGroup::CCpjFrmGroup
$L45987:
	mov	ecx, DWORD PTR -48+[esp+64]
	mov	eax, DWORD PTR [esi+16]
	inc	ebx
	add	ecx, 24					; 00000018H
	cmp	ebx, eax
	mov	BYTE PTR __$EHRec$[esp+72], 2
	mov	DWORD PTR -48+[esp+64], ecx
	jb	SHORT $L45999
$L46001:
	mov	eax, DWORD PTR [esi+32]
	lea	edi, DWORD PTR [ebp+28]
	push	4
	push	eax
	mov	ecx, edi
	mov	BYTE PTR __$EHRec$[esp+80], 4
	mov	DWORD PTR $T45970[esp+72], edi
	call	??0CCorArray@@IAE@KK@Z			; CCorArray::CCorArray
	xor	ebx, ebx
	mov	BYTE PTR __$EHRec$[esp+72], 5
	mov	DWORD PTR [edi+4], ebx
	mov	eax, DWORD PTR [esi+32]
	cmp	eax, ebx
	jbe	SHORT $L46018
$L46016:
	push	1
	mov	ecx, edi
	call	?AddNoConstruct@?$TCorArray@VCCpjFrmBytePos@@@@QAEKK@Z ; TCorArray<CCpjFrmBytePos>::AddNoConstruct
	mov	ecx, DWORD PTR [edi]
	lea	eax, DWORD PTR [ecx+eax*4]
	test	eax, eax
	je	SHORT $L46006
	mov	edx, DWORD PTR [esi+28]
	mov	ecx, DWORD PTR [edx+ebx*4]
	mov	DWORD PTR [eax], ecx
$L46006:
	mov	eax, DWORD PTR [esi+32]
	inc	ebx
	cmp	ebx, eax
	jb	SHORT $L46016
$L46018:
	lea	edx, DWORD PTR [esi+44]
	lea	ecx, DWORD PTR [ebp+44]
	push	edx
	mov	BYTE PTR __$EHRec$[esp+76], 6
	call	??0?$TCorArray@VVVec3@@@@QAE@AAV0@@Z	; TCorArray<VVec3>::TCorArray<VVec3>
	lea	ecx, DWORD PTR [ebp+60]
	mov	edx, 2
	mov	eax, ecx
	sub	eax, ebp
	sub	ebp, esi
	lea	eax, DWORD PTR [eax+esi+8]
$L45979:
	mov	esi, DWORD PTR [eax-8]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR [ecx], esi
	mov	esi, DWORD PTR [eax-16]
	mov	DWORD PTR [ecx+4], esi
	mov	esi, DWORD PTR [eax-12]
	mov	DWORD PTR [eax+ebp-12], esi
	add	ecx, 12					; 0000000cH
	dec	edx
	jne	SHORT $L45979
	mov	ebx, DWORD PTR _inArray$[esp+60]
	mov	esi, DWORD PTR _this$[esp+64]
$L45856:
	mov	eax, DWORD PTR _i$[esp+64]
	mov	edx, DWORD PTR -44+[esp+64]
	mov	ecx, DWORD PTR [ebx+4]
	inc	eax
	add	edx, 84					; 00000054H
	cmp	eax, ecx
	mov	DWORD PTR __$EHRec$[esp+72], -1
	mov	DWORD PTR _i$[esp+64], eax
	mov	DWORD PTR -44+[esp+64], edx
	jb	$L14094
	pop	ebp
$L14096:
	pop	edi
$L46033:

; 277  : 		return(*this);
; 278  : 	}

	mov	ecx, DWORD PTR __$EHRec$[esp+56]
	mov	eax, esi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 48					; 00000030H
	ret	4

; 274  : 		Realloc(sizeof(T));

$L45862:
	cmp	eax, edi
	je	$L45868
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [esi+8]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	DWORD PTR [esi], eax
	jmp	$L45869
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L45858:
	mov	eax, DWORD PTR $T45855[ebp]
	push	eax
	mov	ecx, DWORD PTR $T45854[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
$L45885:
	mov	ecx, DWORD PTR $T45854[ebp]
	jmp	??1CCorString@@QAE@XZ			; CCorString::~CCorString
$L45898:
	mov	ecx, DWORD PTR $T45933[ebp]
	jmp	??1CCorArray@@IAE@XZ			; CCorArray::~CCorArray
$L45899:
	mov	eax, DWORD PTR $T45986[ebp]
	push	eax
	mov	ecx, DWORD PTR $T45985[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
$L45886:
	mov	ecx, DWORD PTR $T45854[ebp]
	add	ecx, 12					; 0000000cH
	jmp	??1?$TCorArray@VCCpjFrmGroup@@@@QAE@XZ	; TCorArray<CCpjFrmGroup>::~TCorArray<CCpjFrmGroup>
$L45941:
	mov	ecx, DWORD PTR $T45970[ebp]
	jmp	??1CCorArray@@IAE@XZ			; CCorArray::~CCorArray
$L45887:
	mov	ecx, DWORD PTR $T45854[ebp]
	add	ecx, 28					; 0000001cH
	jmp	??1?$TCorArray@VCCpjFrmBytePos@@@@QAE@XZ ; TCorArray<CCpjFrmBytePos>::~TCorArray<CCpjFrmBytePos>
$L46032:
	mov	eax, OFFSET FLAT:$T46023
	jmp	___CxxFrameHandler
text$x	ENDS
??4?$TCorArray@VCCpjFrmFrame@@@@QAEAAV0@AAV0@@Z ENDP	; TCorArray<CCpjFrmFrame>::operator=
PUBLIC	??1OCpjFrames@@UAE@XZ				; OCpjFrames::~OCpjFrames
;	COMDAT xdata$x
xdata$x	SEGMENT
$T46130	DD	0ffffffffH
	DD	FLAT:$L46040
	DD	00H
	DD	FLAT:$L46043
$T46126	DD	019930520H
	DD	02H
	DD	FLAT:$T46130
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ??1OCpjFrames@@UAE@XZ
_TEXT	SEGMENT
_this$ = -20
$T46114 = -16
__$EHRec$ = -12
??1OCpjFrames@@UAE@XZ PROC NEAR				; OCpjFrames::~OCpjFrames, COMDAT
; _this$ = ecx
	push	-1
	push	$L46129
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 8
	push	ebp
	push	esi
	push	edi
	mov	DWORD PTR _this$[esp+32], ecx
	xor	ebp, ebp
	lea	esi, DWORD PTR [ecx+96]
	mov	DWORD PTR __$EHRec$[esp+40], ebp
	mov	DWORD PTR $T46114[esp+32], esi
	mov	edi, DWORD PTR [esi+4]
	mov	BYTE PTR __$EHRec$[esp+40], 1
	cmp	edi, ebp
	jbe	SHORT $L46099
	push	ebx
	mov	ebx, edi
$L46097:
	mov	ecx, DWORD PTR [esi]
	add	ecx, ebp
	call	??1CCpjFrmFrame@@QAE@XZ			; CCpjFrmFrame::~CCpjFrmFrame
	add	ebp, 84					; 00000054H
	dec	ebx
	jne	SHORT $L46097
	pop	ebx
$L46099:
	test	edi, edi
	je	SHORT $L46107
	mov	ebp, DWORD PTR [esi+4]
	lea	eax, DWORD PTR [edi*8]
	mov	edx, DWORD PTR [esi]
	sub	eax, edi
	lea	ecx, DWORD PTR [ebp*8]
	sub	ecx, ebp
	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 2
	lea	ecx, DWORD PTR [ecx+ecx*2]
	shl	ecx, 2
	sub	ecx, eax
	add	eax, edx
	push	ecx
	push	eax
	push	edx
	call	DWORD PTR __imp__memmove
	mov	eax, DWORD PTR [esi+4]
	add	esp, 12					; 0000000cH
	sub	eax, edi
	mov	DWORD PTR [esi+4], eax
$L46107:
	mov	eax, DWORD PTR [esi]
	mov	BYTE PTR __$EHRec$[esp+40], 0
	test	eax, eax
	je	SHORT $L46112
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L46112:
	mov	ecx, DWORD PTR _this$[esp+32]
	mov	DWORD PTR __$EHRec$[esp+40], -1
	call	??1OObject@@UAE@XZ			; OObject::~OObject
	mov	ecx, DWORD PTR __$EHRec$[esp+32]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 20					; 00000014H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L46040:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1OCpjChunk@@UAE@XZ			; OCpjChunk::~OCpjChunk
$L46043:
	mov	ecx, DWORD PTR $T46114[ebp]
	jmp	??1CCorArray@@IAE@XZ			; CCorArray::~CCorArray
$L46129:
	mov	eax, OFFSET FLAT:$T46126
	jmp	___CxxFrameHandler
text$x	ENDS
??1OCpjFrames@@UAE@XZ ENDP				; OCpjFrames::~OCpjFrames
PUBLIC	??_GOCpjFrames@@UAEPAXI@Z			; OCpjFrames::`scalar deleting destructor'
; Function compile flags: /Ogty
;	COMDAT ??_GOCpjFrames@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_GOCpjFrames@@UAEPAXI@Z PROC NEAR			; OCpjFrames::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1OCpjFrames@@UAE@XZ			; OCpjFrames::~OCpjFrames
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $L46148
	mov	DWORD PTR [esi+4], 0
	mov	edx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	dec	edx
	mov	DWORD PTR ?sObjCount@OObject@@1KA, edx	; OObject::sObjCount
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L46148:
	mov	eax, esi
	pop	esi
	ret	4
??_GOCpjFrames@@UAEPAXI@Z ENDP				; OCpjFrames::`scalar deleting destructor'
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??_EOCpjFrames@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_EOCpjFrames@@UAEPAXI@Z PROC NEAR			; OCpjFrames::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebx
	mov	bl, BYTE PTR ___flags$[esp]
	push	esi
	mov	esi, ecx
	test	bl, 2
	je	SHORT $L9384
	mov	eax, DWORD PTR [esi-4]
	push	edi
	lea	edi, DWORD PTR [esi-4]
	push	OFFSET FLAT:??1OCpjFrames@@UAE@XZ	; OCpjFrames::~OCpjFrames
	push	eax
	push	112					; 00000070H
	push	esi
	call	??_M@YGXPAXIHP6EX0@Z@Z			; `eh vector destructor iterator'
	test	bl, 1
	je	SHORT $L9385
	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L9385:
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	ret	4
$L9384:
	mov	ecx, esi
	call	??1OCpjFrames@@UAE@XZ			; OCpjFrames::~OCpjFrames
	test	bl, 1
	je	SHORT $L46158
	mov	DWORD PTR [esi+4], 0
	mov	edx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	dec	edx
	mov	DWORD PTR ?sObjCount@OObject@@1KA, edx	; OObject::sObjCount
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L46158:
	mov	eax, esi
	pop	esi
	pop	ebx
	ret	4
??_EOCpjFrames@@UAEPAXI@Z ENDP				; OCpjFrames::`vector deleting destructor'
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??0CCpjSklBone@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8
??0CCpjSklBone@@QAE@ABV0@@Z PROC NEAR			; CCpjSklBone::CCpjSklBone, COMDAT
; _this$ = ecx
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR ___that$[esp+4]
	push	esi
	mov	esi, ecx
	xor	eax, eax
	push	edi
	mov	DWORD PTR [esi], eax
	mov	ebx, DWORD PTR [ebp]
	cmp	ebx, eax
	je	SHORT $L46185
	cmp	BYTE PTR [ebx], 0
	jne	SHORT $L46185
	xor	ebx, ebx
$L46185:
	cmp	ebx, eax
	mov	DWORD PTR [esi], eax
	je	SHORT $L46188
	mov	edi, ebx
	or	ecx, -1
	xor	eax, eax
	repne scasb
	not	ecx
	dec	ecx
	mov	edi, ecx
	inc	edi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	edi
	mov	ecx, eax
	call	DWORD PTR [edx]
	test	eax, eax
	mov	DWORD PTR [esi], eax
	je	SHORT $L46278
	mov	ecx, eax
$L46182:
	mov	al, BYTE PTR [ebx]
	inc	ebx
	mov	BYTE PTR [ecx], al
	inc	ecx
	test	al, al
	jne	SHORT $L46182
	add	DWORD PTR ?sMemTotal@CCorString@@0KA, edi ; CCorString::sMemTotal
$L46278:
	xor	eax, eax
$L46188:
	mov	ecx, DWORD PTR [ebp+4]
	pop	edi
	mov	DWORD PTR [esi+4], ecx
	mov	edx, DWORD PTR [ebp+8]
	mov	ecx, 1065353216				; 3f800000H
	mov	DWORD PTR [esi+8], edx
	mov	DWORD PTR [esi+12], ecx
	mov	DWORD PTR [esi+16], eax
	mov	DWORD PTR [esi+20], eax
	mov	DWORD PTR [esi+24], eax
	mov	DWORD PTR [esi+28], ecx
	mov	DWORD PTR [esi+32], eax
	mov	DWORD PTR [esi+36], eax
	mov	DWORD PTR [esi+40], eax
	mov	DWORD PTR [esi+44], ecx
	mov	eax, DWORD PTR [ebp+12]
	mov	DWORD PTR [esi+12], eax
	mov	ecx, DWORD PTR [ebp+16]
	mov	DWORD PTR [esi+16], ecx
	mov	edx, DWORD PTR [ebp+20]
	mov	DWORD PTR [esi+20], edx
	mov	eax, DWORD PTR [ebp+24]
	mov	DWORD PTR [esi+24], eax
	mov	ecx, DWORD PTR [ebp+28]
	mov	DWORD PTR [esi+28], ecx
	mov	edx, DWORD PTR [ebp+32]
	mov	DWORD PTR [esi+32], edx
	mov	eax, DWORD PTR [ebp+36]
	mov	DWORD PTR [esi+36], eax
	mov	ecx, DWORD PTR [ebp+40]
	mov	DWORD PTR [esi+40], ecx
	mov	edx, DWORD PTR [ebp+44]
	mov	DWORD PTR [esi+44], edx
	mov	eax, DWORD PTR [ebp+48]
	mov	DWORD PTR [esi+48], eax
	mov	ecx, DWORD PTR [ebp+52]
	mov	DWORD PTR [esi+52], ecx
	mov	edx, DWORD PTR [ebp+56]
	mov	DWORD PTR [esi+56], edx
	mov	eax, DWORD PTR [ebp+60]
	mov	DWORD PTR [esi+60], eax
	mov	ecx, DWORD PTR [ebp+64]
	mov	DWORD PTR [esi+64], ecx
	mov	edx, DWORD PTR [ebp+68]
	mov	DWORD PTR [esi+68], edx
	mov	eax, DWORD PTR [ebp+72]
	mov	DWORD PTR [esi+72], eax
	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx
	ret	4
??0CCpjSklBone@@QAE@ABV0@@Z ENDP			; CCpjSklBone::CCpjSklBone
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
$T46353	DD	0ffffffffH
	DD	FLAT:$L46289
$T46348	DD	019930520H
	DD	01H
	DD	FLAT:$T46353
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ??0CCpjSklVert@@QAE@AAV0@@Z
_TEXT	SEGMENT
___that$ = 8
_this$ = -16
_i$46343 = 8
__$EHRec$ = -12
??0CCpjSklVert@@QAE@AAV0@@Z PROC NEAR			; CCpjSklVert::CCpjSklVert, COMDAT
; _this$ = ecx
	push	-1
	push	$L46352
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	push	ebx
	mov	ebx, DWORD PTR ___that$[esp+16]
	push	ebp
	push	esi
	mov	eax, DWORD PTR [ebx+4]
	mov	esi, ecx
	xor	ebp, ebp
	push	20					; 00000014H
	mov	DWORD PTR _this$[esp+32], esi
	mov	DWORD PTR [esi], ebp
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], 20			; 00000014H
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
	mov	DWORD PTR [esi+4], ebp
	mov	eax, DWORD PTR [ebx+4]
	cmp	eax, ebp
	mov	DWORD PTR __$EHRec$[esp+36], ebp
	mov	DWORD PTR _i$46343[esp+24], ebp
	jbe	SHORT $L46351
	push	edi
$L46344:
	mov	edi, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	lea	eax, DWORD PTR [edi+1]
	cmp	eax, ecx
	mov	DWORD PTR [esi+4], eax
	jbe	SHORT $L46330
	mov	ecx, eax
	push	20					; 00000014H
	shr	ecx, 2
	lea	edx, DWORD PTR [ecx+eax+32]
	mov	ecx, esi
	mov	DWORD PTR [esi+8], edx
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
$L46330:
	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [edi+edi*4]
	lea	ecx, DWORD PTR [ecx+eax*4]
	test	ecx, ecx
	je	SHORT $L46324
	mov	eax, DWORD PTR [ebx]
	add	eax, ebp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], edx
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+16], eax
$L46324:
	mov	eax, DWORD PTR _i$46343[esp+28]
	mov	ecx, DWORD PTR [ebx+4]
	inc	eax
	add	ebp, 20					; 00000014H
	cmp	eax, ecx
	mov	DWORD PTR _i$46343[esp+28], eax
	jb	SHORT $L46344
	pop	edi
$L46351:
	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L46289:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CCorArray@@IAE@XZ			; CCorArray::~CCorArray
$L46352:
	mov	eax, OFFSET FLAT:$T46348
	jmp	___CxxFrameHandler
text$x	ENDS
??0CCpjSklVert@@QAE@AAV0@@Z ENDP			; CCpjSklVert::CCpjSklVert
; Function compile flags: /Ogty
;	COMDAT ??0CCpjSklMount@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8
??0CCpjSklMount@@QAE@ABV0@@Z PROC NEAR			; CCpjSklMount::CCpjSklMount, COMDAT
; _this$ = ecx
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR ___that$[esp+4]
	push	esi
	mov	esi, ecx
	xor	eax, eax
	push	edi
	mov	DWORD PTR [esi], eax
	mov	ebx, DWORD PTR [ebp]
	cmp	ebx, eax
	je	SHORT $L46375
	cmp	BYTE PTR [ebx], 0
	jne	SHORT $L46375
	xor	ebx, ebx
$L46375:
	cmp	ebx, eax
	mov	DWORD PTR [esi], eax
	je	SHORT $L46378
	mov	edi, ebx
	or	ecx, -1
	xor	eax, eax
	repne scasb
	not	ecx
	dec	ecx
	mov	edi, ecx
	inc	edi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	edi
	mov	ecx, eax
	call	DWORD PTR [edx]
	test	eax, eax
	mov	DWORD PTR [esi], eax
	je	SHORT $L46470
	mov	ecx, eax
$L46380:
	mov	al, BYTE PTR [ebx]
	inc	ebx
	mov	BYTE PTR [ecx], al
	inc	ecx
	test	al, al
	jne	SHORT $L46380
	add	DWORD PTR ?sMemTotal@CCorString@@0KA, edi ; CCorString::sMemTotal
$L46470:
	xor	eax, eax
$L46378:
	mov	ecx, DWORD PTR [ebp+4]
	pop	edi
	mov	DWORD PTR [esi+4], ecx
	mov	ecx, 1065353216				; 3f800000H
	mov	DWORD PTR [esi+8], ecx
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+16], eax
	mov	DWORD PTR [esi+20], eax
	mov	DWORD PTR [esi+24], ecx
	mov	DWORD PTR [esi+28], eax
	mov	DWORD PTR [esi+32], eax
	mov	DWORD PTR [esi+36], eax
	mov	DWORD PTR [esi+40], ecx
	mov	edx, DWORD PTR [ebp+8]
	mov	DWORD PTR [esi+8], edx
	mov	eax, DWORD PTR [ebp+12]
	mov	DWORD PTR [esi+12], eax
	mov	ecx, DWORD PTR [ebp+16]
	mov	DWORD PTR [esi+16], ecx
	mov	edx, DWORD PTR [ebp+20]
	mov	DWORD PTR [esi+20], edx
	mov	eax, DWORD PTR [ebp+24]
	mov	DWORD PTR [esi+24], eax
	mov	ecx, DWORD PTR [ebp+28]
	mov	DWORD PTR [esi+28], ecx
	mov	edx, DWORD PTR [ebp+32]
	mov	DWORD PTR [esi+32], edx
	mov	eax, DWORD PTR [ebp+36]
	mov	DWORD PTR [esi+36], eax
	mov	ecx, DWORD PTR [ebp+40]
	mov	DWORD PTR [esi+40], ecx
	mov	edx, DWORD PTR [ebp+44]
	mov	DWORD PTR [esi+44], edx
	mov	eax, DWORD PTR [ebp+48]
	mov	DWORD PTR [esi+48], eax
	mov	ecx, DWORD PTR [ebp+52]
	mov	DWORD PTR [esi+52], ecx
	mov	edx, DWORD PTR [ebp+56]
	mov	DWORD PTR [esi+56], edx
	mov	eax, DWORD PTR [ebp+60]
	mov	DWORD PTR [esi+60], eax
	mov	ecx, DWORD PTR [ebp+64]
	mov	DWORD PTR [esi+64], ecx
	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx
	ret	4
??0CCpjSklMount@@QAE@ABV0@@Z ENDP			; CCpjSklMount::CCpjSklMount
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??0CCpjFrmGroup@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8
??0CCpjFrmGroup@@QAE@ABV0@@Z PROC NEAR			; CCpjFrmGroup::CCpjFrmGroup, COMDAT
; _this$ = ecx
	mov	eax, ecx
	mov	ecx, DWORD PTR ___that$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx
	mov	ecx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+20], ecx
	ret	4
??0CCpjFrmGroup@@QAE@ABV0@@Z ENDP			; CCpjFrmGroup::CCpjFrmGroup
_TEXT	ENDS
PUBLIC	??2OCpjSequence@@CAPAXIPAVOObject@@PAVCObjClass@@@Z ; OCpjSequence::operator new
; Function compile flags: /Ogty
; File C:\duke4\Cannibal\CpjSeq.h
;	COMDAT ??2OCpjSequence@@CAPAXIPAVOObject@@PAVCObjClass@@@Z
_TEXT	SEGMENT
_inParent$ = 12
_inSetClass$ = 16
??2OCpjSequence@@CAPAXIPAVOObject@@PAVCObjClass@@@Z PROC NEAR ; OCpjSequence::operator new, COMDAT

; 85   : 	OBJ_CLASS_DEFINE(OCpjSequence, OCpjChunk);

	push	esi
	push	edi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	124					; 0000007cH
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	ecx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	mov	esi, eax
	inc	ecx
	xor	eax, eax
	mov	DWORD PTR ?sObjCount@OObject@@1KA, ecx	; OObject::sObjCount
	mov	ecx, 31					; 0000001fH
	mov	edi, esi
	rep stosd
	mov	eax, DWORD PTR [esi+40]
	mov	DWORD PTR [esi+4], 305419896		; 12345678H
	test	eax, eax
	jne	SHORT $L46492
	mov	eax, DWORD PTR _inSetClass$[esp+4]
	mov	DWORD PTR [esi+40], eax
$L46492:
	mov	ecx, DWORD PTR _inParent$[esp+4]
	push	ecx
	mov	ecx, esi
	call	?PreConstruct@OObject@@QAEXPAV1@@Z	; OObject::PreConstruct
	mov	eax, esi
	pop	edi
	pop	esi
	ret	0
??2OCpjSequence@@CAPAXIPAVOObject@@PAVCObjClass@@@Z ENDP ; OCpjSequence::operator new
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
$T46546	DD	0ffffffffH
	DD	FLAT:$L46497
$T46544	DD	019930520H
	DD	01H
	DD	FLAT:$T46546
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ??0CCpjMacSection@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20
__$EHRec$ = -12
??0CCpjMacSection@@QAE@XZ PROC NEAR			; CCpjMacSection::CCpjMacSection, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR fs:__except_list
	push	-1
	push	$L46545
	push	eax
	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR fs:__except_list, esp
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR __$EHRec$[esp+12]
	mov	DWORD PTR [eax+16], 4
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 12					; 0000000cH
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L46497:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CCorString@@QAE@XZ			; CCorString::~CCorString
$L46545:
	mov	eax, OFFSET FLAT:$T46544
	jmp	___CxxFrameHandler
text$x	ENDS
??0CCpjMacSection@@QAE@XZ ENDP				; CCpjMacSection::CCpjMacSection
PUBLIC	??3OCpjSequence@@CAXPAX@Z			; OCpjSequence::operator delete
; Function compile flags: /Ogty
;	COMDAT ??3OCpjSequence@@CAXPAX@Z
_TEXT	SEGMENT
_ptr$ = 8
??3OCpjSequence@@CAXPAX@Z PROC NEAR			; OCpjSequence::operator delete, COMDAT

; 85   : 	OBJ_CLASS_DEFINE(OCpjSequence, OCpjChunk);

	push	esi
	mov	esi, DWORD PTR _ptr$[esp]
	mov	DWORD PTR [esi+4], 0
	mov	edx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	dec	edx
	mov	DWORD PTR ?sObjCount@OObject@@1KA, edx	; OObject::sObjCount
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	ecx, eax
	call	DWORD PTR [edx+8]
	pop	esi
	ret	0
??3OCpjSequence@@CAXPAX@Z ENDP				; OCpjSequence::operator delete
_TEXT	ENDS
PUBLIC	??3OCpjSequence@@CAXPAXPAVOObject@@PAVCObjClass@@@Z ; OCpjSequence::operator delete
; Function compile flags: /Ogty
;	COMDAT ??3OCpjSequence@@CAXPAXPAVOObject@@PAVCObjClass@@@Z
_TEXT	SEGMENT
_ptr$ = 8
??3OCpjSequence@@CAXPAXPAVOObject@@PAVCObjClass@@@Z PROC NEAR ; OCpjSequence::operator delete, COMDAT

; 85   : 	OBJ_CLASS_DEFINE(OCpjSequence, OCpjChunk);

	push	esi
	mov	esi, DWORD PTR _ptr$[esp]
	mov	DWORD PTR [esi+4], 0
	mov	edx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	dec	edx
	mov	DWORD PTR ?sObjCount@OObject@@1KA, edx	; OObject::sObjCount
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	ecx, eax
	call	DWORD PTR [edx+8]
	pop	esi
	ret	0
??3OCpjSequence@@CAXPAXPAVOObject@@PAVCObjClass@@@Z ENDP ; OCpjSequence::operator delete
; Function compile flags: /Ogty
; File C:\duke4\Cannibal\CorMain.h
_TEXT	ENDS
;	COMDAT ?AddNoConstruct@?$TCorArray@E@@QAEKK@Z
_TEXT	SEGMENT
_inCount$ = 8
?AddNoConstruct@?$TCorArray@E@@QAEKK@Z PROC NEAR	; TCorArray<unsigned char>::AddNoConstruct, COMDAT
; _this$ = ecx

; 322  : 		NDword i = m_Count;
; 323  : 		if ((m_Count+=inCount)>m_Limit)

	mov	eax, DWORD PTR _inCount$[esp-4]
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	add	eax, edi
	cmp	eax, ecx
	mov	DWORD PTR [esi+4], eax
	jbe	SHORT $L46579

; 324  : 		{
; 325  : 			m_Limit = m_Count + (m_Count>>2) + 32;

	mov	ecx, eax

; 326  : 			Realloc(sizeof(T));

	mov	DWORD PTR [esi+12], 1
	shr	ecx, 2
	lea	eax, DWORD PTR [ecx+eax+32]
	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	mov	DWORD PTR [esi+8], eax
	je	SHORT $L46571
	test	eax, eax
	je	SHORT $L46573
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [esi+8]
	push	ecx
	mov	ecx, DWORD PTR [esi]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+4]
	mov	DWORD PTR [esi], eax

; 327  : 		}
; 328  : 		return(i);

	mov	eax, edi
	pop	edi
	pop	esi

; 329  : 	}

	ret	4

; 326  : 			Realloc(sizeof(T));

$L46573:
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L46577:
	mov	DWORD PTR [esi], 0
$L46579:

; 327  : 		}
; 328  : 		return(i);

	mov	eax, edi
	pop	edi
	pop	esi

; 329  : 	}

	ret	4

; 326  : 			Realloc(sizeof(T));

$L46571:
	test	eax, eax
	je	SHORT $L46577
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [esi+8]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	DWORD PTR [esi], eax

; 327  : 		}
; 328  : 		return(i);

	mov	eax, edi
	pop	edi
	pop	esi

; 329  : 	}

	ret	4
?AddNoConstruct@?$TCorArray@E@@QAEKK@Z ENDP		; TCorArray<unsigned char>::AddNoConstruct
_TEXT	ENDS
PUBLIC	?GetStaticClass@OCpjSequence@@SAPAVCObjClass@@XZ ; OCpjSequence::GetStaticClass
; Function compile flags: /Ogty
; File C:\duke4\Cannibal\CpjSeq.h
;	COMDAT ?GetStaticClass@OCpjSequence@@SAPAVCObjClass@@XZ
_TEXT	SEGMENT
?GetStaticClass@OCpjSequence@@SAPAVCObjClass@@XZ PROC NEAR ; OCpjSequence::GetStaticClass, COMDAT

; 85   : 	OBJ_CLASS_DEFINE(OCpjSequence, OCpjChunk);

	mov	eax, DWORD PTR ?staticObjClass@OCpjSequence@@0PAVCObjClass@@A ; OCpjSequence::staticObjClass
	ret	0
?GetStaticClass@OCpjSequence@@SAPAVCObjClass@@XZ ENDP	; OCpjSequence::GetStaticClass
_TEXT	ENDS
PUBLIC	?New@OCpjSequence@@SAPAV1@PAVOObject@@PAVCObjClass@@@Z ; OCpjSequence::New
PUBLIC	?GetClass@OCpjSequence@@UAEPAVCObjClass@@XZ	; OCpjSequence::GetClass
PUBLIC	??1?$TCorArray@VCCpjSeqFrame@@@@QAE@XZ		; TCorArray<CCpjSeqFrame>::~TCorArray<CCpjSeqFrame>
PUBLIC	??1?$TCorArray@VCCpjSeqEvent@@@@QAE@XZ		; TCorArray<CCpjSeqEvent>::~TCorArray<CCpjSeqEvent>
PUBLIC	?Create@OCpjSequence@@UAEXXZ			; OCpjSequence::Create
PUBLIC	?GetFileExtension@OCpjSequence@@UAEPADXZ	; OCpjSequence::GetFileExtension
PUBLIC	?GetFileDescription@OCpjSequence@@UAEPADXZ	; OCpjSequence::GetFileDescription
PUBLIC	??_7OCpjSequence@@6B@				; OCpjSequence::`vftable'
PUBLIC	??_EOCpjSequence@@UAEPAXI@Z			; OCpjSequence::`vector deleting destructor'
EXTRN	?LoadChunk@OCpjSequence@@UAE_NPAXK@Z:NEAR	; OCpjSequence::LoadChunk
EXTRN	?SaveChunk@OCpjSequence@@UAE_NPAXPAK@Z:NEAR	; OCpjSequence::SaveChunk
EXTRN	?GetFourCC@OCpjSequence@@UAEKXZ:NEAR		; OCpjSequence::GetFourCC
;	COMDAT xdata$x
; File C:\duke4\Cannibal\CorMain.h
xdata$x	SEGMENT
$T46721	DD	0ffffffffH
	DD	FLAT:$L46590
	DD	00H
	DD	FLAT:$L46615
	DD	01H
	DD	FLAT:$L46616
	DD	02H
	DD	FLAT:$L46617
$T46719	DD	019930520H
	DD	04H
	DD	FLAT:$T46721
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_7OCpjSequence@@6B@
CONST	SEGMENT
??_7OCpjSequence@@6B@ DD FLAT:?Msg@OObject@@UAE_NPAVIMsg@@@Z ; OCpjSequence::`vftable'
	DD	FLAT:?MsgGetChild@OObject@@UAEPAVIMsgTarget@@PAD@Z
	DD	FLAT:?MsgGetParent@OObject@@UAEPAVIMsgTarget@@XZ
	DD	FLAT:?MsgGetRoot@OObject@@UAEPAVIMsgTarget@@XZ
	DD	FLAT:?GetClass@OCpjSequence@@UAEPAVCObjClass@@XZ
	DD	FLAT:??_EOCpjSequence@@UAEPAXI@Z
	DD	FLAT:?Create@OCpjSequence@@UAEXXZ
	DD	FLAT:?Destroy@OObject@@UAEXXZ
	DD	FLAT:?GetParent@OObject@@UAEPAV1@XZ
	DD	FLAT:?SetParent@OObject@@UAEXPAV1@_N@Z
	DD	FLAT:?HasChildren@OObject@@UAE_NXZ
	DD	FLAT:?IsA@OObject@@UAE_NPAVCObjClass@@@Z
	DD	FLAT:?GetFileExtension@OCpjSequence@@UAEPADXZ
	DD	FLAT:?GetFileDescription@OCpjSequence@@UAEPADXZ
	DD	FLAT:?LoadFile@OCpjChunk@@UAE_NPAD@Z
	DD	FLAT:?SaveFile@OCpjChunk@@UAE_NPAD@Z
	DD	FLAT:?GetFourCC@OCpjSequence@@UAEKXZ
	DD	FLAT:?LoadChunk@OCpjSequence@@UAE_NPAXK@Z
	DD	FLAT:?SaveChunk@OCpjSequence@@UAE_NPAXPAK@Z
; Function compile flags: /Ogty
; File C:\duke4\Cannibal\CpjSeq.h
CONST	ENDS
;	COMDAT ?New@OCpjSequence@@SAPAV1@PAVOObject@@PAVCObjClass@@@Z
_TEXT	SEGMENT
_inParent$ = 8
_inSetClass$ = 12
$T46587 = -16
__$EHRec$ = -12
?New@OCpjSequence@@SAPAV1@PAVOObject@@PAVCObjClass@@@Z PROC NEAR ; OCpjSequence::New, COMDAT

; 85   : 	OBJ_CLASS_DEFINE(OCpjSequence, OCpjChunk);

	push	-1
	push	$L46720
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _inSetClass$[esp+20]
	xor	ebx, ebx
	cmp	ebp, ebx
	push	esi
	jne	SHORT $L9819
	mov	ebp, DWORD PTR ?staticObjClass@OCpjSequence@@0PAVCObjClass@@A ; OCpjSequence::staticObjClass
	mov	DWORD PTR _inSetClass$[esp+24], ebp
$L9819:
	push	edi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	124					; 0000007cH
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	ecx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	mov	esi, eax
	inc	ecx
	xor	eax, eax
	mov	DWORD PTR ?sObjCount@OObject@@1KA, ecx	; OObject::sObjCount
	mov	ecx, 31					; 0000001fH
	mov	edi, esi
	rep stosd
	mov	eax, DWORD PTR [esi+40]
	mov	DWORD PTR [esi+4], 305419896		; 12345678H
	cmp	eax, ebx
	pop	edi
	jne	SHORT $L46611
	mov	DWORD PTR [esi+40], ebp
$L46611:
	mov	eax, DWORD PTR _inParent$[esp+24]
	mov	ecx, esi
	push	eax
	call	?PreConstruct@OObject@@QAEXPAV1@@Z	; OObject::PreConstruct
	mov	DWORD PTR $T46587[esp+28], esi
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+36], ebx
	call	??0OObject@@QAE@XZ			; OObject::OObject
	mov	DWORD PTR [esi], OFFSET FLAT:??_7OCpjChunk@@6B@ ; OCpjChunk::`vftable'
	lea	ecx, DWORD PTR [esi+76]
	push	52					; 00000034H
	mov	BYTE PTR __$EHRec$[esp+40], 1
	mov	DWORD PTR [ecx], ebx
	mov	DWORD PTR [ecx+4], ebx
	mov	DWORD PTR [ecx+8], ebx
	mov	DWORD PTR [ecx+12], 52			; 00000034H
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
	lea	ecx, DWORD PTR [esi+92]
	push	12					; 0000000cH
	mov	BYTE PTR __$EHRec$[esp+40], 2
	mov	DWORD PTR [ecx], ebx
	mov	DWORD PTR [ecx+4], ebx
	mov	DWORD PTR [ecx+8], ebx
	mov	DWORD PTR [ecx+12], 12			; 0000000cH
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
	mov	DWORD PTR [esi+112], ebx
	mov	DWORD PTR [esi+116], ebx
	mov	DWORD PTR [esi+120], 8
	mov	DWORD PTR [esi+108], ebx
	mov	DWORD PTR [esi], OFFSET FLAT:??_7OCpjSequence@@6B@ ; OCpjSequence::`vftable'
	mov	edx, DWORD PTR [esi]
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+36], -1
	call	DWORD PTR [edx+24]
	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L46590:
	mov	eax, DWORD PTR _inSetClass$[ebp-4]
	push	eax
	mov	ecx, DWORD PTR _inParent$[ebp-4]
	push	ecx
	mov	edx, DWORD PTR $T46587[ebp]
	push	edx
	call	??3OCpjSequence@@CAXPAXPAVOObject@@PAVCObjClass@@@Z ; OCpjSequence::operator delete
	add	esp, 12					; 0000000cH
	ret	0
$L46615:
	mov	ecx, DWORD PTR $T46587[ebp]
	jmp	??1OCpjChunk@@UAE@XZ			; OCpjChunk::~OCpjChunk
$L46616:
	mov	ecx, DWORD PTR $T46587[ebp]
	add	ecx, 76					; 0000004cH
	jmp	??1?$TCorArray@VCCpjSeqFrame@@@@QAE@XZ	; TCorArray<CCpjSeqFrame>::~TCorArray<CCpjSeqFrame>
$L46617:
	mov	ecx, DWORD PTR $T46587[ebp]
	add	ecx, 92					; 0000005cH
	jmp	??1?$TCorArray@VCCpjSeqEvent@@@@QAE@XZ	; TCorArray<CCpjSeqEvent>::~TCorArray<CCpjSeqEvent>
$L46720:
	mov	eax, OFFSET FLAT:$T46719
	jmp	___CxxFrameHandler
text$x	ENDS
?New@OCpjSequence@@SAPAV1@PAVOObject@@PAVCObjClass@@@Z ENDP ; OCpjSequence::New
PUBLIC	??1?$TCorArray@VCCpjSeqTranslate@@@@QAE@XZ	; TCorArray<CCpjSeqTranslate>::~TCorArray<CCpjSeqTranslate>
PUBLIC	??1?$TCorArray@VCCpjSeqRotate@@@@QAE@XZ		; TCorArray<CCpjSeqRotate>::~TCorArray<CCpjSeqRotate>
PUBLIC	?Remove@?$TCorArray@VCCpjSeqRotate@@@@QAEXKK@Z	; TCorArray<CCpjSeqRotate>::Remove
PUBLIC	?Remove@?$TCorArray@VCCpjSeqScale@@@@QAEXKK@Z	; TCorArray<CCpjSeqScale>::Remove
;	COMDAT xdata$x
; File C:\duke4\Cannibal\CorMain.h
xdata$x	SEGMENT
$T46858	DD	0ffffffffH
	DD	FLAT:$L46727
	DD	00H
	DD	FLAT:$L46735
	DD	01H
	DD	FLAT:$L46736
	DD	02H
	DD	FLAT:$L46737
	DD	03H
	DD	FLAT:$L46740
	DD	02H
	DD	FLAT:$L46750
$T46854	DD	019930520H
	DD	06H
	DD	FLAT:$T46858
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ??1?$TCorArray@VCCpjSeqFrame@@@@QAE@XZ
_TEXT	SEGMENT
$T46748 = -16
$T46758 = -16
$T46789 = -20
$T46820 = -28
__$EHRec$ = -12
_this$ = -24
??1?$TCorArray@VCCpjSeqFrame@@@@QAE@XZ PROC NEAR	; TCorArray<CCpjSeqFrame>::~TCorArray<CCpjSeqFrame>, COMDAT
; _this$ = ecx

; 280  : 	{

	push	-1
	push	$L46857
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 20					; 00000014H
	push	ebx
	push	ebp
	mov	ebx, ecx
	push	esi
	push	edi
	mov	DWORD PTR _this$[esp+48], ebx

; 281  : 		Purge();

	mov	esi, DWORD PTR [ebx+4]
	xor	ebp, ebp
	cmp	esi, ebp
	mov	DWORD PTR __$EHRec$[esp+56], ebp
	mov	DWORD PTR $T46820[esp+48], esi
	jbe	$L46843

; 280  : 	{

	mov	DWORD PTR -32+[esp+48], esi

; 281  : 		Purge();

$L46841:
	mov	esi, DWORD PTR [ebx]
	add	esi, ebp
	mov	DWORD PTR $T46789[esp+48], esi
	lea	edi, DWORD PTR [esi+36]
	mov	DWORD PTR $T46748[esp+48], edi
	mov	eax, DWORD PTR [edi+4]
	mov	ecx, edi
	push	eax
	push	0
	mov	BYTE PTR __$EHRec$[esp+64], 4
	call	?Remove@?$TCorArray@VCCpjSeqScale@@@@QAEXKK@Z ; TCorArray<CCpjSeqScale>::Remove
	mov	ecx, edi
	mov	BYTE PTR __$EHRec$[esp+56], 3
	call	??1CCorArray@@IAE@XZ			; CCorArray::~CCorArray
	lea	edi, DWORD PTR [esi+20]
	mov	DWORD PTR $T46758[esp+48], edi
	mov	ecx, DWORD PTR [edi+4]
	mov	BYTE PTR __$EHRec$[esp+56], 5
	push	ecx
	push	0
	mov	ecx, edi
	call	?Remove@?$TCorArray@VCCpjSeqRotate@@@@QAEXKK@Z ; TCorArray<CCpjSeqRotate>::Remove
	mov	ecx, edi
	mov	BYTE PTR __$EHRec$[esp+56], 2
	call	??1CCorArray@@IAE@XZ			; CCorArray::~CCorArray
	lea	ecx, DWORD PTR [esi+4]
	mov	BYTE PTR __$EHRec$[esp+56], 1
	call	??1?$TCorArray@VCCpjSeqTranslate@@@@QAE@XZ ; TCorArray<CCpjSeqTranslate>::~TCorArray<CCpjSeqTranslate>
	push	0
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+60], 0
	call	?Set@CCorString@@QAEXPAD@Z		; CCorString::Set
	mov	eax, DWORD PTR -32+[esp+48]
	add	ebp, 52					; 00000034H
	dec	eax
	mov	DWORD PTR -32+[esp+48], eax
	jne	SHORT $L46841
	mov	esi, DWORD PTR $T46820[esp+48]
$L46843:
	test	esi, esi
	je	SHORT $L46837
	mov	ecx, DWORD PTR [ebx+4]
	lea	edx, DWORD PTR [esi+esi*2]
	lea	edi, DWORD PTR [ecx+ecx*2]
	lea	eax, DWORD PTR [esi+edx*4]
	mov	edx, DWORD PTR [ebx]
	lea	ecx, DWORD PTR [ecx+edi*4]
	shl	eax, 2
	shl	ecx, 2
	sub	ecx, eax
	add	eax, edx
	push	ecx
	push	eax
	push	edx
	call	DWORD PTR __imp__memmove
	mov	eax, DWORD PTR [ebx+4]
	add	esp, 12					; 0000000cH
	sub	eax, esi
	mov	DWORD PTR [ebx+4], eax
$L46837:

; 282  : 	}

	mov	eax, DWORD PTR [ebx]
	mov	DWORD PTR __$EHRec$[esp+56], -1
	test	eax, eax
	je	SHORT $L46852
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [ebx]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L46852:
	mov	ecx, DWORD PTR __$EHRec$[esp+48]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 32					; 00000020H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L46727:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CCorArray@@IAE@XZ			; CCorArray::~CCorArray
$L46735:
	mov	ecx, DWORD PTR $T46789[ebp]
	jmp	??1CCorString@@QAE@XZ			; CCorString::~CCorString
$L46736:
	mov	ecx, DWORD PTR $T46789[ebp]
	add	ecx, 4
	jmp	??1?$TCorArray@VCCpjSeqTranslate@@@@QAE@XZ ; TCorArray<CCpjSeqTranslate>::~TCorArray<CCpjSeqTranslate>
$L46737:
	mov	ecx, DWORD PTR $T46789[ebp]
	add	ecx, 20					; 00000014H
	jmp	??1?$TCorArray@VCCpjSeqRotate@@@@QAE@XZ	; TCorArray<CCpjSeqRotate>::~TCorArray<CCpjSeqRotate>
$L46740:
	mov	ecx, DWORD PTR $T46748[ebp]
	jmp	??1CCorArray@@IAE@XZ			; CCorArray::~CCorArray
$L46750:
	mov	ecx, DWORD PTR $T46758[ebp]
	jmp	??1CCorArray@@IAE@XZ			; CCorArray::~CCorArray
$L46857:
	mov	eax, OFFSET FLAT:$T46854
	jmp	___CxxFrameHandler
text$x	ENDS
??1?$TCorArray@VCCpjSeqFrame@@@@QAE@XZ ENDP		; TCorArray<CCpjSeqFrame>::~TCorArray<CCpjSeqFrame>
; Function compile flags: /Ogty
;	COMDAT ??1?$TCorArray@VCCpjSeqTranslate@@@@QAE@XZ
_TEXT	SEGMENT
??1?$TCorArray@VCCpjSeqTranslate@@@@QAE@XZ PROC NEAR	; TCorArray<CCpjSeqTranslate>::~TCorArray<CCpjSeqTranslate>, COMDAT
; _this$ = ecx

; 280  : 	{

	push	esi
	mov	esi, ecx
	push	edi

; 281  : 		Purge();

	mov	edi, DWORD PTR [esi+4]
	test	edi, edi
	je	SHORT $L46889
	mov	eax, DWORD PTR [esi]
	mov	ecx, edi
	mov	edx, edi
	sub	ecx, edi
	shl	edx, 4
	shl	ecx, 4
	add	edx, eax
	push	ecx
	push	edx
	push	eax
	call	DWORD PTR __imp__memmove
	mov	eax, DWORD PTR [esi+4]
	add	esp, 12					; 0000000cH
	sub	eax, edi
	mov	DWORD PTR [esi+4], eax
$L46889:

; 282  : 	}

	cmp	DWORD PTR [esi], 0
	je	SHORT $L46895
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L46895:
	pop	edi
	pop	esi
	ret	0
??1?$TCorArray@VCCpjSeqTranslate@@@@QAE@XZ ENDP		; TCorArray<CCpjSeqTranslate>::~TCorArray<CCpjSeqTranslate>
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??1?$TCorArray@VCCpjSeqRotate@@@@QAE@XZ
_TEXT	SEGMENT
??1?$TCorArray@VCCpjSeqRotate@@@@QAE@XZ PROC NEAR	; TCorArray<CCpjSeqRotate>::~TCorArray<CCpjSeqRotate>, COMDAT
; _this$ = ecx

; 280  : 	{

	push	esi
	mov	esi, ecx
	push	edi

; 281  : 		Purge();

	mov	edi, DWORD PTR [esi+4]
	test	edi, edi
	je	SHORT $L46926
	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [edi+edi*2]
	shl	eax, 3
	mov	edx, eax
	sub	edx, eax
	add	eax, ecx
	push	edx
	push	eax
	push	ecx
	call	DWORD PTR __imp__memmove
	mov	eax, DWORD PTR [esi+4]
	add	esp, 12					; 0000000cH
	sub	eax, edi
	mov	DWORD PTR [esi+4], eax
$L46926:

; 282  : 	}

	cmp	DWORD PTR [esi], 0
	je	SHORT $L46932
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L46932:
	pop	edi
	pop	esi
	ret	0
??1?$TCorArray@VCCpjSeqRotate@@@@QAE@XZ ENDP		; TCorArray<CCpjSeqRotate>::~TCorArray<CCpjSeqRotate>
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
$T47067	DD	0ffffffffH
	DD	FLAT:$L46938
$T47062	DD	019930520H
	DD	01H
	DD	FLAT:$T47067
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ??1?$TCorArray@VCCpjSeqEvent@@@@QAE@XZ
_TEXT	SEGMENT
$T47028 = -20
__$EHRec$ = -12
_this$ = -16
??1?$TCorArray@VCCpjSeqEvent@@@@QAE@XZ PROC NEAR	; TCorArray<CCpjSeqEvent>::~TCorArray<CCpjSeqEvent>, COMDAT
; _this$ = ecx

; 280  : 	{

	push	-1
	push	$L47066
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	mov	ebx, ecx
	push	ebp
	push	esi
	mov	DWORD PTR _this$[esp+36], ebx

; 281  : 		Purge();

	mov	esi, DWORD PTR [ebx+4]
	xor	ebp, ebp
	cmp	esi, ebp
	mov	DWORD PTR __$EHRec$[esp+44], ebp
	mov	DWORD PTR $T47028[esp+36], esi
	jbe	SHORT $L47034
	mov	DWORD PTR -24+[esp+36], esi
	push	edi
$L47032:
	mov	esi, DWORD PTR [ebx]
	add	esi, ebp
	mov	edi, DWORD PTR [esi+8]
	test	edi, edi
	je	SHORT $L47047
	or	ecx, -1
	xor	eax, eax
	repne scasb
	not	ecx
	dec	ecx
	or	eax, -1
	sub	eax, ecx
	mov	ecx, DWORD PTR ?sMemTotal@CCorString@@0KA ; CCorString::sMemTotal
	add	ecx, eax
	mov	DWORD PTR ?sMemTotal@CCorString@@0KA, ecx ; CCorString::sMemTotal
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+8]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L47047:
	mov	eax, DWORD PTR -24+[esp+40]
	add	ebp, 12					; 0000000cH
	dec	eax
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR -24+[esp+40], eax
	jne	SHORT $L47032
	mov	esi, DWORD PTR $T47028[esp+40]
	pop	edi
$L47034:
	test	esi, esi
	je	SHORT $L47054
	mov	edx, DWORD PTR [ebx+4]
	mov	ecx, DWORD PTR [ebx]
	lea	eax, DWORD PTR [esi+esi*2]
	lea	edx, DWORD PTR [edx+edx*2]
	shl	eax, 2
	shl	edx, 2
	sub	edx, eax
	add	eax, ecx
	push	edx
	push	eax
	push	ecx
	call	DWORD PTR __imp__memmove
	mov	eax, DWORD PTR [ebx+4]
	add	esp, 12					; 0000000cH
	sub	eax, esi
	mov	DWORD PTR [ebx+4], eax
$L47054:

; 282  : 	}

	mov	eax, DWORD PTR [ebx]
	mov	DWORD PTR __$EHRec$[esp+44], -1
	test	eax, eax
	je	SHORT $L47060
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [ebx]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L47060:
	mov	ecx, DWORD PTR __$EHRec$[esp+36]
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 24					; 00000018H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L46938:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CCorArray@@IAE@XZ			; CCorArray::~CCorArray
$L47066:
	mov	eax, OFFSET FLAT:$T47062
	jmp	___CxxFrameHandler
text$x	ENDS
??1?$TCorArray@VCCpjSeqEvent@@@@QAE@XZ ENDP		; TCorArray<CCpjSeqEvent>::~TCorArray<CCpjSeqEvent>
; Function compile flags: /Ogty
;	COMDAT ?Remove@?$TCorArray@E@@QAEXKK@Z
_TEXT	SEGMENT
_inIndex$ = 8
_inCount$ = 12
?Remove@?$TCorArray@E@@QAEXKK@Z PROC NEAR		; TCorArray<unsigned char>::Remove, COMDAT
; _this$ = ecx

; 374  : 	{

	push	esi
	push	edi

; 375  : 		for (NDword i=inIndex; i<(inIndex+inCount); i++)
; 376  : 			(&(*this)[i])->~T();
; 377  : 		CCorArray::Remove(inIndex, inCount, sizeof(T));

	mov	edi, DWORD PTR _inCount$[esp+4]
	mov	esi, ecx
	test	edi, edi
	je	SHORT $L47075
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR _inIndex$[esp+4]
	mov	edx, DWORD PTR [esi+4]
	add	eax, ecx
	sub	edx, ecx
	sub	edx, edi
	lea	ecx, DWORD PTR [eax+edi]
	push	edx
	push	ecx
	push	eax
	call	DWORD PTR __imp__memmove
	mov	eax, DWORD PTR [esi+4]
	add	esp, 12					; 0000000cH
	sub	eax, edi
	mov	DWORD PTR [esi+4], eax
$L47075:
	pop	edi
	pop	esi

; 378  : 	}

	ret	8
?Remove@?$TCorArray@E@@QAEXKK@Z ENDP			; TCorArray<unsigned char>::Remove
; Function compile flags: /Ogty
; File C:\duke4\Cannibal\CpjSeq.h
_TEXT	ENDS
;	COMDAT ?GetClass@OCpjSequence@@UAEPAVCObjClass@@XZ
_TEXT	SEGMENT
?GetClass@OCpjSequence@@UAEPAVCObjClass@@XZ PROC NEAR	; OCpjSequence::GetClass, COMDAT
; _this$ = ecx

; 85   : 	OBJ_CLASS_DEFINE(OCpjSequence, OCpjChunk);

	mov	eax, DWORD PTR [ecx+40]
	ret	0
?GetClass@OCpjSequence@@UAEPAVCObjClass@@XZ ENDP	; OCpjSequence::GetClass
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?Create@OCpjSequence@@UAEXXZ
_TEXT	SEGMENT
?Create@OCpjSequence@@UAEXXZ PROC NEAR			; OCpjSequence::Create, COMDAT
; _this$ = ecx

; 93   : 	{

	push	esi
	mov	esi, ecx

; 94   : 		Super::Create();

	call	?Create@OObject@@UAEXXZ			; OObject::Create
	xor	eax, eax

; 95   : 
; 96   : 		m_Rate = 10.0;

	mov	DWORD PTR [esi+72], 1092616192		; 41200000H
	mov	BYTE PTR [esi+56], al
	mov	DWORD PTR [esi+64], eax
	mov	DWORD PTR [esi+60], eax
	mov	DWORD PTR [esi+68], eax
	pop	esi

; 97   : 	}

	ret	0
?Create@OCpjSequence@@UAEXXZ ENDP			; OCpjSequence::Create
_TEXT	ENDS
PUBLIC	??_C@_03NHBO@seq?$AA@				; `string'
;	COMDAT ??_C@_03NHBO@seq?$AA@
_DATA	SEGMENT
??_C@_03NHBO@seq?$AA@ DB 'seq', 00H			; `string'
; Function compile flags: /Ogty
_DATA	ENDS
;	COMDAT ?GetFileExtension@OCpjSequence@@UAEPADXZ
_TEXT	SEGMENT
?GetFileExtension@OCpjSequence@@UAEPADXZ PROC NEAR	; OCpjSequence::GetFileExtension, COMDAT
; _this$ = ecx

; 105  : 	NChar* GetFileExtension() { return("seq"); }

	mov	eax, OFFSET FLAT:??_C@_03NHBO@seq?$AA@	; `string'
	ret	0
?GetFileExtension@OCpjSequence@@UAEPADXZ ENDP		; OCpjSequence::GetFileExtension
_TEXT	ENDS
PUBLIC	??_C@_0BC@KGFM@Cannibal?5Sequence?$AA@		; `string'
;	COMDAT ??_C@_0BC@KGFM@Cannibal?5Sequence?$AA@
_DATA	SEGMENT
??_C@_0BC@KGFM@Cannibal?5Sequence?$AA@ DB 'Cannibal Sequence', 00H ; `string'
; Function compile flags: /Ogty
_DATA	ENDS
;	COMDAT ?GetFileDescription@OCpjSequence@@UAEPADXZ
_TEXT	SEGMENT
?GetFileDescription@OCpjSequence@@UAEPADXZ PROC NEAR	; OCpjSequence::GetFileDescription, COMDAT
; _this$ = ecx

; 106  : 	NChar* GetFileDescription() { return("Cannibal Sequence"); }

	mov	eax, OFFSET FLAT:??_C@_0BC@KGFM@Cannibal?5Sequence?$AA@ ; `string'
	ret	0
?GetFileDescription@OCpjSequence@@UAEPADXZ ENDP		; OCpjSequence::GetFileDescription
_TEXT	ENDS
PUBLIC	??0OCpjSequence@@QAE@XZ				; OCpjSequence::OCpjSequence
;	COMDAT xdata$x
xdata$x	SEGMENT
$T47206	DD	0ffffffffH
	DD	FLAT:$L47097
	DD	00H
	DD	FLAT:$L47098
	DD	01H
	DD	FLAT:$L47099
$T47204	DD	019930520H
	DD	03H
	DD	FLAT:$T47206
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ??0OCpjSequence@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12
_this$ = -16
??0OCpjSequence@@QAE@XZ PROC NEAR			; OCpjSequence::OCpjSequence, COMDAT
; _this$ = ecx
	push	-1
	push	$L47205
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	push	esi
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+24], esi
	call	??0OObject@@QAE@XZ			; OObject::OObject
	mov	DWORD PTR [esi], OFFSET FLAT:??_7OCpjChunk@@6B@ ; OCpjChunk::`vftable'
	xor	edi, edi
	mov	DWORD PTR [esi+88], 52			; 00000034H
	mov	DWORD PTR __$EHRec$[esp+32], edi
	mov	DWORD PTR [esi+80], edi
	mov	DWORD PTR [esi+84], edi
	mov	DWORD PTR [esi+76], edi
	lea	ecx, DWORD PTR [esi+92]
	push	12					; 0000000cH
	mov	BYTE PTR __$EHRec$[esp+36], 1
	mov	DWORD PTR [ecx], edi
	mov	DWORD PTR [ecx+4], edi
	mov	DWORD PTR [ecx+8], edi
	mov	DWORD PTR [ecx+12], 12			; 0000000cH
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR [esi+112], edi
	mov	DWORD PTR [esi+116], edi
	mov	DWORD PTR [esi+120], 8
	mov	DWORD PTR [esi+108], edi
	mov	DWORD PTR [esi], OFFSET FLAT:??_7OCpjSequence@@6B@ ; OCpjSequence::`vftable'
	mov	eax, esi
	pop	edi
	pop	esi
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L47097:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1OCpjChunk@@UAE@XZ			; OCpjChunk::~OCpjChunk
$L47098:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 76					; 0000004cH
	jmp	??1?$TCorArray@VCCpjSeqFrame@@@@QAE@XZ	; TCorArray<CCpjSeqFrame>::~TCorArray<CCpjSeqFrame>
$L47099:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 92					; 0000005cH
	jmp	??1?$TCorArray@VCCpjSeqEvent@@@@QAE@XZ	; TCorArray<CCpjSeqEvent>::~TCorArray<CCpjSeqEvent>
$L47205:
	mov	eax, OFFSET FLAT:$T47204
	jmp	___CxxFrameHandler
text$x	ENDS
??0OCpjSequence@@QAE@XZ ENDP				; OCpjSequence::OCpjSequence
PUBLIC	??0CCpjSeqBoneInfo@@QAE@ABV0@@Z			; CCpjSeqBoneInfo::CCpjSeqBoneInfo
PUBLIC	??0CCpjSeqFrame@@QAE@AAV0@@Z			; CCpjSeqFrame::CCpjSeqFrame
PUBLIC	??0CCpjSeqEvent@@QAE@ABV0@@Z			; CCpjSeqEvent::CCpjSeqEvent
PUBLIC	?AddNoConstruct@?$TCorArray@VCCpjSeqBoneInfo@@@@QAEKK@Z ; TCorArray<CCpjSeqBoneInfo>::AddNoConstruct
PUBLIC	??0OCpjSequence@@QAE@AAV0@@Z			; OCpjSequence::OCpjSequence
;	COMDAT xdata$x
xdata$x	SEGMENT
$T47375	DD	0ffffffffH
	DD	FLAT:$L47212
	DD	00H
	DD	FLAT:$L47232
	DD	01H
	DD	FLAT:$L47233
	DD	00H
	DD	FLAT:$L47213
	DD	03H
	DD	FLAT:$L47283
	DD	04H
	DD	FLAT:$L47284
	DD	03H
	DD	FLAT:$L47214
	DD	06H
	DD	FLAT:$L47334
	DD	07H
	DD	FLAT:$L47335
$T47366	DD	019930520H
	DD	09H
	DD	FLAT:$T47375
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ??0OCpjSequence@@QAE@AAV0@@Z
_TEXT	SEGMENT
$T47254 = -16
$T47255 = -20
_i$47271 = -32
$T47275 = -24
$T47305 = -24
$T47306 = -20
_i$47322 = -32
$T47326 = -16
$T47348 = -20
$T47349 = -16
$T47363 = 8
__$EHRec$ = -12
___that$ = 8
_this$ = -28
??0OCpjSequence@@QAE@AAV0@@Z PROC NEAR			; OCpjSequence::OCpjSequence, COMDAT
; _this$ = ecx
	push	-1
	push	$L47374
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 20					; 00000014H
	push	ebx
	push	ebp
	push	esi
	mov	esi, DWORD PTR ___that$[esp+40]
	push	edi
	mov	ebp, ecx
	push	esi
	mov	DWORD PTR _this$[esp+52], ebp
	call	??0OObject@@QAE@ABV0@@Z			; OObject::OObject
	mov	DWORD PTR [ebp], OFFSET FLAT:??_7OCpjRes@@6B@ ; OCpjRes::`vftable'
	mov	al, BYTE PTR [esi+56]
	mov	BYTE PTR [ebp+56], al
	mov	ecx, DWORD PTR [esi+60]
	mov	DWORD PTR [ebp+60], ecx
	mov	edx, DWORD PTR [esi+64]
	mov	DWORD PTR [ebp+64], edx
	mov	eax, DWORD PTR [esi+68]
	mov	DWORD PTR [ebp+68], eax
	mov	DWORD PTR [ebp], OFFSET FLAT:??_7OCpjChunk@@6B@ ; OCpjChunk::`vftable'
	mov	ecx, DWORD PTR [esi+72]
	lea	edi, DWORD PTR [ebp+76]
	mov	DWORD PTR [ebp+72], ecx
	mov	eax, DWORD PTR [esi+80]
	xor	ebx, ebx
	push	52					; 00000034H
	mov	ecx, edi
	mov	DWORD PTR __$EHRec$[esp+60], ebx
	mov	DWORD PTR $T47275[esp+52], edi
	mov	DWORD PTR [edi], ebx
	mov	DWORD PTR [edi+4], eax
	mov	DWORD PTR [edi+8], eax
	mov	DWORD PTR [edi+12], 52			; 00000034H
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
	mov	DWORD PTR [edi+4], ebx
	mov	eax, DWORD PTR [esi+80]
	cmp	eax, ebx
	mov	BYTE PTR __$EHRec$[esp+56], 1
	mov	DWORD PTR _i$47271[esp+48], ebx
	jbe	SHORT $L47274
	mov	DWORD PTR 8+[esp+44], ebx
$L47272:
	mov	ebx, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi+8]
	lea	eax, DWORD PTR [ebx+1]
	cmp	eax, ecx
	mov	DWORD PTR [edi+4], eax
	jbe	SHORT $L47263
	mov	edx, eax
	push	52					; 00000034H
	shr	edx, 2
	mov	ecx, edi
	lea	eax, DWORD PTR [edx+eax+32]
	mov	DWORD PTR [edi+8], eax
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
$L47263:
	mov	eax, DWORD PTR [edi]
	lea	ecx, DWORD PTR [ebx+ebx*2]
	lea	edx, DWORD PTR [ebx+ecx*4]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR $T47255[esp+48], ecx
	mov	DWORD PTR $T47254[esp+48], ecx
	test	ecx, ecx
	mov	BYTE PTR __$EHRec$[esp+56], 2
	je	SHORT $L47256
	mov	edx, DWORD PTR [esi+76]
	mov	ebx, DWORD PTR 8+[esp+44]
	add	edx, ebx
	push	edx
	call	??0CCpjSeqFrame@@QAE@AAV0@@Z		; CCpjSeqFrame::CCpjSeqFrame
$L47256:
	mov	eax, DWORD PTR _i$47271[esp+48]
	mov	edx, DWORD PTR 8+[esp+44]
	mov	ecx, DWORD PTR [esi+80]
	inc	eax
	add	edx, 52					; 00000034H
	cmp	eax, ecx
	mov	BYTE PTR __$EHRec$[esp+56], 1
	mov	DWORD PTR _i$47271[esp+48], eax
	mov	DWORD PTR 8+[esp+44], edx
	jb	SHORT $L47272
	xor	ebx, ebx
$L47274:
	mov	eax, DWORD PTR [esi+96]
	lea	edi, DWORD PTR [ebp+92]
	push	12					; 0000000cH
	mov	ecx, edi
	mov	BYTE PTR __$EHRec$[esp+60], 3
	mov	DWORD PTR $T47326[esp+52], edi
	mov	DWORD PTR [edi], ebx
	mov	DWORD PTR [edi+4], eax
	mov	DWORD PTR [edi+8], eax
	mov	DWORD PTR [edi+12], 12			; 0000000cH
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
	mov	DWORD PTR [edi+4], ebx
	mov	eax, DWORD PTR [esi+96]
	cmp	eax, ebx
	mov	BYTE PTR __$EHRec$[esp+56], 4
	mov	DWORD PTR _i$47322[esp+48], ebx
	jbe	SHORT $L47325
	mov	DWORD PTR 8+[esp+44], ebx
$L47323:
	mov	ebx, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi+8]
	lea	eax, DWORD PTR [ebx+1]
	cmp	eax, ecx
	mov	DWORD PTR [edi+4], eax
	jbe	SHORT $L47314
	mov	ecx, eax
	push	12					; 0000000cH
	shr	ecx, 2
	lea	edx, DWORD PTR [ecx+eax+32]
	mov	ecx, edi
	mov	DWORD PTR [edi+8], edx
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
$L47314:
	mov	ecx, DWORD PTR [edi]
	lea	eax, DWORD PTR [ebx+ebx*2]
	lea	ecx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR $T47306[esp+48], ecx
	mov	DWORD PTR $T47305[esp+48], ecx
	test	ecx, ecx
	mov	BYTE PTR __$EHRec$[esp+56], 5
	je	SHORT $L47307
	mov	edx, DWORD PTR [esi+92]
	mov	ebx, DWORD PTR 8+[esp+44]
	add	edx, ebx
	push	edx
	call	??0CCpjSeqEvent@@QAE@ABV0@@Z		; CCpjSeqEvent::CCpjSeqEvent
$L47307:
	mov	eax, DWORD PTR _i$47322[esp+48]
	mov	edx, DWORD PTR 8+[esp+44]
	mov	ecx, DWORD PTR [esi+96]
	inc	eax
	add	edx, 12					; 0000000cH
	cmp	eax, ecx
	mov	BYTE PTR __$EHRec$[esp+56], 4
	mov	DWORD PTR _i$47322[esp+48], eax
	mov	DWORD PTR 8+[esp+44], edx
	jb	SHORT $L47323
	xor	ebx, ebx
$L47325:
	mov	eax, DWORD PTR [esi+112]
	lea	edi, DWORD PTR [ebp+108]
	push	8
	push	eax
	mov	ecx, edi
	mov	BYTE PTR __$EHRec$[esp+64], 6
	mov	DWORD PTR $T47363[esp+52], edi
	call	??0CCorArray@@IAE@KK@Z			; CCorArray::CCorArray
	mov	DWORD PTR [edi+4], ebx
	mov	eax, DWORD PTR [esi+112]
	test	eax, eax
	mov	BYTE PTR __$EHRec$[esp+56], 7
	jbe	SHORT $L47373
$L47360:
	push	1
	mov	ecx, edi
	call	?AddNoConstruct@?$TCorArray@VCCpjSeqBoneInfo@@@@QAEKK@Z ; TCorArray<CCpjSeqBoneInfo>::AddNoConstruct
	mov	ecx, DWORD PTR [edi]
	lea	ecx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR $T47349[esp+48], ecx
	mov	DWORD PTR $T47348[esp+48], ecx
	test	ecx, ecx
	mov	BYTE PTR __$EHRec$[esp+56], 8
	je	SHORT $L47350
	mov	edx, DWORD PTR [esi+108]
	lea	eax, DWORD PTR [edx+ebx*8]
	push	eax
	call	??0CCpjSeqBoneInfo@@QAE@ABV0@@Z		; CCpjSeqBoneInfo::CCpjSeqBoneInfo
$L47350:
	mov	eax, DWORD PTR [esi+112]
	inc	ebx
	cmp	ebx, eax
	mov	BYTE PTR __$EHRec$[esp+56], 7
	jb	SHORT $L47360
$L47373:
	mov	ecx, DWORD PTR __$EHRec$[esp+48]
	pop	edi
	mov	DWORD PTR [ebp], OFFSET FLAT:??_7OCpjSequence@@6B@ ; OCpjSequence::`vftable'
	mov	eax, ebp
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 32					; 00000020H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L47212:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1OCpjChunk@@UAE@XZ			; OCpjChunk::~OCpjChunk
$L47232:
	mov	ecx, DWORD PTR $T47275[ebp]
	jmp	??1CCorArray@@IAE@XZ			; CCorArray::~CCorArray
$L47233:
	mov	eax, DWORD PTR $T47255[ebp]
	push	eax
	mov	ecx, DWORD PTR $T47254[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
$L47213:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 76					; 0000004cH
	jmp	??1?$TCorArray@VCCpjSeqFrame@@@@QAE@XZ	; TCorArray<CCpjSeqFrame>::~TCorArray<CCpjSeqFrame>
$L47283:
	mov	ecx, DWORD PTR $T47326[ebp]
	jmp	??1CCorArray@@IAE@XZ			; CCorArray::~CCorArray
$L47284:
	mov	eax, DWORD PTR $T47306[ebp]
	push	eax
	mov	ecx, DWORD PTR $T47305[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
$L47214:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 92					; 0000005cH
	jmp	??1?$TCorArray@VCCpjSeqEvent@@@@QAE@XZ	; TCorArray<CCpjSeqEvent>::~TCorArray<CCpjSeqEvent>
$L47334:
	mov	ecx, DWORD PTR $T47363[ebp-4]
	jmp	??1CCorArray@@IAE@XZ			; CCorArray::~CCorArray
$L47335:
	mov	eax, DWORD PTR $T47349[ebp]
	push	eax
	mov	ecx, DWORD PTR $T47348[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
$L47374:
	mov	eax, OFFSET FLAT:$T47366
	jmp	___CxxFrameHandler
text$x	ENDS
??0OCpjSequence@@QAE@AAV0@@Z ENDP			; OCpjSequence::OCpjSequence
PUBLIC	??0CCpjSeqTranslate@@QAE@ABV0@@Z		; CCpjSeqTranslate::CCpjSeqTranslate
PUBLIC	??0CCpjSeqRotate@@QAE@ABV0@@Z			; CCpjSeqRotate::CCpjSeqRotate
PUBLIC	??0CCpjSeqScale@@QAE@ABV0@@Z			; CCpjSeqScale::CCpjSeqScale
PUBLIC	?AddNoConstruct@?$TCorArray@VCCpjSeqRotate@@@@QAEKK@Z ; TCorArray<CCpjSeqRotate>::AddNoConstruct
PUBLIC	?AddNoConstruct@?$TCorArray@VCCpjSeqScale@@@@QAEKK@Z ; TCorArray<CCpjSeqScale>::AddNoConstruct
;	COMDAT xdata$x
xdata$x	SEGMENT
$T47551	DD	0ffffffffH
	DD	FLAT:$L47381
	DD	00H
	DD	FLAT:$L47413
	DD	01H
	DD	FLAT:$L47414
	DD	00H
	DD	FLAT:$L47382
	DD	03H
	DD	FLAT:$L47464
	DD	04H
	DD	FLAT:$L47465
	DD	03H
	DD	FLAT:$L47383
	DD	06H
	DD	FLAT:$L47507
	DD	07H
	DD	FLAT:$L47508
$T47539	DD	019930520H
	DD	09H
	DD	FLAT:$T47551
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ??0CCpjSeqFrame@@QAE@AAV0@@Z
_TEXT	SEGMENT
___that$ = 8
_this$ = -28
$T47435 = -16
$T47436 = -20
$T47456 = -24
$T47487 = -20
$T47488 = -16
$T47499 = 8
$T47526 = -20
$T47527 = -16
$T47536 = 8
__$EHRec$ = -12
??0CCpjSeqFrame@@QAE@AAV0@@Z PROC NEAR			; CCpjSeqFrame::CCpjSeqFrame, COMDAT
; _this$ = ecx
	push	-1
	push	$L47550
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 16					; 00000010H
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR ___that$[esp+32]
	mov	ebx, ecx
	push	esi
	push	edi
	mov	DWORD PTR [ebx], 0
	mov	esi, DWORD PTR [ebp]
	test	esi, esi
	mov	DWORD PTR _this$[esp+44], ebx
	je	SHORT $L47401
	cmp	BYTE PTR [esi], 0
	jne	SHORT $L47401
	xor	esi, esi
$L47401:
	test	esi, esi
	mov	DWORD PTR [ebx], 0
	je	SHORT $L47404
	mov	edi, esi
	or	ecx, -1
	xor	eax, eax
	repne scasb
	not	ecx
	dec	ecx
	mov	edi, ecx
	inc	edi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	edi
	mov	ecx, eax
	call	DWORD PTR [edx]
	test	eax, eax
	mov	DWORD PTR [ebx], eax
	je	SHORT $L47404
	mov	ecx, eax
$L47406:
	mov	al, BYTE PTR [esi]
	inc	esi
	mov	BYTE PTR [ecx], al
	inc	ecx
	test	al, al
	jne	SHORT $L47406
	add	DWORD PTR ?sMemTotal@CCorString@@0KA, edi ; CCorString::sMemTotal
$L47404:
	mov	eax, DWORD PTR [ebp+8]
	lea	esi, DWORD PTR [ebx+4]
	xor	edi, edi
	push	16					; 00000010H
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+56], edi
	mov	DWORD PTR $T47456[esp+48], esi
	mov	DWORD PTR [esi], edi
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], 16			; 00000010H
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
	mov	DWORD PTR [esi+4], edi
	mov	eax, DWORD PTR [ebp+8]
	xor	ebx, ebx
	mov	BYTE PTR __$EHRec$[esp+52], 1
	test	eax, eax
	jbe	SHORT $L47455
	mov	DWORD PTR 8+[esp+40], ebx
$L47453:
	mov	edi, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	lea	eax, DWORD PTR [edi+1]
	cmp	eax, ecx
	mov	DWORD PTR [esi+4], eax
	jbe	SHORT $L47443
	mov	ecx, eax
	push	16					; 00000010H
	shr	ecx, 2
	lea	edx, DWORD PTR [ecx+eax+32]
	mov	ecx, esi
	mov	DWORD PTR [esi+8], edx
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
$L47443:
	mov	eax, DWORD PTR [esi]
	shl	edi, 4
	add	edi, eax
	mov	ecx, edi
	mov	DWORD PTR $T47436[esp+44], ecx
	mov	DWORD PTR $T47435[esp+44], ecx
	mov	BYTE PTR __$EHRec$[esp+52], 2
	je	SHORT $L47437
	mov	eax, DWORD PTR [ebp+4]
	mov	edi, DWORD PTR 8+[esp+40]
	add	eax, edi
	push	eax
	call	??0CCpjSeqTranslate@@QAE@ABV0@@Z	; CCpjSeqTranslate::CCpjSeqTranslate
$L47437:
	mov	ecx, DWORD PTR 8+[esp+40]
	mov	eax, DWORD PTR [ebp+8]
	inc	ebx
	add	ecx, 16					; 00000010H
	cmp	ebx, eax
	mov	BYTE PTR __$EHRec$[esp+52], 1
	mov	DWORD PTR 8+[esp+40], ecx
	jb	SHORT $L47453
$L47455:
	mov	ebx, DWORD PTR _this$[esp+44]
	mov	eax, DWORD PTR [ebp+24]
	xor	edi, edi
	push	24					; 00000018H
	lea	esi, DWORD PTR [ebx+20]
	mov	BYTE PTR __$EHRec$[esp+56], 3
	mov	ecx, esi
	mov	DWORD PTR $T47499[esp+44], esi
	mov	DWORD PTR [esi], edi
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], 24			; 00000018H
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
	mov	DWORD PTR [esi+4], edi
	mov	eax, DWORD PTR [ebp+24]
	test	eax, eax
	mov	BYTE PTR __$EHRec$[esp+52], 4
	jbe	SHORT $L47484
	xor	ebx, ebx
$L47482:
	push	1
	mov	ecx, esi
	call	?AddNoConstruct@?$TCorArray@VCCpjSeqRotate@@@@QAEKK@Z ; TCorArray<CCpjSeqRotate>::AddNoConstruct
	mov	edx, DWORD PTR [esi]
	lea	ecx, DWORD PTR [eax+eax*2]
	lea	ecx, DWORD PTR [edx+ecx*8]
	mov	DWORD PTR $T47488[esp+44], ecx
	mov	DWORD PTR $T47487[esp+44], ecx
	test	ecx, ecx
	mov	BYTE PTR __$EHRec$[esp+52], 5
	je	SHORT $L47489
	mov	eax, DWORD PTR [ebp+20]
	add	eax, ebx
	push	eax
	call	??0CCpjSeqRotate@@QAE@ABV0@@Z		; CCpjSeqRotate::CCpjSeqRotate
$L47489:
	mov	eax, DWORD PTR [ebp+24]
	inc	edi
	add	ebx, 24					; 00000018H
	cmp	edi, eax
	mov	BYTE PTR __$EHRec$[esp+52], 4
	jb	SHORT $L47482
	mov	ebx, DWORD PTR _this$[esp+44]
$L47484:
	mov	ecx, DWORD PTR [ebp+40]
	lea	esi, DWORD PTR [ebx+36]
	push	16					; 00000010H
	push	ecx
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+60], 6
	mov	DWORD PTR $T47536[esp+48], esi
	call	??0CCorArray@@IAE@KK@Z			; CCorArray::CCorArray
	xor	edi, edi
	mov	BYTE PTR __$EHRec$[esp+52], 7
	mov	DWORD PTR [esi+4], edi
	mov	eax, DWORD PTR [ebp+40]
	cmp	eax, edi
	jbe	SHORT $L47547
	xor	ebx, ebx
$L47521:
	push	1
	mov	ecx, esi
	call	?AddNoConstruct@?$TCorArray@VCCpjSeqScale@@@@QAEKK@Z ; TCorArray<CCpjSeqScale>::AddNoConstruct
	mov	ecx, DWORD PTR [esi]
	shl	eax, 4
	add	eax, ecx
	mov	DWORD PTR $T47527[esp+44], eax
	mov	DWORD PTR $T47526[esp+44], eax
	mov	BYTE PTR __$EHRec$[esp+52], 8
	je	SHORT $L47528
	mov	edx, DWORD PTR [ebp+36]
	mov	ecx, eax
	add	edx, ebx
	push	edx
	call	??0CCpjSeqScale@@QAE@ABV0@@Z		; CCpjSeqScale::CCpjSeqScale
$L47528:
	mov	eax, DWORD PTR [ebp+40]
	inc	edi
	add	ebx, 16					; 00000010H
	cmp	edi, eax
	mov	BYTE PTR __$EHRec$[esp+52], 7
	jb	SHORT $L47521
	mov	eax, DWORD PTR _this$[esp+44]
	jmp	SHORT $L47523
$L47547:
	mov	eax, ebx
$L47523:
	mov	ecx, DWORD PTR __$EHRec$[esp+44]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 28					; 0000001cH
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L47381:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CCorString@@QAE@XZ			; CCorString::~CCorString
$L47413:
	mov	ecx, DWORD PTR $T47456[ebp]
	jmp	??1CCorArray@@IAE@XZ			; CCorArray::~CCorArray
$L47414:
	mov	eax, DWORD PTR $T47436[ebp]
	push	eax
	mov	ecx, DWORD PTR $T47435[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
$L47382:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	??1?$TCorArray@VCCpjSeqTranslate@@@@QAE@XZ ; TCorArray<CCpjSeqTranslate>::~TCorArray<CCpjSeqTranslate>
$L47464:
	mov	ecx, DWORD PTR $T47499[ebp-4]
	jmp	??1CCorArray@@IAE@XZ			; CCorArray::~CCorArray
$L47465:
	mov	eax, DWORD PTR $T47488[ebp]
	push	eax
	mov	ecx, DWORD PTR $T47487[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
$L47383:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	jmp	??1?$TCorArray@VCCpjSeqRotate@@@@QAE@XZ	; TCorArray<CCpjSeqRotate>::~TCorArray<CCpjSeqRotate>
$L47507:
	mov	ecx, DWORD PTR $T47536[ebp-4]
	jmp	??1CCorArray@@IAE@XZ			; CCorArray::~CCorArray
$L47508:
	mov	eax, DWORD PTR $T47527[ebp]
	push	eax
	mov	ecx, DWORD PTR $T47526[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
$L47550:
	mov	eax, OFFSET FLAT:$T47539
	jmp	___CxxFrameHandler
text$x	ENDS
??0CCpjSeqFrame@@QAE@AAV0@@Z ENDP			; CCpjSeqFrame::CCpjSeqFrame
; Function compile flags: /Ogty
;	COMDAT ??0CCpjSeqEvent@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8
??0CCpjSeqEvent@@QAE@ABV0@@Z PROC NEAR			; CCpjSeqEvent::CCpjSeqEvent, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	ebp
	mov	ebp, ecx
	push	esi
	mov	ecx, DWORD PTR [eax]
	push	edi
	mov	DWORD PTR [ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ebp+4], edx
	mov	DWORD PTR [ebp+8], 0
	mov	esi, DWORD PTR [eax+8]
	test	esi, esi
	je	SHORT $L47574
	cmp	BYTE PTR [esi], 0
	jne	SHORT $L47574
	xor	esi, esi
$L47574:
	test	esi, esi
	mov	DWORD PTR [ebp+8], 0
	je	SHORT $L47583
	mov	edi, esi
	or	ecx, -1
	xor	eax, eax
	repne scasb
	not	ecx
	dec	ecx
	mov	edi, ecx
	inc	edi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	edi
	mov	ecx, eax
	call	DWORD PTR [edx]
	test	eax, eax
	mov	DWORD PTR [ebp+8], eax
	je	SHORT $L47583
	mov	ecx, eax
$L47579:
	mov	al, BYTE PTR [esi]
	inc	esi
	mov	BYTE PTR [ecx], al
	inc	ecx
	test	al, al
	jne	SHORT $L47579
	add	DWORD PTR ?sMemTotal@CCorString@@0KA, edi ; CCorString::sMemTotal
$L47583:
	pop	edi
	mov	eax, ebp
	pop	esi
	pop	ebp
	ret	4
??0CCpjSeqEvent@@QAE@ABV0@@Z ENDP			; CCpjSeqEvent::CCpjSeqEvent
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??0CCpjSeqBoneInfo@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8
??0CCpjSeqBoneInfo@@QAE@ABV0@@Z PROC NEAR		; CCpjSeqBoneInfo::CCpjSeqBoneInfo, COMDAT
; _this$ = ecx
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR ___that$[esp+4]
	mov	ebx, ecx
	push	esi
	push	edi
	mov	DWORD PTR [ebx], 0
	mov	esi, DWORD PTR [ebp]
	test	esi, esi
	je	SHORT $L47604
	cmp	BYTE PTR [esi], 0
	jne	SHORT $L47604
	xor	esi, esi
$L47604:
	test	esi, esi
	mov	DWORD PTR [ebx], 0
	je	SHORT $L47607
	mov	edi, esi
	or	ecx, -1
	xor	eax, eax
	repne scasb
	not	ecx
	dec	ecx
	mov	edi, ecx
	inc	edi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	edi
	mov	ecx, eax
	call	DWORD PTR [edx]
	test	eax, eax
	mov	DWORD PTR [ebx], eax
	je	SHORT $L47607
	mov	ecx, eax
$L47609:
	mov	al, BYTE PTR [esi]
	inc	esi
	mov	BYTE PTR [ecx], al
	inc	ecx
	test	al, al
	jne	SHORT $L47609
	add	DWORD PTR ?sMemTotal@CCorString@@0KA, edi ; CCorString::sMemTotal
$L47607:
	mov	eax, DWORD PTR [ebp+4]
	pop	edi
	mov	DWORD PTR [ebx+4], eax
	pop	esi
	mov	eax, ebx
	pop	ebp
	pop	ebx
	ret	4
??0CCpjSeqBoneInfo@@QAE@ABV0@@Z ENDP			; CCpjSeqBoneInfo::CCpjSeqBoneInfo
_TEXT	ENDS
PUBLIC	??4?$TCorArray@VCCpjSeqFrame@@@@QAEAAV0@AAV0@@Z	; TCorArray<CCpjSeqFrame>::operator=
PUBLIC	??4?$TCorArray@VCCpjSeqEvent@@@@QAEAAV0@AAV0@@Z	; TCorArray<CCpjSeqEvent>::operator=
PUBLIC	??4?$TCorArray@VCCpjSeqBoneInfo@@@@QAEAAV0@AAV0@@Z ; TCorArray<CCpjSeqBoneInfo>::operator=
PUBLIC	??4OCpjSequence@@QAEAAV0@AAV0@@Z		; OCpjSequence::operator=
; Function compile flags: /Ogty
;	COMDAT ??4OCpjSequence@@QAEAAV0@AAV0@@Z
_TEXT	SEGMENT
___that$ = 8
??4OCpjSequence@@QAEAAV0@AAV0@@Z PROC NEAR		; OCpjSequence::operator=, COMDAT
; _this$ = ecx
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR ___that$[esp+4]
	push	esi
	mov	esi, ecx
	push	edi
	mov	eax, DWORD PTR [ebp+4]
	lea	ecx, DWORD PTR [ebp+8]
	mov	DWORD PTR [esi+4], eax
	lea	edx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	lea	eax, DWORD PTR [esi+24]
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], ecx
	lea	edx, DWORD PTR [ebp+24]
	mov	ecx, DWORD PTR [ebp+24]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR [ebp+40]
	mov	DWORD PTR [esi+40], eax
	mov	ebx, DWORD PTR [ebp+44]
	test	ebx, ebx
	je	SHORT $L47683
	cmp	BYTE PTR [ebx], 0
	jne	SHORT $L47683
	xor	ebx, ebx
$L47683:
	mov	edi, DWORD PTR [esi+44]
	test	edi, edi
	je	SHORT $L47684
	or	ecx, -1
	xor	eax, eax
	repne scasb
	mov	eax, DWORD PTR ?sMemTotal@CCorString@@0KA ; CCorString::sMemTotal
	or	edx, -1
	not	ecx
	dec	ecx
	sub	edx, ecx
	add	eax, edx
	mov	DWORD PTR ?sMemTotal@CCorString@@0KA, eax ; CCorString::sMemTotal
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+44]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L47684:
	test	ebx, ebx
	mov	DWORD PTR [esi+44], 0
	je	SHORT $L47687
	mov	edi, ebx
	or	ecx, -1
	xor	eax, eax
	repne scasb
	not	ecx
	dec	ecx
	mov	edi, ecx
	inc	edi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	edi
	mov	ecx, eax
	call	DWORD PTR [edx]
	test	eax, eax
	mov	DWORD PTR [esi+44], eax
	je	SHORT $L47687
$L47689:
	mov	cl, BYTE PTR [ebx]
	inc	ebx
	mov	BYTE PTR [eax], cl
	inc	eax
	test	cl, cl
	jne	SHORT $L47689
	add	DWORD PTR ?sMemTotal@CCorString@@0KA, edi ; CCorString::sMemTotal
$L47687:
	mov	eax, DWORD PTR [ebp+48]
	mov	DWORD PTR [esi+48], eax
	mov	ecx, DWORD PTR [ebp+52]
	mov	DWORD PTR [esi+52], ecx
	mov	dl, BYTE PTR [ebp+56]
	mov	BYTE PTR [esi+56], dl
	mov	eax, DWORD PTR [ebp+60]
	mov	DWORD PTR [esi+60], eax
	mov	ecx, DWORD PTR [ebp+64]
	mov	DWORD PTR [esi+64], ecx
	mov	edx, DWORD PTR [ebp+68]
	lea	ecx, DWORD PTR [ebp+76]
	mov	DWORD PTR [esi+68], edx
	mov	eax, DWORD PTR [ebp+72]
	push	ecx
	lea	ecx, DWORD PTR [esi+76]
	mov	DWORD PTR [esi+72], eax
	call	??4?$TCorArray@VCCpjSeqFrame@@@@QAEAAV0@AAV0@@Z ; TCorArray<CCpjSeqFrame>::operator=
	lea	edx, DWORD PTR [ebp+92]
	lea	ecx, DWORD PTR [esi+92]
	push	edx
	call	??4?$TCorArray@VCCpjSeqEvent@@@@QAEAAV0@AAV0@@Z ; TCorArray<CCpjSeqEvent>::operator=
	add	ebp, 108				; 0000006cH
	lea	ecx, DWORD PTR [esi+108]
	push	ebp
	call	??4?$TCorArray@VCCpjSeqBoneInfo@@@@QAEAAV0@AAV0@@Z ; TCorArray<CCpjSeqBoneInfo>::operator=
	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	4
??4OCpjSequence@@QAEAAV0@AAV0@@Z ENDP			; OCpjSequence::operator=
_TEXT	ENDS
PUBLIC	?AddNoConstruct@?$TCorArray@VCCpjSeqTranslate@@@@QAEKK@Z ; TCorArray<CCpjSeqTranslate>::AddNoConstruct
PUBLIC	??0?$TCorArray@VCCpjSeqScale@@@@QAE@AAV0@@Z	; TCorArray<CCpjSeqScale>::TCorArray<CCpjSeqScale>
;	COMDAT xdata$x
; File C:\duke4\Cannibal\CorMain.h
xdata$x	SEGMENT
$T47866	DD	0ffffffffH
	DD	FLAT:$L47700
	DD	00H
	DD	FLAT:$L47727
	DD	01H
	DD	FLAT:$L47740
	DD	02H
	DD	FLAT:$L47741
	DD	01H
	DD	FLAT:$L47728
	DD	04H
	DD	FLAT:$L47783
	DD	05H
	DD	FLAT:$L47784
	DD	04H
	DD	FLAT:$L47729
$T47856	DD	019930520H
	DD	08H
	DD	FLAT:$T47866
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ??4?$TCorArray@VCCpjSeqFrame@@@@QAEAAV0@AAV0@@Z
_TEXT	SEGMENT
$T47775 = -24
$T47812 = -16
$T47824 = -16
$T47825 = -20
$T47835 = -24
$T47836 = -20
__$EHRec$ = -12
_inArray$ = 8
_this$ = -36
_i$ = -40
$T47696 = -28
$T47697 = -32
??4?$TCorArray@VCCpjSeqFrame@@@@QAEAAV0@AAV0@@Z PROC NEAR ; TCorArray<CCpjSeqFrame>::operator=, COMDAT
; _this$ = ecx

; 269  : 	{

	push	-1
	push	$L47864
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 36					; 00000024H
	push	ebx

; 270  : 		if (this == &inArray)

	mov	ebx, DWORD PTR _inArray$[esp+48]
	push	esi
	mov	esi, ecx
	cmp	esi, ebx
	mov	DWORD PTR _this$[esp+56], esi

; 271  : 			return(*this);

	je	$L47865
	push	edi

; 272  : 		m_Count = 0;

	xor	edi, edi
	mov	DWORD PTR [esi+4], edi

; 273  : 		m_Limit = inArray.m_Count;

	mov	eax, DWORD PTR [ebx+4]
	mov	DWORD PTR [esi+8], eax

; 274  : 		Realloc(sizeof(T));

	mov	eax, DWORD PTR [esi]
	cmp	eax, edi
	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [esi+12], 52			; 00000034H
	je	$L47703
	cmp	eax, edi
	je	SHORT $L47705
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [esi+8]
	push	ecx
	mov	ecx, DWORD PTR [esi]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+4]
	mov	DWORD PTR [esi], eax
	jmp	SHORT $L47710
$L47705:
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L47709:
	mov	DWORD PTR [esi], edi
$L47710:

; 275  : 		for (NDword i=0;i<inArray.m_Count;i++)

	mov	eax, DWORD PTR [ebx+4]
	mov	DWORD PTR _i$[esp+60], edi
	cmp	eax, edi
	jbe	$L14163
	push	ebp
	mov	DWORD PTR -44+[esp+64], edi
$L14161:

; 276  : 			new(&(*this)[AddNoConstruct()]) T(inArray[i]);

	mov	edi, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	lea	eax, DWORD PTR [edi+1]
	cmp	eax, ecx
	mov	DWORD PTR [esi+4], eax
	jbe	SHORT $L47715
	mov	edx, eax
	push	52					; 00000034H
	shr	edx, 2
	mov	ecx, esi
	lea	eax, DWORD PTR [edx+eax+32]
	mov	DWORD PTR [esi+8], eax
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
$L47715:
	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR [edi+edi*2]
	lea	edx, DWORD PTR [edi+ecx*4]
	lea	ebp, DWORD PTR [eax+edx*4]
	mov	DWORD PTR $T47697[esp+64], ebp
	mov	DWORD PTR $T47696[esp+64], ebp
	test	ebp, ebp
	mov	DWORD PTR __$EHRec$[esp+72], 0
	je	$L47698
	mov	esi, DWORD PTR [ebx]
	mov	edi, DWORD PTR -44+[esp+64]
	add	esi, edi
	mov	DWORD PTR [ebp], 0
	mov	ecx, DWORD PTR [esi]
	push	ecx
	mov	ecx, ebp
	call	?Set@CCorString@@QAEXPAD@Z		; CCorString::Set
	mov	eax, DWORD PTR [esi+8]
	lea	edi, DWORD PTR [ebp+4]
	xor	ebx, ebx
	push	16					; 00000010H
	mov	ecx, edi
	mov	BYTE PTR __$EHRec$[esp+76], 1
	mov	DWORD PTR $T47775[esp+68], edi
	mov	DWORD PTR [edi], ebx
	mov	DWORD PTR [edi+4], eax
	mov	DWORD PTR [edi+8], eax
	mov	DWORD PTR [edi+12], 16			; 00000010H
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
	mov	DWORD PTR [edi+4], ebx
	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	mov	BYTE PTR __$EHRec$[esp+72], 2
	jbe	SHORT $L47821
	mov	DWORD PTR -48+[esp+64], ebx
$L47819:
	push	1
	mov	ecx, edi
	call	?AddNoConstruct@?$TCorArray@VCCpjSeqTranslate@@@@QAEKK@Z ; TCorArray<CCpjSeqTranslate>::AddNoConstruct
	mov	ecx, DWORD PTR [edi]
	shl	eax, 4
	add	eax, ecx
	mov	DWORD PTR $T47825[esp+64], eax
	mov	DWORD PTR $T47824[esp+64], eax
	mov	BYTE PTR __$EHRec$[esp+72], 3
	je	SHORT $L47826
	mov	edx, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR -48+[esp+64]
	add	edx, ecx
	mov	ecx, eax
	push	edx
	call	??0CCpjSeqTranslate@@QAE@ABV0@@Z	; CCpjSeqTranslate::CCpjSeqTranslate
$L47826:
	mov	ecx, DWORD PTR -48+[esp+64]
	mov	eax, DWORD PTR [esi+8]
	inc	ebx
	add	ecx, 16					; 00000010H
	cmp	ebx, eax
	mov	BYTE PTR __$EHRec$[esp+72], 2
	mov	DWORD PTR -48+[esp+64], ecx
	jb	SHORT $L47819
$L47821:
	mov	eax, DWORD PTR [esi+24]
	lea	edi, DWORD PTR [ebp+20]
	push	24					; 00000018H
	push	eax
	mov	ecx, edi
	mov	BYTE PTR __$EHRec$[esp+80], 4
	mov	DWORD PTR $T47812[esp+72], edi
	call	??0CCorArray@@IAE@KK@Z			; CCorArray::CCorArray
	xor	ebx, ebx
	mov	BYTE PTR __$EHRec$[esp+72], 5
	mov	DWORD PTR [edi+4], ebx
	mov	eax, DWORD PTR [esi+24]
	cmp	eax, ebx
	jbe	SHORT $L47849
	mov	DWORD PTR -48+[esp+64], ebx
$L47847:
	push	1
	mov	ecx, edi
	call	?AddNoConstruct@?$TCorArray@VCCpjSeqRotate@@@@QAEKK@Z ; TCorArray<CCpjSeqRotate>::AddNoConstruct
	mov	edx, DWORD PTR [edi]
	lea	ecx, DWORD PTR [eax+eax*2]
	lea	ecx, DWORD PTR [edx+ecx*8]
	mov	DWORD PTR $T47836[esp+64], ecx
	mov	DWORD PTR $T47835[esp+64], ecx
	test	ecx, ecx
	mov	BYTE PTR __$EHRec$[esp+72], 6
	je	SHORT $L47837
	mov	eax, DWORD PTR [esi+20]
	mov	edx, DWORD PTR -48+[esp+64]
	add	eax, edx
	push	eax
	call	??0CCpjSeqRotate@@QAE@ABV0@@Z		; CCpjSeqRotate::CCpjSeqRotate
$L47837:
	mov	ecx, DWORD PTR -48+[esp+64]
	mov	eax, DWORD PTR [esi+24]
	inc	ebx
	add	ecx, 24					; 00000018H
	cmp	ebx, eax
	mov	BYTE PTR __$EHRec$[esp+72], 5
	mov	DWORD PTR -48+[esp+64], ecx
	jb	SHORT $L47847
$L47849:
	add	esi, 36					; 00000024H
	lea	ecx, DWORD PTR [ebp+36]
	push	esi
	mov	BYTE PTR __$EHRec$[esp+76], 7
	call	??0?$TCorArray@VCCpjSeqScale@@@@QAE@AAV0@@Z ; TCorArray<CCpjSeqScale>::TCorArray<CCpjSeqScale>
	mov	ebx, DWORD PTR _inArray$[esp+60]
	mov	esi, DWORD PTR _this$[esp+64]
$L47698:
	mov	eax, DWORD PTR _i$[esp+64]
	mov	edx, DWORD PTR -44+[esp+64]
	mov	ecx, DWORD PTR [ebx+4]
	inc	eax
	add	edx, 52					; 00000034H
	cmp	eax, ecx
	mov	DWORD PTR __$EHRec$[esp+72], -1
	mov	DWORD PTR _i$[esp+64], eax
	mov	DWORD PTR -44+[esp+64], edx
	jb	$L14161
	pop	ebp
$L14163:
	pop	edi
$L47865:

; 277  : 		return(*this);
; 278  : 	}

	mov	ecx, DWORD PTR __$EHRec$[esp+56]
	mov	eax, esi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 48					; 00000030H
	ret	4

; 274  : 		Realloc(sizeof(T));

$L47703:
	cmp	eax, edi
	je	$L47709
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [esi+8]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	DWORD PTR [esi], eax
	jmp	$L47710
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L47700:
	mov	eax, DWORD PTR $T47697[ebp]
	push	eax
	mov	ecx, DWORD PTR $T47696[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
$L47727:
	mov	ecx, DWORD PTR $T47696[ebp]
	jmp	??1CCorString@@QAE@XZ			; CCorString::~CCorString
$L47740:
	mov	ecx, DWORD PTR $T47775[ebp]
	jmp	??1CCorArray@@IAE@XZ			; CCorArray::~CCorArray
$L47741:
	mov	eax, DWORD PTR $T47825[ebp]
	push	eax
	mov	ecx, DWORD PTR $T47824[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
$L47728:
	mov	ecx, DWORD PTR $T47696[ebp]
	add	ecx, 4
	jmp	??1?$TCorArray@VCCpjSeqTranslate@@@@QAE@XZ ; TCorArray<CCpjSeqTranslate>::~TCorArray<CCpjSeqTranslate>
$L47783:
	mov	ecx, DWORD PTR $T47812[ebp]
	jmp	??1CCorArray@@IAE@XZ			; CCorArray::~CCorArray
$L47784:
	mov	eax, DWORD PTR $T47836[ebp]
	push	eax
	mov	ecx, DWORD PTR $T47835[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
$L47729:
	mov	ecx, DWORD PTR $T47696[ebp]
	add	ecx, 20					; 00000014H
	jmp	??1?$TCorArray@VCCpjSeqRotate@@@@QAE@XZ	; TCorArray<CCpjSeqRotate>::~TCorArray<CCpjSeqRotate>
$L47864:
	mov	eax, OFFSET FLAT:$T47856
	jmp	___CxxFrameHandler
text$x	ENDS
??4?$TCorArray@VCCpjSeqFrame@@@@QAEAAV0@AAV0@@Z ENDP	; TCorArray<CCpjSeqFrame>::operator=
;	COMDAT xdata$x
xdata$x	SEGMENT
$T47951	DD	0ffffffffH
	DD	FLAT:$L47877
$T47942	DD	019930520H
	DD	01H
	DD	FLAT:$T47951
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ??4?$TCorArray@VCCpjSeqEvent@@@@QAEAAV0@AAV0@@Z
_TEXT	SEGMENT
$T47873 = -16
$T47874 = -20
__$EHRec$ = -12
_inArray$ = 8
_i$ = -24
??4?$TCorArray@VCCpjSeqEvent@@@@QAEAAV0@AAV0@@Z PROC NEAR ; TCorArray<CCpjSeqEvent>::operator=, COMDAT
; _this$ = ecx

; 269  : 	{

	mov	eax, DWORD PTR fs:__except_list
	push	-1
	push	$L47949
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 16					; 00000010H
	push	ebx
	push	edi

; 270  : 		if (this == &inArray)

	mov	edi, DWORD PTR _inArray$[esp+32]
	mov	ebx, ecx
	cmp	ebx, edi

; 271  : 			return(*this);

	je	$L47950
	push	ebp

; 272  : 		m_Count = 0;

	xor	ebp, ebp
	mov	DWORD PTR [ebx+4], ebp

; 273  : 		m_Limit = inArray.m_Count;

	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [ebx+8], eax

; 274  : 		Realloc(sizeof(T));

	mov	eax, DWORD PTR [ebx]
	cmp	eax, ebp
	mov	eax, DWORD PTR [ebx+8]
	mov	DWORD PTR [ebx+12], 12			; 0000000cH
	je	SHORT $L47881
	cmp	eax, ebp
	je	SHORT $L47883
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [ebx+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [ebx+8]
	push	ecx
	mov	ecx, DWORD PTR [ebx]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+4]
	mov	DWORD PTR [ebx], eax
	jmp	SHORT $L47888
$L47883:
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [ebx]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L47887:
	mov	DWORD PTR [ebx], ebp
$L47888:

; 275  : 		for (NDword i=0;i<inArray.m_Count;i++)

	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR _i$[esp+40], ebp
	cmp	eax, ebp
	jbe	$L14200
	push	esi
	mov	DWORD PTR -28+[esp+44], ebp
	jmp	SHORT $L14198

; 274  : 		Realloc(sizeof(T));

$L47881:
	cmp	eax, ebp
	je	SHORT $L47887
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [ebx+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [ebx+8]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	DWORD PTR [ebx], eax
	jmp	SHORT $L47888
$L47948:

; 275  : 		for (NDword i=0;i<inArray.m_Count;i++)

	xor	ebp, ebp
$L14198:

; 276  : 			new(&(*this)[AddNoConstruct()]) T(inArray[i]);

	mov	esi, DWORD PTR [ebx+4]
	mov	ecx, DWORD PTR [ebx+8]
	lea	eax, DWORD PTR [esi+1]
	cmp	eax, ecx
	mov	DWORD PTR [ebx+4], eax
	jbe	SHORT $L47893
	mov	edx, eax
	push	12					; 0000000cH
	shr	edx, 2
	mov	ecx, ebx
	lea	eax, DWORD PTR [edx+eax+32]
	mov	DWORD PTR [ebx+8], eax
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
$L47893:
	mov	edx, DWORD PTR [ebx]
	lea	ecx, DWORD PTR [esi+esi*2]
	lea	esi, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR $T47874[esp+44], esi
	mov	DWORD PTR $T47873[esp+44], esi
	cmp	esi, ebp
	mov	DWORD PTR __$EHRec$[esp+52], ebp
	je	SHORT $L47937
	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR -28+[esp+44]
	add	eax, ecx
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [esi], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [esi+4], edx
	mov	DWORD PTR [esi+8], ebp
	mov	ebp, DWORD PTR [eax+8]
	test	ebp, ebp
	je	SHORT $L47934
	cmp	BYTE PTR [ebp], 0
	jne	SHORT $L47934
	xor	ebp, ebp
$L47934:
	test	ebp, ebp
	mov	DWORD PTR [esi+8], 0
	je	SHORT $L47937
	mov	edi, ebp
	or	ecx, -1
	xor	eax, eax
	repne scasb
	not	ecx
	dec	ecx
	mov	edi, ecx
	inc	edi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	edi
	mov	ecx, eax
	call	DWORD PTR [edx]
	test	eax, eax
	mov	DWORD PTR [esi+8], eax
	je	SHORT $L47946
$L47931:
	mov	cl, BYTE PTR [ebp]
	inc	ebp
	mov	BYTE PTR [eax], cl
	inc	eax
	test	cl, cl
	jne	SHORT $L47931
	add	DWORD PTR ?sMemTotal@CCorString@@0KA, edi ; CCorString::sMemTotal
$L47946:
	mov	edi, DWORD PTR _inArray$[esp+40]
$L47937:
	mov	eax, DWORD PTR _i$[esp+44]
	mov	edx, DWORD PTR -28+[esp+44]
	mov	ecx, DWORD PTR [edi+4]
	inc	eax
	add	edx, 12					; 0000000cH
	cmp	eax, ecx
	mov	DWORD PTR __$EHRec$[esp+52], -1
	mov	DWORD PTR _i$[esp+44], eax
	mov	DWORD PTR -28+[esp+44], edx
	jb	$L47948
	pop	esi
$L14200:
	pop	ebp
$L47950:

; 277  : 		return(*this);
; 278  : 	}

	mov	ecx, DWORD PTR __$EHRec$[esp+36]
	mov	eax, ebx
	pop	edi
	pop	ebx
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 28					; 0000001cH
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L47877:
	mov	eax, DWORD PTR $T47874[ebp]
	push	eax
	mov	ecx, DWORD PTR $T47873[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
$L47949:
	mov	eax, OFFSET FLAT:$T47942
	jmp	___CxxFrameHandler
text$x	ENDS
??4?$TCorArray@VCCpjSeqEvent@@@@QAEAAV0@AAV0@@Z ENDP	; TCorArray<CCpjSeqEvent>::operator=
;	COMDAT xdata$x
xdata$x	SEGMENT
$T48035	DD	0ffffffffH
	DD	FLAT:$L47962
$T48026	DD	019930520H
	DD	01H
	DD	FLAT:$T48035
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ??4?$TCorArray@VCCpjSeqBoneInfo@@@@QAEAAV0@AAV0@@Z
_TEXT	SEGMENT
_i$ = -28
$T47958 = -16
$T47959 = -20
$T48024 = -24
__$EHRec$ = -12
_inArray$ = 8
??4?$TCorArray@VCCpjSeqBoneInfo@@@@QAEAAV0@AAV0@@Z PROC NEAR ; TCorArray<CCpjSeqBoneInfo>::operator=, COMDAT
; _this$ = ecx

; 269  : 	{

	mov	eax, DWORD PTR fs:__except_list
	push	-1
	push	$L48033
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 16					; 00000010H
	push	ebp
	push	edi

; 270  : 		if (this == &inArray)

	mov	edi, DWORD PTR _inArray$[esp+32]
	mov	ebp, ecx
	cmp	ebp, edi

; 271  : 			return(*this);

	je	$L48034
	push	esi

; 272  : 		m_Count = 0;

	xor	esi, esi
	mov	DWORD PTR [ebp+4], esi

; 273  : 		m_Limit = inArray.m_Count;

	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [ebp+8], eax

; 274  : 		Realloc(sizeof(T));

	mov	eax, DWORD PTR [ebp]
	cmp	eax, esi
	mov	eax, DWORD PTR [ebp+8]
	mov	DWORD PTR [ebp+12], 8
	je	$L47966
	cmp	eax, esi
	je	SHORT $L47968
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [ebp+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [ebp+8]
	push	ecx
	mov	ecx, DWORD PTR [ebp]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+4]
	mov	DWORD PTR [ebp], eax
	jmp	SHORT $L47973
$L47968:
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [ebp]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L47972:
	mov	DWORD PTR [ebp], esi
$L47973:

; 275  : 		for (NDword i=0;i<inArray.m_Count;i++)

	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR _i$[esp+40], esi
	cmp	eax, esi
	jbe	$L14232
	push	ebx
$L14230:

; 276  : 			new(&(*this)[AddNoConstruct()]) T(inArray[i]);

	mov	esi, DWORD PTR [ebp+4]
	mov	ecx, DWORD PTR [ebp+8]
	lea	eax, DWORD PTR [esi+1]
	cmp	eax, ecx
	mov	DWORD PTR [ebp+4], eax
	jbe	SHORT $L47978
	mov	edx, eax
	push	8
	shr	edx, 2
	mov	ecx, ebp
	lea	eax, DWORD PTR [edx+eax+32]
	mov	DWORD PTR [ebp+8], eax
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
$L47978:
	mov	ecx, DWORD PTR [ebp]
	lea	ebx, DWORD PTR [ecx+esi*8]
	mov	DWORD PTR $T47959[esp+44], ebx
	mov	DWORD PTR $T47958[esp+44], ebx
	test	ebx, ebx
	mov	DWORD PTR __$EHRec$[esp+52], 0
	je	SHORT $L47960
	mov	edx, DWORD PTR [edi]
	mov	eax, DWORD PTR _i$[esp+44]
	mov	DWORD PTR [ebx], 0
	mov	esi, DWORD PTR [edx+eax*8]
	lea	eax, DWORD PTR [edx+eax*8]
	test	esi, esi
	mov	DWORD PTR $T48024[esp+44], eax
	je	SHORT $L48018
	cmp	BYTE PTR [esi], 0
	jne	SHORT $L48018
	xor	esi, esi
$L48018:
	test	esi, esi
	mov	DWORD PTR [ebx], 0
	je	SHORT $L48021
	mov	edi, esi
	or	ecx, -1
	xor	eax, eax
	repne scasb
	not	ecx
	dec	ecx
	mov	edi, ecx
	inc	edi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	edi
	mov	ecx, eax
	call	DWORD PTR [edx]
	test	eax, eax
	mov	DWORD PTR [ebx], eax
	je	SHORT $L48030
$L48015:
	mov	cl, BYTE PTR [esi]
	inc	esi
	mov	BYTE PTR [eax], cl
	inc	eax
	test	cl, cl
	jne	SHORT $L48015
	add	DWORD PTR ?sMemTotal@CCorString@@0KA, edi ; CCorString::sMemTotal
$L48030:
	mov	edi, DWORD PTR _inArray$[esp+40]
$L48021:
	mov	eax, DWORD PTR $T48024[esp+44]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ebx+4], ecx
$L47960:
	mov	eax, DWORD PTR _i$[esp+44]
	mov	ecx, DWORD PTR [edi+4]
	inc	eax
	mov	DWORD PTR __$EHRec$[esp+52], -1
	cmp	eax, ecx
	mov	DWORD PTR _i$[esp+44], eax
	jb	$L14230
	pop	ebx
$L14232:
	pop	esi
$L48034:

; 277  : 		return(*this);
; 278  : 	}

	mov	ecx, DWORD PTR __$EHRec$[esp+36]
	mov	eax, ebp
	pop	edi
	pop	ebp
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 28					; 0000001cH
	ret	4

; 274  : 		Realloc(sizeof(T));

$L47966:
	cmp	eax, esi
	je	$L47972
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [ebp+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [ebp+8]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	DWORD PTR [ebp], eax
	jmp	$L47973
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L47962:
	mov	eax, DWORD PTR $T47959[ebp]
	push	eax
	mov	ecx, DWORD PTR $T47958[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
$L48033:
	mov	eax, OFFSET FLAT:$T48026
	jmp	___CxxFrameHandler
text$x	ENDS
??4?$TCorArray@VCCpjSeqBoneInfo@@@@QAEAAV0@AAV0@@Z ENDP	; TCorArray<CCpjSeqBoneInfo>::operator=
PUBLIC	??_GCCpjSeqBoneInfo@@QAEPAXI@Z			; CCpjSeqBoneInfo::`scalar deleting destructor'
PUBLIC	??1CCpjSeqFrame@@QAE@XZ				; CCpjSeqFrame::~CCpjSeqFrame
PUBLIC	??_GCCpjSeqEvent@@QAEPAXI@Z			; CCpjSeqEvent::`scalar deleting destructor'
PUBLIC	??1OCpjSequence@@UAE@XZ				; OCpjSequence::~OCpjSequence
;	COMDAT xdata$x
xdata$x	SEGMENT
$T48218	DD	0ffffffffH
	DD	FLAT:$L48041
	DD	00H
	DD	FLAT:$L48042
	DD	01H
	DD	FLAT:$L48043
	DD	02H
	DD	FLAT:$L48046
	DD	01H
	DD	FLAT:$L48092
	DD	00H
	DD	FLAT:$L48138
$T48208	DD	019930520H
	DD	06H
	DD	FLAT:$T48218
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ??1OCpjSequence@@UAE@XZ
_TEXT	SEGMENT
$T48090 = -16
$T48136 = -16
$T48196 = -16
__$EHRec$ = -12
_this$ = -20
??1OCpjSequence@@UAE@XZ PROC NEAR			; OCpjSequence::~OCpjSequence, COMDAT
; _this$ = ecx
	push	-1
	push	$L48217
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 8
	push	ebx
	push	ebp
	mov	ebx, ecx
	push	esi
	push	edi
	mov	DWORD PTR _this$[esp+36], ebx
	xor	esi, esi
	mov	DWORD PTR __$EHRec$[esp+44], esi
	lea	edi, DWORD PTR [ebx+108]
	mov	DWORD PTR $T48090[esp+36], edi
	mov	ebp, DWORD PTR [edi+4]
	mov	BYTE PTR __$EHRec$[esp+44], 3
	cmp	ebp, esi
	jbe	SHORT $L48082
$L48080:
	mov	eax, DWORD PTR [edi]
	push	0
	lea	ecx, DWORD PTR [eax+esi*8]
	call	??_GCCpjSeqBoneInfo@@QAEPAXI@Z		; CCpjSeqBoneInfo::`scalar deleting destructor'
	inc	esi
	cmp	esi, ebp
	jb	SHORT $L48080
$L48082:
	push	8
	push	ebp
	push	0
	mov	ecx, edi
	call	?Remove@CCorArray@@QAEXKKK@Z		; CCorArray::Remove
	mov	eax, DWORD PTR [edi]
	mov	BYTE PTR __$EHRec$[esp+44], 2
	test	eax, eax
	je	SHORT $L48089
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L48089:
	lea	esi, DWORD PTR [ebx+92]
	mov	DWORD PTR $T48136[esp+36], esi
	mov	ebx, DWORD PTR [esi+4]
	mov	BYTE PTR __$EHRec$[esp+44], 4
	test	ebx, ebx
	jbe	SHORT $L48127
	xor	edi, edi
	mov	ebp, ebx
$L48125:
	mov	ecx, DWORD PTR [esi]
	push	0
	add	ecx, edi
	call	??_GCCpjSeqEvent@@QAEPAXI@Z		; CCpjSeqEvent::`scalar deleting destructor'
	add	edi, 12					; 0000000cH
	dec	ebp
	jne	SHORT $L48125
$L48127:
	push	12					; 0000000cH
	push	ebx
	push	0
	mov	ecx, esi
	call	?Remove@CCorArray@@QAEXKKK@Z		; CCorArray::Remove
	mov	eax, DWORD PTR [esi]
	mov	BYTE PTR __$EHRec$[esp+44], 1
	test	eax, eax
	je	SHORT $L48134
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L48134:
	mov	edx, DWORD PTR _this$[esp+36]
	lea	esi, DWORD PTR [edx+76]
	mov	DWORD PTR $T48196[esp+36], esi
	mov	ebx, DWORD PTR [esi+4]
	mov	BYTE PTR __$EHRec$[esp+44], 5
	test	ebx, ebx
	jbe	SHORT $L48184
	xor	edi, edi
	mov	ebp, ebx
$L48182:
	mov	ecx, DWORD PTR [esi]
	add	ecx, edi
	call	??1CCpjSeqFrame@@QAE@XZ			; CCpjSeqFrame::~CCpjSeqFrame
	add	edi, 52					; 00000034H
	dec	ebp
	jne	SHORT $L48182
$L48184:
	push	52					; 00000034H
	push	ebx
	push	0
	mov	ecx, esi
	call	?Remove@CCorArray@@QAEXKKK@Z		; CCorArray::Remove
	mov	eax, DWORD PTR [esi]
	mov	BYTE PTR __$EHRec$[esp+44], 0
	test	eax, eax
	je	SHORT $L48194
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L48194:
	mov	ecx, DWORD PTR _this$[esp+36]
	mov	DWORD PTR __$EHRec$[esp+44], -1
	call	??1OObject@@UAE@XZ			; OObject::~OObject
	mov	ecx, DWORD PTR __$EHRec$[esp+36]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 20					; 00000014H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L48041:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1OCpjChunk@@UAE@XZ			; OCpjChunk::~OCpjChunk
$L48042:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 76					; 0000004cH
	jmp	??1?$TCorArray@VCCpjSeqFrame@@@@QAE@XZ	; TCorArray<CCpjSeqFrame>::~TCorArray<CCpjSeqFrame>
$L48043:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 92					; 0000005cH
	jmp	??1?$TCorArray@VCCpjSeqEvent@@@@QAE@XZ	; TCorArray<CCpjSeqEvent>::~TCorArray<CCpjSeqEvent>
$L48046:
	mov	ecx, DWORD PTR $T48090[ebp]
	jmp	??1CCorArray@@IAE@XZ			; CCorArray::~CCorArray
$L48092:
	mov	ecx, DWORD PTR $T48136[ebp]
	jmp	??1CCorArray@@IAE@XZ			; CCorArray::~CCorArray
$L48138:
	mov	ecx, DWORD PTR $T48196[ebp]
	jmp	??1CCorArray@@IAE@XZ			; CCorArray::~CCorArray
$L48217:
	mov	eax, OFFSET FLAT:$T48208
	jmp	___CxxFrameHandler
text$x	ENDS
??1OCpjSequence@@UAE@XZ ENDP				; OCpjSequence::~OCpjSequence
PUBLIC	??_GOCpjSequence@@UAEPAXI@Z			; OCpjSequence::`scalar deleting destructor'
; Function compile flags: /Ogty
;	COMDAT ??_GOCpjSequence@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_GOCpjSequence@@UAEPAXI@Z PROC NEAR			; OCpjSequence::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1OCpjSequence@@UAE@XZ			; OCpjSequence::~OCpjSequence
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $L48236
	mov	DWORD PTR [esi+4], 0
	mov	edx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	dec	edx
	mov	DWORD PTR ?sObjCount@OObject@@1KA, edx	; OObject::sObjCount
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L48236:
	mov	eax, esi
	pop	esi
	ret	4
??_GOCpjSequence@@UAEPAXI@Z ENDP			; OCpjSequence::`scalar deleting destructor'
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??_EOCpjSequence@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_EOCpjSequence@@UAEPAXI@Z PROC NEAR			; OCpjSequence::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebx
	mov	bl, BYTE PTR ___flags$[esp]
	push	esi
	mov	esi, ecx
	test	bl, 2
	je	SHORT $L9854
	mov	eax, DWORD PTR [esi-4]
	push	edi
	lea	edi, DWORD PTR [esi-4]
	push	OFFSET FLAT:??1OCpjSequence@@UAE@XZ	; OCpjSequence::~OCpjSequence
	push	eax
	push	124					; 0000007cH
	push	esi
	call	??_M@YGXPAXIHP6EX0@Z@Z			; `eh vector destructor iterator'
	test	bl, 1
	je	SHORT $L9855
	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L9855:
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	ret	4
$L9854:
	mov	ecx, esi
	call	??1OCpjSequence@@UAE@XZ			; OCpjSequence::~OCpjSequence
	test	bl, 1
	je	SHORT $L48251
	mov	DWORD PTR [esi+4], 0
	mov	edx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	dec	edx
	mov	DWORD PTR ?sObjCount@OObject@@1KA, edx	; OObject::sObjCount
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L48251:
	mov	eax, esi
	pop	esi
	pop	ebx
	ret	4
??_EOCpjSequence@@UAEPAXI@Z ENDP			; OCpjSequence::`vector deleting destructor'
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?AddNoConstruct@?$TCorArray@VCCpjGeoEdge@@@@QAEKK@Z
_TEXT	SEGMENT
_inCount$ = 8
?AddNoConstruct@?$TCorArray@VCCpjGeoEdge@@@@QAEKK@Z PROC NEAR ; TCorArray<CCpjGeoEdge>::AddNoConstruct, COMDAT
; _this$ = ecx

; 322  : 		NDword i = m_Count;
; 323  : 		if ((m_Count+=inCount)>m_Limit)

	mov	eax, DWORD PTR _inCount$[esp-4]
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	add	eax, edi
	cmp	eax, ecx
	mov	DWORD PTR [esi+4], eax
	jbe	SHORT $L48266

; 324  : 		{
; 325  : 			m_Limit = m_Count + (m_Count>>2) + 32;

	mov	ecx, eax

; 326  : 			Realloc(sizeof(T));

	mov	DWORD PTR [esi+12], 28			; 0000001cH
	shr	ecx, 2
	lea	eax, DWORD PTR [ecx+eax+32]
	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	mov	DWORD PTR [esi+8], eax
	je	SHORT $L48258
	test	eax, eax
	je	SHORT $L48260
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [esi+8]
	push	ecx
	mov	ecx, DWORD PTR [esi]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+4]
	mov	DWORD PTR [esi], eax

; 327  : 		}
; 328  : 		return(i);

	mov	eax, edi
	pop	edi
	pop	esi

; 329  : 	}

	ret	4

; 326  : 			Realloc(sizeof(T));

$L48260:
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L48264:
	mov	DWORD PTR [esi], 0
$L48266:

; 327  : 		}
; 328  : 		return(i);

	mov	eax, edi
	pop	edi
	pop	esi

; 329  : 	}

	ret	4

; 326  : 			Realloc(sizeof(T));

$L48258:
	test	eax, eax
	je	SHORT $L48264
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [esi+8]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	DWORD PTR [esi], eax

; 327  : 		}
; 328  : 		return(i);

	mov	eax, edi
	pop	edi
	pop	esi

; 329  : 	}

	ret	4
?AddNoConstruct@?$TCorArray@VCCpjGeoEdge@@@@QAEKK@Z ENDP ; TCorArray<CCpjGeoEdge>::AddNoConstruct
_TEXT	ENDS
PUBLIC	??2OCpjConfig@@CAPAXIPAVOObject@@PAVCObjClass@@@Z ; OCpjConfig::operator new
; Function compile flags: /Ogty
; File C:\duke4\Cannibal\CpjMac.h
;	COMDAT ??2OCpjConfig@@CAPAXIPAVOObject@@PAVCObjClass@@@Z
_TEXT	SEGMENT
_inParent$ = 12
_inSetClass$ = 16
??2OCpjConfig@@CAPAXIPAVOObject@@PAVCObjClass@@@Z PROC NEAR ; OCpjConfig::operator new, COMDAT

; 30   : 	OBJ_CLASS_DEFINE(OCpjConfig, OCpjChunk);

	push	esi
	push	edi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	88					; 00000058H
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	ecx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	mov	esi, eax
	inc	ecx
	xor	eax, eax
	mov	DWORD PTR ?sObjCount@OObject@@1KA, ecx	; OObject::sObjCount
	mov	ecx, 22					; 00000016H
	mov	edi, esi
	rep stosd
	mov	eax, DWORD PTR [esi+40]
	mov	DWORD PTR [esi+4], 305419896		; 12345678H
	test	eax, eax
	jne	SHORT $L48277
	mov	eax, DWORD PTR _inSetClass$[esp+4]
	mov	DWORD PTR [esi+40], eax
$L48277:
	mov	ecx, DWORD PTR _inParent$[esp+4]
	push	ecx
	mov	ecx, esi
	call	?PreConstruct@OObject@@QAEXPAV1@@Z	; OObject::PreConstruct
	mov	eax, esi
	pop	edi
	pop	esi
	ret	0
??2OCpjConfig@@CAPAXIPAVOObject@@PAVCObjClass@@@Z ENDP	; OCpjConfig::operator new
_TEXT	ENDS
PUBLIC	??3OCpjConfig@@CAXPAX@Z				; OCpjConfig::operator delete
; Function compile flags: /Ogty
;	COMDAT ??3OCpjConfig@@CAXPAX@Z
_TEXT	SEGMENT
_ptr$ = 8
??3OCpjConfig@@CAXPAX@Z PROC NEAR			; OCpjConfig::operator delete, COMDAT

; 30   : 	OBJ_CLASS_DEFINE(OCpjConfig, OCpjChunk);

	push	esi
	mov	esi, DWORD PTR _ptr$[esp]
	mov	DWORD PTR [esi+4], 0
	mov	edx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	dec	edx
	mov	DWORD PTR ?sObjCount@OObject@@1KA, edx	; OObject::sObjCount
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	ecx, eax
	call	DWORD PTR [edx+8]
	pop	esi
	ret	0
??3OCpjConfig@@CAXPAX@Z ENDP				; OCpjConfig::operator delete
; Function compile flags: /Ogty
; File C:\duke4\Cannibal\CorMain.h
_TEXT	ENDS
;	COMDAT ?AddNoConstruct@?$TCorArray@VCCpjGeoTri@@@@QAEKK@Z
_TEXT	SEGMENT
_inCount$ = 8
?AddNoConstruct@?$TCorArray@VCCpjGeoTri@@@@QAEKK@Z PROC NEAR ; TCorArray<CCpjGeoTri>::AddNoConstruct, COMDAT
; _this$ = ecx

; 322  : 		NDword i = m_Count;
; 323  : 		if ((m_Count+=inCount)>m_Limit)

	mov	eax, DWORD PTR _inCount$[esp-4]
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	add	eax, edi
	cmp	eax, ecx
	mov	DWORD PTR [esi+4], eax
	jbe	SHORT $L48301

; 324  : 		{
; 325  : 			m_Limit = m_Count + (m_Count>>2) + 32;

	mov	ecx, eax

; 326  : 			Realloc(sizeof(T));

	mov	DWORD PTR [esi+12], 12			; 0000000cH
	shr	ecx, 2
	lea	eax, DWORD PTR [ecx+eax+32]
	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	mov	DWORD PTR [esi+8], eax
	je	SHORT $L48293
	test	eax, eax
	je	SHORT $L48295
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [esi+8]
	push	ecx
	mov	ecx, DWORD PTR [esi]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+4]
	mov	DWORD PTR [esi], eax

; 327  : 		}
; 328  : 		return(i);

	mov	eax, edi
	pop	edi
	pop	esi

; 329  : 	}

	ret	4

; 326  : 			Realloc(sizeof(T));

$L48295:
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L48299:
	mov	DWORD PTR [esi], 0
$L48301:

; 327  : 		}
; 328  : 		return(i);

	mov	eax, edi
	pop	edi
	pop	esi

; 329  : 	}

	ret	4

; 326  : 			Realloc(sizeof(T));

$L48293:
	test	eax, eax
	je	SHORT $L48299
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [esi+8]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	DWORD PTR [esi], eax

; 327  : 		}
; 328  : 		return(i);

	mov	eax, edi
	pop	edi
	pop	esi

; 329  : 	}

	ret	4
?AddNoConstruct@?$TCorArray@VCCpjGeoTri@@@@QAEKK@Z ENDP	; TCorArray<CCpjGeoTri>::AddNoConstruct
_TEXT	ENDS
PUBLIC	??3OCpjConfig@@CAXPAXPAVOObject@@PAVCObjClass@@@Z ; OCpjConfig::operator delete
; Function compile flags: /Ogty
; File C:\duke4\Cannibal\CpjMac.h
;	COMDAT ??3OCpjConfig@@CAXPAXPAVOObject@@PAVCObjClass@@@Z
_TEXT	SEGMENT
_ptr$ = 8
??3OCpjConfig@@CAXPAXPAVOObject@@PAVCObjClass@@@Z PROC NEAR ; OCpjConfig::operator delete, COMDAT

; 30   : 	OBJ_CLASS_DEFINE(OCpjConfig, OCpjChunk);

	push	esi
	mov	esi, DWORD PTR _ptr$[esp]
	mov	DWORD PTR [esi+4], 0
	mov	edx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	dec	edx
	mov	DWORD PTR ?sObjCount@OObject@@1KA, edx	; OObject::sObjCount
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	ecx, eax
	call	DWORD PTR [edx+8]
	pop	esi
	ret	0
??3OCpjConfig@@CAXPAXPAVOObject@@PAVCObjClass@@@Z ENDP	; OCpjConfig::operator delete
_TEXT	ENDS
PUBLIC	?GetStaticClass@OCpjConfig@@SAPAVCObjClass@@XZ	; OCpjConfig::GetStaticClass
EXTRN	?staticObjClass@OCpjConfig@@0PAVCObjClass@@A:DWORD ; OCpjConfig::staticObjClass
; Function compile flags: /Ogty
;	COMDAT ?GetStaticClass@OCpjConfig@@SAPAVCObjClass@@XZ
_TEXT	SEGMENT
?GetStaticClass@OCpjConfig@@SAPAVCObjClass@@XZ PROC NEAR ; OCpjConfig::GetStaticClass, COMDAT

; 30   : 	OBJ_CLASS_DEFINE(OCpjConfig, OCpjChunk);

	mov	eax, DWORD PTR ?staticObjClass@OCpjConfig@@0PAVCObjClass@@A ; OCpjConfig::staticObjClass
	ret	0
?GetStaticClass@OCpjConfig@@SAPAVCObjClass@@XZ ENDP	; OCpjConfig::GetStaticClass
_TEXT	ENDS
PUBLIC	?New@OCpjConfig@@SAPAV1@PAVOObject@@PAVCObjClass@@@Z ; OCpjConfig::New
PUBLIC	?GetClass@OCpjConfig@@UAEPAVCObjClass@@XZ	; OCpjConfig::GetClass
PUBLIC	?GetFileExtension@OCpjConfig@@UAEPADXZ		; OCpjConfig::GetFileExtension
PUBLIC	?GetFileDescription@OCpjConfig@@UAEPADXZ	; OCpjConfig::GetFileDescription
PUBLIC	??_7OCpjConfig@@6B@				; OCpjConfig::`vftable'
PUBLIC	??_EOCpjConfig@@UAEPAXI@Z			; OCpjConfig::`vector deleting destructor'
EXTRN	?LoadChunk@OCpjConfig@@UAE_NPAXK@Z:NEAR		; OCpjConfig::LoadChunk
EXTRN	?SaveChunk@OCpjConfig@@UAE_NPAXPAK@Z:NEAR	; OCpjConfig::SaveChunk
EXTRN	?GetFourCC@OCpjConfig@@UAEKXZ:NEAR		; OCpjConfig::GetFourCC
;	COMDAT xdata$x
; File C:\duke4\Cannibal\CorMain.h
xdata$x	SEGMENT
$T48421	DD	0ffffffffH
	DD	FLAT:$L48320
	DD	00H
	DD	FLAT:$L48345
$T48419	DD	019930520H
	DD	02H
	DD	FLAT:$T48421
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_7OCpjConfig@@6B@
CONST	SEGMENT
??_7OCpjConfig@@6B@ DD FLAT:?Msg@OObject@@UAE_NPAVIMsg@@@Z ; OCpjConfig::`vftable'
	DD	FLAT:?MsgGetChild@OObject@@UAEPAVIMsgTarget@@PAD@Z
	DD	FLAT:?MsgGetParent@OObject@@UAEPAVIMsgTarget@@XZ
	DD	FLAT:?MsgGetRoot@OObject@@UAEPAVIMsgTarget@@XZ
	DD	FLAT:?GetClass@OCpjConfig@@UAEPAVCObjClass@@XZ
	DD	FLAT:??_EOCpjConfig@@UAEPAXI@Z
	DD	FLAT:?Create@OCpjChunk@@UAEXXZ
	DD	FLAT:?Destroy@OObject@@UAEXXZ
	DD	FLAT:?GetParent@OObject@@UAEPAV1@XZ
	DD	FLAT:?SetParent@OObject@@UAEXPAV1@_N@Z
	DD	FLAT:?HasChildren@OObject@@UAE_NXZ
	DD	FLAT:?IsA@OObject@@UAE_NPAVCObjClass@@@Z
	DD	FLAT:?GetFileExtension@OCpjConfig@@UAEPADXZ
	DD	FLAT:?GetFileDescription@OCpjConfig@@UAEPADXZ
	DD	FLAT:?LoadFile@OCpjChunk@@UAE_NPAD@Z
	DD	FLAT:?SaveFile@OCpjChunk@@UAE_NPAD@Z
	DD	FLAT:?GetFourCC@OCpjConfig@@UAEKXZ
	DD	FLAT:?LoadChunk@OCpjConfig@@UAE_NPAXK@Z
	DD	FLAT:?SaveChunk@OCpjConfig@@UAE_NPAXPAK@Z
; Function compile flags: /Ogty
; File C:\duke4\Cannibal\CpjMac.h
CONST	ENDS
;	COMDAT ?New@OCpjConfig@@SAPAV1@PAVOObject@@PAVCObjClass@@@Z
_TEXT	SEGMENT
$T48317 = -16
__$EHRec$ = -12
_inParent$ = 8
_inSetClass$ = 12
?New@OCpjConfig@@SAPAV1@PAVOObject@@PAVCObjClass@@@Z PROC NEAR ; OCpjConfig::New, COMDAT

; 30   : 	OBJ_CLASS_DEFINE(OCpjConfig, OCpjChunk);

	push	-1
	push	$L48420
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	push	ebx
	mov	ebx, DWORD PTR _inSetClass$[esp+16]
	push	ebp
	xor	ebp, ebp
	cmp	ebx, ebp
	push	esi
	jne	SHORT $L10021
	mov	ebx, DWORD PTR ?staticObjClass@OCpjConfig@@0PAVCObjClass@@A ; OCpjConfig::staticObjClass
	mov	DWORD PTR _inSetClass$[esp+24], ebx
$L10021:
	push	edi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	88					; 00000058H
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	ecx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	mov	esi, eax
	inc	ecx
	xor	eax, eax
	mov	DWORD PTR ?sObjCount@OObject@@1KA, ecx	; OObject::sObjCount
	mov	ecx, 22					; 00000016H
	mov	edi, esi
	rep stosd
	mov	eax, DWORD PTR [esi+40]
	mov	DWORD PTR [esi+4], 305419896		; 12345678H
	cmp	eax, ebp
	pop	edi
	jne	SHORT $L48340
	mov	DWORD PTR [esi+40], ebx
$L48340:
	mov	eax, DWORD PTR _inParent$[esp+24]
	mov	ecx, esi
	push	eax
	call	?PreConstruct@OObject@@QAEXPAV1@@Z	; OObject::PreConstruct
	mov	DWORD PTR $T48317[esp+28], esi
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+36], ebp
	call	??0OObject@@QAE@XZ			; OObject::OObject
	mov	DWORD PTR [esi+76], ebp
	mov	DWORD PTR [esi+80], ebp
	mov	DWORD PTR [esi+84], 20			; 00000014H
	mov	DWORD PTR [esi+72], ebp
	mov	DWORD PTR [esi], OFFSET FLAT:??_7OCpjConfig@@6B@ ; OCpjConfig::`vftable'
	mov	edx, DWORD PTR [esi]
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+36], -1
	call	DWORD PTR [edx+24]
	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L48320:
	mov	eax, DWORD PTR _inSetClass$[ebp-4]
	push	eax
	mov	ecx, DWORD PTR _inParent$[ebp-4]
	push	ecx
	mov	edx, DWORD PTR $T48317[ebp]
	push	edx
	call	??3OCpjConfig@@CAXPAXPAVOObject@@PAVCObjClass@@@Z ; OCpjConfig::operator delete
	add	esp, 12					; 0000000cH
	ret	0
$L48345:
	mov	ecx, DWORD PTR $T48317[ebp]
	jmp	??1OCpjChunk@@UAE@XZ			; OCpjChunk::~OCpjChunk
$L48420:
	mov	eax, OFFSET FLAT:$T48419
	jmp	___CxxFrameHandler
text$x	ENDS
?New@OCpjConfig@@SAPAV1@PAVOObject@@PAVCObjClass@@@Z ENDP ; OCpjConfig::New
; Function compile flags: /Ogty
;	COMDAT ?GetClass@OCpjConfig@@UAEPAVCObjClass@@XZ
_TEXT	SEGMENT
?GetClass@OCpjConfig@@UAEPAVCObjClass@@XZ PROC NEAR	; OCpjConfig::GetClass, COMDAT
; _this$ = ecx

; 30   : 	OBJ_CLASS_DEFINE(OCpjConfig, OCpjChunk);

	mov	eax, DWORD PTR [ecx+40]
	ret	0
?GetClass@OCpjConfig@@UAEPAVCObjClass@@XZ ENDP		; OCpjConfig::GetClass
_TEXT	ENDS
PUBLIC	??_C@_03CMEC@mac?$AA@				; `string'
;	COMDAT ??_C@_03CMEC@mac?$AA@
_DATA	SEGMENT
??_C@_03CMEC@mac?$AA@ DB 'mac', 00H			; `string'
; Function compile flags: /Ogty
_DATA	ENDS
;	COMDAT ?GetFileExtension@OCpjConfig@@UAEPADXZ
_TEXT	SEGMENT
?GetFileExtension@OCpjConfig@@UAEPADXZ PROC NEAR	; OCpjConfig::GetFileExtension, COMDAT
; _this$ = ecx

; 40   : 	NChar* GetFileExtension() { return("mac"); }

	mov	eax, OFFSET FLAT:??_C@_03CMEC@mac?$AA@	; `string'
	ret	0
?GetFileExtension@OCpjConfig@@UAEPADXZ ENDP		; OCpjConfig::GetFileExtension
_TEXT	ENDS
PUBLIC	??_C@_0BM@NPDB@Cannibal?5Model?5Actor?5Config?$AA@ ; `string'
;	COMDAT ??_C@_0BM@NPDB@Cannibal?5Model?5Actor?5Config?$AA@
_DATA	SEGMENT
??_C@_0BM@NPDB@Cannibal?5Model?5Actor?5Config?$AA@ DB 'Cannibal Model Act'
	DB	'or Config', 00H				; `string'
; Function compile flags: /Ogty
_DATA	ENDS
;	COMDAT ?GetFileDescription@OCpjConfig@@UAEPADXZ
_TEXT	SEGMENT
?GetFileDescription@OCpjConfig@@UAEPADXZ PROC NEAR	; OCpjConfig::GetFileDescription, COMDAT
; _this$ = ecx

; 41   : 	NChar* GetFileDescription() { return("Cannibal Model Actor Config"); }

	mov	eax, OFFSET FLAT:??_C@_0BM@NPDB@Cannibal?5Model?5Actor?5Config?$AA@ ; `string'
	ret	0
?GetFileDescription@OCpjConfig@@UAEPADXZ ENDP		; OCpjConfig::GetFileDescription
_TEXT	ENDS
PUBLIC	??0OCpjConfig@@QAE@XZ				; OCpjConfig::OCpjConfig
;	COMDAT xdata$x
xdata$x	SEGMENT
$T48492	DD	0ffffffffH
	DD	FLAT:$L48436
$T48490	DD	019930520H
	DD	01H
	DD	FLAT:$T48492
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ??0OCpjConfig@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12
_this$ = -20
??0OCpjConfig@@QAE@XZ PROC NEAR				; OCpjConfig::OCpjConfig, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR fs:__except_list
	push	-1
	push	$L48491
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	esi
	mov	esi, ecx
	call	??0OObject@@QAE@XZ			; OObject::OObject
	mov	ecx, DWORD PTR __$EHRec$[esp+16]
	xor	eax, eax
	mov	DWORD PTR [esi+76], eax
	mov	DWORD PTR [esi+80], eax
	mov	DWORD PTR [esi+84], 20			; 00000014H
	mov	DWORD PTR [esi+72], eax
	mov	DWORD PTR [esi], OFFSET FLAT:??_7OCpjConfig@@6B@ ; OCpjConfig::`vftable'
	mov	eax, esi
	mov	DWORD PTR fs:__except_list, ecx
	pop	esi
	add	esp, 12					; 0000000cH
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L48436:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1OCpjChunk@@UAE@XZ			; OCpjChunk::~OCpjChunk
$L48491:
	mov	eax, OFFSET FLAT:$T48490
	jmp	___CxxFrameHandler
text$x	ENDS
??0OCpjConfig@@QAE@XZ ENDP				; OCpjConfig::OCpjConfig
PUBLIC	??0?$TCorArray@VCCorString@@@@QAE@AAV0@@Z	; TCorArray<CCorString>::TCorArray<CCorString>
PUBLIC	??0OCpjConfig@@QAE@AAV0@@Z			; OCpjConfig::OCpjConfig
;	COMDAT xdata$x
xdata$x	SEGMENT
$T48612	DD	0ffffffffH
	DD	FLAT:$L48505
	DD	00H
	DD	FLAT:$L48506
	DD	0ffffffffH
	DD	FLAT:$L48498
	DD	02H
	DD	FLAT:$L48545
	DD	03H
	DD	FLAT:$L48546
	DD	04H
	DD	FLAT:$L48566
$T48606	DD	019930520H
	DD	06H
	DD	FLAT:$T48612
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ??0OCpjConfig@@QAE@AAV0@@Z
_TEXT	SEGMENT
$T48575 = -32
_i$48577 = -36
$T48583 = -16
$T48584 = -20
$T48603 = -24
__$EHRec$ = -12
___that$ = 8
_this$ = -28
??0OCpjConfig@@QAE@AAV0@@Z PROC NEAR			; OCpjConfig::OCpjConfig, COMDAT
; _this$ = ecx
	push	-1
	push	$L48611
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 24					; 00000018H
	push	ebx
	push	ebp
	push	esi
	mov	esi, DWORD PTR ___that$[esp+44]
	push	edi
	mov	edi, ecx
	lea	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR _this$[esp+52], edi
	mov	DWORD PTR [edi], OFFSET FLAT:??_7IMsgTarget@@6B@ ; IMsgTarget::`vftable'
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [edi+4], eax
	mov	eax, DWORD PTR [ecx]
	lea	edx, DWORD PTR [edi+8]
	mov	DWORD PTR [edi+8], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], ecx
	lea	edx, DWORD PTR [esi+24]
	lea	eax, DWORD PTR [edi+24]
	xor	ebx, ebx
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR __$EHRec$[esp+60], ebx
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR [esi+40]
	lea	ecx, DWORD PTR [edi+44]
	mov	DWORD PTR [edi+40], eax
	mov	BYTE PTR __$EHRec$[esp+60], 1
	mov	DWORD PTR [ecx], ebx
	mov	edx, DWORD PTR [esi+44]
	push	edx
	call	?Set@CCorString@@QAEXPAD@Z		; CCorString::Set
	mov	eax, DWORD PTR [esi+48]
	mov	DWORD PTR [edi+48], eax
	mov	ecx, DWORD PTR [esi+52]
	mov	DWORD PTR [edi+52], ecx
	mov	DWORD PTR [edi], OFFSET FLAT:??_7OCpjRes@@6B@ ; OCpjRes::`vftable'
	mov	dl, BYTE PTR [esi+56]
	mov	BYTE PTR [edi+56], dl
	mov	eax, DWORD PTR [esi+60]
	mov	DWORD PTR [edi+60], eax
	mov	ecx, DWORD PTR [esi+64]
	mov	DWORD PTR [edi+64], ecx
	mov	edx, DWORD PTR [esi+68]
	mov	DWORD PTR [edi+68], edx
	mov	DWORD PTR [edi], OFFSET FLAT:??_7OCpjChunk@@6B@ ; OCpjChunk::`vftable'
	mov	eax, DWORD PTR [esi+76]
	lea	ebp, DWORD PTR [edi+72]
	push	20					; 00000014H
	mov	ecx, ebp
	mov	DWORD PTR __$EHRec$[esp+64], 2
	mov	DWORD PTR $T48603[esp+56], ebp
	mov	DWORD PTR [ebp], ebx
	mov	DWORD PTR [ebp+4], eax
	mov	DWORD PTR [ebp+8], eax
	mov	DWORD PTR [ebp+12], 20			; 00000014H
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
	mov	DWORD PTR [ebp+4], ebx
	mov	eax, DWORD PTR [esi+76]
	cmp	eax, ebx
	mov	BYTE PTR __$EHRec$[esp+60], 3
	mov	DWORD PTR _i$48577[esp+52], ebx
	jbe	$L48609
	mov	DWORD PTR 8+[esp+48], ebx
$L48578:
	mov	ebx, DWORD PTR [ebp+4]
	mov	ecx, DWORD PTR [ebp+8]
	lea	eax, DWORD PTR [ebx+1]
	cmp	eax, ecx
	mov	DWORD PTR [ebp+4], eax
	jbe	SHORT $L48592
	mov	ecx, eax
	push	20					; 00000014H
	shr	ecx, 2
	lea	edx, DWORD PTR [ecx+eax+32]
	mov	ecx, ebp
	mov	DWORD PTR [ebp+8], edx
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
$L48592:
	mov	ecx, DWORD PTR [ebp]
	lea	eax, DWORD PTR [ebx+ebx*4]
	lea	ebx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR $T48584[esp+52], ebx
	mov	DWORD PTR $T48583[esp+52], ebx
	test	ebx, ebx
	mov	BYTE PTR __$EHRec$[esp+60], 4
	je	SHORT $L48585
	mov	eax, DWORD PTR [esi+72]
	mov	ecx, DWORD PTR 8+[esp+48]
	add	eax, ecx
	mov	DWORD PTR [ebx], 0
	mov	ecx, ebx
	mov	DWORD PTR $T48575[esp+52], eax
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?Set@CCorString@@QAEXPAD@Z		; CCorString::Set
	mov	eax, DWORD PTR $T48575[esp+52]
	lea	ecx, DWORD PTR [ebx+4]
	add	eax, 4
	mov	BYTE PTR __$EHRec$[esp+60], 5
	push	eax
	call	??0?$TCorArray@VCCorString@@@@QAE@AAV0@@Z ; TCorArray<CCorString>::TCorArray<CCorString>
$L48585:
	mov	eax, DWORD PTR _i$48577[esp+52]
	mov	edx, DWORD PTR 8+[esp+48]
	mov	ecx, DWORD PTR [esi+76]
	inc	eax
	add	edx, 20					; 00000014H
	cmp	eax, ecx
	mov	BYTE PTR __$EHRec$[esp+60], 3
	mov	DWORD PTR _i$48577[esp+52], eax
	mov	DWORD PTR 8+[esp+48], edx
	jb	$L48578
$L48609:
	mov	ecx, DWORD PTR __$EHRec$[esp+52]
	mov	DWORD PTR [edi], OFFSET FLAT:??_7OCpjConfig@@6B@ ; OCpjConfig::`vftable'
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 36					; 00000024H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L48505:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1CObjLink@@QAE@XZ			; CObjLink::~CObjLink
$L48506:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	jmp	??1CObjLink@@QAE@XZ			; CObjLink::~CObjLink
$L48498:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1OCpjChunk@@UAE@XZ			; OCpjChunk::~OCpjChunk
$L48545:
	mov	ecx, DWORD PTR $T48603[ebp]
	jmp	??1CCorArray@@IAE@XZ			; CCorArray::~CCorArray
$L48546:
	mov	eax, DWORD PTR $T48584[ebp]
	push	eax
	mov	ecx, DWORD PTR $T48583[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
$L48566:
	mov	ecx, DWORD PTR $T48583[ebp]
	jmp	??1CCorString@@QAE@XZ			; CCorString::~CCorString
$L48611:
	mov	eax, OFFSET FLAT:$T48606
	jmp	___CxxFrameHandler
text$x	ENDS
??0OCpjConfig@@QAE@AAV0@@Z ENDP				; OCpjConfig::OCpjConfig
;	COMDAT xdata$x
; File C:\duke4\Cannibal\CorMain.h
xdata$x	SEGMENT
$T48676	DD	0ffffffffH
	DD	FLAT:$L48623
	DD	00H
	DD	FLAT:$L48624
$T48667	DD	019930520H
	DD	02H
	DD	FLAT:$T48676
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ??0?$TCorArray@VCCorString@@@@QAE@AAV0@@Z
_TEXT	SEGMENT
_this$ = -24
_i$ = -28
_inArray$ = 8
$T48619 = -16
$T48620 = -20
__$EHRec$ = -12
??0?$TCorArray@VCCorString@@@@QAE@AAV0@@Z PROC NEAR	; TCorArray<CCorString>::TCorArray<CCorString>, COMDAT
; _this$ = ecx

; 263  : 	{

	push	-1
	push	$L48675
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	push	edi
	mov	edi, DWORD PTR _inArray$[esp+36]
	mov	ebx, ecx
	xor	esi, esi
	mov	eax, DWORD PTR [edi+4]
	push	4
	mov	DWORD PTR _this$[esp+44], ebx
	mov	DWORD PTR [ebx], esi
	mov	DWORD PTR [ebx+4], eax
	mov	DWORD PTR [ebx+8], eax
	mov	DWORD PTR [ebx+12], 4
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc

; 264  : 		m_Count = 0;

	mov	DWORD PTR [ebx+4], esi

; 265  : 		for (NDword i=0;i<inArray.m_Count;i++)

	mov	eax, DWORD PTR [edi+4]
	cmp	eax, esi
	mov	DWORD PTR __$EHRec$[esp+48], esi
	mov	DWORD PTR _i$[esp+40], esi
	jbe	$L48671
	push	ebp
$L14253:

; 266  : 			new(&(*this)[AddNoConstruct()]) T(inArray[i]);

	mov	esi, DWORD PTR [ebx+4]
	mov	ecx, DWORD PTR [ebx+8]
	lea	eax, DWORD PTR [esi+1]
	cmp	eax, ecx
	mov	DWORD PTR [ebx+4], eax
	jbe	SHORT $L48632
	mov	ecx, eax
	push	4
	shr	ecx, 2
	lea	edx, DWORD PTR [ecx+eax+32]
	mov	ecx, ebx
	mov	DWORD PTR [ebx+8], edx
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
$L48632:
	mov	eax, DWORD PTR [ebx]
	lea	ebp, DWORD PTR [eax+esi*4]
	mov	DWORD PTR $T48620[esp+44], ebp
	mov	DWORD PTR $T48619[esp+44], ebp
	test	ebp, ebp
	mov	BYTE PTR __$EHRec$[esp+52], 1
	je	SHORT $L48662
	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR _i$[esp+44]
	mov	DWORD PTR [ebp], 0
	mov	esi, DWORD PTR [ecx+edx*4]
	lea	eax, DWORD PTR [ecx+edx*4]
	test	esi, esi
	je	SHORT $L48659
	cmp	BYTE PTR [esi], 0
	jne	SHORT $L48659
	xor	esi, esi
$L48659:
	test	esi, esi
	mov	DWORD PTR [ebp], 0
	je	SHORT $L48662
	mov	edi, esi
	or	ecx, -1
	xor	eax, eax
	repne scasb
	not	ecx
	dec	ecx
	mov	edi, ecx
	inc	edi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	edi
	mov	ecx, eax
	call	DWORD PTR [edx]
	test	eax, eax
	mov	DWORD PTR [ebp], eax
	je	SHORT $L48672
$L48664:
	mov	cl, BYTE PTR [esi]
	inc	esi
	mov	BYTE PTR [eax], cl
	inc	eax
	test	cl, cl
	jne	SHORT $L48664
	add	DWORD PTR ?sMemTotal@CCorString@@0KA, edi ; CCorString::sMemTotal
$L48672:
	mov	edi, DWORD PTR _inArray$[esp+40]
$L48662:
	mov	eax, DWORD PTR _i$[esp+44]
	mov	ecx, DWORD PTR [edi+4]
	inc	eax
	mov	BYTE PTR __$EHRec$[esp+52], 0
	cmp	eax, ecx
	mov	DWORD PTR _i$[esp+44], eax
	jb	$L14253
	pop	ebp
$L48671:

; 267  : 	}

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	pop	edi
	mov	eax, ebx
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 28					; 0000001cH
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L48623:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CCorArray@@IAE@XZ			; CCorArray::~CCorArray
$L48624:
	mov	eax, DWORD PTR $T48620[ebp]
	push	eax
	mov	ecx, DWORD PTR $T48619[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
$L48675:
	mov	eax, OFFSET FLAT:$T48667
	jmp	___CxxFrameHandler
text$x	ENDS
??0?$TCorArray@VCCorString@@@@QAE@AAV0@@Z ENDP		; TCorArray<CCorString>::TCorArray<CCorString>
PUBLIC	??4?$TCorArray@VCCpjMacSection@@@@QAEAAV0@AAV0@@Z ; TCorArray<CCpjMacSection>::operator=
PUBLIC	??4OCpjConfig@@QAEAAV0@AAV0@@Z			; OCpjConfig::operator=
; Function compile flags: /Ogty
;	COMDAT ??4OCpjConfig@@QAEAAV0@AAV0@@Z
_TEXT	SEGMENT
___that$ = 8
??4OCpjConfig@@QAEAAV0@AAV0@@Z PROC NEAR		; OCpjConfig::operator=, COMDAT
; _this$ = ecx
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR ___that$[esp+4]
	push	esi
	mov	esi, ecx
	push	edi
	mov	eax, DWORD PTR [ebp+4]
	lea	ecx, DWORD PTR [ebp+8]
	mov	DWORD PTR [esi+4], eax
	lea	edx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	lea	eax, DWORD PTR [esi+24]
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], ecx
	lea	edx, DWORD PTR [ebp+24]
	mov	ecx, DWORD PTR [ebp+24]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR [ebp+40]
	mov	DWORD PTR [esi+40], eax
	mov	ebx, DWORD PTR [ebp+44]
	test	ebx, ebx
	je	SHORT $L48751
	cmp	BYTE PTR [ebx], 0
	jne	SHORT $L48751
	xor	ebx, ebx
$L48751:
	mov	edi, DWORD PTR [esi+44]
	test	edi, edi
	je	SHORT $L48752
	or	ecx, -1
	xor	eax, eax
	repne scasb
	mov	eax, DWORD PTR ?sMemTotal@CCorString@@0KA ; CCorString::sMemTotal
	or	edx, -1
	not	ecx
	dec	ecx
	sub	edx, ecx
	add	eax, edx
	mov	DWORD PTR ?sMemTotal@CCorString@@0KA, eax ; CCorString::sMemTotal
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+44]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L48752:
	test	ebx, ebx
	mov	DWORD PTR [esi+44], 0
	je	SHORT $L48755
	mov	edi, ebx
	or	ecx, -1
	xor	eax, eax
	repne scasb
	not	ecx
	dec	ecx
	mov	edi, ecx
	inc	edi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	edi
	mov	ecx, eax
	call	DWORD PTR [edx]
	test	eax, eax
	mov	DWORD PTR [esi+44], eax
	je	SHORT $L48755
$L48757:
	mov	cl, BYTE PTR [ebx]
	inc	ebx
	mov	BYTE PTR [eax], cl
	inc	eax
	test	cl, cl
	jne	SHORT $L48757
	add	DWORD PTR ?sMemTotal@CCorString@@0KA, edi ; CCorString::sMemTotal
$L48755:
	mov	eax, DWORD PTR [ebp+48]
	add	ebp, 72					; 00000048H
	mov	DWORD PTR [esi+48], eax
	mov	ecx, DWORD PTR [ebp-20]
	mov	DWORD PTR [esi+52], ecx
	mov	dl, BYTE PTR [ebp-16]
	mov	BYTE PTR [esi+56], dl
	mov	eax, DWORD PTR [ebp-12]
	mov	DWORD PTR [esi+60], eax
	mov	ecx, DWORD PTR [ebp-8]
	mov	DWORD PTR [esi+64], ecx
	mov	edx, DWORD PTR [ebp-4]
	push	ebp
	lea	ecx, DWORD PTR [esi+72]
	mov	DWORD PTR [esi+68], edx
	call	??4?$TCorArray@VCCpjMacSection@@@@QAEAAV0@AAV0@@Z ; TCorArray<CCpjMacSection>::operator=
	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	4
??4OCpjConfig@@QAEAAV0@AAV0@@Z ENDP			; OCpjConfig::operator=
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
$T48926	DD	0ffffffffH
	DD	FLAT:$L48768
	DD	00H
	DD	FLAT:$L48795
	DD	01H
	DD	FLAT:$L48825
	DD	02H
	DD	FLAT:$L48826
$T48915	DD	019930520H
	DD	04H
	DD	FLAT:$T48926
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ??4?$TCorArray@VCCpjMacSection@@@@QAEAAV0@AAV0@@Z
_TEXT	SEGMENT
_this$ = -44
_i$ = -36
$T48874 = -24
$T48894 = -16
$T48895 = -20
__$EHRec$ = -12
_inArray$ = 8
$T48764 = -28
$T48765 = -32
??4?$TCorArray@VCCpjMacSection@@@@QAEAAV0@AAV0@@Z PROC NEAR ; TCorArray<CCpjMacSection>::operator=, COMDAT
; _this$ = ecx

; 269  : 	{

	push	-1
	push	$L48924
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 32					; 00000020H
	push	ebp

; 270  : 		if (this == &inArray)

	mov	ebp, DWORD PTR _inArray$[esp+44]
	push	edi
	mov	edi, ecx
	cmp	edi, ebp
	mov	DWORD PTR _this$[esp+52], edi

; 271  : 			return(*this);

	je	$L48925
	push	esi

; 272  : 		m_Count = 0;

	xor	esi, esi
	mov	DWORD PTR [edi+4], esi

; 273  : 		m_Limit = inArray.m_Count;

	mov	eax, DWORD PTR [ebp+4]
	mov	DWORD PTR [edi+8], eax

; 274  : 		Realloc(sizeof(T));

	mov	eax, DWORD PTR [edi]
	cmp	eax, esi
	mov	eax, DWORD PTR [edi+8]
	mov	DWORD PTR [edi+12], 20			; 00000014H
	je	$L48772
	cmp	eax, esi
	je	SHORT $L48774
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [edi+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [edi+8]
	push	ecx
	mov	ecx, DWORD PTR [edi]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+4]
	mov	DWORD PTR [edi], eax
	jmp	SHORT $L48779
$L48774:
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L48778:
	mov	DWORD PTR [edi], esi
$L48779:

; 275  : 		for (NDword i=0;i<inArray.m_Count;i++)

	mov	eax, DWORD PTR [ebp+4]
	mov	DWORD PTR _i$[esp+56], esi
	cmp	eax, esi
	jbe	$L14315
	push	ebx
	mov	DWORD PTR -40+[esp+60], esi
$L14313:

; 276  : 			new(&(*this)[AddNoConstruct()]) T(inArray[i]);

	mov	esi, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi+8]
	lea	eax, DWORD PTR [esi+1]
	cmp	eax, ecx
	mov	DWORD PTR [edi+4], eax
	jbe	SHORT $L48784
	mov	edx, eax
	push	20					; 00000014H
	shr	edx, 2
	mov	ecx, edi
	lea	eax, DWORD PTR [edx+eax+32]
	mov	DWORD PTR [edi+8], eax
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
$L48784:
	mov	edx, DWORD PTR [edi]
	lea	ecx, DWORD PTR [esi+esi*4]
	lea	ebx, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR $T48765[esp+60], ebx
	mov	DWORD PTR $T48764[esp+60], ebx
	test	ebx, ebx
	mov	DWORD PTR __$EHRec$[esp+68], 0
	je	$L48891
	mov	ebp, DWORD PTR [ebp]
	mov	ecx, DWORD PTR -40+[esp+60]
	add	ebp, ecx
	mov	DWORD PTR [ebx], 0
	mov	esi, DWORD PTR [ebp]
	test	esi, esi
	je	SHORT $L48882
	cmp	BYTE PTR [esi], 0
	jne	SHORT $L48882
	xor	esi, esi
$L48882:
	test	esi, esi
	mov	DWORD PTR [ebx], 0
	je	SHORT $L48885
	mov	edi, esi
	or	ecx, -1
	xor	eax, eax
	repne scasb
	not	ecx
	dec	ecx
	mov	edi, ecx
	inc	edi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	edi
	mov	ecx, eax
	call	DWORD PTR [edx]
	test	eax, eax
	mov	DWORD PTR [ebx], eax
	je	SHORT $L48921
$L48879:
	mov	cl, BYTE PTR [esi]
	inc	esi
	mov	BYTE PTR [eax], cl
	inc	eax
	test	cl, cl
	jne	SHORT $L48879
	add	DWORD PTR ?sMemTotal@CCorString@@0KA, edi ; CCorString::sMemTotal
$L48921:
	mov	edi, DWORD PTR _this$[esp+60]
$L48885:
	mov	eax, DWORD PTR [ebp+8]
	lea	esi, DWORD PTR [ebx+4]
	push	4
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+72], 1
	mov	DWORD PTR $T48874[esp+64], esi
	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], 4
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
	xor	ebx, ebx
	mov	BYTE PTR __$EHRec$[esp+68], 2
	mov	DWORD PTR [esi+4], ebx
	mov	eax, DWORD PTR [ebp+8]
	cmp	eax, ebx
	jbe	SHORT $L48922
$L48889:
	mov	edi, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	lea	eax, DWORD PTR [edi+1]
	cmp	eax, ecx
	mov	DWORD PTR [esi+4], eax
	jbe	SHORT $L48903
	mov	ecx, eax
	push	4
	shr	ecx, 2
	lea	edx, DWORD PTR [ecx+eax+32]
	mov	ecx, esi
	mov	DWORD PTR [esi+8], edx
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
$L48903:
	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR [eax+edi*4]
	mov	DWORD PTR $T48895[esp+60], ecx
	mov	DWORD PTR $T48894[esp+60], ecx
	test	ecx, ecx
	mov	BYTE PTR __$EHRec$[esp+68], 3
	je	SHORT $L48896
	mov	edx, DWORD PTR [ebp+4]
	mov	DWORD PTR [ecx], 0
	lea	eax, DWORD PTR [edx+ebx*4]
	mov	eax, DWORD PTR [edx+ebx*4]
	push	eax
	call	?Set@CCorString@@QAEXPAD@Z		; CCorString::Set
$L48896:
	mov	eax, DWORD PTR [ebp+8]
	inc	ebx
	cmp	ebx, eax
	mov	BYTE PTR __$EHRec$[esp+68], 2
	jb	SHORT $L48889
	mov	edi, DWORD PTR _this$[esp+60]
$L48922:
	mov	ebp, DWORD PTR _inArray$[esp+56]
$L48891:
	mov	eax, DWORD PTR _i$[esp+60]
	mov	edx, DWORD PTR -40+[esp+60]
	mov	ecx, DWORD PTR [ebp+4]
	inc	eax
	add	edx, 20					; 00000014H
	cmp	eax, ecx
	mov	DWORD PTR __$EHRec$[esp+68], -1
	mov	DWORD PTR _i$[esp+60], eax
	mov	DWORD PTR -40+[esp+60], edx
	jb	$L14313
	pop	ebx
$L14315:
	pop	esi
$L48925:

; 277  : 		return(*this);
; 278  : 	}

	mov	ecx, DWORD PTR __$EHRec$[esp+52]
	mov	eax, edi
	pop	edi
	pop	ebp
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 44					; 0000002cH
	ret	4

; 274  : 		Realloc(sizeof(T));

$L48772:
	cmp	eax, esi
	je	$L48778
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [edi+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [edi+8]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	DWORD PTR [edi], eax
	jmp	$L48779
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L48768:
	mov	eax, DWORD PTR $T48765[ebp]
	push	eax
	mov	ecx, DWORD PTR $T48764[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
$L48795:
	mov	ecx, DWORD PTR $T48764[ebp]
	jmp	??1CCorString@@QAE@XZ			; CCorString::~CCorString
$L48825:
	mov	ecx, DWORD PTR $T48874[ebp]
	jmp	??1CCorArray@@IAE@XZ			; CCorArray::~CCorArray
$L48826:
	mov	eax, DWORD PTR $T48895[ebp]
	push	eax
	mov	ecx, DWORD PTR $T48894[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
$L48924:
	mov	eax, OFFSET FLAT:$T48915
	jmp	___CxxFrameHandler
text$x	ENDS
??4?$TCorArray@VCCpjMacSection@@@@QAEAAV0@AAV0@@Z ENDP	; TCorArray<CCpjMacSection>::operator=
PUBLIC	??1?$TCorArray@VCCorString@@@@QAE@XZ		; TCorArray<CCorString>::~TCorArray<CCorString>
PUBLIC	??1OCpjConfig@@UAE@XZ				; OCpjConfig::~OCpjConfig
;	COMDAT xdata$x
xdata$x	SEGMENT
$T49035	DD	0ffffffffH
	DD	FLAT:$L48932
	DD	00H
	DD	FLAT:$L48935
	DD	01H
	DD	FLAT:$L48943
$T49031	DD	019930520H
	DD	03H
	DD	FLAT:$T49035
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ??1OCpjConfig@@UAE@XZ
_TEXT	SEGMENT
$T48959 = -16
$T48975 = -24
$T49019 = -20
__$EHRec$ = -12
_this$ = -28
??1OCpjConfig@@UAE@XZ PROC NEAR				; OCpjConfig::~OCpjConfig, COMDAT
; _this$ = ecx
	push	-1
	push	$L49034
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 16					; 00000010H
	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+44], esi
	xor	edi, edi
	lea	ebp, DWORD PTR [esi+72]
	mov	DWORD PTR __$EHRec$[esp+52], edi
	mov	DWORD PTR $T49019[esp+44], ebp
	mov	ebx, DWORD PTR [ebp+4]
	cmp	ebx, edi
	mov	DWORD PTR $T48975[esp+44], ebx
	jbe	SHORT $L49004
$L49002:
	mov	esi, DWORD PTR [ebp]
	add	esi, edi
	mov	DWORD PTR $T48959[esp+44], esi
	lea	ecx, DWORD PTR [esi+4]
	mov	BYTE PTR __$EHRec$[esp+52], 2
	call	??1?$TCorArray@VCCorString@@@@QAE@XZ	; TCorArray<CCorString>::~TCorArray<CCorString>
	push	0
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+56], 1
	call	?Set@CCorString@@QAEXPAD@Z		; CCorString::Set
	add	edi, 20					; 00000014H
	dec	ebx
	jne	SHORT $L49002
	mov	esi, DWORD PTR _this$[esp+44]
	mov	ebx, DWORD PTR $T48975[esp+44]
$L49004:
	push	20					; 00000014H
	push	ebx
	push	0
	mov	ecx, ebp
	call	?Remove@CCorArray@@QAEXKKK@Z		; CCorArray::Remove
	mov	eax, DWORD PTR [ebp]
	mov	BYTE PTR __$EHRec$[esp+52], 0
	test	eax, eax
	je	SHORT $L49018
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [ebp]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L49018:
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+52], -1
	call	??1OObject@@UAE@XZ			; OObject::~OObject
	mov	ecx, DWORD PTR __$EHRec$[esp+44]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 28					; 0000001cH
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L48932:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1OCpjChunk@@UAE@XZ			; OCpjChunk::~OCpjChunk
$L48935:
	mov	ecx, DWORD PTR $T49019[ebp]
	jmp	??1CCorArray@@IAE@XZ			; CCorArray::~CCorArray
$L48943:
	mov	ecx, DWORD PTR $T48959[ebp]
	jmp	??1CCorString@@QAE@XZ			; CCorString::~CCorString
$L49034:
	mov	eax, OFFSET FLAT:$T49031
	jmp	___CxxFrameHandler
text$x	ENDS
??1OCpjConfig@@UAE@XZ ENDP				; OCpjConfig::~OCpjConfig
;	COMDAT xdata$x
xdata$x	SEGMENT
$T49150	DD	0ffffffffH
	DD	FLAT:$L49041
$T49144	DD	019930520H
	DD	01H
	DD	FLAT:$T49150
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ??1?$TCorArray@VCCorString@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16
$T49112 = -20
__$EHRec$ = -12
??1?$TCorArray@VCCorString@@@@QAE@XZ PROC NEAR		; TCorArray<CCorString>::~TCorArray<CCorString>, COMDAT
; _this$ = ecx

; 280  : 	{

	push	-1
	push	$L49148
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 8
	push	ebx
	mov	ebx, ecx
	push	ebp
	mov	DWORD PTR _this$[esp+28], ebx

; 281  : 		Purge();

	mov	eax, DWORD PTR [ebx+4]
	xor	ebp, ebp
	test	eax, eax
	mov	DWORD PTR __$EHRec$[esp+36], 0
	mov	DWORD PTR $T49112[esp+28], eax
	jbe	SHORT $L49149
	push	esi
	push	edi
$L49136:
	mov	ecx, DWORD PTR [ebx]
	mov	edi, DWORD PTR [ecx+ebp*4]
	lea	esi, DWORD PTR [ecx+ebp*4]
	test	edi, edi
	je	SHORT $L49124
	or	ecx, -1
	xor	eax, eax
	repne scasb
	mov	eax, DWORD PTR ?sMemTotal@CCorString@@0KA ; CCorString::sMemTotal
	or	edx, -1
	not	ecx
	dec	ecx
	sub	edx, ecx
	add	eax, edx
	mov	DWORD PTR ?sMemTotal@CCorString@@0KA, eax ; CCorString::sMemTotal
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
	mov	eax, DWORD PTR $T49112[esp+36]
$L49124:
	inc	ebp
	mov	DWORD PTR [esi], 0
	cmp	ebp, eax
	jb	SHORT $L49136
	pop	edi
	pop	esi
	test	eax, eax
$L49149:
	je	SHORT $L49132
	mov	edx, DWORD PTR [ebx+4]
	mov	ecx, DWORD PTR [ebx]
	sub	edx, eax
	shl	edx, 2
	lea	eax, DWORD PTR [ecx+eax*4]
	push	edx
	push	eax
	push	ecx
	call	DWORD PTR __imp__memmove
	mov	ecx, DWORD PTR $T49112[esp+40]
	mov	eax, DWORD PTR [ebx+4]
	add	esp, 12					; 0000000cH
	sub	eax, ecx
	mov	DWORD PTR [ebx+4], eax
$L49132:

; 282  : 	}

	mov	eax, DWORD PTR [ebx]
	mov	DWORD PTR __$EHRec$[esp+36], -1
	test	eax, eax
	je	SHORT $L49142
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [ebx]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L49142:
	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 20					; 00000014H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L49041:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CCorArray@@IAE@XZ			; CCorArray::~CCorArray
$L49148:
	mov	eax, OFFSET FLAT:$T49144
	jmp	___CxxFrameHandler
text$x	ENDS
??1?$TCorArray@VCCorString@@@@QAE@XZ ENDP		; TCorArray<CCorString>::~TCorArray<CCorString>
PUBLIC	??_GOCpjConfig@@UAEPAXI@Z			; OCpjConfig::`scalar deleting destructor'
; Function compile flags: /Ogty
;	COMDAT ??_GOCpjConfig@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_GOCpjConfig@@UAEPAXI@Z PROC NEAR			; OCpjConfig::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1OCpjConfig@@UAE@XZ			; OCpjConfig::~OCpjConfig
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $L49168
	mov	DWORD PTR [esi+4], 0
	mov	edx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	dec	edx
	mov	DWORD PTR ?sObjCount@OObject@@1KA, edx	; OObject::sObjCount
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L49168:
	mov	eax, esi
	pop	esi
	ret	4
??_GOCpjConfig@@UAEPAXI@Z ENDP				; OCpjConfig::`scalar deleting destructor'
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??_EOCpjConfig@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_EOCpjConfig@@UAEPAXI@Z PROC NEAR			; OCpjConfig::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebx
	mov	bl, BYTE PTR ___flags$[esp]
	push	esi
	mov	esi, ecx
	test	bl, 2
	je	SHORT $L10054
	mov	eax, DWORD PTR [esi-4]
	push	edi
	lea	edi, DWORD PTR [esi-4]
	push	OFFSET FLAT:??1OCpjConfig@@UAE@XZ	; OCpjConfig::~OCpjConfig
	push	eax
	push	88					; 00000058H
	push	esi
	call	??_M@YGXPAXIHP6EX0@Z@Z			; `eh vector destructor iterator'
	test	bl, 1
	je	SHORT $L10055
	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L10055:
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	ret	4
$L10054:
	mov	ecx, esi
	call	??1OCpjConfig@@UAE@XZ			; OCpjConfig::~OCpjConfig
	test	bl, 1
	je	SHORT $L49183
	mov	DWORD PTR [esi+4], 0
	mov	edx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	dec	edx
	mov	DWORD PTR ?sObjCount@OObject@@1KA, edx	; OObject::sObjCount
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L49183:
	mov	eax, esi
	pop	esi
	pop	ebx
	ret	4
??_EOCpjConfig@@UAEPAXI@Z ENDP				; OCpjConfig::`vector deleting destructor'
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?AddNoConstruct@?$TCorArray@VVVec2@@@@QAEKK@Z
_TEXT	SEGMENT
_inCount$ = 8
?AddNoConstruct@?$TCorArray@VVVec2@@@@QAEKK@Z PROC NEAR	; TCorArray<VVec2>::AddNoConstruct, COMDAT
; _this$ = ecx

; 322  : 		NDword i = m_Count;
; 323  : 		if ((m_Count+=inCount)>m_Limit)

	mov	eax, DWORD PTR _inCount$[esp-4]
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	add	eax, edi
	cmp	eax, ecx
	mov	DWORD PTR [esi+4], eax
	jbe	SHORT $L49198

; 324  : 		{
; 325  : 			m_Limit = m_Count + (m_Count>>2) + 32;

	mov	ecx, eax

; 326  : 			Realloc(sizeof(T));

	mov	DWORD PTR [esi+12], 8
	shr	ecx, 2
	lea	eax, DWORD PTR [ecx+eax+32]
	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	mov	DWORD PTR [esi+8], eax
	je	SHORT $L49190
	test	eax, eax
	je	SHORT $L49192
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [esi+8]
	push	ecx
	mov	ecx, DWORD PTR [esi]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+4]
	mov	DWORD PTR [esi], eax

; 327  : 		}
; 328  : 		return(i);

	mov	eax, edi
	pop	edi
	pop	esi

; 329  : 	}

	ret	4

; 326  : 			Realloc(sizeof(T));

$L49192:
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L49196:
	mov	DWORD PTR [esi], 0
$L49198:

; 327  : 		}
; 328  : 		return(i);

	mov	eax, edi
	pop	edi
	pop	esi

; 329  : 	}

	ret	4

; 326  : 			Realloc(sizeof(T));

$L49190:
	test	eax, eax
	je	SHORT $L49196
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [esi+8]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	DWORD PTR [esi], eax

; 327  : 		}
; 328  : 		return(i);

	mov	eax, edi
	pop	edi
	pop	esi

; 329  : 	}

	ret	4
?AddNoConstruct@?$TCorArray@VVVec2@@@@QAEKK@Z ENDP	; TCorArray<VVec2>::AddNoConstruct
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
$T49256	DD	0ffffffffH
	DD	FLAT:$L49207
$T49249	DD	019930520H
	DD	01H
	DD	FLAT:$T49256
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ??0?$TCorArray@VCCpjLodTri@@@@QAE@AAV0@@Z
_TEXT	SEGMENT
_inArray$ = 8
__$EHRec$ = -12
_this$ = -16
??0?$TCorArray@VCCpjLodTri@@@@QAE@AAV0@@Z PROC NEAR	; TCorArray<CCpjLodTri>::TCorArray<CCpjLodTri>, COMDAT
; _this$ = ecx

; 263  : 	{

	push	-1
	push	$L49255
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	push	ebx
	mov	ebx, DWORD PTR _inArray$[esp+16]
	push	ebp
	push	esi
	mov	eax, DWORD PTR [ebx+4]
	mov	esi, ecx
	xor	ebp, ebp
	push	16					; 00000010H
	mov	DWORD PTR _this$[esp+32], esi
	mov	DWORD PTR [esi], ebp
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], 16			; 00000010H
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc

; 264  : 		m_Count = 0;

	mov	DWORD PTR [esi+4], ebp

; 265  : 		for (NDword i=0;i<inArray.m_Count;i++)

	mov	eax, DWORD PTR [ebx+4]
	cmp	eax, ebp
	mov	DWORD PTR __$EHRec$[esp+36], ebp
	jbe	$L49252
	mov	DWORD PTR 8+[esp+24], ebp
	push	edi
$L14839:

; 266  : 			new(&(*this)[AddNoConstruct()]) T(inArray[i]);

	mov	edi, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	lea	eax, DWORD PTR [edi+1]
	cmp	eax, ecx
	mov	DWORD PTR [esi+4], eax
	jbe	SHORT $L49238
	mov	ecx, eax
	mov	DWORD PTR [esi+12], 16			; 00000010H
	shr	ecx, 2
	lea	eax, DWORD PTR [ecx+eax+32]
	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	mov	DWORD PTR [esi+8], eax
	je	$L49231
	test	eax, eax
	je	SHORT $L49233
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+8]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [esi+12]
	push	ecx
	mov	ecx, DWORD PTR [esi]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+4]
	mov	DWORD PTR [esi], eax
	jmp	SHORT $L49238
$L49233:
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L49237:
	mov	DWORD PTR [esi], 0
$L49238:
	mov	eax, DWORD PTR [esi]
	shl	edi, 4
	add	edi, eax
	mov	eax, edi
	je	SHORT $L49205
	mov	edx, DWORD PTR [ebx]
	mov	ecx, DWORD PTR 8+[esp+28]
	add	edx, ecx
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], edx
$L49205:
	mov	ecx, DWORD PTR 8+[esp+28]
	mov	eax, DWORD PTR [ebx+4]
	inc	ebp
	add	ecx, 16					; 00000010H
	cmp	ebp, eax
	mov	DWORD PTR 8+[esp+28], ecx
	jb	$L14839
	pop	edi
$L49252:

; 267  : 	}

	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	ret	4

; 266  : 			new(&(*this)[AddNoConstruct()]) T(inArray[i]);

$L49231:
	test	eax, eax
	je	SHORT $L49237
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+8]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [esi+12]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	DWORD PTR [esi], eax
	jmp	SHORT $L49238
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L49207:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CCorArray@@IAE@XZ			; CCorArray::~CCorArray
$L49255:
	mov	eax, OFFSET FLAT:$T49249
	jmp	___CxxFrameHandler
text$x	ENDS
??0?$TCorArray@VCCpjLodTri@@@@QAE@AAV0@@Z ENDP		; TCorArray<CCpjLodTri>::TCorArray<CCpjLodTri>
; Function compile flags: /Ogty
; File C:\duke4\Cannibal\VecPrim.h
;	COMDAT ??0VLine3@@QAE@XZ
_TEXT	SEGMENT
??0VLine3@@QAE@XZ PROC NEAR				; VLine3::VLine3, COMDAT
; _this$ = ecx

; 192  : VEC_INLINE VLine3::VLine3() {}

	mov	eax, ecx
	ret	0
??0VLine3@@QAE@XZ ENDP					; VLine3::VLine3
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?TwoPoint@VLine3@@QAEXABVVVec3@@0@Z
_TEXT	SEGMENT
_inP$ = 8
_inQ$ = 12
$T49271 = -12
?TwoPoint@VLine3@@QAEXABVVVec3@@0@Z PROC NEAR		; VLine3::TwoPoint, COMDAT
; _this$ = ecx

; 196  : VEC_INLINE void VLine3::TwoPoint(const VVec3& inP, const VVec3& inQ) { u = inP; v = inQ - inP; v.Normalize(); }

	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _inP$[esp+8]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR _inQ$[esp+8]
	fld	DWORD PTR [edx]
	fsub	DWORD PTR [eax]
	fld	DWORD PTR [edx+4]
	fsub	DWORD PTR [eax+4]
	fld	DWORD PTR [edx+8]
	fsub	DWORD PTR [eax+8]
	fstp	DWORD PTR $T49271[esp+20]
	mov	eax, DWORD PTR $T49271[esp+20]
	fxch	ST(1)
	fstp	DWORD PTR [ecx+12]
	mov	DWORD PTR [ecx+20], eax
	fstp	DWORD PTR [ecx+16]
	fld	DWORD PTR [ecx+20]
	fld	DWORD PTR [ecx+16]
	fld	DWORD PTR [ecx+12]
	fld	ST(0)
	fmul	ST(0), ST(1)
	fld	ST(2)
	fmul	ST(0), ST(3)
	faddp	ST(1), ST(0)
	fld	ST(3)
	fmul	ST(0), ST(4)
	faddp	ST(1), ST(0)
	fsqrt
	fstp	ST(3)
	fstp	ST(0)
	fstp	ST(0)
	fdivr	DWORD PTR __real@3f800000
	fld	ST(0)
	fmul	DWORD PTR [ecx+12]
	fstp	DWORD PTR [ecx+12]
	fld	ST(0)
	fmul	DWORD PTR [ecx+16]
	fstp	DWORD PTR [ecx+16]
	fmul	DWORD PTR [ecx+20]
	fstp	DWORD PTR [ecx+20]
	add	esp, 12					; 0000000cH
	ret	8
?TwoPoint@VLine3@@QAEXABVVVec3@@0@Z ENDP		; VLine3::TwoPoint
; Function compile flags: /Ogty
; File C:\duke4\Cannibal\CorMain.h
_TEXT	ENDS
;	COMDAT ?AddNoConstruct@?$TCorArray@VCCpjSklMount@@@@QAEKK@Z
_TEXT	SEGMENT
_inCount$ = 8
?AddNoConstruct@?$TCorArray@VCCpjSklMount@@@@QAEKK@Z PROC NEAR ; TCorArray<CCpjSklMount>::AddNoConstruct, COMDAT
; _this$ = ecx

; 322  : 		NDword i = m_Count;
; 323  : 		if ((m_Count+=inCount)>m_Limit)

	mov	eax, DWORD PTR _inCount$[esp-4]
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	add	eax, edi
	cmp	eax, ecx
	mov	DWORD PTR [esi+4], eax
	jbe	SHORT $L49315

; 324  : 		{
; 325  : 			m_Limit = m_Count + (m_Count>>2) + 32;

	mov	ecx, eax

; 326  : 			Realloc(sizeof(T));

	mov	DWORD PTR [esi+12], 68			; 00000044H
	shr	ecx, 2
	lea	eax, DWORD PTR [ecx+eax+32]
	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	mov	DWORD PTR [esi+8], eax
	je	SHORT $L49307
	test	eax, eax
	je	SHORT $L49309
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [esi+8]
	push	ecx
	mov	ecx, DWORD PTR [esi]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+4]
	mov	DWORD PTR [esi], eax

; 327  : 		}
; 328  : 		return(i);

	mov	eax, edi
	pop	edi
	pop	esi

; 329  : 	}

	ret	4

; 326  : 			Realloc(sizeof(T));

$L49309:
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L49313:
	mov	DWORD PTR [esi], 0
$L49315:

; 327  : 		}
; 328  : 		return(i);

	mov	eax, edi
	pop	edi
	pop	esi

; 329  : 	}

	ret	4

; 326  : 			Realloc(sizeof(T));

$L49307:
	test	eax, eax
	je	SHORT $L49313
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [esi+8]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	DWORD PTR [esi], eax

; 327  : 		}
; 328  : 		return(i);

	mov	eax, edi
	pop	edi
	pop	esi

; 329  : 	}

	ret	4
?AddNoConstruct@?$TCorArray@VCCpjSklMount@@@@QAEKK@Z ENDP ; TCorArray<CCpjSklMount>::AddNoConstruct
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?AddNoConstruct@?$TCorArray@VCCpjFrmGroup@@@@QAEKK@Z
_TEXT	SEGMENT
_inCount$ = 8
?AddNoConstruct@?$TCorArray@VCCpjFrmGroup@@@@QAEKK@Z PROC NEAR ; TCorArray<CCpjFrmGroup>::AddNoConstruct, COMDAT
; _this$ = ecx

; 322  : 		NDword i = m_Count;
; 323  : 		if ((m_Count+=inCount)>m_Limit)

	mov	eax, DWORD PTR _inCount$[esp-4]
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	add	eax, edi
	cmp	eax, ecx
	mov	DWORD PTR [esi+4], eax
	jbe	SHORT $L49330

; 324  : 		{
; 325  : 			m_Limit = m_Count + (m_Count>>2) + 32;

	mov	ecx, eax

; 326  : 			Realloc(sizeof(T));

	mov	DWORD PTR [esi+12], 24			; 00000018H
	shr	ecx, 2
	lea	eax, DWORD PTR [ecx+eax+32]
	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	mov	DWORD PTR [esi+8], eax
	je	SHORT $L49322
	test	eax, eax
	je	SHORT $L49324
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [esi+8]
	push	ecx
	mov	ecx, DWORD PTR [esi]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+4]
	mov	DWORD PTR [esi], eax

; 327  : 		}
; 328  : 		return(i);

	mov	eax, edi
	pop	edi
	pop	esi

; 329  : 	}

	ret	4

; 326  : 			Realloc(sizeof(T));

$L49324:
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L49328:
	mov	DWORD PTR [esi], 0
$L49330:

; 327  : 		}
; 328  : 		return(i);

	mov	eax, edi
	pop	edi
	pop	esi

; 329  : 	}

	ret	4

; 326  : 			Realloc(sizeof(T));

$L49322:
	test	eax, eax
	je	SHORT $L49328
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [esi+8]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	DWORD PTR [esi], eax

; 327  : 		}
; 328  : 		return(i);

	mov	eax, edi
	pop	edi
	pop	esi

; 329  : 	}

	ret	4
?AddNoConstruct@?$TCorArray@VCCpjFrmGroup@@@@QAEKK@Z ENDP ; TCorArray<CCpjFrmGroup>::AddNoConstruct
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?AddNoConstruct@?$TCorArray@VCCpjFrmBytePos@@@@QAEKK@Z
_TEXT	SEGMENT
_inCount$ = 8
?AddNoConstruct@?$TCorArray@VCCpjFrmBytePos@@@@QAEKK@Z PROC NEAR ; TCorArray<CCpjFrmBytePos>::AddNoConstruct, COMDAT
; _this$ = ecx

; 322  : 		NDword i = m_Count;
; 323  : 		if ((m_Count+=inCount)>m_Limit)

	mov	eax, DWORD PTR _inCount$[esp-4]
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	add	eax, edi
	cmp	eax, ecx
	mov	DWORD PTR [esi+4], eax
	jbe	SHORT $L49345

; 324  : 		{
; 325  : 			m_Limit = m_Count + (m_Count>>2) + 32;

	mov	ecx, eax

; 326  : 			Realloc(sizeof(T));

	mov	DWORD PTR [esi+12], 4
	shr	ecx, 2
	lea	eax, DWORD PTR [ecx+eax+32]
	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	mov	DWORD PTR [esi+8], eax
	je	SHORT $L49337
	test	eax, eax
	je	SHORT $L49339
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [esi+8]
	push	ecx
	mov	ecx, DWORD PTR [esi]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+4]
	mov	DWORD PTR [esi], eax

; 327  : 		}
; 328  : 		return(i);

	mov	eax, edi
	pop	edi
	pop	esi

; 329  : 	}

	ret	4

; 326  : 			Realloc(sizeof(T));

$L49339:
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L49343:
	mov	DWORD PTR [esi], 0
$L49345:

; 327  : 		}
; 328  : 		return(i);

	mov	eax, edi
	pop	edi
	pop	esi

; 329  : 	}

	ret	4

; 326  : 			Realloc(sizeof(T));

$L49337:
	test	eax, eax
	je	SHORT $L49343
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [esi+8]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	DWORD PTR [esi], eax

; 327  : 		}
; 328  : 		return(i);

	mov	eax, edi
	pop	edi
	pop	esi

; 329  : 	}

	ret	4
?AddNoConstruct@?$TCorArray@VCCpjFrmBytePos@@@@QAEKK@Z ENDP ; TCorArray<CCpjFrmBytePos>::AddNoConstruct
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?AddNoConstruct@?$TCorArray@VVVec3@@@@QAEKK@Z
_TEXT	SEGMENT
_inCount$ = 8
?AddNoConstruct@?$TCorArray@VVVec3@@@@QAEKK@Z PROC NEAR	; TCorArray<VVec3>::AddNoConstruct, COMDAT
; _this$ = ecx

; 322  : 		NDword i = m_Count;
; 323  : 		if ((m_Count+=inCount)>m_Limit)

	mov	eax, DWORD PTR _inCount$[esp-4]
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	add	eax, edi
	cmp	eax, ecx
	mov	DWORD PTR [esi+4], eax
	jbe	SHORT $L49360

; 324  : 		{
; 325  : 			m_Limit = m_Count + (m_Count>>2) + 32;

	mov	ecx, eax

; 326  : 			Realloc(sizeof(T));

	mov	DWORD PTR [esi+12], 12			; 0000000cH
	shr	ecx, 2
	lea	eax, DWORD PTR [ecx+eax+32]
	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	mov	DWORD PTR [esi+8], eax
	je	SHORT $L49352
	test	eax, eax
	je	SHORT $L49354
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [esi+8]
	push	ecx
	mov	ecx, DWORD PTR [esi]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+4]
	mov	DWORD PTR [esi], eax

; 327  : 		}
; 328  : 		return(i);

	mov	eax, edi
	pop	edi
	pop	esi

; 329  : 	}

	ret	4

; 326  : 			Realloc(sizeof(T));

$L49354:
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L49358:
	mov	DWORD PTR [esi], 0
$L49360:

; 327  : 		}
; 328  : 		return(i);

	mov	eax, edi
	pop	edi
	pop	esi

; 329  : 	}

	ret	4

; 326  : 			Realloc(sizeof(T));

$L49352:
	test	eax, eax
	je	SHORT $L49358
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [esi+8]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	DWORD PTR [esi], eax

; 327  : 		}
; 328  : 		return(i);

	mov	eax, edi
	pop	edi
	pop	esi

; 329  : 	}

	ret	4
?AddNoConstruct@?$TCorArray@VVVec3@@@@QAEKK@Z ENDP	; TCorArray<VVec3>::AddNoConstruct
_TEXT	ENDS
;	COMDAT xdata$x
; File C:\duke4\Cannibal\VecMain.h
xdata$x	SEGMENT
$T49406	DD	0ffffffffH
	DD	FLAT:$L49369
$T49401	DD	019930520H
	DD	01H
	DD	FLAT:$T49406
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File C:\duke4\Cannibal\CorMain.h
xdata$x	ENDS
;	COMDAT ??0?$TCorArray@VCCpjSeqScale@@@@QAE@AAV0@@Z
_TEXT	SEGMENT
_inArray$ = 8
__$EHRec$ = -12
_this$ = -16
_i$ = 8
??0?$TCorArray@VCCpjSeqScale@@@@QAE@AAV0@@Z PROC NEAR	; TCorArray<CCpjSeqScale>::TCorArray<CCpjSeqScale>, COMDAT
; _this$ = ecx

; 263  : 	{

	push	-1
	push	$L49405
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	push	ebx
	mov	ebx, DWORD PTR _inArray$[esp+16]
	push	ebp
	push	esi
	mov	eax, DWORD PTR [ebx+4]
	mov	esi, ecx
	xor	ebp, ebp
	push	16					; 00000010H
	mov	DWORD PTR _this$[esp+32], esi
	mov	DWORD PTR [esi], ebp
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], 16			; 00000010H
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc

; 264  : 		m_Count = 0;

	mov	DWORD PTR [esi+4], ebp

; 265  : 		for (NDword i=0;i<inArray.m_Count;i++)

	mov	eax, DWORD PTR [ebx+4]
	cmp	eax, ebp
	mov	DWORD PTR __$EHRec$[esp+36], ebp
	mov	DWORD PTR _i$[esp+24], ebp
	jbe	SHORT $L49404
	push	edi
$L14958:

; 266  : 			new(&(*this)[AddNoConstruct()]) T(inArray[i]);

	mov	edi, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	lea	eax, DWORD PTR [edi+1]
	cmp	eax, ecx
	mov	DWORD PTR [esi+4], eax
	jbe	SHORT $L49378
	mov	ecx, eax
	push	16					; 00000010H
	shr	ecx, 2
	lea	edx, DWORD PTR [ecx+eax+32]
	mov	ecx, esi
	mov	DWORD PTR [esi+8], edx
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
$L49378:
	mov	eax, DWORD PTR [esi]
	shl	edi, 4
	add	edi, eax
	mov	ecx, edi
	je	SHORT $L49367
	mov	eax, DWORD PTR [ebx]
	add	eax, ebp
	mov	dx, WORD PTR [eax]
	mov	WORD PTR [ecx], dx
	mov	dx, WORD PTR [eax+2]
	mov	WORD PTR [ecx+2], dx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax
$L49367:
	mov	eax, DWORD PTR _i$[esp+28]
	mov	ecx, DWORD PTR [ebx+4]
	inc	eax
	add	ebp, 16					; 00000010H
	cmp	eax, ecx
	mov	DWORD PTR _i$[esp+28], eax
	jb	SHORT $L14958
	pop	edi
$L49404:

; 267  : 	}

	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L49369:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CCorArray@@IAE@XZ			; CCorArray::~CCorArray
$L49405:
	mov	eax, OFFSET FLAT:$T49401
	jmp	___CxxFrameHandler
text$x	ENDS
??0?$TCorArray@VCCpjSeqScale@@@@QAE@AAV0@@Z ENDP	; TCorArray<CCpjSeqScale>::TCorArray<CCpjSeqScale>
; Function compile flags: /Ogty
;	COMDAT ?AddNoConstruct@?$TCorArray@VCCpjSeqBoneInfo@@@@QAEKK@Z
_TEXT	SEGMENT
_inCount$ = 8
?AddNoConstruct@?$TCorArray@VCCpjSeqBoneInfo@@@@QAEKK@Z PROC NEAR ; TCorArray<CCpjSeqBoneInfo>::AddNoConstruct, COMDAT
; _this$ = ecx

; 322  : 		NDword i = m_Count;
; 323  : 		if ((m_Count+=inCount)>m_Limit)

	mov	eax, DWORD PTR _inCount$[esp-4]
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	add	eax, edi
	cmp	eax, ecx
	mov	DWORD PTR [esi+4], eax
	jbe	SHORT $L49423

; 324  : 		{
; 325  : 			m_Limit = m_Count + (m_Count>>2) + 32;

	mov	ecx, eax

; 326  : 			Realloc(sizeof(T));

	mov	DWORD PTR [esi+12], 8
	shr	ecx, 2
	lea	eax, DWORD PTR [ecx+eax+32]
	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	mov	DWORD PTR [esi+8], eax
	je	SHORT $L49415
	test	eax, eax
	je	SHORT $L49417
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [esi+8]
	push	ecx
	mov	ecx, DWORD PTR [esi]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+4]
	mov	DWORD PTR [esi], eax

; 327  : 		}
; 328  : 		return(i);

	mov	eax, edi
	pop	edi
	pop	esi

; 329  : 	}

	ret	4

; 326  : 			Realloc(sizeof(T));

$L49417:
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L49421:
	mov	DWORD PTR [esi], 0
$L49423:

; 327  : 		}
; 328  : 		return(i);

	mov	eax, edi
	pop	edi
	pop	esi

; 329  : 	}

	ret	4

; 326  : 			Realloc(sizeof(T));

$L49415:
	test	eax, eax
	je	SHORT $L49421
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [esi+8]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	DWORD PTR [esi], eax

; 327  : 		}
; 328  : 		return(i);

	mov	eax, edi
	pop	edi
	pop	esi

; 329  : 	}

	ret	4
?AddNoConstruct@?$TCorArray@VCCpjSeqBoneInfo@@@@QAEKK@Z ENDP ; TCorArray<CCpjSeqBoneInfo>::AddNoConstruct
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?AddNoConstruct@?$TCorArray@VCCorString@@@@QAEKK@Z
_TEXT	SEGMENT
_inCount$ = 8
?AddNoConstruct@?$TCorArray@VCCorString@@@@QAEKK@Z PROC NEAR ; TCorArray<CCorString>::AddNoConstruct, COMDAT
; _this$ = ecx

; 322  : 		NDword i = m_Count;
; 323  : 		if ((m_Count+=inCount)>m_Limit)

	mov	eax, DWORD PTR _inCount$[esp-4]
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	add	eax, edi
	cmp	eax, ecx
	mov	DWORD PTR [esi+4], eax
	jbe	SHORT $L49438

; 324  : 		{
; 325  : 			m_Limit = m_Count + (m_Count>>2) + 32;

	mov	ecx, eax

; 326  : 			Realloc(sizeof(T));

	mov	DWORD PTR [esi+12], 4
	shr	ecx, 2
	lea	eax, DWORD PTR [ecx+eax+32]
	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	mov	DWORD PTR [esi+8], eax
	je	SHORT $L49430
	test	eax, eax
	je	SHORT $L49432
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [esi+8]
	push	ecx
	mov	ecx, DWORD PTR [esi]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+4]
	mov	DWORD PTR [esi], eax

; 327  : 		}
; 328  : 		return(i);

	mov	eax, edi
	pop	edi
	pop	esi

; 329  : 	}

	ret	4

; 326  : 			Realloc(sizeof(T));

$L49432:
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L49436:
	mov	DWORD PTR [esi], 0
$L49438:

; 327  : 		}
; 328  : 		return(i);

	mov	eax, edi
	pop	edi
	pop	esi

; 329  : 	}

	ret	4

; 326  : 			Realloc(sizeof(T));

$L49430:
	test	eax, eax
	je	SHORT $L49436
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [esi+8]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	DWORD PTR [esi], eax

; 327  : 		}
; 328  : 		return(i);

	mov	eax, edi
	pop	edi
	pop	esi

; 329  : 	}

	ret	4
?AddNoConstruct@?$TCorArray@VCCorString@@@@QAEKK@Z ENDP	; TCorArray<CCorString>::AddNoConstruct
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?Add@?$TCorArray@VCCorString@@@@QAEKK@Z
_TEXT	SEGMENT
_inCount$ = 8
?Add@?$TCorArray@VCCorString@@@@QAEKK@Z PROC NEAR	; TCorArray<CCorString>::Add, COMDAT
; _this$ = ecx

; 332  : 		NDword index = AddNoConstruct(inCount);

	mov	eax, DWORD PTR _inCount$[esp-4]
	push	ebx
	push	esi
	mov	esi, ecx
	push	edi
	mov	ebx, DWORD PTR [esi+4]
	lea	edi, DWORD PTR [ebx+eax]
	mov	eax, DWORD PTR [esi+8]
	cmp	edi, eax
	mov	DWORD PTR [esi+4], edi
	jbe	SHORT $L49470
	mov	ecx, edi
	mov	DWORD PTR [esi+12], 4
	shr	ecx, 2
	lea	eax, DWORD PTR [ecx+edi+32]
	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	mov	DWORD PTR [esi+8], eax
	je	SHORT $L49463
	test	eax, eax
	je	SHORT $L49465
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [esi+8]
	push	ecx
	mov	ecx, DWORD PTR [esi]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+4]
	mov	DWORD PTR [esi], eax
	jmp	SHORT $L49470
$L49465:
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L49469:
	mov	DWORD PTR [esi], 0
$L49470:

; 333  : 		for (NDword i=index; i<index+inCount; i++)

	cmp	ebx, edi
	mov	ecx, ebx
	jae	SHORT $L49485
$L15002:
	mov	edx, DWORD PTR [esi]
	lea	eax, DWORD PTR [edx+ecx*4]

; 334  : 			new(&(*this)[i]) T;

	test	eax, eax
	je	SHORT $L49445
	mov	DWORD PTR [eax], 0
$L49445:

; 333  : 		for (NDword i=index; i<index+inCount; i++)

	inc	ecx
	cmp	ecx, edi
	jb	SHORT $L15002
$L49485:
	pop	edi

; 335  : 		return(index);

	mov	eax, ebx
	pop	esi
	pop	ebx

; 336  : 	}

	ret	4
$L49463:

; 332  : 		NDword index = AddNoConstruct(inCount);

	test	eax, eax
	je	SHORT $L49469
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [esi+8]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	DWORD PTR [esi], eax
	jmp	SHORT $L49470
?Add@?$TCorArray@VCCorString@@@@QAEKK@Z ENDP		; TCorArray<CCorString>::Add
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?Remove@?$TCorArray@VCCorString@@@@QAEXKK@Z
_TEXT	SEGMENT
_inIndex$ = 8
_inCount$ = 12
?Remove@?$TCorArray@VCCorString@@@@QAEXKK@Z PROC NEAR	; TCorArray<CCorString>::Remove, COMDAT
; _this$ = ecx

; 374  : 	{

	push	ecx

; 375  : 		for (NDword i=inIndex; i<(inIndex+inCount); i++)

	mov	edx, DWORD PTR _inIndex$[esp]
	mov	eax, DWORD PTR _inCount$[esp]
	add	eax, edx
	push	ebx
	push	ebp
	cmp	edx, eax
	push	esi
	mov	ebp, ecx
	mov	ebx, edx
	mov	DWORD PTR -4+[esp+16], eax
	jae	SHORT $L15016
	push	edi
$L15014:
	mov	ecx, DWORD PTR [ebp]

; 376  : 			(&(*this)[i])->~T();

	mov	edi, DWORD PTR [ecx+ebx*4]
	lea	esi, DWORD PTR [ecx+ebx*4]
	test	edi, edi
	je	SHORT $L49520
	or	ecx, -1
	xor	eax, eax
	repne scasb
	mov	eax, DWORD PTR ?sMemTotal@CCorString@@0KA ; CCorString::sMemTotal
	or	edx, -1
	not	ecx
	dec	ecx
	sub	edx, ecx
	add	eax, edx
	mov	DWORD PTR ?sMemTotal@CCorString@@0KA, eax ; CCorString::sMemTotal
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
	mov	edx, DWORD PTR _inIndex$[esp+16]
	mov	eax, DWORD PTR -4+[esp+20]
$L49520:
	inc	ebx
	mov	DWORD PTR [esi], 0
	cmp	ebx, eax
	jb	SHORT $L15014
	pop	edi
$L15016:

; 377  : 		CCorArray::Remove(inIndex, inCount, sizeof(T));

	mov	ecx, DWORD PTR _inCount$[esp+12]
	test	ecx, ecx
	je	SHORT $L49531
	mov	esi, DWORD PTR [ebp+4]
	mov	ecx, DWORD PTR [ebp]
	sub	esi, eax
	shl	esi, 2
	lea	eax, DWORD PTR [ecx+eax*4]
	push	esi
	lea	ecx, DWORD PTR [ecx+edx*4]
	push	eax
	push	ecx
	call	DWORD PTR __imp__memmove
	mov	edx, DWORD PTR _inCount$[esp+24]
	mov	eax, DWORD PTR [ebp+4]
	add	esp, 12					; 0000000cH
	sub	eax, edx
	mov	DWORD PTR [ebp+4], eax
$L49531:
	pop	esi
	pop	ebp
	pop	ebx

; 378  : 	}

	pop	ecx
	ret	8
?Remove@?$TCorArray@VCCorString@@@@QAEXKK@Z ENDP	; TCorArray<CCorString>::Remove
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?AddNoConstruct@?$TCorArray@VCCpjMacSection@@@@QAEKK@Z
_TEXT	SEGMENT
_inCount$ = 8
?AddNoConstruct@?$TCorArray@VCCpjMacSection@@@@QAEKK@Z PROC NEAR ; TCorArray<CCpjMacSection>::AddNoConstruct, COMDAT
; _this$ = ecx

; 322  : 		NDword i = m_Count;
; 323  : 		if ((m_Count+=inCount)>m_Limit)

	mov	eax, DWORD PTR _inCount$[esp-4]
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	add	eax, edi
	cmp	eax, ecx
	mov	DWORD PTR [esi+4], eax
	jbe	SHORT $L49551

; 324  : 		{
; 325  : 			m_Limit = m_Count + (m_Count>>2) + 32;

	mov	ecx, eax

; 326  : 			Realloc(sizeof(T));

	mov	DWORD PTR [esi+12], 20			; 00000014H
	shr	ecx, 2
	lea	eax, DWORD PTR [ecx+eax+32]
	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	mov	DWORD PTR [esi+8], eax
	je	SHORT $L49543
	test	eax, eax
	je	SHORT $L49545
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [esi+8]
	push	ecx
	mov	ecx, DWORD PTR [esi]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+4]
	mov	DWORD PTR [esi], eax

; 327  : 		}
; 328  : 		return(i);

	mov	eax, edi
	pop	edi
	pop	esi

; 329  : 	}

	ret	4

; 326  : 			Realloc(sizeof(T));

$L49545:
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L49549:
	mov	DWORD PTR [esi], 0
$L49551:

; 327  : 		}
; 328  : 		return(i);

	mov	eax, edi
	pop	edi
	pop	esi

; 329  : 	}

	ret	4

; 326  : 			Realloc(sizeof(T));

$L49543:
	test	eax, eax
	je	SHORT $L49549
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [esi+8]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	DWORD PTR [esi], eax

; 327  : 		}
; 328  : 		return(i);

	mov	eax, edi
	pop	edi
	pop	esi

; 329  : 	}

	ret	4
?AddNoConstruct@?$TCorArray@VCCpjMacSection@@@@QAEKK@Z ENDP ; TCorArray<CCpjMacSection>::AddNoConstruct
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?AddNoConstruct@?$TCorArray@PAVOCpjSurface@@@@QAEKK@Z
_TEXT	SEGMENT
_inCount$ = 8
?AddNoConstruct@?$TCorArray@PAVOCpjSurface@@@@QAEKK@Z PROC NEAR ; TCorArray<OCpjSurface *>::AddNoConstruct, COMDAT
; _this$ = ecx

; 322  : 		NDword i = m_Count;
; 323  : 		if ((m_Count+=inCount)>m_Limit)

	mov	eax, DWORD PTR _inCount$[esp-4]
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	add	eax, edi
	cmp	eax, ecx
	mov	DWORD PTR [esi+4], eax
	jbe	SHORT $L49566

; 324  : 		{
; 325  : 			m_Limit = m_Count + (m_Count>>2) + 32;

	mov	ecx, eax

; 326  : 			Realloc(sizeof(T));

	mov	DWORD PTR [esi+12], 4
	shr	ecx, 2
	lea	eax, DWORD PTR [ecx+eax+32]
	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	mov	DWORD PTR [esi+8], eax
	je	SHORT $L49558
	test	eax, eax
	je	SHORT $L49560
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [esi+8]
	push	ecx
	mov	ecx, DWORD PTR [esi]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+4]
	mov	DWORD PTR [esi], eax

; 327  : 		}
; 328  : 		return(i);

	mov	eax, edi
	pop	edi
	pop	esi

; 329  : 	}

	ret	4

; 326  : 			Realloc(sizeof(T));

$L49560:
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L49564:
	mov	DWORD PTR [esi], 0
$L49566:

; 327  : 		}
; 328  : 		return(i);

	mov	eax, edi
	pop	edi
	pop	esi

; 329  : 	}

	ret	4

; 326  : 			Realloc(sizeof(T));

$L49558:
	test	eax, eax
	je	SHORT $L49564
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [esi+8]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	DWORD PTR [esi], eax

; 327  : 		}
; 328  : 		return(i);

	mov	eax, edi
	pop	edi
	pop	esi

; 329  : 	}

	ret	4
?AddNoConstruct@?$TCorArray@PAVOCpjSurface@@@@QAEKK@Z ENDP ; TCorArray<OCpjSurface *>::AddNoConstruct
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?Remove@?$TCorArray@PAVOCpjSurface@@@@QAEXKK@Z
_TEXT	SEGMENT
_inIndex$ = 8
_inCount$ = 12
?Remove@?$TCorArray@PAVOCpjSurface@@@@QAEXKK@Z PROC NEAR ; TCorArray<OCpjSurface *>::Remove, COMDAT
; _this$ = ecx

; 375  : 		for (NDword i=inIndex; i<(inIndex+inCount); i++)

	mov	edx, DWORD PTR _inIndex$[esp-4]
	push	esi
	push	edi
	mov	edi, DWORD PTR _inCount$[esp+4]
	mov	esi, ecx

; 376  : 			(&(*this)[i])->~T();
; 377  : 		CCorArray::Remove(inIndex, inCount, sizeof(T));

	test	edi, edi
	lea	ecx, DWORD PTR [edx+edi]
	je	SHORT $L49572
	mov	eax, DWORD PTR [esi]
	push	ebx
	mov	ebx, DWORD PTR [esi+4]
	sub	ebx, ecx
	lea	ecx, DWORD PTR [eax+ecx*4]
	shl	ebx, 2
	push	ebx
	lea	edx, DWORD PTR [eax+edx*4]
	push	ecx
	push	edx
	call	DWORD PTR __imp__memmove
	mov	eax, DWORD PTR [esi+4]
	add	esp, 12					; 0000000cH
	sub	eax, edi
	mov	DWORD PTR [esi+4], eax
	pop	ebx
$L49572:
	pop	edi
	pop	esi

; 378  : 	}

	ret	8
?Remove@?$TCorArray@PAVOCpjSurface@@@@QAEXKK@Z ENDP	; TCorArray<OCpjSurface *>::Remove
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?Add@?$TCorArray@PAVOCpjFrames@@@@QAEKK@Z
_TEXT	SEGMENT
_inCount$ = 8
?Add@?$TCorArray@PAVOCpjFrames@@@@QAEKK@Z PROC NEAR	; TCorArray<OCpjFrames *>::Add, COMDAT
; _this$ = ecx

; 332  : 		NDword index = AddNoConstruct(inCount);

	mov	eax, DWORD PTR _inCount$[esp-4]
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	add	eax, edi
	cmp	eax, ecx
	mov	DWORD PTR [esi+4], eax
	jbe	SHORT $L49614
	mov	ecx, eax
	mov	DWORD PTR [esi+12], 4
	shr	ecx, 2
	lea	eax, DWORD PTR [ecx+eax+32]
	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	mov	DWORD PTR [esi+8], eax
	je	SHORT $L49597
	test	eax, eax
	je	SHORT $L49600
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [esi+8]
	push	ecx
	mov	ecx, DWORD PTR [esi]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+4]
	mov	DWORD PTR [esi], eax

; 333  : 		for (NDword i=index; i<index+inCount; i++)
; 334  : 			new(&(*this)[i]) T;
; 335  : 		return(index);

	mov	eax, edi
	pop	edi
	pop	esi

; 336  : 	}

	ret	4

; 332  : 		NDword index = AddNoConstruct(inCount);

$L49600:
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L49604:
	mov	DWORD PTR [esi], 0
$L49614:

; 333  : 		for (NDword i=index; i<index+inCount; i++)
; 334  : 			new(&(*this)[i]) T;
; 335  : 		return(index);

	mov	eax, edi
	pop	edi
	pop	esi

; 336  : 	}

	ret	4

; 332  : 		NDword index = AddNoConstruct(inCount);

$L49597:
	test	eax, eax
	je	SHORT $L49604
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [esi+8]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	DWORD PTR [esi], eax

; 333  : 		for (NDword i=index; i<index+inCount; i++)
; 334  : 			new(&(*this)[i]) T;
; 335  : 		return(index);

	mov	eax, edi
	pop	edi
	pop	esi

; 336  : 	}

	ret	4
?Add@?$TCorArray@PAVOCpjFrames@@@@QAEKK@Z ENDP		; TCorArray<OCpjFrames *>::Add
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?Remove@?$TCorArray@PAVOCpjFrames@@@@QAEXKK@Z
_TEXT	SEGMENT
_inIndex$ = 8
_inCount$ = 12
?Remove@?$TCorArray@PAVOCpjFrames@@@@QAEXKK@Z PROC NEAR	; TCorArray<OCpjFrames *>::Remove, COMDAT
; _this$ = ecx

; 375  : 		for (NDword i=inIndex; i<(inIndex+inCount); i++)

	mov	edx, DWORD PTR _inIndex$[esp-4]
	push	esi
	push	edi
	mov	edi, DWORD PTR _inCount$[esp+4]
	mov	esi, ecx

; 376  : 			(&(*this)[i])->~T();
; 377  : 		CCorArray::Remove(inIndex, inCount, sizeof(T));

	test	edi, edi
	lea	ecx, DWORD PTR [edx+edi]
	je	SHORT $L49620
	mov	eax, DWORD PTR [esi]
	push	ebx
	mov	ebx, DWORD PTR [esi+4]
	sub	ebx, ecx
	lea	ecx, DWORD PTR [eax+ecx*4]
	shl	ebx, 2
	push	ebx
	lea	edx, DWORD PTR [eax+edx*4]
	push	ecx
	push	edx
	call	DWORD PTR __imp__memmove
	mov	eax, DWORD PTR [esi+4]
	add	esp, 12					; 0000000cH
	sub	eax, edi
	mov	DWORD PTR [esi+4], eax
	pop	ebx
$L49620:
	pop	edi
	pop	esi

; 378  : 	}

	ret	8
?Remove@?$TCorArray@PAVOCpjFrames@@@@QAEXKK@Z ENDP	; TCorArray<OCpjFrames *>::Remove
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?Add@?$TCorArray@PAVOCpjSequence@@@@QAEKK@Z
_TEXT	SEGMENT
_inCount$ = 8
?Add@?$TCorArray@PAVOCpjSequence@@@@QAEKK@Z PROC NEAR	; TCorArray<OCpjSequence *>::Add, COMDAT
; _this$ = ecx

; 332  : 		NDword index = AddNoConstruct(inCount);

	mov	eax, DWORD PTR _inCount$[esp-4]
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	add	eax, edi
	cmp	eax, ecx
	mov	DWORD PTR [esi+4], eax
	jbe	SHORT $L49662
	mov	ecx, eax
	mov	DWORD PTR [esi+12], 4
	shr	ecx, 2
	lea	eax, DWORD PTR [ecx+eax+32]
	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	mov	DWORD PTR [esi+8], eax
	je	SHORT $L49646
	test	eax, eax
	je	SHORT $L49648
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [esi+8]
	push	ecx
	mov	ecx, DWORD PTR [esi]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+4]
	mov	DWORD PTR [esi], eax

; 333  : 		for (NDword i=index; i<index+inCount; i++)
; 334  : 			new(&(*this)[i]) T;
; 335  : 		return(index);

	mov	eax, edi
	pop	edi
	pop	esi

; 336  : 	}

	ret	4

; 332  : 		NDword index = AddNoConstruct(inCount);

$L49648:
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L49652:
	mov	DWORD PTR [esi], 0
$L49662:

; 333  : 		for (NDword i=index; i<index+inCount; i++)
; 334  : 			new(&(*this)[i]) T;
; 335  : 		return(index);

	mov	eax, edi
	pop	edi
	pop	esi

; 336  : 	}

	ret	4

; 332  : 		NDword index = AddNoConstruct(inCount);

$L49646:
	test	eax, eax
	je	SHORT $L49652
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [esi+8]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	DWORD PTR [esi], eax

; 333  : 		for (NDword i=index; i<index+inCount; i++)
; 334  : 			new(&(*this)[i]) T;
; 335  : 		return(index);

	mov	eax, edi
	pop	edi
	pop	esi

; 336  : 	}

	ret	4
?Add@?$TCorArray@PAVOCpjSequence@@@@QAEKK@Z ENDP	; TCorArray<OCpjSequence *>::Add
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?Remove@?$TCorArray@PAVOCpjSequence@@@@QAEXKK@Z
_TEXT	SEGMENT
_inIndex$ = 8
_inCount$ = 12
?Remove@?$TCorArray@PAVOCpjSequence@@@@QAEXKK@Z PROC NEAR ; TCorArray<OCpjSequence *>::Remove, COMDAT
; _this$ = ecx

; 375  : 		for (NDword i=inIndex; i<(inIndex+inCount); i++)

	mov	edx, DWORD PTR _inIndex$[esp-4]
	push	esi
	push	edi
	mov	edi, DWORD PTR _inCount$[esp+4]
	mov	esi, ecx

; 376  : 			(&(*this)[i])->~T();
; 377  : 		CCorArray::Remove(inIndex, inCount, sizeof(T));

	test	edi, edi
	lea	ecx, DWORD PTR [edx+edi]
	je	SHORT $L49668
	mov	eax, DWORD PTR [esi]
	push	ebx
	mov	ebx, DWORD PTR [esi+4]
	sub	ebx, ecx
	lea	ecx, DWORD PTR [eax+ecx*4]
	shl	ebx, 2
	push	ebx
	lea	edx, DWORD PTR [eax+edx*4]
	push	ecx
	push	edx
	call	DWORD PTR __imp__memmove
	mov	eax, DWORD PTR [esi+4]
	add	esp, 12					; 0000000cH
	sub	eax, edi
	mov	DWORD PTR [esi+4], eax
	pop	ebx
$L49668:
	pop	edi
	pop	esi

; 378  : 	}

	ret	8
?Remove@?$TCorArray@PAVOCpjSequence@@@@QAEXKK@Z ENDP	; TCorArray<OCpjSequence *>::Remove
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?Remove@?$TCorArray@VCMacBone@@@@QAEXKK@Z
_TEXT	SEGMENT
_inIndex$ = 8
_inCount$ = 12
?Remove@?$TCorArray@VCMacBone@@@@QAEXKK@Z PROC NEAR	; TCorArray<CMacBone>::Remove, COMDAT
; _this$ = ecx

; 374  : 	{

	push	ebx

; 375  : 		for (NDword i=inIndex; i<(inIndex+inCount); i++)

	mov	ebx, DWORD PTR _inIndex$[esp]
	push	ebp
	mov	ebp, DWORD PTR _inCount$[esp+4]
	push	esi
	mov	esi, ecx

; 376  : 			(&(*this)[i])->~T();
; 377  : 		CCorArray::Remove(inIndex, inCount, sizeof(T));

	test	ebp, ebp
	lea	ecx, DWORD PTR [ebx+ebp]
	je	SHORT $L49677
	push	edi
	mov	edi, DWORD PTR [esi+4]
	lea	eax, DWORD PTR [ecx*8]
	mov	edx, DWORD PTR [esi]
	sub	eax, ecx
	lea	ecx, DWORD PTR [edi*8]
	sub	ecx, edi
	lea	eax, DWORD PTR [eax+eax*4]
	lea	ecx, DWORD PTR [ecx+ecx*4]
	shl	eax, 2
	shl	ecx, 2
	sub	ecx, eax
	add	eax, edx
	push	ecx
	push	eax
	lea	eax, DWORD PTR [ebx*8]
	sub	eax, ebx
	lea	ecx, DWORD PTR [eax+eax*4]
	lea	edx, DWORD PTR [edx+ecx*4]
	push	edx
	call	DWORD PTR __imp__memmove
	mov	eax, DWORD PTR [esi+4]
	add	esp, 12					; 0000000cH
	sub	eax, ebp
	mov	DWORD PTR [esi+4], eax
	pop	edi
$L49677:
	pop	esi
	pop	ebp
	pop	ebx

; 378  : 	}

	ret	8
?Remove@?$TCorArray@VCMacBone@@@@QAEXKK@Z ENDP		; TCorArray<CMacBone>::Remove
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?AddNoConstruct@?$TCorArray@PAVOMacChannel@@@@QAEKK@Z
_TEXT	SEGMENT
_inCount$ = 8
?AddNoConstruct@?$TCorArray@PAVOMacChannel@@@@QAEKK@Z PROC NEAR ; TCorArray<OMacChannel *>::AddNoConstruct, COMDAT
; _this$ = ecx

; 322  : 		NDword i = m_Count;
; 323  : 		if ((m_Count+=inCount)>m_Limit)

	mov	eax, DWORD PTR _inCount$[esp-4]
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	add	eax, edi
	cmp	eax, ecx
	mov	DWORD PTR [esi+4], eax
	jbe	SHORT $L49695

; 324  : 		{
; 325  : 			m_Limit = m_Count + (m_Count>>2) + 32;

	mov	ecx, eax

; 326  : 			Realloc(sizeof(T));

	mov	DWORD PTR [esi+12], 4
	shr	ecx, 2
	lea	eax, DWORD PTR [ecx+eax+32]
	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	mov	DWORD PTR [esi+8], eax
	je	SHORT $L49686
	test	eax, eax
	je	SHORT $L49688
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [esi+8]
	push	ecx
	mov	ecx, DWORD PTR [esi]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+4]
	mov	DWORD PTR [esi], eax

; 327  : 		}
; 328  : 		return(i);

	mov	eax, edi
	pop	edi
	pop	esi

; 329  : 	}

	ret	4

; 326  : 			Realloc(sizeof(T));

$L49688:
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L49692:
	mov	DWORD PTR [esi], 0
$L49695:

; 327  : 		}
; 328  : 		return(i);

	mov	eax, edi
	pop	edi
	pop	esi

; 329  : 	}

	ret	4

; 326  : 			Realloc(sizeof(T));

$L49686:
	test	eax, eax
	je	SHORT $L49692
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [esi+8]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	DWORD PTR [esi], eax

; 327  : 		}
; 328  : 		return(i);

	mov	eax, edi
	pop	edi
	pop	esi

; 329  : 	}

	ret	4
?AddNoConstruct@?$TCorArray@PAVOMacChannel@@@@QAEKK@Z ENDP ; TCorArray<OMacChannel *>::AddNoConstruct
_TEXT	ENDS
PUBLIC	??0CMacBone@@QAE@XZ				; CMacBone::CMacBone
; Function compile flags: /Ogty
; File C:\duke4\Cannibal\MacMain.h
;	COMDAT ??0CMacBone@@QAE@XZ
_TEXT	SEGMENT
??0CMacBone@@QAE@XZ PROC NEAR				; CMacBone::CMacBone, COMDAT
; _this$ = ecx

; 45   : 	CMacBone() { mSklBone = NULL; mParent = mFirstChild = mNextSibling = NULL; mAbsValid = 0; }

	mov	eax, ecx
	mov	edx, 1065353216				; 3f800000H
	xor	ecx, ecx
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx
	mov	DWORD PTR [eax+16], edx
	mov	DWORD PTR [eax+20], ecx
	mov	DWORD PTR [eax+24], ecx
	mov	DWORD PTR [eax+28], ecx
	mov	DWORD PTR [eax+32], edx
	mov	DWORD PTR [eax+36], ecx
	mov	DWORD PTR [eax+40], ecx
	mov	DWORD PTR [eax+44], ecx
	mov	DWORD PTR [eax+48], edx
	mov	DWORD PTR [eax+52], edx
	mov	DWORD PTR [eax+56], edx
	mov	DWORD PTR [eax+60], edx
	mov	DWORD PTR [eax+64], ecx
	mov	DWORD PTR [eax+68], ecx
	mov	DWORD PTR [eax+72], ecx
	mov	DWORD PTR [eax+76], edx
	mov	DWORD PTR [eax+80], ecx
	mov	DWORD PTR [eax+84], ecx
	mov	DWORD PTR [eax+88], ecx
	mov	DWORD PTR [eax+92], edx
	mov	DWORD PTR [eax+96], ecx
	mov	DWORD PTR [eax+100], ecx
	mov	DWORD PTR [eax+104], ecx
	mov	DWORD PTR [eax+108], edx
	mov	DWORD PTR [eax+112], edx
	mov	DWORD PTR [eax+116], edx
	mov	DWORD PTR [eax+124], ecx
	mov	DWORD PTR [eax+136], ecx
	mov	DWORD PTR [eax+132], ecx
	mov	DWORD PTR [eax+128], ecx
	mov	BYTE PTR [eax+120], cl
	ret	0
??0CMacBone@@QAE@XZ ENDP				; CMacBone::CMacBone
; Function compile flags: /Ogty
; File C:\duke4\Cannibal\CorMain.h
_TEXT	ENDS
;	COMDAT ?Remove@?$TCorArray@PAVOMacChannel@@@@QAEXKK@Z
_TEXT	SEGMENT
_inIndex$ = 8
_inCount$ = 12
?Remove@?$TCorArray@PAVOMacChannel@@@@QAEXKK@Z PROC NEAR ; TCorArray<OMacChannel *>::Remove, COMDAT
; _this$ = ecx

; 375  : 		for (NDword i=inIndex; i<(inIndex+inCount); i++)

	mov	edx, DWORD PTR _inIndex$[esp-4]
	push	esi
	push	edi
	mov	edi, DWORD PTR _inCount$[esp+4]
	mov	esi, ecx

; 376  : 			(&(*this)[i])->~T();
; 377  : 		CCorArray::Remove(inIndex, inCount, sizeof(T));

	test	edi, edi
	lea	ecx, DWORD PTR [edx+edi]
	je	SHORT $L49791
	mov	eax, DWORD PTR [esi]
	push	ebx
	mov	ebx, DWORD PTR [esi+4]
	sub	ebx, ecx
	lea	ecx, DWORD PTR [eax+ecx*4]
	shl	ebx, 2
	push	ebx
	lea	edx, DWORD PTR [eax+edx*4]
	push	ecx
	push	edx
	call	DWORD PTR __imp__memmove
	mov	eax, DWORD PTR [esi+4]
	add	esp, 12					; 0000000cH
	sub	eax, edi
	mov	DWORD PTR [esi+4], eax
	pop	ebx
$L49791:
	pop	edi
	pop	esi

; 378  : 	}

	ret	8
?Remove@?$TCorArray@PAVOMacChannel@@@@QAEXKK@Z ENDP	; TCorArray<OMacChannel *>::Remove
_TEXT	ENDS
PUBLIC	??0CMacBone@@QAE@ABV0@@Z			; CMacBone::CMacBone
; Function compile flags: /Ogty
;	COMDAT ??0CMacBone@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8
??0CMacBone@@QAE@ABV0@@Z PROC NEAR			; CMacBone::CMacBone, COMDAT
; _this$ = ecx
	mov	eax, ecx
	mov	ecx, DWORD PTR ___that$[esp-4]
	push	esi
	mov	esi, 1065353216				; 3f800000H
	xor	edx, edx
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax+8], edx
	mov	DWORD PTR [eax+12], edx
	mov	DWORD PTR [eax+16], esi
	mov	DWORD PTR [eax+20], edx
	mov	DWORD PTR [eax+24], edx
	mov	DWORD PTR [eax+28], edx
	mov	DWORD PTR [eax+32], esi
	push	edi
	mov	edi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edi
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edi
	mov	edi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edi
	mov	edi, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edi
	mov	edi, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edi
	mov	edi, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+20], edi
	mov	edi, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax+24], edi
	mov	edi, DWORD PTR [ecx+28]
	mov	DWORD PTR [eax+28], edi
	mov	edi, DWORD PTR [ecx+32]
	mov	DWORD PTR [eax+32], edi
	mov	edi, DWORD PTR [ecx+36]
	mov	DWORD PTR [eax+36], edi
	mov	edi, DWORD PTR [ecx+40]
	mov	DWORD PTR [eax+40], edi
	mov	edi, DWORD PTR [ecx+44]
	mov	DWORD PTR [eax+44], edi
	mov	edi, DWORD PTR [ecx+48]
	mov	DWORD PTR [eax+48], edi
	mov	edi, DWORD PTR [ecx+52]
	mov	DWORD PTR [eax+52], edi
	mov	edi, DWORD PTR [ecx+56]
	mov	DWORD PTR [eax+56], edi
	mov	DWORD PTR [eax+60], esi
	mov	DWORD PTR [eax+64], edx
	mov	DWORD PTR [eax+68], edx
	mov	DWORD PTR [eax+72], edx
	mov	DWORD PTR [eax+76], esi
	mov	DWORD PTR [eax+80], edx
	mov	DWORD PTR [eax+84], edx
	mov	DWORD PTR [eax+88], edx
	mov	DWORD PTR [eax+92], esi
	mov	edx, DWORD PTR [ecx+60]
	mov	DWORD PTR [eax+60], edx
	mov	edx, DWORD PTR [ecx+64]
	mov	DWORD PTR [eax+64], edx
	mov	edx, DWORD PTR [ecx+68]
	mov	DWORD PTR [eax+68], edx
	mov	edx, DWORD PTR [ecx+72]
	mov	DWORD PTR [eax+72], edx
	mov	edx, DWORD PTR [ecx+76]
	mov	DWORD PTR [eax+76], edx
	mov	edx, DWORD PTR [ecx+80]
	mov	DWORD PTR [eax+80], edx
	mov	edx, DWORD PTR [ecx+84]
	mov	DWORD PTR [eax+84], edx
	mov	edx, DWORD PTR [ecx+88]
	mov	DWORD PTR [eax+88], edx
	mov	edx, DWORD PTR [ecx+92]
	mov	DWORD PTR [eax+92], edx
	mov	edx, DWORD PTR [ecx+96]
	mov	DWORD PTR [eax+96], edx
	mov	edx, DWORD PTR [ecx+100]
	mov	DWORD PTR [eax+100], edx
	mov	edx, DWORD PTR [ecx+104]
	mov	DWORD PTR [eax+104], edx
	mov	edx, DWORD PTR [ecx+108]
	mov	DWORD PTR [eax+108], edx
	mov	edx, DWORD PTR [ecx+112]
	mov	DWORD PTR [eax+112], edx
	mov	edx, DWORD PTR [ecx+116]
	mov	DWORD PTR [eax+116], edx
	mov	dl, BYTE PTR [ecx+120]
	mov	BYTE PTR [eax+120], dl
	mov	edx, DWORD PTR [ecx+124]
	mov	DWORD PTR [eax+124], edx
	mov	edx, DWORD PTR [ecx+128]
	mov	DWORD PTR [eax+128], edx
	mov	edx, DWORD PTR [ecx+132]
	mov	DWORD PTR [eax+132], edx
	mov	ecx, DWORD PTR [ecx+136]
	pop	edi
	mov	DWORD PTR [eax+136], ecx
	pop	esi
	ret	4
??0CMacBone@@QAE@ABV0@@Z ENDP				; CMacBone::CMacBone
_TEXT	ENDS
PUBLIC	??4CMacBone@@QAEAAV0@ABV0@@Z			; CMacBone::operator=
; Function compile flags: /Ogty
;	COMDAT ??4CMacBone@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8
??4CMacBone@@QAEAAV0@ABV0@@Z PROC NEAR			; CMacBone::operator=, COMDAT
; _this$ = ecx
	mov	eax, ecx
	mov	ecx, DWORD PTR ___that$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+20], edx
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax+24], edx
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR [eax+28], edx
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR [eax+32], edx
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [eax+36], edx
	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR [eax+40], edx
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR [eax+44], edx
	mov	edx, DWORD PTR [ecx+48]
	mov	DWORD PTR [eax+48], edx
	mov	edx, DWORD PTR [ecx+52]
	mov	DWORD PTR [eax+52], edx
	mov	edx, DWORD PTR [ecx+56]
	mov	DWORD PTR [eax+56], edx
	mov	edx, DWORD PTR [ecx+60]
	mov	DWORD PTR [eax+60], edx
	mov	edx, DWORD PTR [ecx+64]
	mov	DWORD PTR [eax+64], edx
	mov	edx, DWORD PTR [ecx+68]
	mov	DWORD PTR [eax+68], edx
	mov	edx, DWORD PTR [ecx+72]
	mov	DWORD PTR [eax+72], edx
	mov	edx, DWORD PTR [ecx+76]
	mov	DWORD PTR [eax+76], edx
	mov	edx, DWORD PTR [ecx+80]
	mov	DWORD PTR [eax+80], edx
	mov	edx, DWORD PTR [ecx+84]
	mov	DWORD PTR [eax+84], edx
	mov	edx, DWORD PTR [ecx+88]
	mov	DWORD PTR [eax+88], edx
	mov	edx, DWORD PTR [ecx+92]
	mov	DWORD PTR [eax+92], edx
	mov	edx, DWORD PTR [ecx+96]
	mov	DWORD PTR [eax+96], edx
	mov	edx, DWORD PTR [ecx+100]
	mov	DWORD PTR [eax+100], edx
	mov	edx, DWORD PTR [ecx+104]
	mov	DWORD PTR [eax+104], edx
	mov	edx, DWORD PTR [ecx+108]
	mov	DWORD PTR [eax+108], edx
	mov	edx, DWORD PTR [ecx+112]
	mov	DWORD PTR [eax+112], edx
	mov	edx, DWORD PTR [ecx+116]
	mov	DWORD PTR [eax+116], edx
	mov	dl, BYTE PTR [ecx+120]
	mov	BYTE PTR [eax+120], dl
	mov	edx, DWORD PTR [ecx+124]
	mov	DWORD PTR [eax+124], edx
	mov	edx, DWORD PTR [ecx+128]
	mov	DWORD PTR [eax+128], edx
	mov	edx, DWORD PTR [ecx+132]
	mov	DWORD PTR [eax+132], edx
	mov	ecx, DWORD PTR [ecx+136]
	mov	DWORD PTR [eax+136], ecx
	ret	4
??4CMacBone@@QAEAAV0@ABV0@@Z ENDP			; CMacBone::operator=
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?AddNoConstruct@?$TCorArray@VVBox3@@@@QAEKK@Z
_TEXT	SEGMENT
_inCount$ = 8
?AddNoConstruct@?$TCorArray@VVBox3@@@@QAEKK@Z PROC NEAR	; TCorArray<VBox3>::AddNoConstruct, COMDAT
; _this$ = ecx

; 322  : 		NDword i = m_Count;
; 323  : 		if ((m_Count+=inCount)>m_Limit)

	mov	eax, DWORD PTR _inCount$[esp-4]
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	add	eax, edi
	cmp	eax, ecx
	mov	DWORD PTR [esi+4], eax
	jbe	SHORT $L50083

; 324  : 		{
; 325  : 			m_Limit = m_Count + (m_Count>>2) + 32;

	mov	ecx, eax

; 326  : 			Realloc(sizeof(T));

	mov	DWORD PTR [esi+12], 60			; 0000003cH
	shr	ecx, 2
	lea	eax, DWORD PTR [ecx+eax+32]
	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	mov	DWORD PTR [esi+8], eax
	je	SHORT $L50075
	test	eax, eax
	je	SHORT $L50077
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [esi+8]
	push	ecx
	mov	ecx, DWORD PTR [esi]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+4]
	mov	DWORD PTR [esi], eax

; 327  : 		}
; 328  : 		return(i);

	mov	eax, edi
	pop	edi
	pop	esi

; 329  : 	}

	ret	4

; 326  : 			Realloc(sizeof(T));

$L50077:
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L50081:
	mov	DWORD PTR [esi], 0
$L50083:

; 327  : 		}
; 328  : 		return(i);

	mov	eax, edi
	pop	edi
	pop	esi

; 329  : 	}

	ret	4

; 326  : 			Realloc(sizeof(T));

$L50075:
	test	eax, eax
	je	SHORT $L50081
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [esi+8]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	DWORD PTR [esi], eax

; 327  : 		}
; 328  : 		return(i);

	mov	eax, edi
	pop	edi
	pop	esi

; 329  : 	}

	ret	4
?AddNoConstruct@?$TCorArray@VVBox3@@@@QAEKK@Z ENDP	; TCorArray<VBox3>::AddNoConstruct
_TEXT	ENDS
PUBLIC	?Unlink@CMacActorLink@@AAEXXZ			; CMacActorLink::Unlink
; Function compile flags: /Ogty
; File C:\duke4\Cannibal\MacMain.h
;	COMDAT ?Unlink@CMacActorLink@@AAEXXZ
_TEXT	SEGMENT
?Unlink@CMacActorLink@@AAEXXZ PROC NEAR			; CMacActorLink::Unlink, COMDAT
; _this$ = ecx

; 82   : 	void Unlink() { mNext->mPrev = mPrev; mPrev->mNext = mNext; mPrev = mNext = this; }

	mov	eax, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	DWORD PTR [ecx+8], ecx
	mov	DWORD PTR [ecx+4], ecx
	ret	0
?Unlink@CMacActorLink@@AAEXXZ ENDP			; CMacActorLink::Unlink
; Function compile flags: /Ogty
; File C:\duke4\Cannibal\ObjMain.h
_TEXT	ENDS
;	COMDAT ?AdvanceToType@?$TObjIter@VOCpjFrames@@@@IAEXXZ
_TEXT	SEGMENT
?AdvanceToType@?$TObjIter@VOCpjFrames@@@@IAEXXZ PROC NEAR ; TObjIter<OCpjFrames>::AdvanceToType, COMDAT
; _this$ = ecx

; 382  : 	{

	push	esi
	mov	esi, ecx
$L15120:

; 383  : 		while (GetObject() && (!GetObject()->IsA(T::GetStaticClass())))

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $L50144
	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $L50144
	mov	ecx, DWORD PTR ?staticObjClass@OCpjFrames@@0PAVCObjClass@@A ; OCpjFrames::staticObjClass
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+44]
	test	al, al
	jne	SHORT $L50144

; 384  : 			Advance();

	mov	cl, BYTE PTR [esi+8]
	mov	eax, DWORD PTR [esi+4]
	test	cl, cl
	mov	DWORD PTR [esi], eax
	je	SHORT $L50140
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [esi+4], edx
	jmp	SHORT $L15120
$L50140:
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [esi+4], eax
	jmp	SHORT $L15120
$L50144:
	pop	esi

; 385  : 	}

	ret	0
?AdvanceToType@?$TObjIter@VOCpjFrames@@@@IAEXXZ ENDP	; TObjIter<OCpjFrames>::AdvanceToType
_TEXT	ENDS
PUBLIC	?Link@CMacActorLink@@AAEXPAV1@@Z		; CMacActorLink::Link
; Function compile flags: /Ogty
; File C:\duke4\Cannibal\MacMain.h
;	COMDAT ?Link@CMacActorLink@@AAEXPAV1@@Z
_TEXT	SEGMENT
_inLink$ = 8
?Link@CMacActorLink@@AAEXPAV1@@Z PROC NEAR		; CMacActorLink::Link, COMDAT
; _this$ = ecx

; 83   : 	void Link(CMacActorLink* inLink) { mNext = inLink->mNext; mPrev = inLink; mNext->mPrev = mPrev->mNext = this; }

	mov	eax, DWORD PTR _inLink$[esp-4]
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+4], eax
	mov	DWORD PTR [ecx+8], edx
	mov	DWORD PTR [eax+8], ecx
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+4], ecx
	ret	4
?Link@CMacActorLink@@AAEXPAV1@@Z ENDP			; CMacActorLink::Link
_TEXT	ENDS
PUBLIC	??0CMacActorLink@@QAE@XZ			; CMacActorLink::CMacActorLink
; Function compile flags: /Ogty
;	COMDAT ??0CMacActorLink@@QAE@XZ
_TEXT	SEGMENT
??0CMacActorLink@@QAE@XZ PROC NEAR			; CMacActorLink::CMacActorLink, COMDAT
; _this$ = ecx

; 86   : 	CMacActorLink() { mPrev = mNext = this; Link(&sHeadLink); }

	mov	eax, ecx
	mov	DWORD PTR [eax+8], eax
	mov	DWORD PTR [eax+4], eax
	mov	ecx, DWORD PTR ?sHeadLink@CMacActorLink@@0V1@A+8
	mov	DWORD PTR [eax+4], OFFSET FLAT:?sHeadLink@CMacActorLink@@0V1@A ; CMacActorLink::sHeadLink
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR ?sHeadLink@CMacActorLink@@0V1@A+8, eax
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+4], eax
	ret	0
??0CMacActorLink@@QAE@XZ ENDP				; CMacActorLink::CMacActorLink
; Function compile flags: /Ogty
; File C:\duke4\Cannibal\ObjMain.h
_TEXT	ENDS
;	COMDAT ?Reset@?$TObjIter@VOCpjFrames@@@@QAEXPAVOObject@@_N@Z
_TEXT	SEGMENT
_inObj$ = 8
_inReverse$ = 12
?Reset@?$TObjIter@VOCpjFrames@@@@QAEXPAVOObject@@_N@Z PROC NEAR ; TObjIter<OCpjFrames>::Reset, COMDAT
; _this$ = ecx

; 389  : 		CObjIter::Reset(inObj, inReverse);

	mov	eax, DWORD PTR _inObj$[esp-4]
	push	esi
	mov	esi, ecx
	test	eax, eax
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi], 0
	je	SHORT $L50302
	mov	cl, BYTE PTR _inReverse$[esp]
	add	eax, 24					; 00000018H
	test	cl, cl
	mov	DWORD PTR [esi], eax
	mov	BYTE PTR [esi+8], cl
	je	SHORT $L50210
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [esi+4], eax
	jmp	SHORT $L50211
$L50210:
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [esi+4], edx
$L50211:
	mov	eax, DWORD PTR [esi+4]
	test	cl, cl
	mov	DWORD PTR [esi], eax
	je	SHORT $L50219
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [esi+4], eax
	jmp	SHORT $L50302
$L50219:
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [esi+4], ecx

; 390  : 		AdvanceToType();

$L50302:
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $L50306
	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $L50306
	mov	ecx, DWORD PTR ?staticObjClass@OCpjFrames@@0PAVCObjClass@@A ; OCpjFrames::staticObjClass
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+44]
	test	al, al
	jne	SHORT $L50306
	mov	cl, BYTE PTR [esi+8]
	mov	eax, DWORD PTR [esi+4]
	test	cl, cl
	mov	DWORD PTR [esi], eax
	je	SHORT $L50298
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [esi+4], edx
	jmp	SHORT $L50302
$L50298:
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [esi+4], eax
	jmp	SHORT $L50302
$L50306:
	pop	esi

; 391  : 	}

	ret	8
?Reset@?$TObjIter@VOCpjFrames@@@@QAEXPAVOObject@@_N@Z ENDP ; TObjIter<OCpjFrames>::Reset
_TEXT	ENDS
PUBLIC	??1CMacActorLink@@QAE@XZ			; CMacActorLink::~CMacActorLink
; Function compile flags: /Ogty
; File C:\duke4\Cannibal\MacMain.h
;	COMDAT ??1CMacActorLink@@QAE@XZ
_TEXT	SEGMENT
??1CMacActorLink@@QAE@XZ PROC NEAR			; CMacActorLink::~CMacActorLink, COMDAT
; _this$ = ecx

; 87   : 	~CMacActorLink() { Unlink(); }

	mov	eax, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	DWORD PTR [ecx+8], ecx
	mov	DWORD PTR [ecx+4], ecx
	ret	0
??1CMacActorLink@@QAE@XZ ENDP				; CMacActorLink::~CMacActorLink
; Function compile flags: /Ogty
; File C:\duke4\Cannibal\ObjMain.h
_TEXT	ENDS
;	COMDAT ?AdvanceToType@?$TObjIter@VOCpjSequence@@@@IAEXXZ
_TEXT	SEGMENT
?AdvanceToType@?$TObjIter@VOCpjSequence@@@@IAEXXZ PROC NEAR ; TObjIter<OCpjSequence>::AdvanceToType, COMDAT
; _this$ = ecx

; 382  : 	{

	push	esi
	mov	esi, ecx
$L15127:

; 383  : 		while (GetObject() && (!GetObject()->IsA(T::GetStaticClass())))

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $L50372
	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $L50372
	mov	ecx, DWORD PTR ?staticObjClass@OCpjSequence@@0PAVCObjClass@@A ; OCpjSequence::staticObjClass
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+44]
	test	al, al
	jne	SHORT $L50372

; 384  : 			Advance();

	mov	cl, BYTE PTR [esi+8]
	mov	eax, DWORD PTR [esi+4]
	test	cl, cl
	mov	DWORD PTR [esi], eax
	je	SHORT $L50368
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [esi+4], edx
	jmp	SHORT $L15127
$L50368:
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [esi+4], eax
	jmp	SHORT $L15127
$L50372:
	pop	esi

; 385  : 	}

	ret	0
?AdvanceToType@?$TObjIter@VOCpjSequence@@@@IAEXXZ ENDP	; TObjIter<OCpjSequence>::AdvanceToType
_TEXT	ENDS
PUBLIC	?GetFirst@CMacActorLink@@SAPAV1@XZ		; CMacActorLink::GetFirst
; Function compile flags: /Ogty
; File C:\duke4\Cannibal\MacMain.h
;	COMDAT ?GetFirst@CMacActorLink@@SAPAV1@XZ
_TEXT	SEGMENT
?GetFirst@CMacActorLink@@SAPAV1@XZ PROC NEAR		; CMacActorLink::GetFirst, COMDAT

; 89   : 	static CMacActorLink* GetFirst() { return(sHeadLink.mNext); }

	mov	eax, DWORD PTR ?sHeadLink@CMacActorLink@@0V1@A+8
	ret	0
?GetFirst@CMacActorLink@@SAPAV1@XZ ENDP			; CMacActorLink::GetFirst
_TEXT	ENDS
PUBLIC	?GetNext@CMacActorLink@@QAEPAV1@XZ		; CMacActorLink::GetNext
; Function compile flags: /Ogty
;	COMDAT ?GetNext@CMacActorLink@@QAEPAV1@XZ
_TEXT	SEGMENT
?GetNext@CMacActorLink@@QAEPAV1@XZ PROC NEAR		; CMacActorLink::GetNext, COMDAT
; _this$ = ecx

; 90   : 	CMacActorLink* GetNext() { return(mNext); }

	mov	eax, DWORD PTR [ecx+8]
	ret	0
?GetNext@CMacActorLink@@QAEPAV1@XZ ENDP			; CMacActorLink::GetNext
; Function compile flags: /Ogty
; File C:\duke4\Cannibal\ObjMain.h
_TEXT	ENDS
;	COMDAT ?Reset@?$TObjIter@VOCpjSequence@@@@QAEXPAVOObject@@_N@Z
_TEXT	SEGMENT
_inObj$ = 8
_inReverse$ = 12
?Reset@?$TObjIter@VOCpjSequence@@@@QAEXPAVOObject@@_N@Z PROC NEAR ; TObjIter<OCpjSequence>::Reset, COMDAT
; _this$ = ecx

; 389  : 		CObjIter::Reset(inObj, inReverse);

	mov	eax, DWORD PTR _inObj$[esp-4]
	push	esi
	mov	esi, ecx
	test	eax, eax
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi], 0
	je	SHORT $L50527
	mov	cl, BYTE PTR _inReverse$[esp]
	add	eax, 24					; 00000018H
	test	cl, cl
	mov	DWORD PTR [esi], eax
	mov	BYTE PTR [esi+8], cl
	je	SHORT $L50435
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [esi+4], eax
	jmp	SHORT $L50436
$L50435:
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [esi+4], edx
$L50436:
	mov	eax, DWORD PTR [esi+4]
	test	cl, cl
	mov	DWORD PTR [esi], eax
	je	SHORT $L50444
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [esi+4], eax
	jmp	SHORT $L50527
$L50444:
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [esi+4], ecx

; 390  : 		AdvanceToType();

$L50527:
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $L50531
	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $L50531
	mov	ecx, DWORD PTR ?staticObjClass@OCpjSequence@@0PAVCObjClass@@A ; OCpjSequence::staticObjClass
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+44]
	test	al, al
	jne	SHORT $L50531
	mov	cl, BYTE PTR [esi+8]
	mov	eax, DWORD PTR [esi+4]
	test	cl, cl
	mov	DWORD PTR [esi], eax
	je	SHORT $L50523
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [esi+4], edx
	jmp	SHORT $L50527
$L50523:
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [esi+4], eax
	jmp	SHORT $L50527
$L50531:
	pop	esi

; 391  : 	}

	ret	8
?Reset@?$TObjIter@VOCpjSequence@@@@QAEXPAVOObject@@_N@Z ENDP ; TObjIter<OCpjSequence>::Reset
_TEXT	ENDS
PUBLIC	?IsDone@CMacActorLink@@QAE_NXZ			; CMacActorLink::IsDone
; Function compile flags: /Ogty
; File C:\duke4\Cannibal\MacMain.h
;	COMDAT ?IsDone@CMacActorLink@@QAE_NXZ
_TEXT	SEGMENT
?IsDone@CMacActorLink@@QAE_NXZ PROC NEAR		; CMacActorLink::IsDone, COMDAT
; _this$ = ecx

; 91   : 	NBool IsDone() { return(this == &sHeadLink); }

	xor	eax, eax
	cmp	ecx, OFFSET FLAT:?sHeadLink@CMacActorLink@@0V1@A ; CMacActorLink::sHeadLink
	sete	al
	ret	0
?IsDone@CMacActorLink@@QAE_NXZ ENDP			; CMacActorLink::IsDone
_TEXT	ENDS
PUBLIC	?GetActor@CMacActorLink@@QAEPAVOMacActor@@XZ	; CMacActorLink::GetActor
; Function compile flags: /Ogty
;	COMDAT ?GetActor@CMacActorLink@@QAEPAVOMacActor@@XZ
_TEXT	SEGMENT
?GetActor@CMacActorLink@@QAEPAVOMacActor@@XZ PROC NEAR	; CMacActorLink::GetActor, COMDAT
; _this$ = ecx

; 93   : 	OMacActor* GetActor() { return(mActor); }

	mov	eax, DWORD PTR [ecx]
	ret	0
?GetActor@CMacActorLink@@QAEPAVOMacActor@@XZ ENDP	; CMacActorLink::GetActor
_TEXT	ENDS
PUBLIC	?SetActor@CMacActorLink@@QAEXPAVOMacActor@@@Z	; CMacActorLink::SetActor
; Function compile flags: /Ogty
;	COMDAT ?SetActor@CMacActorLink@@QAEXPAVOMacActor@@@Z
_TEXT	SEGMENT
_inActor$ = 8
?SetActor@CMacActorLink@@QAEXPAVOMacActor@@@Z PROC NEAR	; CMacActorLink::SetActor, COMDAT
; _this$ = ecx

; 94   : 	void SetActor(OMacActor* inActor) { mActor = inActor; }

	mov	eax, DWORD PTR _inActor$[esp-4]
	mov	DWORD PTR [ecx], eax
	ret	4
?SetActor@CMacActorLink@@QAEXPAVOMacActor@@@Z ENDP	; CMacActorLink::SetActor
_TEXT	ENDS
PUBLIC	??4CMacActorLink@@QAEAAV0@ABV0@@Z		; CMacActorLink::operator=
; Function compile flags: /Ogty
;	COMDAT ??4CMacActorLink@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8
??4CMacActorLink@@QAEAAV0@ABV0@@Z PROC NEAR		; CMacActorLink::operator=, COMDAT
; _this$ = ecx
	mov	eax, ecx
	mov	ecx, DWORD PTR ___that$[esp-4]
	push	esi
	mov	edx, eax
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [edx], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], esi
	pop	esi
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], ecx
	ret	4
??4CMacActorLink@@QAEAAV0@ABV0@@Z ENDP			; CMacActorLink::operator=
; Function compile flags: /Ogty
; File C:\duke4\Cannibal\CorMain.h
_TEXT	ENDS
;	COMDAT ?AddItem@?$TCorArray@PAVOCpjProject@@@@QAEKABQAVOCpjProject@@@Z
_TEXT	SEGMENT
_inItem$ = 8
?AddItem@?$TCorArray@PAVOCpjProject@@@@QAEKABQAVOCpjProject@@@Z PROC NEAR ; TCorArray<OCpjProject *>::AddItem, COMDAT
; _this$ = ecx

; 315  : 	{

	push	esi
	mov	esi, ecx
	push	edi

; 316  : 		NDword i = Add();

	mov	edi, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	lea	eax, DWORD PTR [edi+1]
	cmp	eax, ecx
	mov	DWORD PTR [esi+4], eax
	jbe	SHORT $L50572
	mov	ecx, eax
	push	4
	shr	ecx, 2
	lea	edx, DWORD PTR [ecx+eax+32]
	mov	ecx, esi
	mov	DWORD PTR [esi+8], edx
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
$L50572:

; 317  : 		(*this)[i] = inItem;

	mov	ecx, DWORD PTR _inItem$[esp+4]
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+edi*4], edx

; 318  : 		return(i);

	mov	eax, edi
	pop	edi
	pop	esi

; 319  : 	}

	ret	4
?AddItem@?$TCorArray@PAVOCpjProject@@@@QAEKABQAVOCpjProject@@@Z ENDP ; TCorArray<OCpjProject *>::AddItem
_TEXT	ENDS
PUBLIC	??2OMacActor@@CAPAXIPAVOObject@@PAVCObjClass@@@Z ; OMacActor::operator new
; Function compile flags: /Ogty
; File C:\duke4\Cannibal\MacMain.h
;	COMDAT ??2OMacActor@@CAPAXIPAVOObject@@PAVCObjClass@@@Z
_TEXT	SEGMENT
_inParent$ = 12
_inSetClass$ = 16
??2OMacActor@@CAPAXIPAVOObject@@PAVCObjClass@@@Z PROC NEAR ; OMacActor::operator new, COMDAT

; 104  : 	OBJ_CLASS_DEFINE(OMacActor, OObject);

	push	esi
	push	edi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	308					; 00000134H
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	ecx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	mov	esi, eax
	inc	ecx
	xor	eax, eax
	mov	DWORD PTR ?sObjCount@OObject@@1KA, ecx	; OObject::sObjCount
	mov	ecx, 77					; 0000004dH
	mov	edi, esi
	rep stosd
	mov	eax, DWORD PTR [esi+40]
	mov	DWORD PTR [esi+4], 305419896		; 12345678H
	test	eax, eax
	jne	SHORT $L50592
	mov	eax, DWORD PTR _inSetClass$[esp+4]
	mov	DWORD PTR [esi+40], eax
$L50592:
	mov	ecx, DWORD PTR _inParent$[esp+4]
	push	ecx
	mov	ecx, esi
	call	?PreConstruct@OObject@@QAEXPAV1@@Z	; OObject::PreConstruct
	mov	eax, esi
	pop	edi
	pop	esi
	ret	0
??2OMacActor@@CAPAXIPAVOObject@@PAVCObjClass@@@Z ENDP	; OMacActor::operator new
; Function compile flags: /Ogty
; File C:\duke4\Cannibal\CorMain.h
_TEXT	ENDS
;	COMDAT ?FindItem@?$TCorArray@PAVOCpjProject@@@@QBE_NABQAVOCpjProject@@PAK@Z
_TEXT	SEGMENT
_inItem$ = 8
_outIndex$ = 12
?FindItem@?$TCorArray@PAVOCpjProject@@@@QBE_NABQAVOCpjProject@@PAK@Z PROC NEAR ; TCorArray<OCpjProject *>::FindItem, COMDAT
; _this$ = ecx

; 345  : 		for (NDword i=0;i<m_Count;i++)

	mov	edx, DWORD PTR [ecx+4]
	xor	eax, eax
	push	esi
	test	edx, edx
	jbe	SHORT $L15141
	mov	esi, DWORD PTR _inItem$[esp]
	mov	ecx, DWORD PTR [ecx]
	mov	esi, DWORD PTR [esi]
$L15139:

; 346  : 		{
; 347  : 			if (((T*)m_Data)[i] == inItem)

	cmp	DWORD PTR [ecx], esi
	je	SHORT $L50599
	inc	eax
	add	ecx, 4
	cmp	eax, edx
	jb	SHORT $L15139
$L15141:

; 352  : 			}
; 353  : 		}
; 354  : 		return(0);

	xor	al, al
	pop	esi

; 355  : 	}

	ret	8
$L50599:

; 348  : 			{
; 349  : 				if (outIndex)

	mov	ecx, DWORD PTR _outIndex$[esp]
	test	ecx, ecx
	je	SHORT $L15144

; 350  : 					*outIndex = i;

	mov	DWORD PTR [ecx], eax
$L15144:

; 351  : 				return(1);

	mov	al, 1
	pop	esi

; 355  : 	}

	ret	8
?FindItem@?$TCorArray@PAVOCpjProject@@@@QBE_NABQAVOCpjProject@@PAK@Z ENDP ; TCorArray<OCpjProject *>::FindItem
_TEXT	ENDS
PUBLIC	??3OMacActor@@CAXPAX@Z				; OMacActor::operator delete
; Function compile flags: /Ogty
; File C:\duke4\Cannibal\MacMain.h
;	COMDAT ??3OMacActor@@CAXPAX@Z
_TEXT	SEGMENT
_ptr$ = 8
??3OMacActor@@CAXPAX@Z PROC NEAR			; OMacActor::operator delete, COMDAT

; 104  : 	OBJ_CLASS_DEFINE(OMacActor, OObject);

	push	esi
	mov	esi, DWORD PTR _ptr$[esp]
	mov	DWORD PTR [esi+4], 0
	mov	edx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	dec	edx
	mov	DWORD PTR ?sObjCount@OObject@@1KA, edx	; OObject::sObjCount
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	ecx, eax
	call	DWORD PTR [edx+8]
	pop	esi
	ret	0
??3OMacActor@@CAXPAX@Z ENDP				; OMacActor::operator delete
_TEXT	ENDS
PUBLIC	??3OMacActor@@CAXPAXPAVOObject@@PAVCObjClass@@@Z ; OMacActor::operator delete
; Function compile flags: /Ogty
;	COMDAT ??3OMacActor@@CAXPAXPAVOObject@@PAVCObjClass@@@Z
_TEXT	SEGMENT
_ptr$ = 8
??3OMacActor@@CAXPAXPAVOObject@@PAVCObjClass@@@Z PROC NEAR ; OMacActor::operator delete, COMDAT

; 104  : 	OBJ_CLASS_DEFINE(OMacActor, OObject);

	push	esi
	mov	esi, DWORD PTR _ptr$[esp]
	mov	DWORD PTR [esi+4], 0
	mov	edx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	dec	edx
	mov	DWORD PTR ?sObjCount@OObject@@1KA, edx	; OObject::sObjCount
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	ecx, eax
	call	DWORD PTR [edx+8]
	pop	esi
	ret	0
??3OMacActor@@CAXPAXPAVOObject@@PAVCObjClass@@@Z ENDP	; OMacActor::operator delete
_TEXT	ENDS
PUBLIC	?GetStaticClass@OMacActor@@SAPAVCObjClass@@XZ	; OMacActor::GetStaticClass
; Function compile flags: /Ogty
;	COMDAT ?GetStaticClass@OMacActor@@SAPAVCObjClass@@XZ
_TEXT	SEGMENT
?GetStaticClass@OMacActor@@SAPAVCObjClass@@XZ PROC NEAR	; OMacActor::GetStaticClass, COMDAT

; 104  : 	OBJ_CLASS_DEFINE(OMacActor, OObject);

	mov	eax, DWORD PTR ?staticObjClass@OMacActor@@0PAVCObjClass@@A ; OMacActor::staticObjClass
	ret	0
?GetStaticClass@OMacActor@@SAPAVCObjClass@@XZ ENDP	; OMacActor::GetStaticClass
_TEXT	ENDS
PUBLIC	?GetClass@OMacActor@@UAEPAVCObjClass@@XZ	; OMacActor::GetClass
PUBLIC	??1?$TCorArray@PAVOCpjSurface@@@@QAE@XZ		; TCorArray<OCpjSurface *>::~TCorArray<OCpjSurface *>
PUBLIC	??1?$TCorArray@PAVOCpjFrames@@@@QAE@XZ		; TCorArray<OCpjFrames *>::~TCorArray<OCpjFrames *>
PUBLIC	??1?$TCorArray@PAVOCpjSequence@@@@QAE@XZ	; TCorArray<OCpjSequence *>::~TCorArray<OCpjSequence *>
PUBLIC	??0?$TCorArray@VCMacBone@@@@QAE@K@Z		; TCorArray<CMacBone>::TCorArray<CMacBone>
PUBLIC	??1?$TCorArray@VCMacBone@@@@QAE@XZ		; TCorArray<CMacBone>::~TCorArray<CMacBone>
PUBLIC	??0?$TCorArray@PAVOMacChannel@@@@QAE@K@Z	; TCorArray<OMacChannel *>::TCorArray<OMacChannel *>
PUBLIC	??0?$TCorArray@VCCorString@@@@QAE@K@Z		; TCorArray<CCorString>::TCorArray<CCorString>
PUBLIC	??_7OMacActor@@6B@				; OMacActor::`vftable'
PUBLIC	??_EOMacActor@@UAEPAXI@Z			; OMacActor::`vector deleting destructor'
;	COMDAT xdata$x
; File C:\duke4\Cannibal\CorMain.h
xdata$x	SEGMENT
$T50767	DD	0ffffffffH
	DD	FLAT:$L50627
	DD	00H
	DD	FLAT:$L50652
	DD	01H
	DD	FLAT:$L50653
	DD	02H
	DD	FLAT:$L50654
	DD	03H
	DD	FLAT:$L50655
	DD	04H
	DD	FLAT:$L50656
	DD	05H
	DD	FLAT:$L50657
	DD	06H
	DD	FLAT:$L50658
	DD	07H
	DD	FLAT:$L50659
	DD	08H
	DD	FLAT:$L50660
	DD	09H
	DD	FLAT:$L50661
	DD	0aH
	DD	FLAT:$L50662
	DD	0bH
	DD	FLAT:$L50663
$T50763	DD	019930520H
	DD	0dH
	DD	FLAT:$T50767
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_7OMacActor@@6B@
CONST	SEGMENT
??_7OMacActor@@6B@ DD FLAT:?Msg@OObject@@UAE_NPAVIMsg@@@Z ; OMacActor::`vftable'
	DD	FLAT:?MsgGetChild@OMacActor@@UAEPAVIMsgTarget@@PAD@Z
	DD	FLAT:?MsgGetParent@OObject@@UAEPAVIMsgTarget@@XZ
	DD	FLAT:?MsgGetRoot@OObject@@UAEPAVIMsgTarget@@XZ
	DD	FLAT:?GetClass@OMacActor@@UAEPAVCObjClass@@XZ
	DD	FLAT:??_EOMacActor@@UAEPAXI@Z
	DD	FLAT:?Create@OMacActor@@UAEXXZ
	DD	FLAT:?Destroy@OObject@@UAEXXZ
	DD	FLAT:?GetParent@OObject@@UAEPAV1@XZ
	DD	FLAT:?SetParent@OObject@@UAEXPAV1@_N@Z
	DD	FLAT:?HasChildren@OObject@@UAE_NXZ
	DD	FLAT:?IsA@OObject@@UAE_NPAVCObjClass@@@Z
; Function compile flags: /Ogty
; File C:\duke4\Cannibal\MacMain.h
CONST	ENDS
;	COMDAT ?New@OMacActor@@SAPAV1@PAVOObject@@PAVCObjClass@@@Z
_TEXT	SEGMENT
_inParent$ = 8
_inSetClass$ = 12
$T50624 = -16
__$EHRec$ = -12
?New@OMacActor@@SAPAV1@PAVOObject@@PAVCObjClass@@@Z PROC NEAR ; OMacActor::New, COMDAT

; 104  : 	OBJ_CLASS_DEFINE(OMacActor, OObject);

	push	-1
	push	$L50766
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _inSetClass$[esp+20]
	xor	ebx, ebx
	cmp	ebp, ebx
	push	esi
	jne	SHORT $L10985
	mov	ebp, DWORD PTR ?staticObjClass@OMacActor@@0PAVCObjClass@@A ; OMacActor::staticObjClass
	mov	DWORD PTR _inSetClass$[esp+24], ebp
$L10985:
	push	edi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	308					; 00000134H
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	ecx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	mov	esi, eax
	inc	ecx
	xor	eax, eax
	mov	DWORD PTR ?sObjCount@OObject@@1KA, ecx	; OObject::sObjCount
	mov	ecx, 77					; 0000004dH
	mov	edi, esi
	rep stosd
	mov	eax, DWORD PTR [esi+40]
	mov	DWORD PTR [esi+4], 305419896		; 12345678H
	cmp	eax, ebx
	pop	edi
	jne	SHORT $L50648
	mov	DWORD PTR [esi+40], ebp
$L50648:
	mov	eax, DWORD PTR _inParent$[esp+24]
	mov	ecx, esi
	push	eax
	call	?PreConstruct@OObject@@QAEXPAV1@@Z	; OObject::PreConstruct
	mov	DWORD PTR $T50624[esp+28], esi
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+36], ebx
	call	??0OObject@@QAE@XZ			; OObject::OObject
	lea	ecx, DWORD PTR [esi+56]
	push	OFFSET FLAT:?sHeadLink@CMacActorLink@@0V1@A ; CMacActorLink::sHeadLink
	mov	DWORD PTR [ecx+8], ecx
	mov	DWORD PTR [ecx+4], ecx
	call	?Link@CMacActorLink@@AAEXPAV1@@Z	; CMacActorLink::Link
	mov	DWORD PTR [esi+72], ebx
	mov	DWORD PTR [esi+76], ebx
	push	4
	lea	ecx, DWORD PTR [esi+152]
	push	ebx
	mov	BYTE PTR __$EHRec$[esp+44], 4
	mov	DWORD PTR [esi+104], ebx
	mov	DWORD PTR [esi+108], ebx
	mov	DWORD PTR [esi+112], ebx
	call	??0CCorArray@@IAE@KK@Z			; CCorArray::CCorArray
	push	4
	lea	ecx, DWORD PTR [esi+168]
	push	ebx
	mov	BYTE PTR __$EHRec$[esp+44], 5
	call	??0CCorArray@@IAE@KK@Z			; CCorArray::CCorArray
	push	4
	lea	ecx, DWORD PTR [esi+184]
	push	ebx
	mov	BYTE PTR __$EHRec$[esp+44], 6
	call	??0CCorArray@@IAE@KK@Z			; CCorArray::CCorArray
	push	4
	lea	ecx, DWORD PTR [esi+200]
	push	ebx
	mov	BYTE PTR __$EHRec$[esp+44], 7
	call	??0CCorArray@@IAE@KK@Z			; CCorArray::CCorArray
	push	4
	lea	ecx, DWORD PTR [esi+216]
	push	ebx
	mov	BYTE PTR __$EHRec$[esp+44], 8
	call	??0CCorArray@@IAE@KK@Z			; CCorArray::CCorArray
	push	4
	lea	ecx, DWORD PTR [esi+232]
	push	ebx
	mov	BYTE PTR __$EHRec$[esp+44], 9
	call	??0CCorArray@@IAE@KK@Z			; CCorArray::CCorArray
	push	ebx
	lea	ecx, DWORD PTR [esi+248]
	mov	BYTE PTR __$EHRec$[esp+40], 10		; 0000000aH
	call	??0?$TCorArray@VCCorString@@@@QAE@K@Z	; TCorArray<CCorString>::TCorArray<CCorString>
	push	ebx
	lea	ecx, DWORD PTR [esi+272]
	mov	BYTE PTR __$EHRec$[esp+40], 11		; 0000000bH
	call	??0?$TCorArray@VCMacBone@@@@QAE@K@Z	; TCorArray<CMacBone>::TCorArray<CMacBone>
	push	ebx
	lea	ecx, DWORD PTR [esi+288]
	mov	BYTE PTR __$EHRec$[esp+40], 12		; 0000000cH
	call	??0?$TCorArray@PAVOMacChannel@@@@QAE@K@Z ; TCorArray<OMacChannel *>::TCorArray<OMacChannel *>
	mov	DWORD PTR [esi], OFFSET FLAT:??_7OMacActor@@6B@ ; OMacActor::`vftable'
	mov	edx, DWORD PTR [esi]
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+36], -1
	call	DWORD PTR [edx+24]
	mov	eax, esi
	pop	esi
	pop	ebp
	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	pop	ebx
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L50627:
	mov	eax, DWORD PTR _inSetClass$[ebp-4]
	push	eax
	mov	ecx, DWORD PTR _inParent$[ebp-4]
	push	ecx
	mov	edx, DWORD PTR $T50624[ebp]
	push	edx
	call	??3OMacActor@@CAXPAXPAVOObject@@PAVCObjClass@@@Z ; OMacActor::operator delete
	add	esp, 12					; 0000000cH
	ret	0
$L50652:
	mov	ecx, DWORD PTR $T50624[ebp]
	jmp	??1OObject@@UAE@XZ			; OObject::~OObject
$L50653:
	mov	ecx, DWORD PTR $T50624[ebp]
	add	ecx, 56					; 00000038H
	jmp	??1CMacActorLink@@QAE@XZ		; CMacActorLink::~CMacActorLink
$L50654:
	mov	ecx, DWORD PTR $T50624[ebp]
	add	ecx, 72					; 00000048H
	jmp	??1CCorString@@QAE@XZ			; CCorString::~CCorString
$L50655:
	mov	ecx, DWORD PTR $T50624[ebp]
	add	ecx, 76					; 0000004cH
	jmp	??1CCorString@@QAE@XZ			; CCorString::~CCorString
$L50656:
	mov	ecx, DWORD PTR $T50624[ebp]
	add	ecx, 152				; 00000098H
	jmp	??1?$TCorArray@PAVOCpjSurface@@@@QAE@XZ	; TCorArray<OCpjSurface *>::~TCorArray<OCpjSurface *>
$L50657:
	mov	ecx, DWORD PTR $T50624[ebp]
	add	ecx, 168				; 000000a8H
	jmp	??1?$TCorArray@PAVOCpjFrames@@@@QAE@XZ	; TCorArray<OCpjFrames *>::~TCorArray<OCpjFrames *>
$L50658:
	mov	ecx, DWORD PTR $T50624[ebp]
	add	ecx, 184				; 000000b8H
	jmp	??1?$TCorArray@PAVOCpjSequence@@@@QAE@XZ ; TCorArray<OCpjSequence *>::~TCorArray<OCpjSequence *>
$L50659:
	mov	ecx, DWORD PTR $T50624[ebp]
	add	ecx, 200				; 000000c8H
	jmp	??1?$TCorArray@VCCorString@@@@QAE@XZ	; TCorArray<CCorString>::~TCorArray<CCorString>
$L50660:
	mov	ecx, DWORD PTR $T50624[ebp]
	add	ecx, 216				; 000000d8H
	jmp	??1?$TCorArray@VCCorString@@@@QAE@XZ	; TCorArray<CCorString>::~TCorArray<CCorString>
$L50661:
	mov	ecx, DWORD PTR $T50624[ebp]
	add	ecx, 232				; 000000e8H
	jmp	??1?$TCorArray@VCCorString@@@@QAE@XZ	; TCorArray<CCorString>::~TCorArray<CCorString>
$L50662:
	mov	ecx, DWORD PTR $T50624[ebp]
	add	ecx, 248				; 000000f8H
	jmp	??1?$TCorArray@VCCorString@@@@QAE@XZ	; TCorArray<CCorString>::~TCorArray<CCorString>
$L50663:
	mov	ecx, DWORD PTR $T50624[ebp]
	add	ecx, 272				; 00000110H
	jmp	??1?$TCorArray@VCMacBone@@@@QAE@XZ	; TCorArray<CMacBone>::~TCorArray<CMacBone>
$L50766:
	mov	eax, OFFSET FLAT:$T50763
	jmp	___CxxFrameHandler
text$x	ENDS
?New@OMacActor@@SAPAV1@PAVOObject@@PAVCObjClass@@@Z ENDP ; OMacActor::New
; Function compile flags: /Ogty
; File C:\duke4\Cannibal\CorMain.h
;	COMDAT ??0?$TCorArray@VCCorString@@@@QAE@K@Z
_TEXT	SEGMENT
_inCount$ = 8
??0?$TCorArray@VCCorString@@@@QAE@K@Z PROC NEAR		; TCorArray<CCorString>::TCorArray<CCorString>, COMDAT
; _this$ = ecx

; 259  : 	{

	mov	eax, DWORD PTR _inCount$[esp-4]
	push	esi
	mov	esi, ecx
	test	eax, eax
	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], 4
	je	SHORT $L50795
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+8]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [esi+12]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	DWORD PTR [esi], eax

; 260  : 	}

	mov	eax, esi
	pop	esi
	ret	4

; 259  : 	{

$L50795:
	mov	DWORD PTR [esi], 0

; 260  : 	}

	mov	eax, esi
	pop	esi
	ret	4
??0?$TCorArray@VCCorString@@@@QAE@K@Z ENDP		; TCorArray<CCorString>::TCorArray<CCorString>
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??1?$TCorArray@PAVOCpjSurface@@@@QAE@XZ
_TEXT	SEGMENT
??1?$TCorArray@PAVOCpjSurface@@@@QAE@XZ PROC NEAR	; TCorArray<OCpjSurface *>::~TCorArray<OCpjSurface *>, COMDAT
; _this$ = ecx

; 280  : 	{

	push	esi
	mov	esi, ecx
	push	edi

; 281  : 		Purge();

	mov	edi, DWORD PTR [esi+4]
	test	edi, edi
	je	SHORT $L50822
	mov	eax, DWORD PTR [esi]
	mov	ecx, edi
	sub	ecx, edi
	shl	ecx, 2
	lea	edx, DWORD PTR [eax+edi*4]
	push	ecx
	push	edx
	push	eax
	call	DWORD PTR __imp__memmove
	mov	eax, DWORD PTR [esi+4]
	add	esp, 12					; 0000000cH
	sub	eax, edi
	mov	DWORD PTR [esi+4], eax
$L50822:

; 282  : 	}

	cmp	DWORD PTR [esi], 0
	je	SHORT $L50833
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L50833:
	pop	edi
	pop	esi
	ret	0
??1?$TCorArray@PAVOCpjSurface@@@@QAE@XZ ENDP		; TCorArray<OCpjSurface *>::~TCorArray<OCpjSurface *>
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??1?$TCorArray@PAVOCpjFrames@@@@QAE@XZ
_TEXT	SEGMENT
??1?$TCorArray@PAVOCpjFrames@@@@QAE@XZ PROC NEAR	; TCorArray<OCpjFrames *>::~TCorArray<OCpjFrames *>, COMDAT
; _this$ = ecx

; 280  : 	{

	push	esi
	mov	esi, ecx
	push	edi

; 281  : 		Purge();

	mov	edi, DWORD PTR [esi+4]
	test	edi, edi
	je	SHORT $L50859
	mov	eax, DWORD PTR [esi]
	mov	ecx, edi
	sub	ecx, edi
	shl	ecx, 2
	lea	edx, DWORD PTR [eax+edi*4]
	push	ecx
	push	edx
	push	eax
	call	DWORD PTR __imp__memmove
	mov	eax, DWORD PTR [esi+4]
	add	esp, 12					; 0000000cH
	sub	eax, edi
	mov	DWORD PTR [esi+4], eax
$L50859:

; 282  : 	}

	cmp	DWORD PTR [esi], 0
	je	SHORT $L50870
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L50870:
	pop	edi
	pop	esi
	ret	0
??1?$TCorArray@PAVOCpjFrames@@@@QAE@XZ ENDP		; TCorArray<OCpjFrames *>::~TCorArray<OCpjFrames *>
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??1?$TCorArray@PAVOCpjSequence@@@@QAE@XZ
_TEXT	SEGMENT
??1?$TCorArray@PAVOCpjSequence@@@@QAE@XZ PROC NEAR	; TCorArray<OCpjSequence *>::~TCorArray<OCpjSequence *>, COMDAT
; _this$ = ecx

; 280  : 	{

	push	esi
	mov	esi, ecx
	push	edi

; 281  : 		Purge();

	mov	edi, DWORD PTR [esi+4]
	test	edi, edi
	je	SHORT $L50896
	mov	eax, DWORD PTR [esi]
	mov	ecx, edi
	sub	ecx, edi
	shl	ecx, 2
	lea	edx, DWORD PTR [eax+edi*4]
	push	ecx
	push	edx
	push	eax
	call	DWORD PTR __imp__memmove
	mov	eax, DWORD PTR [esi+4]
	add	esp, 12					; 0000000cH
	sub	eax, edi
	mov	DWORD PTR [esi+4], eax
$L50896:

; 282  : 	}

	cmp	DWORD PTR [esi], 0
	je	SHORT $L50907
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L50907:
	pop	edi
	pop	esi
	ret	0
??1?$TCorArray@PAVOCpjSequence@@@@QAE@XZ ENDP		; TCorArray<OCpjSequence *>::~TCorArray<OCpjSequence *>
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??0?$TCorArray@VCMacBone@@@@QAE@K@Z
_TEXT	SEGMENT
_inCount$ = 8
??0?$TCorArray@VCMacBone@@@@QAE@K@Z PROC NEAR		; TCorArray<CMacBone>::TCorArray<CMacBone>, COMDAT
; _this$ = ecx

; 259  : 	{

	mov	eax, DWORD PTR _inCount$[esp-4]
	push	esi
	mov	esi, ecx
	test	eax, eax
	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], 140			; 0000008cH
	je	SHORT $L50935
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+8]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [esi+12]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	DWORD PTR [esi], eax

; 260  : 	}

	mov	eax, esi
	pop	esi
	ret	4

; 259  : 	{

$L50935:
	mov	DWORD PTR [esi], 0

; 260  : 	}

	mov	eax, esi
	pop	esi
	ret	4
??0?$TCorArray@VCMacBone@@@@QAE@K@Z ENDP		; TCorArray<CMacBone>::TCorArray<CMacBone>
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??1?$TCorArray@VCMacBone@@@@QAE@XZ
_TEXT	SEGMENT
??1?$TCorArray@VCMacBone@@@@QAE@XZ PROC NEAR		; TCorArray<CMacBone>::~TCorArray<CMacBone>, COMDAT
; _this$ = ecx

; 280  : 	{

	push	esi
	mov	esi, ecx
	push	edi

; 281  : 		Purge();

	mov	edi, DWORD PTR [esi+4]
	test	edi, edi
	je	SHORT $L50962
	lea	eax, DWORD PTR [edi*8]
	mov	ecx, DWORD PTR [esi]
	sub	eax, edi
	lea	eax, DWORD PTR [eax+eax*4]
	shl	eax, 2
	mov	edx, eax
	sub	edx, eax
	add	eax, ecx
	push	edx
	push	eax
	push	ecx
	call	DWORD PTR __imp__memmove
	mov	eax, DWORD PTR [esi+4]
	add	esp, 12					; 0000000cH
	sub	eax, edi
	mov	DWORD PTR [esi+4], eax
$L50962:

; 282  : 	}

	cmp	DWORD PTR [esi], 0
	je	SHORT $L50973
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L50973:
	pop	edi
	pop	esi
	ret	0
??1?$TCorArray@VCMacBone@@@@QAE@XZ ENDP			; TCorArray<CMacBone>::~TCorArray<CMacBone>
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??0?$TCorArray@PAVOMacChannel@@@@QAE@K@Z
_TEXT	SEGMENT
_inCount$ = 8
??0?$TCorArray@PAVOMacChannel@@@@QAE@K@Z PROC NEAR	; TCorArray<OMacChannel *>::TCorArray<OMacChannel *>, COMDAT
; _this$ = ecx

; 259  : 	{

	mov	eax, DWORD PTR _inCount$[esp-4]
	push	esi
	mov	esi, ecx
	test	eax, eax
	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], 4
	je	SHORT $L51001
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+8]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [esi+12]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	DWORD PTR [esi], eax

; 260  : 	}

	mov	eax, esi
	pop	esi
	ret	4

; 259  : 	{

$L51001:
	mov	DWORD PTR [esi], 0

; 260  : 	}

	mov	eax, esi
	pop	esi
	ret	4
??0?$TCorArray@PAVOMacChannel@@@@QAE@K@Z ENDP		; TCorArray<OMacChannel *>::TCorArray<OMacChannel *>
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??0CCpjSeqTranslate@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8
??0CCpjSeqTranslate@@QAE@ABV0@@Z PROC NEAR		; CCpjSeqTranslate::CCpjSeqTranslate, COMDAT
; _this$ = ecx
	mov	eax, ecx
	mov	ecx, DWORD PTR ___that$[esp-4]
	mov	dx, WORD PTR [ecx]
	mov	WORD PTR [eax], dx
	mov	dx, WORD PTR [ecx+2]
	mov	WORD PTR [eax+2], dx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], ecx
	ret	4
??0CCpjSeqTranslate@@QAE@ABV0@@Z ENDP			; CCpjSeqTranslate::CCpjSeqTranslate
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??0CCpjSeqRotate@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8
??0CCpjSeqRotate@@QAE@ABV0@@Z PROC NEAR			; CCpjSeqRotate::CCpjSeqRotate, COMDAT
; _this$ = ecx
	mov	eax, ecx
	mov	ecx, DWORD PTR ___that$[esp-4]
	mov	dx, WORD PTR [ecx]
	mov	WORD PTR [eax], dx
	mov	dx, WORD PTR [ecx+2]
	mov	WORD PTR [eax+2], dx
	mov	dx, WORD PTR [ecx+4]
	mov	WORD PTR [eax+4], dx
	mov	dx, WORD PTR [ecx+6]
	mov	WORD PTR [eax+6], dx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx
	mov	ecx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+20], ecx
	ret	4
??0CCpjSeqRotate@@QAE@ABV0@@Z ENDP			; CCpjSeqRotate::CCpjSeqRotate
; Function compile flags: /Ogty
; File C:\duke4\Cannibal\MacMain.h
_TEXT	ENDS
;	COMDAT ?GetClass@OMacActor@@UAEPAVCObjClass@@XZ
_TEXT	SEGMENT
?GetClass@OMacActor@@UAEPAVCObjClass@@XZ PROC NEAR	; OMacActor::GetClass, COMDAT
; _this$ = ecx

; 104  : 	OBJ_CLASS_DEFINE(OMacActor, OObject);

	mov	eax, DWORD PTR [ecx+40]
	ret	0
?GetClass@OMacActor@@UAEPAVCObjClass@@XZ ENDP		; OMacActor::GetClass
_TEXT	ENDS
PUBLIC	??0OMacActor@@QAE@XZ				; OMacActor::OMacActor
;	COMDAT xdata$x
xdata$x	SEGMENT
$T51165	DD	0ffffffffH
	DD	FLAT:$L51037
	DD	00H
	DD	FLAT:$L51038
	DD	01H
	DD	FLAT:$L51039
	DD	02H
	DD	FLAT:$L51040
	DD	03H
	DD	FLAT:$L51041
	DD	04H
	DD	FLAT:$L51042
	DD	05H
	DD	FLAT:$L51043
	DD	06H
	DD	FLAT:$L51044
	DD	07H
	DD	FLAT:$L51045
	DD	08H
	DD	FLAT:$L51046
	DD	09H
	DD	FLAT:$L51047
	DD	0aH
	DD	FLAT:$L51048
$T51161	DD	019930520H
	DD	0cH
	DD	FLAT:$T51165
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ??0OMacActor@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12
_this$ = -16
??0OMacActor@@QAE@XZ PROC NEAR				; OMacActor::OMacActor, COMDAT
; _this$ = ecx
	push	-1
	push	$L51164
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	push	ebx
	push	esi
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+28], esi
	call	??0OObject@@QAE@XZ			; OObject::OObject
	lea	eax, DWORD PTR [esi+56]
	xor	edi, edi
	mov	DWORD PTR __$EHRec$[esp+36], edi
	mov	DWORD PTR [eax+8], eax
	mov	DWORD PTR [eax+4], eax
	mov	ecx, DWORD PTR ?sHeadLink@CMacActorLink@@0V1@A+8
	mov	DWORD PTR [eax+4], OFFSET FLAT:?sHeadLink@CMacActorLink@@0V1@A ; CMacActorLink::sHeadLink
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR ?sHeadLink@CMacActorLink@@0V1@A+8, eax
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+4], eax
	mov	DWORD PTR [esi+72], edi
	mov	DWORD PTR [esi+76], edi
	lea	ecx, DWORD PTR [esi+152]
	mov	ebx, 4
	mov	DWORD PTR [esi+104], edi
	mov	DWORD PTR [esi+108], edi
	mov	DWORD PTR [esi+112], edi
	push	ebx
	mov	BYTE PTR __$EHRec$[esp+40], 3
	mov	DWORD PTR [ecx], edi
	mov	DWORD PTR [ecx+4], edi
	mov	DWORD PTR [ecx+8], edi
	mov	DWORD PTR [ecx+12], ebx
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
	lea	ecx, DWORD PTR [esi+168]
	push	ebx
	mov	BYTE PTR __$EHRec$[esp+40], bl
	mov	DWORD PTR [ecx], edi
	mov	DWORD PTR [ecx+4], edi
	mov	DWORD PTR [ecx+8], edi
	mov	DWORD PTR [ecx+12], ebx
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
	lea	ecx, DWORD PTR [esi+184]
	push	ebx
	mov	BYTE PTR __$EHRec$[esp+40], 5
	mov	DWORD PTR [ecx], edi
	mov	DWORD PTR [ecx+4], edi
	mov	DWORD PTR [ecx+8], edi
	mov	DWORD PTR [ecx+12], ebx
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
	lea	ecx, DWORD PTR [esi+200]
	push	ebx
	mov	BYTE PTR __$EHRec$[esp+40], 6
	mov	DWORD PTR [ecx], edi
	mov	DWORD PTR [ecx+4], edi
	mov	DWORD PTR [ecx+8], edi
	mov	DWORD PTR [ecx+12], ebx
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
	push	ebx
	lea	ecx, DWORD PTR [esi+216]
	push	edi
	mov	BYTE PTR __$EHRec$[esp+44], 7
	call	??0CCorArray@@IAE@KK@Z			; CCorArray::CCorArray
	push	ebx
	lea	ecx, DWORD PTR [esi+232]
	push	edi
	mov	BYTE PTR __$EHRec$[esp+44], 8
	call	??0CCorArray@@IAE@KK@Z			; CCorArray::CCorArray
	push	ebx
	lea	ecx, DWORD PTR [esi+248]
	push	edi
	mov	BYTE PTR __$EHRec$[esp+44], 9
	call	??0CCorArray@@IAE@KK@Z			; CCorArray::CCorArray
	lea	ecx, DWORD PTR [esi+272]
	push	140					; 0000008cH
	mov	BYTE PTR __$EHRec$[esp+40], 10		; 0000000aH
	mov	DWORD PTR [ecx], edi
	mov	DWORD PTR [ecx+4], edi
	mov	DWORD PTR [ecx+8], edi
	mov	DWORD PTR [ecx+12], 140			; 0000008cH
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
	push	ebx
	push	edi
	lea	ecx, DWORD PTR [esi+288]
	mov	BYTE PTR __$EHRec$[esp+44], 11		; 0000000bH
	call	??0CCorArray@@IAE@KK@Z			; CCorArray::CCorArray
	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR [esi], OFFSET FLAT:??_7OMacActor@@6B@ ; OMacActor::`vftable'
	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L51037:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1OObject@@UAE@XZ			; OObject::~OObject
$L51038:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 56					; 00000038H
	jmp	??1CMacActorLink@@QAE@XZ		; CMacActorLink::~CMacActorLink
$L51039:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 72					; 00000048H
	jmp	??1CCorString@@QAE@XZ			; CCorString::~CCorString
$L51040:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 76					; 0000004cH
	jmp	??1CCorString@@QAE@XZ			; CCorString::~CCorString
$L51041:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 152				; 00000098H
	jmp	??1?$TCorArray@PAVOCpjSurface@@@@QAE@XZ	; TCorArray<OCpjSurface *>::~TCorArray<OCpjSurface *>
$L51042:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 168				; 000000a8H
	jmp	??1?$TCorArray@PAVOCpjFrames@@@@QAE@XZ	; TCorArray<OCpjFrames *>::~TCorArray<OCpjFrames *>
$L51043:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 184				; 000000b8H
	jmp	??1?$TCorArray@PAVOCpjSequence@@@@QAE@XZ ; TCorArray<OCpjSequence *>::~TCorArray<OCpjSequence *>
$L51044:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 200				; 000000c8H
	jmp	??1?$TCorArray@VCCorString@@@@QAE@XZ	; TCorArray<CCorString>::~TCorArray<CCorString>
$L51045:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 216				; 000000d8H
	jmp	??1?$TCorArray@VCCorString@@@@QAE@XZ	; TCorArray<CCorString>::~TCorArray<CCorString>
$L51046:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 232				; 000000e8H
	jmp	??1?$TCorArray@VCCorString@@@@QAE@XZ	; TCorArray<CCorString>::~TCorArray<CCorString>
$L51047:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 248				; 000000f8H
	jmp	??1?$TCorArray@VCCorString@@@@QAE@XZ	; TCorArray<CCorString>::~TCorArray<CCorString>
$L51048:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 272				; 00000110H
	jmp	??1?$TCorArray@VCMacBone@@@@QAE@XZ	; TCorArray<CMacBone>::~TCorArray<CMacBone>
$L51164:
	mov	eax, OFFSET FLAT:$T51161
	jmp	___CxxFrameHandler
text$x	ENDS
??0OMacActor@@QAE@XZ ENDP				; OMacActor::OMacActor
; Function compile flags: /Ogty
;	COMDAT ??0CCpjSeqScale@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8
??0CCpjSeqScale@@QAE@ABV0@@Z PROC NEAR			; CCpjSeqScale::CCpjSeqScale, COMDAT
; _this$ = ecx
	mov	eax, ecx
	mov	ecx, DWORD PTR ___that$[esp-4]
	mov	dx, WORD PTR [ecx]
	mov	WORD PTR [eax], dx
	mov	dx, WORD PTR [ecx+2]
	mov	WORD PTR [eax+2], dx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], ecx
	ret	4
??0CCpjSeqScale@@QAE@ABV0@@Z ENDP			; CCpjSeqScale::CCpjSeqScale
; Function compile flags: /Ogty
; File C:\duke4\Cannibal\CorMain.h
_TEXT	ENDS
;	COMDAT ?Remove@?$TCorArray@PAVCCpjGeoEdge@@@@QAEXKK@Z
_TEXT	SEGMENT
_inIndex$ = 8
_inCount$ = 12
?Remove@?$TCorArray@PAVCCpjGeoEdge@@@@QAEXKK@Z PROC NEAR ; TCorArray<CCpjGeoEdge *>::Remove, COMDAT
; _this$ = ecx

; 375  : 		for (NDword i=inIndex; i<(inIndex+inCount); i++)

	mov	edx, DWORD PTR _inIndex$[esp-4]
	push	esi
	push	edi
	mov	edi, DWORD PTR _inCount$[esp+4]
	mov	esi, ecx

; 376  : 			(&(*this)[i])->~T();
; 377  : 		CCorArray::Remove(inIndex, inCount, sizeof(T));

	test	edi, edi
	lea	ecx, DWORD PTR [edx+edi]
	je	SHORT $L51181
	mov	eax, DWORD PTR [esi]
	push	ebx
	mov	ebx, DWORD PTR [esi+4]
	sub	ebx, ecx
	lea	ecx, DWORD PTR [eax+ecx*4]
	shl	ebx, 2
	push	ebx
	lea	edx, DWORD PTR [eax+edx*4]
	push	ecx
	push	edx
	call	DWORD PTR __imp__memmove
	mov	eax, DWORD PTR [esi+4]
	add	esp, 12					; 0000000cH
	sub	eax, edi
	mov	DWORD PTR [esi+4], eax
	pop	ebx
$L51181:
	pop	edi
	pop	esi

; 378  : 	}

	ret	8
?Remove@?$TCorArray@PAVCCpjGeoEdge@@@@QAEXKK@Z ENDP	; TCorArray<CCpjGeoEdge *>::Remove
_TEXT	ENDS
PUBLIC	?AddNoConstruct@?$TCorArray@PAVOCpjFrames@@@@QAEKK@Z ; TCorArray<OCpjFrames *>::AddNoConstruct
PUBLIC	?AddNoConstruct@?$TCorArray@PAVOCpjSequence@@@@QAEKK@Z ; TCorArray<OCpjSequence *>::AddNoConstruct
PUBLIC	??0?$TCorArray@VCMacBone@@@@QAE@AAV0@@Z		; TCorArray<CMacBone>::TCorArray<CMacBone>
PUBLIC	??0?$TCorArray@PAVOMacChannel@@@@QAE@AAV0@@Z	; TCorArray<OMacChannel *>::TCorArray<OMacChannel *>
PUBLIC	??0OMacActor@@QAE@AAV0@@Z			; OMacActor::OMacActor
;	COMDAT xdata$x
xdata$x	SEGMENT
$T51412	DD	0ffffffffH
	DD	FLAT:$L51202
	DD	00H
	DD	FLAT:$L51203
	DD	0ffffffffH
	DD	FLAT:$L51188
	DD	02H
	DD	FLAT:$L51189
	DD	03H
	DD	FLAT:$L51190
	DD	04H
	DD	FLAT:$L51191
	DD	05H
	DD	FLAT:$L51250
	DD	05H
	DD	FLAT:$L51192
	DD	07H
	DD	FLAT:$L51293
	DD	07H
	DD	FLAT:$L51193
	DD	09H
	DD	FLAT:$L51330
	DD	09H
	DD	FLAT:$L51194
	DD	0bH
	DD	FLAT:$L51367
	DD	0cH
	DD	FLAT:$L51368
	DD	0bH
	DD	FLAT:$L51195
	DD	0eH
	DD	FLAT:$L51196
	DD	0fH
	DD	FLAT:$L51197
	DD	010H
	DD	FLAT:$L51198
	DD	011H
	DD	FLAT:$L51199
$T51399	DD	019930520H
	DD	013H
	DD	FLAT:$T51412
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ??0OMacActor@@QAE@AAV0@@Z
_TEXT	SEGMENT
$T51285 = 8
$T51322 = 8
$T51359 = 8
$T51386 = -16
$T51387 = -20
$T51396 = 8
__$EHRec$ = -12
___that$ = 8
_this$ = -24
??0OMacActor@@QAE@AAV0@@Z PROC NEAR			; OMacActor::OMacActor, COMDAT
; _this$ = ecx
	push	-1
	push	$L51411
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	ebp
	push	esi
	mov	esi, DWORD PTR ___that$[esp+32]
	push	edi
	mov	edi, ecx
	lea	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR _this$[esp+40], edi
	mov	DWORD PTR [edi], OFFSET FLAT:??_7IMsgTarget@@6B@ ; IMsgTarget::`vftable'
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [edi+4], eax
	mov	eax, DWORD PTR [ecx]
	lea	edx, DWORD PTR [edi+8]
	mov	DWORD PTR [edi+8], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], ecx
	lea	edx, DWORD PTR [esi+24]
	lea	eax, DWORD PTR [edi+24]
	mov	DWORD PTR __$EHRec$[esp+48], 0
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR [esi+40]
	lea	ecx, DWORD PTR [edi+44]
	mov	DWORD PTR [edi+40], eax
	mov	BYTE PTR __$EHRec$[esp+48], 1
	mov	DWORD PTR [ecx], 0
	mov	edx, DWORD PTR [esi+44]
	push	edx
	call	?Set@CCorString@@QAEXPAD@Z		; CCorString::Set
	mov	eax, DWORD PTR [esi+48]
	mov	DWORD PTR [edi+48], eax
	mov	ecx, DWORD PTR [esi+52]
	mov	DWORD PTR [edi+52], ecx
	mov	DWORD PTR [edi], OFFSET FLAT:??_7OObject@@6B@ ; OObject::`vftable'
	lea	edx, DWORD PTR [esi+56]
	lea	eax, DWORD PTR [edi+56]
	mov	ebp, 2
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR __$EHRec$[esp+48], ebp
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR [esi+68]
	lea	ecx, DWORD PTR [edi+72]
	mov	DWORD PTR [edi+68], eax
	mov	BYTE PTR __$EHRec$[esp+48], 3
	mov	DWORD PTR [ecx], 0
	mov	edx, DWORD PTR [esi+72]
	push	edx
	call	?Set@CCorString@@QAEXPAD@Z		; CCorString::Set
	lea	ecx, DWORD PTR [edi+76]
	mov	BYTE PTR __$EHRec$[esp+48], 4
	mov	DWORD PTR [ecx], 0
	mov	eax, DWORD PTR [esi+76]
	push	eax
	call	?Set@CCorString@@QAEXPAD@Z		; CCorString::Set
	mov	ecx, DWORD PTR [esi+80]
	mov	BYTE PTR __$EHRec$[esp+48], 5
	mov	DWORD PTR [edi+80], ecx
	mov	edx, DWORD PTR [esi+84]
	mov	DWORD PTR [edi+84], edx
	mov	eax, DWORD PTR [esi+88]
	mov	DWORD PTR [edi+88], eax
	mov	ecx, DWORD PTR [esi+92]
	mov	DWORD PTR [edi+92], ecx
	mov	edx, DWORD PTR [esi+96]
	mov	DWORD PTR [edi+96], edx
	mov	eax, DWORD PTR [esi+100]
	mov	DWORD PTR [edi+100], eax
	mov	ecx, DWORD PTR [esi+104]
	mov	DWORD PTR [edi+104], ecx
	mov	edx, DWORD PTR [esi+108]
	lea	ecx, DWORD PTR [edi+116]
	mov	DWORD PTR [edi+108], edx
	mov	eax, DWORD PTR [esi+112]
	mov	edx, ecx
	sub	edx, edi
	mov	DWORD PTR [edi+112], eax
	lea	eax, DWORD PTR [edx+esi+8]
	mov	edx, edi
	sub	edx, esi
$L11005:
	mov	ebx, DWORD PTR [eax-8]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR [ecx], ebx
	mov	ebx, DWORD PTR [eax-16]
	mov	DWORD PTR [ecx+4], ebx
	mov	ebx, DWORD PTR [eax-12]
	mov	DWORD PTR [edx+eax-12], ebx
	add	ecx, 12					; 0000000cH
	dec	ebp
	jne	SHORT $L11005
	mov	eax, DWORD PTR [esi+140]
	lea	ebp, DWORD PTR [edi+152]
	mov	DWORD PTR [edi+140], eax
	mov	ecx, DWORD PTR [esi+144]
	mov	DWORD PTR [edi+144], ecx
	mov	edx, DWORD PTR [esi+148]
	mov	DWORD PTR [edi+148], edx
	mov	eax, DWORD PTR [esi+156]
	xor	ebx, ebx
	push	4
	mov	ecx, ebp
	mov	DWORD PTR $T51285[esp+40], ebp
	mov	DWORD PTR [ebp], ebx
	mov	DWORD PTR [ebp+4], eax
	mov	DWORD PTR [ebp+8], eax
	mov	DWORD PTR [ebp+12], 4
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
	mov	DWORD PTR [ebp+4], ebx
	mov	eax, DWORD PTR [esi+156]
	test	eax, eax
	mov	BYTE PTR __$EHRec$[esp+48], 6
	jbe	SHORT $L51270
$L51268:
	push	1
	mov	ecx, ebp
	call	?AddNoConstruct@?$TCorArray@PAVOCpjSurface@@@@QAEKK@Z ; TCorArray<OCpjSurface *>::AddNoConstruct
	mov	ecx, DWORD PTR [ebp]
	lea	eax, DWORD PTR [ecx+eax*4]
	test	eax, eax
	je	SHORT $L51275
	mov	edx, DWORD PTR [esi+152]
	mov	ecx, DWORD PTR [edx+ebx*4]
	mov	DWORD PTR [eax], ecx
$L51275:
	mov	eax, DWORD PTR [esi+156]
	inc	ebx
	cmp	ebx, eax
	jb	SHORT $L51268
$L51270:
	mov	edx, DWORD PTR [esi+172]
	lea	ebp, DWORD PTR [edi+168]
	push	4
	push	edx
	mov	ecx, ebp
	mov	BYTE PTR __$EHRec$[esp+56], 7
	mov	DWORD PTR $T51322[esp+44], ebp
	call	??0CCorArray@@IAE@KK@Z			; CCorArray::CCorArray
	xor	ebx, ebx
	mov	BYTE PTR __$EHRec$[esp+48], 8
	mov	DWORD PTR [ebp+4], ebx
	mov	eax, DWORD PTR [esi+172]
	cmp	eax, ebx
	jbe	SHORT $L51309
$L51307:
	push	1
	mov	ecx, ebp
	call	?AddNoConstruct@?$TCorArray@PAVOCpjFrames@@@@QAEKK@Z ; TCorArray<OCpjFrames *>::AddNoConstruct
	mov	ecx, DWORD PTR [ebp]
	lea	eax, DWORD PTR [ecx+eax*4]
	test	eax, eax
	je	SHORT $L51314
	mov	edx, DWORD PTR [esi+168]
	mov	ecx, DWORD PTR [edx+ebx*4]
	mov	DWORD PTR [eax], ecx
$L51314:
	mov	eax, DWORD PTR [esi+172]
	inc	ebx
	cmp	ebx, eax
	jb	SHORT $L51307
$L51309:
	mov	edx, DWORD PTR [esi+188]
	lea	ebp, DWORD PTR [edi+184]
	push	4
	push	edx
	mov	ecx, ebp
	mov	BYTE PTR __$EHRec$[esp+56], 9
	mov	DWORD PTR $T51359[esp+44], ebp
	call	??0CCorArray@@IAE@KK@Z			; CCorArray::CCorArray
	xor	ebx, ebx
	mov	BYTE PTR __$EHRec$[esp+48], 10		; 0000000aH
	mov	DWORD PTR [ebp+4], ebx
	mov	eax, DWORD PTR [esi+188]
	test	eax, eax
	jbe	SHORT $L51346
$L51344:
	push	1
	mov	ecx, ebp
	call	?AddNoConstruct@?$TCorArray@PAVOCpjSequence@@@@QAEKK@Z ; TCorArray<OCpjSequence *>::AddNoConstruct
	mov	ecx, DWORD PTR [ebp]
	lea	eax, DWORD PTR [ecx+eax*4]
	test	eax, eax
	je	SHORT $L51351
	mov	edx, DWORD PTR [esi+184]
	mov	ecx, DWORD PTR [edx+ebx*4]
	mov	DWORD PTR [eax], ecx
$L51351:
	mov	eax, DWORD PTR [esi+188]
	inc	ebx
	cmp	ebx, eax
	jb	SHORT $L51344
$L51346:
	mov	edx, DWORD PTR [esi+204]
	lea	ebp, DWORD PTR [edi+200]
	push	4
	push	edx
	mov	ecx, ebp
	mov	BYTE PTR __$EHRec$[esp+56], 11		; 0000000bH
	mov	DWORD PTR $T51396[esp+44], ebp
	call	??0CCorArray@@IAE@KK@Z			; CCorArray::CCorArray
	xor	ebx, ebx
	mov	BYTE PTR __$EHRec$[esp+48], 12		; 0000000cH
	mov	DWORD PTR [ebp+4], ebx
	mov	eax, DWORD PTR [esi+204]
	test	eax, eax
	jbe	SHORT $L51383
$L51381:
	push	1
	mov	ecx, ebp
	call	?AddNoConstruct@?$TCorArray@VCCorString@@@@QAEKK@Z ; TCorArray<CCorString>::AddNoConstruct
	mov	ecx, DWORD PTR [ebp]
	lea	ecx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR $T51387[esp+40], ecx
	mov	DWORD PTR $T51386[esp+40], ecx
	test	ecx, ecx
	mov	BYTE PTR __$EHRec$[esp+48], 13		; 0000000dH
	je	SHORT $L51388
	mov	edx, DWORD PTR [esi+200]
	lea	eax, DWORD PTR [edx+ebx*4]
	push	eax
	call	??0CCorString@@QAE@ABV0@@Z		; CCorString::CCorString
$L51388:
	mov	eax, DWORD PTR [esi+204]
	inc	ebx
	cmp	ebx, eax
	mov	BYTE PTR __$EHRec$[esp+48], 12		; 0000000cH
	jb	SHORT $L51381
$L51383:
	lea	ecx, DWORD PTR [esi+216]
	mov	BYTE PTR __$EHRec$[esp+48], 14		; 0000000eH
	push	ecx
	lea	ecx, DWORD PTR [edi+216]
	call	??0?$TCorArray@VCCorString@@@@QAE@AAV0@@Z ; TCorArray<CCorString>::TCorArray<CCorString>
	lea	edx, DWORD PTR [esi+232]
	lea	ecx, DWORD PTR [edi+232]
	push	edx
	mov	BYTE PTR __$EHRec$[esp+52], 15		; 0000000fH
	call	??0?$TCorArray@VCCorString@@@@QAE@AAV0@@Z ; TCorArray<CCorString>::TCorArray<CCorString>
	lea	eax, DWORD PTR [esi+248]
	lea	ecx, DWORD PTR [edi+248]
	push	eax
	mov	BYTE PTR __$EHRec$[esp+52], 16		; 00000010H
	call	??0?$TCorArray@VCCorString@@@@QAE@AAV0@@Z ; TCorArray<CCorString>::TCorArray<CCorString>
	mov	ecx, DWORD PTR [esi+264]
	lea	eax, DWORD PTR [esi+272]
	mov	DWORD PTR [edi+264], ecx
	mov	dl, BYTE PTR [esi+268]
	push	eax
	lea	ecx, DWORD PTR [edi+272]
	mov	BYTE PTR __$EHRec$[esp+52], 17		; 00000011H
	mov	BYTE PTR [edi+268], dl
	call	??0?$TCorArray@VCMacBone@@@@QAE@AAV0@@Z	; TCorArray<CMacBone>::TCorArray<CMacBone>
	lea	ecx, DWORD PTR [esi+288]
	mov	BYTE PTR __$EHRec$[esp+48], 18		; 00000012H
	push	ecx
	lea	ecx, DWORD PTR [edi+288]
	call	??0?$TCorArray@PAVOMacChannel@@@@QAE@AAV0@@Z ; TCorArray<OMacChannel *>::TCorArray<OMacChannel *>
	mov	edx, DWORD PTR [esi+304]
	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR [edi+304], edx
	mov	DWORD PTR [edi], OFFSET FLAT:??_7OMacActor@@6B@ ; OMacActor::`vftable'
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 24					; 00000018H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L51202:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1CObjLink@@QAE@XZ			; CObjLink::~CObjLink
$L51203:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	jmp	??1CObjLink@@QAE@XZ			; CObjLink::~CObjLink
$L51188:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1OObject@@UAE@XZ			; OObject::~OObject
$L51189:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 56					; 00000038H
	jmp	??1CMacActorLink@@QAE@XZ		; CMacActorLink::~CMacActorLink
$L51190:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 72					; 00000048H
	jmp	??1CCorString@@QAE@XZ			; CCorString::~CCorString
$L51191:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 76					; 0000004cH
	jmp	??1CCorString@@QAE@XZ			; CCorString::~CCorString
$L51250:
	mov	ecx, DWORD PTR $T51285[ebp-4]
	jmp	??1CCorArray@@IAE@XZ			; CCorArray::~CCorArray
$L51192:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 152				; 00000098H
	jmp	??1?$TCorArray@PAVOCpjSurface@@@@QAE@XZ	; TCorArray<OCpjSurface *>::~TCorArray<OCpjSurface *>
$L51293:
	mov	ecx, DWORD PTR $T51322[ebp-4]
	jmp	??1CCorArray@@IAE@XZ			; CCorArray::~CCorArray
$L51193:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 168				; 000000a8H
	jmp	??1?$TCorArray@PAVOCpjFrames@@@@QAE@XZ	; TCorArray<OCpjFrames *>::~TCorArray<OCpjFrames *>
$L51330:
	mov	ecx, DWORD PTR $T51359[ebp-4]
	jmp	??1CCorArray@@IAE@XZ			; CCorArray::~CCorArray
$L51194:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 184				; 000000b8H
	jmp	??1?$TCorArray@PAVOCpjSequence@@@@QAE@XZ ; TCorArray<OCpjSequence *>::~TCorArray<OCpjSequence *>
$L51367:
	mov	ecx, DWORD PTR $T51396[ebp-4]
	jmp	??1CCorArray@@IAE@XZ			; CCorArray::~CCorArray
$L51368:
	mov	eax, DWORD PTR $T51387[ebp]
	push	eax
	mov	ecx, DWORD PTR $T51386[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
$L51195:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 200				; 000000c8H
	jmp	??1?$TCorArray@VCCorString@@@@QAE@XZ	; TCorArray<CCorString>::~TCorArray<CCorString>
$L51196:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 216				; 000000d8H
	jmp	??1?$TCorArray@VCCorString@@@@QAE@XZ	; TCorArray<CCorString>::~TCorArray<CCorString>
$L51197:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 232				; 000000e8H
	jmp	??1?$TCorArray@VCCorString@@@@QAE@XZ	; TCorArray<CCorString>::~TCorArray<CCorString>
$L51198:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 248				; 000000f8H
	jmp	??1?$TCorArray@VCCorString@@@@QAE@XZ	; TCorArray<CCorString>::~TCorArray<CCorString>
$L51199:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 272				; 00000110H
	jmp	??1?$TCorArray@VCMacBone@@@@QAE@XZ	; TCorArray<CMacBone>::~TCorArray<CMacBone>
$L51411:
	mov	eax, OFFSET FLAT:$T51399
	jmp	___CxxFrameHandler
text$x	ENDS
??0OMacActor@@QAE@AAV0@@Z ENDP				; OMacActor::OMacActor
;	COMDAT xdata$x
; File C:\duke4\Cannibal\VecMain.h
xdata$x	SEGMENT
$T51677	DD	0ffffffffH
	DD	FLAT:$L51423
$T51672	DD	019930520H
	DD	01H
	DD	FLAT:$T51677
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File C:\duke4\Cannibal\CorMain.h
xdata$x	ENDS
;	COMDAT ??0?$TCorArray@VCMacBone@@@@QAE@AAV0@@Z
_TEXT	SEGMENT
_this$ = -16
_i$ = -20
_inArray$ = 8
__$EHRec$ = -12
??0?$TCorArray@VCMacBone@@@@QAE@AAV0@@Z PROC NEAR	; TCorArray<CMacBone>::TCorArray<CMacBone>, COMDAT
; _this$ = ecx

; 263  : 	{

	push	-1
	push	$L51676
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 8
	push	ebp
	mov	ebp, DWORD PTR _inArray$[esp+20]
	push	esi
	push	edi
	mov	eax, DWORD PTR [ebp+4]
	mov	esi, ecx
	xor	edi, edi
	push	140					; 0000008cH
	mov	DWORD PTR _this$[esp+36], esi
	mov	DWORD PTR [esi], edi
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], 140			; 0000008cH
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc

; 264  : 		m_Count = 0;

	mov	DWORD PTR [esi+4], edi

; 265  : 		for (NDword i=0;i<inArray.m_Count;i++)

	mov	eax, DWORD PTR [ebp+4]
	cmp	eax, edi
	mov	DWORD PTR __$EHRec$[esp+40], edi
	mov	DWORD PTR _i$[esp+32], edi
	jbe	$L51675
	mov	DWORD PTR 8+[esp+28], edi
	push	ebx
$L14488:

; 266  : 			new(&(*this)[AddNoConstruct()]) T(inArray[i]);

	mov	ebx, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	lea	eax, DWORD PTR [ebx+1]
	cmp	eax, ecx
	mov	DWORD PTR [esi+4], eax
	jbe	SHORT $L51433
	mov	ecx, eax
	push	140					; 0000008cH
	shr	ecx, 2
	lea	edx, DWORD PTR [ecx+eax+32]
	mov	ecx, esi
	mov	DWORD PTR [esi+8], edx
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
$L51433:
	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ebx*8]
	sub	eax, ebx
	lea	eax, DWORD PTR [eax+eax*4]
	lea	eax, DWORD PTR [ecx+eax*4]
	cmp	eax, edi
	je	$L51421
	mov	ecx, DWORD PTR [ebp]
	mov	edx, DWORD PTR 8+[esp+32]
	add	ecx, edx
	mov	edx, 1065353216				; 3f800000H
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], edi
	mov	DWORD PTR [eax+8], edi
	mov	DWORD PTR [eax+12], edi
	mov	DWORD PTR [eax+16], edx
	mov	DWORD PTR [eax+20], edi
	mov	DWORD PTR [eax+24], edi
	mov	DWORD PTR [eax+28], edi
	mov	DWORD PTR [eax+32], edx
	mov	ebx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ebx
	mov	ebx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ebx
	mov	ebx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ebx
	mov	ebx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], ebx
	mov	ebx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], ebx
	mov	ebx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+20], ebx
	mov	ebx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax+24], ebx
	mov	ebx, DWORD PTR [ecx+28]
	mov	DWORD PTR [eax+28], ebx
	mov	ebx, DWORD PTR [ecx+32]
	mov	DWORD PTR [eax+32], ebx
	mov	ebx, DWORD PTR [ecx+36]
	mov	DWORD PTR [eax+36], ebx
	mov	ebx, DWORD PTR [ecx+40]
	mov	DWORD PTR [eax+40], ebx
	mov	ebx, DWORD PTR [ecx+44]
	mov	DWORD PTR [eax+44], ebx
	mov	ebx, DWORD PTR [ecx+48]
	mov	DWORD PTR [eax+48], ebx
	mov	ebx, DWORD PTR [ecx+52]
	mov	DWORD PTR [eax+52], ebx
	mov	ebx, DWORD PTR [ecx+56]
	mov	DWORD PTR [eax+56], ebx
	mov	DWORD PTR [eax+60], edx
	mov	DWORD PTR [eax+64], edi
	mov	DWORD PTR [eax+68], edi
	mov	DWORD PTR [eax+72], edi
	mov	DWORD PTR [eax+76], edx
	mov	DWORD PTR [eax+80], edi
	mov	DWORD PTR [eax+84], edi
	mov	DWORD PTR [eax+88], edi
	mov	DWORD PTR [eax+92], edx
	mov	edx, DWORD PTR [ecx+60]
	mov	DWORD PTR [eax+60], edx
	mov	edx, DWORD PTR [ecx+64]
	mov	DWORD PTR [eax+64], edx
	mov	edx, DWORD PTR [ecx+68]
	mov	DWORD PTR [eax+68], edx
	mov	edx, DWORD PTR [ecx+72]
	mov	DWORD PTR [eax+72], edx
	mov	edx, DWORD PTR [ecx+76]
	mov	DWORD PTR [eax+76], edx
	mov	edx, DWORD PTR [ecx+80]
	mov	DWORD PTR [eax+80], edx
	mov	edx, DWORD PTR [ecx+84]
	mov	DWORD PTR [eax+84], edx
	mov	edx, DWORD PTR [ecx+88]
	mov	DWORD PTR [eax+88], edx
	mov	edx, DWORD PTR [ecx+92]
	mov	DWORD PTR [eax+92], edx
	mov	edx, DWORD PTR [ecx+96]
	mov	DWORD PTR [eax+96], edx
	mov	edx, DWORD PTR [ecx+100]
	mov	DWORD PTR [eax+100], edx
	mov	edx, DWORD PTR [ecx+104]
	mov	DWORD PTR [eax+104], edx
	mov	edx, DWORD PTR [ecx+108]
	mov	DWORD PTR [eax+108], edx
	mov	edx, DWORD PTR [ecx+112]
	mov	DWORD PTR [eax+112], edx
	mov	edx, DWORD PTR [ecx+116]
	mov	DWORD PTR [eax+116], edx
	mov	dl, BYTE PTR [ecx+120]
	mov	BYTE PTR [eax+120], dl
	mov	edx, DWORD PTR [ecx+124]
	mov	DWORD PTR [eax+124], edx
	mov	edx, DWORD PTR [ecx+128]
	mov	DWORD PTR [eax+128], edx
	mov	edx, DWORD PTR [ecx+132]
	mov	DWORD PTR [eax+132], edx
	mov	ecx, DWORD PTR [ecx+136]
	mov	DWORD PTR [eax+136], ecx
$L51421:
	mov	eax, DWORD PTR _i$[esp+36]
	mov	edx, DWORD PTR 8+[esp+32]
	mov	ecx, DWORD PTR [ebp+4]
	inc	eax
	add	edx, 140				; 0000008cH
	cmp	eax, ecx
	mov	DWORD PTR _i$[esp+36], eax
	mov	DWORD PTR 8+[esp+32], edx
	jb	$L14488
	pop	ebx
$L51675:

; 267  : 	}

	mov	ecx, DWORD PTR __$EHRec$[esp+32]
	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 20					; 00000014H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L51423:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CCorArray@@IAE@XZ			; CCorArray::~CCorArray
$L51676:
	mov	eax, OFFSET FLAT:$T51672
	jmp	___CxxFrameHandler
text$x	ENDS
??0?$TCorArray@VCMacBone@@@@QAE@AAV0@@Z ENDP		; TCorArray<CMacBone>::TCorArray<CMacBone>
;	COMDAT xdata$x
xdata$x	SEGMENT
$T51736	DD	0ffffffffH
	DD	FLAT:$L51688
$T51730	DD	019930520H
	DD	01H
	DD	FLAT:$T51736
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ??0?$TCorArray@PAVOMacChannel@@@@QAE@AAV0@@Z
_TEXT	SEGMENT
_this$ = -16
_inArray$ = 8
__$EHRec$ = -12
??0?$TCorArray@PAVOMacChannel@@@@QAE@AAV0@@Z PROC NEAR	; TCorArray<OMacChannel *>::TCorArray<OMacChannel *>, COMDAT
; _this$ = ecx

; 263  : 	{

	push	-1
	push	$L51735
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	push	ebx
	mov	ebx, DWORD PTR _inArray$[esp+16]
	push	ebp
	push	esi
	mov	eax, DWORD PTR [ebx+4]
	mov	esi, ecx
	xor	ebp, ebp
	push	4
	mov	DWORD PTR _this$[esp+32], esi
	mov	DWORD PTR [esi], ebp
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], 4
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc

; 264  : 		m_Count = 0;

	mov	DWORD PTR [esi+4], ebp

; 265  : 		for (NDword i=0;i<inArray.m_Count;i++)

	mov	eax, DWORD PTR [ebx+4]
	cmp	eax, ebp
	mov	DWORD PTR __$EHRec$[esp+36], ebp
	jbe	SHORT $L51733
	push	edi
$L14544:

; 266  : 			new(&(*this)[AddNoConstruct()]) T(inArray[i]);

	mov	edi, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	lea	eax, DWORD PTR [edi+1]
	cmp	eax, ecx
	mov	DWORD PTR [esi+4], eax
	jbe	SHORT $L51718
	mov	ecx, eax
	mov	DWORD PTR [esi+12], 4
	shr	ecx, 2
	lea	eax, DWORD PTR [ecx+eax+32]
	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	mov	DWORD PTR [esi+8], eax
	je	SHORT $L51711
	test	eax, eax
	je	SHORT $L51713
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+8]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [esi+12]
	push	ecx
	mov	ecx, DWORD PTR [esi]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+4]
	mov	DWORD PTR [esi], eax
	jmp	SHORT $L51718
$L51713:
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L51717:
	mov	DWORD PTR [esi], 0
$L51718:
	mov	edx, DWORD PTR [esi]
	lea	eax, DWORD PTR [edx+edi*4]
	test	eax, eax
	je	SHORT $L51686
	mov	ecx, DWORD PTR [ebx]
	mov	edx, DWORD PTR [ecx+ebp*4]
	mov	DWORD PTR [eax], edx
$L51686:
	mov	eax, DWORD PTR [ebx+4]
	inc	ebp
	cmp	ebp, eax
	jb	SHORT $L14544
	pop	edi
$L51733:

; 267  : 	}

	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	ret	4

; 266  : 			new(&(*this)[AddNoConstruct()]) T(inArray[i]);

$L51711:
	test	eax, eax
	je	SHORT $L51717
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+8]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [esi+12]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	DWORD PTR [esi], eax
	jmp	SHORT $L51718
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L51688:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CCorArray@@IAE@XZ			; CCorArray::~CCorArray
$L51735:
	mov	eax, OFFSET FLAT:$T51730
	jmp	___CxxFrameHandler
text$x	ENDS
??0?$TCorArray@PAVOMacChannel@@@@QAE@AAV0@@Z ENDP	; TCorArray<OMacChannel *>::TCorArray<OMacChannel *>
; Function compile flags: /Ogty
;	COMDAT ?AddNoConstruct@?$TCorArray@PAVOCpjFrames@@@@QAEKK@Z
_TEXT	SEGMENT
_inCount$ = 8
?AddNoConstruct@?$TCorArray@PAVOCpjFrames@@@@QAEKK@Z PROC NEAR ; TCorArray<OCpjFrames *>::AddNoConstruct, COMDAT
; _this$ = ecx

; 322  : 		NDword i = m_Count;
; 323  : 		if ((m_Count+=inCount)>m_Limit)

	mov	eax, DWORD PTR _inCount$[esp-4]
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	add	eax, edi
	cmp	eax, ecx
	mov	DWORD PTR [esi+4], eax
	jbe	SHORT $L51753

; 324  : 		{
; 325  : 			m_Limit = m_Count + (m_Count>>2) + 32;

	mov	ecx, eax

; 326  : 			Realloc(sizeof(T));

	mov	DWORD PTR [esi+12], 4
	shr	ecx, 2
	lea	eax, DWORD PTR [ecx+eax+32]
	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	mov	DWORD PTR [esi+8], eax
	je	SHORT $L51744
	test	eax, eax
	je	SHORT $L51746
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [esi+8]
	push	ecx
	mov	ecx, DWORD PTR [esi]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+4]
	mov	DWORD PTR [esi], eax

; 327  : 		}
; 328  : 		return(i);

	mov	eax, edi
	pop	edi
	pop	esi

; 329  : 	}

	ret	4

; 326  : 			Realloc(sizeof(T));

$L51746:
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L51750:
	mov	DWORD PTR [esi], 0
$L51753:

; 327  : 		}
; 328  : 		return(i);

	mov	eax, edi
	pop	edi
	pop	esi

; 329  : 	}

	ret	4

; 326  : 			Realloc(sizeof(T));

$L51744:
	test	eax, eax
	je	SHORT $L51750
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [esi+8]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	DWORD PTR [esi], eax

; 327  : 		}
; 328  : 		return(i);

	mov	eax, edi
	pop	edi
	pop	esi

; 329  : 	}

	ret	4
?AddNoConstruct@?$TCorArray@PAVOCpjFrames@@@@QAEKK@Z ENDP ; TCorArray<OCpjFrames *>::AddNoConstruct
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?AddNoConstruct@?$TCorArray@PAVOCpjSequence@@@@QAEKK@Z
_TEXT	SEGMENT
_inCount$ = 8
?AddNoConstruct@?$TCorArray@PAVOCpjSequence@@@@QAEKK@Z PROC NEAR ; TCorArray<OCpjSequence *>::AddNoConstruct, COMDAT
; _this$ = ecx

; 322  : 		NDword i = m_Count;
; 323  : 		if ((m_Count+=inCount)>m_Limit)

	mov	eax, DWORD PTR _inCount$[esp-4]
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	add	eax, edi
	cmp	eax, ecx
	mov	DWORD PTR [esi+4], eax
	jbe	SHORT $L51768

; 324  : 		{
; 325  : 			m_Limit = m_Count + (m_Count>>2) + 32;

	mov	ecx, eax

; 326  : 			Realloc(sizeof(T));

	mov	DWORD PTR [esi+12], 4
	shr	ecx, 2
	lea	eax, DWORD PTR [ecx+eax+32]
	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	mov	DWORD PTR [esi+8], eax
	je	SHORT $L51759
	test	eax, eax
	je	SHORT $L51761
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [esi+8]
	push	ecx
	mov	ecx, DWORD PTR [esi]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+4]
	mov	DWORD PTR [esi], eax

; 327  : 		}
; 328  : 		return(i);

	mov	eax, edi
	pop	edi
	pop	esi

; 329  : 	}

	ret	4

; 326  : 			Realloc(sizeof(T));

$L51761:
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L51765:
	mov	DWORD PTR [esi], 0
$L51768:

; 327  : 		}
; 328  : 		return(i);

	mov	eax, edi
	pop	edi
	pop	esi

; 329  : 	}

	ret	4

; 326  : 			Realloc(sizeof(T));

$L51759:
	test	eax, eax
	je	SHORT $L51765
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [esi+8]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	DWORD PTR [esi], eax

; 327  : 		}
; 328  : 		return(i);

	mov	eax, edi
	pop	edi
	pop	esi

; 329  : 	}

	ret	4
?AddNoConstruct@?$TCorArray@PAVOCpjSequence@@@@QAEKK@Z ENDP ; TCorArray<OCpjSequence *>::AddNoConstruct
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?AddNoConstruct@?$TCorArray@PAVCCpjGeoTri@@@@QAEKK@Z
_TEXT	SEGMENT
_inCount$ = 8
?AddNoConstruct@?$TCorArray@PAVCCpjGeoTri@@@@QAEKK@Z PROC NEAR ; TCorArray<CCpjGeoTri *>::AddNoConstruct, COMDAT
; _this$ = ecx

; 322  : 		NDword i = m_Count;
; 323  : 		if ((m_Count+=inCount)>m_Limit)

	mov	eax, DWORD PTR _inCount$[esp-4]
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	add	eax, edi
	cmp	eax, ecx
	mov	DWORD PTR [esi+4], eax
	jbe	SHORT $L51783

; 324  : 		{
; 325  : 			m_Limit = m_Count + (m_Count>>2) + 32;

	mov	ecx, eax

; 326  : 			Realloc(sizeof(T));

	mov	DWORD PTR [esi+12], 4
	shr	ecx, 2
	lea	eax, DWORD PTR [ecx+eax+32]
	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	mov	DWORD PTR [esi+8], eax
	je	SHORT $L51774
	test	eax, eax
	je	SHORT $L51776
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [esi+8]
	push	ecx
	mov	ecx, DWORD PTR [esi]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+4]
	mov	DWORD PTR [esi], eax

; 327  : 		}
; 328  : 		return(i);

	mov	eax, edi
	pop	edi
	pop	esi

; 329  : 	}

	ret	4

; 326  : 			Realloc(sizeof(T));

$L51776:
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L51780:
	mov	DWORD PTR [esi], 0
$L51783:

; 327  : 		}
; 328  : 		return(i);

	mov	eax, edi
	pop	edi
	pop	esi

; 329  : 	}

	ret	4

; 326  : 			Realloc(sizeof(T));

$L51774:
	test	eax, eax
	je	SHORT $L51780
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [esi+8]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	DWORD PTR [esi], eax

; 327  : 		}
; 328  : 		return(i);

	mov	eax, edi
	pop	edi
	pop	esi

; 329  : 	}

	ret	4
?AddNoConstruct@?$TCorArray@PAVCCpjGeoTri@@@@QAEKK@Z ENDP ; TCorArray<CCpjGeoTri *>::AddNoConstruct
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?Remove@?$TCorArray@PAVCCpjGeoTri@@@@QAEXKK@Z
_TEXT	SEGMENT
_inIndex$ = 8
_inCount$ = 12
?Remove@?$TCorArray@PAVCCpjGeoTri@@@@QAEXKK@Z PROC NEAR	; TCorArray<CCpjGeoTri *>::Remove, COMDAT
; _this$ = ecx

; 375  : 		for (NDword i=inIndex; i<(inIndex+inCount); i++)

	mov	edx, DWORD PTR _inIndex$[esp-4]
	push	esi
	push	edi
	mov	edi, DWORD PTR _inCount$[esp+4]
	mov	esi, ecx

; 376  : 			(&(*this)[i])->~T();
; 377  : 		CCorArray::Remove(inIndex, inCount, sizeof(T));

	test	edi, edi
	lea	ecx, DWORD PTR [edx+edi]
	je	SHORT $L51788
	mov	eax, DWORD PTR [esi]
	push	ebx
	mov	ebx, DWORD PTR [esi+4]
	sub	ebx, ecx
	lea	ecx, DWORD PTR [eax+ecx*4]
	shl	ebx, 2
	push	ebx
	lea	edx, DWORD PTR [eax+edx*4]
	push	ecx
	push	edx
	call	DWORD PTR __imp__memmove
	mov	eax, DWORD PTR [esi+4]
	add	esp, 12					; 0000000cH
	sub	eax, edi
	mov	DWORD PTR [esi+4], eax
	pop	ebx
$L51788:
	pop	edi
	pop	esi

; 378  : 	}

	ret	8
?Remove@?$TCorArray@PAVCCpjGeoTri@@@@QAEXKK@Z ENDP	; TCorArray<CCpjGeoTri *>::Remove
_TEXT	ENDS
PUBLIC	??4?$TCorArray@PAVOCpjSurface@@@@QAEAAV0@AAV0@@Z ; TCorArray<OCpjSurface *>::operator=
PUBLIC	??4?$TCorArray@PAVOCpjFrames@@@@QAEAAV0@AAV0@@Z	; TCorArray<OCpjFrames *>::operator=
PUBLIC	??4?$TCorArray@PAVOCpjSequence@@@@QAEAAV0@AAV0@@Z ; TCorArray<OCpjSequence *>::operator=
PUBLIC	??4?$TCorArray@VCMacBone@@@@QAEAAV0@AAV0@@Z	; TCorArray<CMacBone>::operator=
PUBLIC	??4?$TCorArray@PAVOMacChannel@@@@QAEAAV0@AAV0@@Z ; TCorArray<OMacChannel *>::operator=
PUBLIC	??4?$TCorArray@VCCorString@@@@QAEAAV0@AAV0@@Z	; TCorArray<CCorString>::operator=
PUBLIC	??4OMacActor@@QAEAAV0@AAV0@@Z			; OMacActor::operator=
; Function compile flags: /Ogty
;	COMDAT ??4OMacActor@@QAEAAV0@AAV0@@Z
_TEXT	SEGMENT
___that$ = 8
??4OMacActor@@QAEAAV0@AAV0@@Z PROC NEAR			; OMacActor::operator=, COMDAT
; _this$ = ecx
	push	ebx
	mov	ebx, DWORD PTR ___that$[esp]
	push	ebp
	push	esi
	mov	eax, DWORD PTR [ebx+4]
	mov	esi, ecx
	lea	ecx, DWORD PTR [ebx+8]
	push	edi
	mov	DWORD PTR [esi+4], eax
	lea	edx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	lea	eax, DWORD PTR [esi+24]
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], ecx
	lea	edx, DWORD PTR [ebx+24]
	mov	ecx, DWORD PTR [ebx+24]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR [ebx+40]
	mov	DWORD PTR [esi+40], eax
	mov	ecx, DWORD PTR [ebx+44]
	push	ecx
	lea	ecx, DWORD PTR [esi+44]
	call	?Set@CCorString@@QAEXPAD@Z		; CCorString::Set
	mov	edx, DWORD PTR [ebx+48]
	lea	ecx, DWORD PTR [ebx+56]
	mov	DWORD PTR [esi+48], edx
	mov	eax, DWORD PTR [ebx+52]
	mov	DWORD PTR [esi+52], eax
	mov	eax, DWORD PTR [ecx]
	lea	edx, DWORD PTR [esi+56]
	mov	DWORD PTR [esi+56], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], ecx
	mov	edx, DWORD PTR [ebx+68]
	mov	DWORD PTR [esi+68], edx
	mov	eax, DWORD PTR [ebx+72]
	push	eax
	lea	ecx, DWORD PTR [esi+72]
	call	?Set@CCorString@@QAEXPAD@Z		; CCorString::Set
	mov	ebp, DWORD PTR [ebx+76]
	test	ebp, ebp
	je	SHORT $L51828
	cmp	BYTE PTR [ebp], 0
	jne	SHORT $L51828
	xor	ebp, ebp
$L51828:
	mov	edi, DWORD PTR [esi+76]
	test	edi, edi
	je	SHORT $L51829
	or	ecx, -1
	xor	eax, eax
	repne scasb
	mov	eax, DWORD PTR ?sMemTotal@CCorString@@0KA ; CCorString::sMemTotal
	or	edx, -1
	not	ecx
	dec	ecx
	sub	edx, ecx
	add	eax, edx
	mov	DWORD PTR ?sMemTotal@CCorString@@0KA, eax ; CCorString::sMemTotal
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+76]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L51829:
	test	ebp, ebp
	mov	DWORD PTR [esi+76], 0
	je	SHORT $L51832
	mov	edi, ebp
	or	ecx, -1
	xor	eax, eax
	repne scasb
	not	ecx
	dec	ecx
	mov	edi, ecx
	inc	edi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	edi
	mov	ecx, eax
	call	DWORD PTR [edx]
	test	eax, eax
	mov	DWORD PTR [esi+76], eax
	je	SHORT $L51832
$L51826:
	mov	cl, BYTE PTR [ebp]
	inc	ebp
	mov	BYTE PTR [eax], cl
	inc	eax
	test	cl, cl
	jne	SHORT $L51826
	add	DWORD PTR ?sMemTotal@CCorString@@0KA, edi ; CCorString::sMemTotal
$L51832:
	mov	eax, DWORD PTR [ebx+80]
	mov	edi, 2
	mov	DWORD PTR [esi+80], eax
	mov	ecx, DWORD PTR [ebx+84]
	mov	DWORD PTR [esi+84], ecx
	mov	edx, DWORD PTR [ebx+88]
	mov	DWORD PTR [esi+88], edx
	mov	eax, DWORD PTR [ebx+92]
	mov	DWORD PTR [esi+92], eax
	mov	ecx, DWORD PTR [ebx+96]
	mov	DWORD PTR [esi+96], ecx
	mov	edx, DWORD PTR [ebx+100]
	mov	DWORD PTR [esi+100], edx
	mov	eax, DWORD PTR [ebx+104]
	mov	DWORD PTR [esi+104], eax
	mov	ecx, DWORD PTR [ebx+108]
	mov	DWORD PTR [esi+108], ecx
	mov	edx, DWORD PTR [ebx+112]
	mov	DWORD PTR [esi+112], edx
	mov	edx, ebx
	lea	ecx, DWORD PTR [ebx+116]
	lea	eax, DWORD PTR [esi+120]
	sub	edx, esi
$L11009:
	mov	ebp, DWORD PTR [ecx]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR [eax-4], ebp
	mov	ebp, DWORD PTR [edx+eax]
	mov	DWORD PTR [eax], ebp
	mov	ebp, DWORD PTR [ecx-4]
	mov	DWORD PTR [eax+4], ebp
	add	eax, 12					; 0000000cH
	dec	edi
	jne	SHORT $L11009
	mov	eax, DWORD PTR [ebx+140]
	mov	DWORD PTR [esi+140], eax
	mov	ecx, DWORD PTR [ebx+144]
	mov	DWORD PTR [esi+144], ecx
	mov	edx, DWORD PTR [ebx+148]
	lea	eax, DWORD PTR [ebx+152]
	lea	ecx, DWORD PTR [esi+152]
	push	eax
	mov	DWORD PTR [esi+148], edx
	call	??4?$TCorArray@PAVOCpjSurface@@@@QAEAAV0@AAV0@@Z ; TCorArray<OCpjSurface *>::operator=
	lea	ecx, DWORD PTR [ebx+168]
	push	ecx
	lea	ecx, DWORD PTR [esi+168]
	call	??4?$TCorArray@PAVOCpjFrames@@@@QAEAAV0@AAV0@@Z ; TCorArray<OCpjFrames *>::operator=
	lea	edx, DWORD PTR [ebx+184]
	lea	ecx, DWORD PTR [esi+184]
	push	edx
	call	??4?$TCorArray@PAVOCpjSequence@@@@QAEAAV0@AAV0@@Z ; TCorArray<OCpjSequence *>::operator=
	lea	eax, DWORD PTR [ebx+200]
	lea	ecx, DWORD PTR [esi+200]
	push	eax
	call	??4?$TCorArray@VCCorString@@@@QAEAAV0@AAV0@@Z ; TCorArray<CCorString>::operator=
	lea	ecx, DWORD PTR [ebx+216]
	push	ecx
	lea	ecx, DWORD PTR [esi+216]
	call	??4?$TCorArray@VCCorString@@@@QAEAAV0@AAV0@@Z ; TCorArray<CCorString>::operator=
	lea	edx, DWORD PTR [ebx+232]
	lea	ecx, DWORD PTR [esi+232]
	push	edx
	call	??4?$TCorArray@VCCorString@@@@QAEAAV0@AAV0@@Z ; TCorArray<CCorString>::operator=
	lea	eax, DWORD PTR [ebx+248]
	lea	ecx, DWORD PTR [esi+248]
	push	eax
	call	??4?$TCorArray@VCCorString@@@@QAEAAV0@AAV0@@Z ; TCorArray<CCorString>::operator=
	mov	ecx, DWORD PTR [ebx+264]
	lea	eax, DWORD PTR [ebx+272]
	mov	DWORD PTR [esi+264], ecx
	mov	dl, BYTE PTR [ebx+268]
	push	eax
	lea	ecx, DWORD PTR [esi+272]
	mov	BYTE PTR [esi+268], dl
	call	??4?$TCorArray@VCMacBone@@@@QAEAAV0@AAV0@@Z ; TCorArray<CMacBone>::operator=
	lea	ecx, DWORD PTR [ebx+288]
	push	ecx
	lea	ecx, DWORD PTR [esi+288]
	call	??4?$TCorArray@PAVOMacChannel@@@@QAEAAV0@AAV0@@Z ; TCorArray<OMacChannel *>::operator=
	mov	edx, DWORD PTR [ebx+304]
	mov	eax, esi
	mov	DWORD PTR [esi+304], edx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	4
??4OMacActor@@QAEAAV0@AAV0@@Z ENDP			; OMacActor::operator=
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
$T51927	DD	0ffffffffH
	DD	FLAT:$L51868
$T51918	DD	019930520H
	DD	01H
	DD	FLAT:$T51927
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ??4?$TCorArray@VCCorString@@@@QAEAAV0@AAV0@@Z
_TEXT	SEGMENT
_i$ = -24
$T51864 = -16
$T51865 = -20
__$EHRec$ = -12
_inArray$ = 8
??4?$TCorArray@VCCorString@@@@QAEAAV0@AAV0@@Z PROC NEAR	; TCorArray<CCorString>::operator=, COMDAT
; _this$ = ecx

; 269  : 	{

	mov	eax, DWORD PTR fs:__except_list
	push	-1
	push	$L51925
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	edi

; 270  : 		if (this == &inArray)

	mov	edi, DWORD PTR _inArray$[esp+28]
	mov	ebx, ecx
	cmp	ebx, edi

; 271  : 			return(*this);

	je	$L51926
	push	esi

; 272  : 		m_Count = 0;

	xor	esi, esi
	mov	DWORD PTR [ebx+4], esi

; 273  : 		m_Limit = inArray.m_Count;

	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [ebx+8], eax

; 274  : 		Realloc(sizeof(T));

	mov	eax, DWORD PTR [ebx]
	cmp	eax, esi
	mov	eax, DWORD PTR [ebx+8]
	mov	DWORD PTR [ebx+12], 4
	je	$L51872
	cmp	eax, esi
	je	SHORT $L51874
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [ebx+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [ebx+8]
	push	ecx
	mov	ecx, DWORD PTR [ebx]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+4]
	mov	DWORD PTR [ebx], eax
	jmp	SHORT $L51879
$L51874:
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [ebx]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L51878:
	mov	DWORD PTR [ebx], esi
$L51879:

; 275  : 		for (NDword i=0;i<inArray.m_Count;i++)

	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR _i$[esp+36], esi
	cmp	eax, esi
	jbe	$L14269
	push	ebp
$L14267:

; 276  : 			new(&(*this)[AddNoConstruct()]) T(inArray[i]);

	mov	esi, DWORD PTR [ebx+4]
	mov	ecx, DWORD PTR [ebx+8]
	lea	eax, DWORD PTR [esi+1]
	cmp	eax, ecx
	mov	DWORD PTR [ebx+4], eax
	jbe	SHORT $L51884
	mov	edx, eax
	push	4
	shr	edx, 2
	mov	ecx, ebx
	lea	eax, DWORD PTR [edx+eax+32]
	mov	DWORD PTR [ebx+8], eax
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
$L51884:
	mov	ecx, DWORD PTR [ebx]
	lea	ebp, DWORD PTR [ecx+esi*4]
	mov	DWORD PTR $T51865[esp+40], ebp
	mov	DWORD PTR $T51864[esp+40], ebp
	test	ebp, ebp
	mov	DWORD PTR __$EHRec$[esp+48], 0
	je	SHORT $L51914
	mov	edx, DWORD PTR [edi]
	mov	eax, DWORD PTR _i$[esp+40]
	mov	DWORD PTR [ebp], 0
	mov	esi, DWORD PTR [edx+eax*4]
	lea	eax, DWORD PTR [edx+eax*4]
	test	esi, esi
	je	SHORT $L51911
	cmp	BYTE PTR [esi], 0
	jne	SHORT $L51911
	xor	esi, esi
$L51911:
	test	esi, esi
	mov	DWORD PTR [ebp], 0
	je	SHORT $L51914
	mov	edi, esi
	or	ecx, -1
	xor	eax, eax
	repne scasb
	not	ecx
	dec	ecx
	mov	edi, ecx
	inc	edi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	edi
	mov	ecx, eax
	call	DWORD PTR [edx]
	test	eax, eax
	mov	DWORD PTR [ebp], eax
	je	SHORT $L51922
$L51908:
	mov	cl, BYTE PTR [esi]
	inc	esi
	mov	BYTE PTR [eax], cl
	inc	eax
	test	cl, cl
	jne	SHORT $L51908
	add	DWORD PTR ?sMemTotal@CCorString@@0KA, edi ; CCorString::sMemTotal
$L51922:
	mov	edi, DWORD PTR _inArray$[esp+36]
$L51914:
	mov	eax, DWORD PTR _i$[esp+40]
	mov	ecx, DWORD PTR [edi+4]
	inc	eax
	mov	DWORD PTR __$EHRec$[esp+48], -1
	cmp	eax, ecx
	mov	DWORD PTR _i$[esp+40], eax
	jb	$L14267
	pop	ebp
$L14269:
	pop	esi
$L51926:

; 277  : 		return(*this);
; 278  : 	}

	mov	ecx, DWORD PTR __$EHRec$[esp+32]
	mov	eax, ebx
	pop	edi
	pop	ebx
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 24					; 00000018H
	ret	4

; 274  : 		Realloc(sizeof(T));

$L51872:
	cmp	eax, esi
	je	$L51878
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [ebx+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [ebx+8]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	DWORD PTR [ebx], eax
	jmp	$L51879
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L51868:
	mov	eax, DWORD PTR $T51865[ebp]
	push	eax
	mov	ecx, DWORD PTR $T51864[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
$L51925:
	mov	eax, OFFSET FLAT:$T51918
	jmp	___CxxFrameHandler
text$x	ENDS
??4?$TCorArray@VCCorString@@@@QAEAAV0@AAV0@@Z ENDP	; TCorArray<CCorString>::operator=
; Function compile flags: /Ogty
;	COMDAT ??4?$TCorArray@PAVOCpjSurface@@@@QAEAAV0@AAV0@@Z
_TEXT	SEGMENT
_inArray$ = 8
??4?$TCorArray@PAVOCpjSurface@@@@QAEAAV0@AAV0@@Z PROC NEAR ; TCorArray<OCpjSurface *>::operator=, COMDAT
; _this$ = ecx

; 269  : 	{

	push	ebp

; 270  : 		if (this == &inArray)

	mov	ebp, DWORD PTR _inArray$[esp]
	push	esi
	mov	esi, ecx
	cmp	esi, ebp

; 271  : 			return(*this);

	je	$L51966
	push	ebx

; 272  : 		m_Count = 0;

	xor	ebx, ebx
	mov	DWORD PTR [esi+4], ebx

; 273  : 		m_Limit = inArray.m_Count;

	mov	eax, DWORD PTR [ebp+4]
	mov	DWORD PTR [esi+8], eax

; 274  : 		Realloc(sizeof(T));

	mov	eax, DWORD PTR [esi]
	cmp	eax, ebx
	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [esi+12], 4
	je	SHORT $L51942
	cmp	eax, ebx
	je	SHORT $L51944
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [esi+8]
	push	ecx
	mov	ecx, DWORD PTR [esi]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+4]
	mov	DWORD PTR [esi], eax
	jmp	SHORT $L51949
$L51944:
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L51948:
	mov	DWORD PTR [esi], ebx
$L51949:

; 275  : 		for (NDword i=0;i<inArray.m_Count;i++)

	cmp	DWORD PTR [ebp+4], ebx
	jbe	SHORT $L14365
	push	edi
$L14363:

; 276  : 			new(&(*this)[AddNoConstruct()]) T(inArray[i]);

	mov	edi, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	lea	eax, DWORD PTR [edi+1]
	cmp	eax, ecx
	mov	DWORD PTR [esi+4], eax
	jbe	SHORT $L51954
	mov	edx, eax
	push	4
	shr	edx, 2
	mov	ecx, esi
	lea	eax, DWORD PTR [edx+eax+32]
	mov	DWORD PTR [esi+8], eax
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
$L51954:
	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ecx+edi*4]
	test	eax, eax
	je	SHORT $L51936
	mov	edx, DWORD PTR [ebp]
	mov	ecx, DWORD PTR [edx+ebx*4]
	mov	DWORD PTR [eax], ecx
$L51936:
	mov	eax, DWORD PTR [ebp+4]
	inc	ebx
	cmp	ebx, eax
	jb	SHORT $L14363
	pop	edi
$L14365:
	pop	ebx
$L51966:

; 277  : 		return(*this);

	mov	eax, esi
	pop	esi
	pop	ebp

; 278  : 	}

	ret	4
$L51942:

; 274  : 		Realloc(sizeof(T));

	cmp	eax, ebx
	je	SHORT $L51948
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [esi+8]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	DWORD PTR [esi], eax
	jmp	SHORT $L51949
??4?$TCorArray@PAVOCpjSurface@@@@QAEAAV0@AAV0@@Z ENDP	; TCorArray<OCpjSurface *>::operator=
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??4?$TCorArray@PAVOCpjFrames@@@@QAEAAV0@AAV0@@Z
_TEXT	SEGMENT
_inArray$ = 8
??4?$TCorArray@PAVOCpjFrames@@@@QAEAAV0@AAV0@@Z PROC NEAR ; TCorArray<OCpjFrames *>::operator=, COMDAT
; _this$ = ecx

; 269  : 	{

	push	ebp

; 270  : 		if (this == &inArray)

	mov	ebp, DWORD PTR _inArray$[esp]
	push	esi
	mov	esi, ecx
	cmp	esi, ebp

; 271  : 			return(*this);

	je	$L52003
	push	ebx

; 272  : 		m_Count = 0;

	xor	ebx, ebx
	mov	DWORD PTR [esi+4], ebx

; 273  : 		m_Limit = inArray.m_Count;

	mov	eax, DWORD PTR [ebp+4]
	mov	DWORD PTR [esi+8], eax

; 274  : 		Realloc(sizeof(T));

	mov	eax, DWORD PTR [esi]
	cmp	eax, ebx
	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [esi+12], 4
	je	SHORT $L51979
	cmp	eax, ebx
	je	SHORT $L51981
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [esi+8]
	push	ecx
	mov	ecx, DWORD PTR [esi]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+4]
	mov	DWORD PTR [esi], eax
	jmp	SHORT $L51986
$L51981:
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L51985:
	mov	DWORD PTR [esi], ebx
$L51986:

; 275  : 		for (NDword i=0;i<inArray.m_Count;i++)

	cmp	DWORD PTR [ebp+4], ebx
	jbe	SHORT $L14412
	push	edi
$L14410:

; 276  : 			new(&(*this)[AddNoConstruct()]) T(inArray[i]);

	mov	edi, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	lea	eax, DWORD PTR [edi+1]
	cmp	eax, ecx
	mov	DWORD PTR [esi+4], eax
	jbe	SHORT $L51991
	mov	edx, eax
	push	4
	shr	edx, 2
	mov	ecx, esi
	lea	eax, DWORD PTR [edx+eax+32]
	mov	DWORD PTR [esi+8], eax
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
$L51991:
	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ecx+edi*4]
	test	eax, eax
	je	SHORT $L51973
	mov	edx, DWORD PTR [ebp]
	mov	ecx, DWORD PTR [edx+ebx*4]
	mov	DWORD PTR [eax], ecx
$L51973:
	mov	eax, DWORD PTR [ebp+4]
	inc	ebx
	cmp	ebx, eax
	jb	SHORT $L14410
	pop	edi
$L14412:
	pop	ebx
$L52003:

; 277  : 		return(*this);

	mov	eax, esi
	pop	esi
	pop	ebp

; 278  : 	}

	ret	4
$L51979:

; 274  : 		Realloc(sizeof(T));

	cmp	eax, ebx
	je	SHORT $L51985
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [esi+8]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	DWORD PTR [esi], eax
	jmp	SHORT $L51986
??4?$TCorArray@PAVOCpjFrames@@@@QAEAAV0@AAV0@@Z ENDP	; TCorArray<OCpjFrames *>::operator=
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??4?$TCorArray@PAVOCpjSequence@@@@QAEAAV0@AAV0@@Z
_TEXT	SEGMENT
_inArray$ = 8
??4?$TCorArray@PAVOCpjSequence@@@@QAEAAV0@AAV0@@Z PROC NEAR ; TCorArray<OCpjSequence *>::operator=, COMDAT
; _this$ = ecx

; 269  : 	{

	push	ebp

; 270  : 		if (this == &inArray)

	mov	ebp, DWORD PTR _inArray$[esp]
	push	esi
	mov	esi, ecx
	cmp	esi, ebp

; 271  : 			return(*this);

	je	$L52040
	push	ebx

; 272  : 		m_Count = 0;

	xor	ebx, ebx
	mov	DWORD PTR [esi+4], ebx

; 273  : 		m_Limit = inArray.m_Count;

	mov	eax, DWORD PTR [ebp+4]
	mov	DWORD PTR [esi+8], eax

; 274  : 		Realloc(sizeof(T));

	mov	eax, DWORD PTR [esi]
	cmp	eax, ebx
	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [esi+12], 4
	je	SHORT $L52016
	cmp	eax, ebx
	je	SHORT $L52018
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [esi+8]
	push	ecx
	mov	ecx, DWORD PTR [esi]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+4]
	mov	DWORD PTR [esi], eax
	jmp	SHORT $L52023
$L52018:
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L52022:
	mov	DWORD PTR [esi], ebx
$L52023:

; 275  : 		for (NDword i=0;i<inArray.m_Count;i++)

	cmp	DWORD PTR [ebp+4], ebx
	jbe	SHORT $L14458
	push	edi
$L14456:

; 276  : 			new(&(*this)[AddNoConstruct()]) T(inArray[i]);

	mov	edi, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	lea	eax, DWORD PTR [edi+1]
	cmp	eax, ecx
	mov	DWORD PTR [esi+4], eax
	jbe	SHORT $L52028
	mov	edx, eax
	push	4
	shr	edx, 2
	mov	ecx, esi
	lea	eax, DWORD PTR [edx+eax+32]
	mov	DWORD PTR [esi+8], eax
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
$L52028:
	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ecx+edi*4]
	test	eax, eax
	je	SHORT $L52010
	mov	edx, DWORD PTR [ebp]
	mov	ecx, DWORD PTR [edx+ebx*4]
	mov	DWORD PTR [eax], ecx
$L52010:
	mov	eax, DWORD PTR [ebp+4]
	inc	ebx
	cmp	ebx, eax
	jb	SHORT $L14456
	pop	edi
$L14458:
	pop	ebx
$L52040:

; 277  : 		return(*this);

	mov	eax, esi
	pop	esi
	pop	ebp

; 278  : 	}

	ret	4
$L52016:

; 274  : 		Realloc(sizeof(T));

	cmp	eax, ebx
	je	SHORT $L52022
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [esi+8]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	DWORD PTR [esi], eax
	jmp	SHORT $L52023
??4?$TCorArray@PAVOCpjSequence@@@@QAEAAV0@AAV0@@Z ENDP	; TCorArray<OCpjSequence *>::operator=
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??4?$TCorArray@VCMacBone@@@@QAEAAV0@AAV0@@Z
_TEXT	SEGMENT
_i$ = -4
_inArray$ = 8
??4?$TCorArray@VCMacBone@@@@QAEAAV0@AAV0@@Z PROC NEAR	; TCorArray<CMacBone>::operator=, COMDAT
; _this$ = ecx

; 269  : 	{

	sub	esp, 8
	push	ebx

; 270  : 		if (this == &inArray)

	mov	ebx, DWORD PTR _inArray$[esp+8]
	push	esi
	mov	esi, ecx
	cmp	esi, ebx

; 271  : 			return(*this);

	je	$L52306
	push	edi

; 272  : 		m_Count = 0;

	xor	edi, edi
	mov	DWORD PTR [esi+4], edi

; 273  : 		m_Limit = inArray.m_Count;

	mov	eax, DWORD PTR [ebx+4]
	mov	DWORD PTR [esi+8], eax

; 274  : 		Realloc(sizeof(T));

	mov	eax, DWORD PTR [esi]
	cmp	eax, edi
	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [esi+12], 140			; 0000008cH
	je	$L52053
	cmp	eax, edi
	je	SHORT $L52055
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [esi+8]
	push	ecx
	mov	ecx, DWORD PTR [esi]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+4]
	mov	DWORD PTR [esi], eax
	jmp	SHORT $L52060
$L52055:
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L52059:
	mov	DWORD PTR [esi], edi
$L52060:

; 275  : 		for (NDword i=0;i<inArray.m_Count;i++)

	mov	eax, DWORD PTR [ebx+4]
	mov	DWORD PTR _i$[esp+20], edi
	cmp	eax, edi
	jbe	$L14504
	push	ebp
	mov	DWORD PTR -8+[esp+24], edi
	mov	ebp, 1065353216				; 3f800000H
$L14502:

; 276  : 			new(&(*this)[AddNoConstruct()]) T(inArray[i]);

	mov	ebx, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	lea	eax, DWORD PTR [ebx+1]
	cmp	eax, ecx
	mov	DWORD PTR [esi+4], eax
	jbe	SHORT $L52065
	mov	edx, eax
	push	140					; 0000008cH
	shr	edx, 2
	mov	ecx, esi
	lea	eax, DWORD PTR [edx+eax+32]
	mov	DWORD PTR [esi+8], eax
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
$L52065:
	mov	edx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ebx*8]
	sub	eax, ebx
	lea	ecx, DWORD PTR [eax+eax*4]
	lea	eax, DWORD PTR [edx+ecx*4]
	cmp	eax, edi
	je	$L52047
	mov	ecx, DWORD PTR _inArray$[esp+20]
	mov	edx, DWORD PTR -8+[esp+24]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ebp
	mov	DWORD PTR [eax+4], edi
	mov	DWORD PTR [eax+8], edi
	add	ecx, edx
	mov	DWORD PTR [eax+12], edi
	mov	DWORD PTR [eax+16], ebp
	mov	DWORD PTR [eax+20], edi
	mov	DWORD PTR [eax+24], edi
	mov	DWORD PTR [eax+28], edi
	mov	DWORD PTR [eax+32], ebp
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+20], edx
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax+24], edx
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR [eax+28], edx
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR [eax+32], edx
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [eax+36], edx
	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR [eax+40], edx
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR [eax+44], edx
	mov	edx, DWORD PTR [ecx+48]
	mov	DWORD PTR [eax+48], edx
	mov	edx, DWORD PTR [ecx+52]
	mov	DWORD PTR [eax+52], edx
	mov	edx, DWORD PTR [ecx+56]
	mov	DWORD PTR [eax+56], edx
	mov	DWORD PTR [eax+60], ebp
	mov	DWORD PTR [eax+64], edi
	mov	DWORD PTR [eax+68], edi
	mov	DWORD PTR [eax+72], edi
	mov	DWORD PTR [eax+76], ebp
	mov	DWORD PTR [eax+80], edi
	mov	DWORD PTR [eax+84], edi
	mov	DWORD PTR [eax+88], edi
	mov	DWORD PTR [eax+92], ebp
	mov	edx, DWORD PTR [ecx+60]
	mov	DWORD PTR [eax+60], edx
	mov	edx, DWORD PTR [ecx+64]
	mov	DWORD PTR [eax+64], edx
	mov	edx, DWORD PTR [ecx+68]
	mov	DWORD PTR [eax+68], edx
	mov	edx, DWORD PTR [ecx+72]
	mov	DWORD PTR [eax+72], edx
	mov	edx, DWORD PTR [ecx+76]
	mov	DWORD PTR [eax+76], edx
	mov	edx, DWORD PTR [ecx+80]
	mov	DWORD PTR [eax+80], edx
	mov	edx, DWORD PTR [ecx+84]
	mov	DWORD PTR [eax+84], edx
	mov	edx, DWORD PTR [ecx+88]
	mov	DWORD PTR [eax+88], edx
	mov	edx, DWORD PTR [ecx+92]
	mov	DWORD PTR [eax+92], edx
	mov	edx, DWORD PTR [ecx+96]
	mov	DWORD PTR [eax+96], edx
	mov	edx, DWORD PTR [ecx+100]
	mov	DWORD PTR [eax+100], edx
	mov	edx, DWORD PTR [ecx+104]
	mov	DWORD PTR [eax+104], edx
	mov	edx, DWORD PTR [ecx+108]
	mov	DWORD PTR [eax+108], edx
	mov	edx, DWORD PTR [ecx+112]
	mov	DWORD PTR [eax+112], edx
	mov	edx, DWORD PTR [ecx+116]
	mov	DWORD PTR [eax+116], edx
	mov	dl, BYTE PTR [ecx+120]
	mov	BYTE PTR [eax+120], dl
	mov	edx, DWORD PTR [ecx+124]
	mov	DWORD PTR [eax+124], edx
	mov	edx, DWORD PTR [ecx+128]
	mov	DWORD PTR [eax+128], edx
	mov	edx, DWORD PTR [ecx+132]
	mov	DWORD PTR [eax+132], edx
	mov	ecx, DWORD PTR [ecx+136]
	mov	DWORD PTR [eax+136], ecx
$L52047:
	mov	edx, DWORD PTR -8+[esp+24]
	mov	eax, DWORD PTR _i$[esp+24]
	add	edx, 140				; 0000008cH
	inc	eax
	mov	DWORD PTR -8+[esp+24], edx
	mov	edx, DWORD PTR _inArray$[esp+20]
	mov	DWORD PTR _i$[esp+24], eax
	cmp	eax, DWORD PTR [edx+4]
	jb	$L14502
	pop	ebp
$L14504:
	pop	edi
$L52306:

; 277  : 		return(*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 278  : 	}

	add	esp, 8
	ret	4

; 274  : 		Realloc(sizeof(T));

$L52053:
	cmp	eax, edi
	je	$L52059
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [esi+8]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	DWORD PTR [esi], eax
	jmp	$L52060
??4?$TCorArray@VCMacBone@@@@QAEAAV0@AAV0@@Z ENDP	; TCorArray<CMacBone>::operator=
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??4?$TCorArray@PAVOMacChannel@@@@QAEAAV0@AAV0@@Z
_TEXT	SEGMENT
_inArray$ = 8
??4?$TCorArray@PAVOMacChannel@@@@QAEAAV0@AAV0@@Z PROC NEAR ; TCorArray<OMacChannel *>::operator=, COMDAT
; _this$ = ecx

; 269  : 	{

	push	ebp

; 270  : 		if (this == &inArray)

	mov	ebp, DWORD PTR _inArray$[esp]
	push	esi
	mov	esi, ecx
	cmp	esi, ebp

; 271  : 			return(*this);

	je	$L52343
	push	ebx

; 272  : 		m_Count = 0;

	xor	ebx, ebx
	mov	DWORD PTR [esi+4], ebx

; 273  : 		m_Limit = inArray.m_Count;

	mov	eax, DWORD PTR [ebp+4]
	mov	DWORD PTR [esi+8], eax

; 274  : 		Realloc(sizeof(T));

	mov	eax, DWORD PTR [esi]
	cmp	eax, ebx
	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [esi+12], 4
	je	SHORT $L52319
	cmp	eax, ebx
	je	SHORT $L52321
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [esi+8]
	push	ecx
	mov	ecx, DWORD PTR [esi]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+4]
	mov	DWORD PTR [esi], eax
	jmp	SHORT $L52326
$L52321:
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L52325:
	mov	DWORD PTR [esi], ebx
$L52326:

; 275  : 		for (NDword i=0;i<inArray.m_Count;i++)

	cmp	DWORD PTR [ebp+4], ebx
	jbe	SHORT $L14560
	push	edi
$L14558:

; 276  : 			new(&(*this)[AddNoConstruct()]) T(inArray[i]);

	mov	edi, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	lea	eax, DWORD PTR [edi+1]
	cmp	eax, ecx
	mov	DWORD PTR [esi+4], eax
	jbe	SHORT $L52331
	mov	edx, eax
	push	4
	shr	edx, 2
	mov	ecx, esi
	lea	eax, DWORD PTR [edx+eax+32]
	mov	DWORD PTR [esi+8], eax
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
$L52331:
	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ecx+edi*4]
	test	eax, eax
	je	SHORT $L52313
	mov	edx, DWORD PTR [ebp]
	mov	ecx, DWORD PTR [edx+ebx*4]
	mov	DWORD PTR [eax], ecx
$L52313:
	mov	eax, DWORD PTR [ebp+4]
	inc	ebx
	cmp	ebx, eax
	jb	SHORT $L14558
	pop	edi
$L14560:
	pop	ebx
$L52343:

; 277  : 		return(*this);

	mov	eax, esi
	pop	esi
	pop	ebp

; 278  : 	}

	ret	4
$L52319:

; 274  : 		Realloc(sizeof(T));

	cmp	eax, ebx
	je	SHORT $L52325
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [esi+8]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	DWORD PTR [esi], eax
	jmp	SHORT $L52326
??4?$TCorArray@PAVOMacChannel@@@@QAEAAV0@AAV0@@Z ENDP	; TCorArray<OMacChannel *>::operator=
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?AddNoConstruct@?$TCorArray@G@@QAEKK@Z
_TEXT	SEGMENT
_inCount$ = 8
?AddNoConstruct@?$TCorArray@G@@QAEKK@Z PROC NEAR	; TCorArray<unsigned short>::AddNoConstruct, COMDAT
; _this$ = ecx

; 322  : 		NDword i = m_Count;
; 323  : 		if ((m_Count+=inCount)>m_Limit)

	mov	eax, DWORD PTR _inCount$[esp-4]
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	add	eax, edi
	cmp	eax, ecx
	mov	DWORD PTR [esi+4], eax
	jbe	SHORT $L52358

; 324  : 		{
; 325  : 			m_Limit = m_Count + (m_Count>>2) + 32;

	mov	ecx, eax

; 326  : 			Realloc(sizeof(T));

	mov	DWORD PTR [esi+12], 2
	shr	ecx, 2
	lea	eax, DWORD PTR [ecx+eax+32]
	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	mov	DWORD PTR [esi+8], eax
	je	SHORT $L52350
	test	eax, eax
	je	SHORT $L52352
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [esi+8]
	push	ecx
	mov	ecx, DWORD PTR [esi]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+4]
	mov	DWORD PTR [esi], eax

; 327  : 		}
; 328  : 		return(i);

	mov	eax, edi
	pop	edi
	pop	esi

; 329  : 	}

	ret	4

; 326  : 			Realloc(sizeof(T));

$L52352:
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L52356:
	mov	DWORD PTR [esi], 0
$L52358:

; 327  : 		}
; 328  : 		return(i);

	mov	eax, edi
	pop	edi
	pop	esi

; 329  : 	}

	ret	4

; 326  : 			Realloc(sizeof(T));

$L52350:
	test	eax, eax
	je	SHORT $L52356
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [esi+8]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	DWORD PTR [esi], eax

; 327  : 		}
; 328  : 		return(i);

	mov	eax, edi
	pop	edi
	pop	esi

; 329  : 	}

	ret	4
?AddNoConstruct@?$TCorArray@G@@QAEKK@Z ENDP		; TCorArray<unsigned short>::AddNoConstruct
_TEXT	ENDS
PUBLIC	??1OMacActor@@UAE@XZ				; OMacActor::~OMacActor
;	COMDAT xdata$x
xdata$x	SEGMENT
$T52546	DD	0ffffffffH
	DD	FLAT:$L52362
	DD	00H
	DD	FLAT:$L52363
	DD	01H
	DD	FLAT:$L52364
	DD	02H
	DD	FLAT:$L52365
	DD	03H
	DD	FLAT:$L52366
	DD	04H
	DD	FLAT:$L52367
	DD	05H
	DD	FLAT:$L52368
	DD	06H
	DD	FLAT:$L52369
	DD	07H
	DD	FLAT:$L52370
	DD	08H
	DD	FLAT:$L52371
	DD	09H
	DD	FLAT:$L52372
	DD	0aH
	DD	FLAT:$L52373
	DD	09H
	DD	FLAT:$L52410
	DD	08H
	DD	FLAT:$L52427
	DD	07H
	DD	FLAT:$L52444
	DD	06H
	DD	FLAT:$L52461
$T52544	DD	019930520H
	DD	010H
	DD	FLAT:$T52546
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ??1OMacActor@@UAE@XZ
_TEXT	SEGMENT
$T52425 = -16
$T52442 = -16
$T52459 = -16
$T52476 = -16
__$EHRec$ = -12
_this$ = -20
??1OMacActor@@UAE@XZ PROC NEAR				; OMacActor::~OMacActor, COMDAT
; _this$ = ecx
	push	-1
	push	$L52545
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 8
	push	esi
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+28], esi
	mov	eax, DWORD PTR [esi+292]
	lea	edi, DWORD PTR [esi+288]
	push	eax
	push	0
	mov	ecx, edi
	mov	DWORD PTR __$EHRec$[esp+44], 11		; 0000000bH
	call	?Remove@?$TCorArray@PAVOMacChannel@@@@QAEXKK@Z ; TCorArray<OMacChannel *>::Remove
	cmp	DWORD PTR [edi], 0
	je	SHORT $L52390
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L52390:
	mov	edx, DWORD PTR [esi+276]
	lea	edi, DWORD PTR [esi+272]
	push	edx
	push	0
	mov	ecx, edi
	mov	BYTE PTR __$EHRec$[esp+44], 10		; 0000000aH
	call	?Remove@?$TCorArray@VCMacBone@@@@QAEXKK@Z ; TCorArray<CMacBone>::Remove
	cmp	DWORD PTR [edi], 0
	je	SHORT $L52407
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L52407:
	lea	edi, DWORD PTR [esi+248]
	mov	DWORD PTR $T52425[esp+28], edi
	mov	edx, DWORD PTR [edi+4]
	mov	ecx, edi
	push	edx
	push	0
	mov	BYTE PTR __$EHRec$[esp+44], 12		; 0000000cH
	call	?Remove@?$TCorArray@VCCorString@@@@QAEXKK@Z ; TCorArray<CCorString>::Remove
	mov	eax, DWORD PTR [edi]
	mov	BYTE PTR __$EHRec$[esp+36], 9
	test	eax, eax
	je	SHORT $L52424
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L52424:
	lea	edi, DWORD PTR [esi+232]
	mov	DWORD PTR $T52442[esp+28], edi
	mov	edx, DWORD PTR [edi+4]
	mov	ecx, edi
	push	edx
	push	0
	mov	BYTE PTR __$EHRec$[esp+44], 13		; 0000000dH
	call	?Remove@?$TCorArray@VCCorString@@@@QAEXKK@Z ; TCorArray<CCorString>::Remove
	mov	eax, DWORD PTR [edi]
	mov	BYTE PTR __$EHRec$[esp+36], 8
	test	eax, eax
	je	SHORT $L52441
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L52441:
	lea	edi, DWORD PTR [esi+216]
	mov	DWORD PTR $T52459[esp+28], edi
	mov	edx, DWORD PTR [edi+4]
	mov	ecx, edi
	push	edx
	push	0
	mov	BYTE PTR __$EHRec$[esp+44], 14		; 0000000eH
	call	?Remove@?$TCorArray@VCCorString@@@@QAEXKK@Z ; TCorArray<CCorString>::Remove
	mov	eax, DWORD PTR [edi]
	mov	BYTE PTR __$EHRec$[esp+36], 7
	test	eax, eax
	je	SHORT $L52458
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L52458:
	lea	edi, DWORD PTR [esi+200]
	mov	DWORD PTR $T52476[esp+28], edi
	mov	edx, DWORD PTR [edi+4]
	mov	ecx, edi
	push	edx
	push	0
	mov	BYTE PTR __$EHRec$[esp+44], 15		; 0000000fH
	call	?Remove@?$TCorArray@VCCorString@@@@QAEXKK@Z ; TCorArray<CCorString>::Remove
	mov	eax, DWORD PTR [edi]
	mov	BYTE PTR __$EHRec$[esp+36], 6
	test	eax, eax
	je	SHORT $L52475
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L52475:
	mov	edx, DWORD PTR [esi+188]
	lea	edi, DWORD PTR [esi+184]
	push	edx
	push	0
	mov	ecx, edi
	mov	BYTE PTR __$EHRec$[esp+44], 5
	call	?Remove@?$TCorArray@PAVOCpjSequence@@@@QAEXKK@Z ; TCorArray<OCpjSequence *>::Remove
	cmp	DWORD PTR [edi], 0
	je	SHORT $L52492
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L52492:
	mov	edx, DWORD PTR [esi+172]
	lea	edi, DWORD PTR [esi+168]
	push	edx
	push	0
	mov	ecx, edi
	mov	BYTE PTR __$EHRec$[esp+44], 4
	call	?Remove@?$TCorArray@PAVOCpjFrames@@@@QAEXKK@Z ; TCorArray<OCpjFrames *>::Remove
	cmp	DWORD PTR [edi], 0
	je	SHORT $L52509
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L52509:
	mov	edx, DWORD PTR [esi+156]
	lea	edi, DWORD PTR [esi+152]
	push	edx
	push	0
	mov	ecx, edi
	mov	BYTE PTR __$EHRec$[esp+44], 3
	call	?Remove@?$TCorArray@PAVOCpjSurface@@@@QAEXKK@Z ; TCorArray<OCpjSurface *>::Remove
	cmp	DWORD PTR [edi], 0
	je	SHORT $L52526
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L52526:
	push	0
	lea	ecx, DWORD PTR [esi+76]
	mov	BYTE PTR __$EHRec$[esp+40], 2
	call	?Set@CCorString@@QAEXPAD@Z		; CCorString::Set
	push	0
	lea	ecx, DWORD PTR [esi+72]
	mov	BYTE PTR __$EHRec$[esp+40], 1
	call	?Set@CCorString@@QAEXPAD@Z		; CCorString::Set
	mov	edx, DWORD PTR [esi+64]
	mov	ecx, DWORD PTR [esi+60]
	lea	eax, DWORD PTR [esi+56]
	mov	DWORD PTR __$EHRec$[esp+36], -1
	mov	DWORD PTR [edx+4], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], ecx
	mov	ecx, esi
	mov	DWORD PTR [eax+8], eax
	mov	DWORD PTR [eax+4], eax
	call	??1OObject@@UAE@XZ			; OObject::~OObject
	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 20					; 00000014H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L52362:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1OObject@@UAE@XZ			; OObject::~OObject
$L52363:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 56					; 00000038H
	jmp	??1CMacActorLink@@QAE@XZ		; CMacActorLink::~CMacActorLink
$L52364:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 72					; 00000048H
	jmp	??1CCorString@@QAE@XZ			; CCorString::~CCorString
$L52365:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 76					; 0000004cH
	jmp	??1CCorString@@QAE@XZ			; CCorString::~CCorString
$L52366:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 152				; 00000098H
	jmp	??1?$TCorArray@PAVOCpjSurface@@@@QAE@XZ	; TCorArray<OCpjSurface *>::~TCorArray<OCpjSurface *>
$L52367:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 168				; 000000a8H
	jmp	??1?$TCorArray@PAVOCpjFrames@@@@QAE@XZ	; TCorArray<OCpjFrames *>::~TCorArray<OCpjFrames *>
$L52368:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 184				; 000000b8H
	jmp	??1?$TCorArray@PAVOCpjSequence@@@@QAE@XZ ; TCorArray<OCpjSequence *>::~TCorArray<OCpjSequence *>
$L52369:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 200				; 000000c8H
	jmp	??1?$TCorArray@VCCorString@@@@QAE@XZ	; TCorArray<CCorString>::~TCorArray<CCorString>
$L52370:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 216				; 000000d8H
	jmp	??1?$TCorArray@VCCorString@@@@QAE@XZ	; TCorArray<CCorString>::~TCorArray<CCorString>
$L52371:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 232				; 000000e8H
	jmp	??1?$TCorArray@VCCorString@@@@QAE@XZ	; TCorArray<CCorString>::~TCorArray<CCorString>
$L52372:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 248				; 000000f8H
	jmp	??1?$TCorArray@VCCorString@@@@QAE@XZ	; TCorArray<CCorString>::~TCorArray<CCorString>
$L52373:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 272				; 00000110H
	jmp	??1?$TCorArray@VCMacBone@@@@QAE@XZ	; TCorArray<CMacBone>::~TCorArray<CMacBone>
$L52410:
	mov	ecx, DWORD PTR $T52425[ebp]
	jmp	??1CCorArray@@IAE@XZ			; CCorArray::~CCorArray
$L52427:
	mov	ecx, DWORD PTR $T52442[ebp]
	jmp	??1CCorArray@@IAE@XZ			; CCorArray::~CCorArray
$L52444:
	mov	ecx, DWORD PTR $T52459[ebp]
	jmp	??1CCorArray@@IAE@XZ			; CCorArray::~CCorArray
$L52461:
	mov	ecx, DWORD PTR $T52476[ebp]
	jmp	??1CCorArray@@IAE@XZ			; CCorArray::~CCorArray
$L52545:
	mov	eax, OFFSET FLAT:$T52544
	jmp	___CxxFrameHandler
text$x	ENDS
??1OMacActor@@UAE@XZ ENDP				; OMacActor::~OMacActor
; Function compile flags: /Ogty
;	COMDAT ?AddNoConstruct@?$TCorArray@VCCpjLodTri@@@@QAEKK@Z
_TEXT	SEGMENT
_inCount$ = 8
?AddNoConstruct@?$TCorArray@VCCpjLodTri@@@@QAEKK@Z PROC NEAR ; TCorArray<CCpjLodTri>::AddNoConstruct, COMDAT
; _this$ = ecx

; 322  : 		NDword i = m_Count;
; 323  : 		if ((m_Count+=inCount)>m_Limit)

	mov	eax, DWORD PTR _inCount$[esp-4]
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	add	eax, edi
	cmp	eax, ecx
	mov	DWORD PTR [esi+4], eax
	jbe	SHORT $L52563

; 324  : 		{
; 325  : 			m_Limit = m_Count + (m_Count>>2) + 32;

	mov	ecx, eax

; 326  : 			Realloc(sizeof(T));

	mov	DWORD PTR [esi+12], 16			; 00000010H
	shr	ecx, 2
	lea	eax, DWORD PTR [ecx+eax+32]
	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	mov	DWORD PTR [esi+8], eax
	je	SHORT $L52555
	test	eax, eax
	je	SHORT $L52557
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [esi+8]
	push	ecx
	mov	ecx, DWORD PTR [esi]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+4]
	mov	DWORD PTR [esi], eax

; 327  : 		}
; 328  : 		return(i);

	mov	eax, edi
	pop	edi
	pop	esi

; 329  : 	}

	ret	4

; 326  : 			Realloc(sizeof(T));

$L52557:
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L52561:
	mov	DWORD PTR [esi], 0
$L52563:

; 327  : 		}
; 328  : 		return(i);

	mov	eax, edi
	pop	edi
	pop	esi

; 329  : 	}

	ret	4

; 326  : 			Realloc(sizeof(T));

$L52555:
	test	eax, eax
	je	SHORT $L52561
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [esi+8]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	DWORD PTR [esi], eax

; 327  : 		}
; 328  : 		return(i);

	mov	eax, edi
	pop	edi
	pop	esi

; 329  : 	}

	ret	4
?AddNoConstruct@?$TCorArray@VCCpjLodTri@@@@QAEKK@Z ENDP	; TCorArray<CCpjLodTri>::AddNoConstruct
_TEXT	ENDS
PUBLIC	??_GOMacActor@@UAEPAXI@Z			; OMacActor::`scalar deleting destructor'
; Function compile flags: /Ogty
;	COMDAT ??_GOMacActor@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_GOMacActor@@UAEPAXI@Z PROC NEAR			; OMacActor::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1OMacActor@@UAE@XZ			; OMacActor::~OMacActor
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $L52579
	mov	DWORD PTR [esi+4], 0
	mov	edx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	dec	edx
	mov	DWORD PTR ?sObjCount@OObject@@1KA, edx	; OObject::sObjCount
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L52579:
	mov	eax, esi
	pop	esi
	ret	4
??_GOMacActor@@UAEPAXI@Z ENDP				; OMacActor::`scalar deleting destructor'
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??_EOMacActor@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_EOMacActor@@UAEPAXI@Z PROC NEAR			; OMacActor::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebx
	mov	bl, BYTE PTR ___flags$[esp]
	push	esi
	mov	esi, ecx
	test	bl, 2
	je	SHORT $L11021
	mov	eax, DWORD PTR [esi-4]
	push	edi
	lea	edi, DWORD PTR [esi-4]
	push	OFFSET FLAT:??1OMacActor@@UAE@XZ	; OMacActor::~OMacActor
	push	eax
	push	308					; 00000134H
	push	esi
	call	??_M@YGXPAXIHP6EX0@Z@Z			; `eh vector destructor iterator'
	test	bl, 1
	je	SHORT $L11022
	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L11022:
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	ret	4
$L11021:
	mov	ecx, esi
	call	??1OMacActor@@UAE@XZ			; OMacActor::~OMacActor
	test	bl, 1
	je	SHORT $L52594
	mov	DWORD PTR [esi+4], 0
	mov	edx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	dec	edx
	mov	DWORD PTR ?sObjCount@OObject@@1KA, edx	; OObject::sObjCount
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L52594:
	mov	eax, esi
	pop	esi
	pop	ebx
	ret	4
??_EOMacActor@@UAEPAXI@Z ENDP				; OMacActor::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??2OMacChannel@@CAPAXIPAVOObject@@PAVCObjClass@@@Z ; OMacChannel::operator new
; Function compile flags: /Ogty
; File C:\duke4\Cannibal\MacMain.h
;	COMDAT ??2OMacChannel@@CAPAXIPAVOObject@@PAVCObjClass@@@Z
_TEXT	SEGMENT
_inParent$ = 12
_inSetClass$ = 16
??2OMacChannel@@CAPAXIPAVOObject@@PAVCObjClass@@@Z PROC NEAR ; OMacChannel::operator new, COMDAT

; 199  : 	OBJ_CLASS_DEFINE(OMacChannel, OObject);

	push	esi
	push	edi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	56					; 00000038H
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	ecx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	mov	esi, eax
	inc	ecx
	xor	eax, eax
	mov	DWORD PTR ?sObjCount@OObject@@1KA, ecx	; OObject::sObjCount
	mov	ecx, 14					; 0000000eH
	mov	edi, esi
	rep stosd
	mov	eax, DWORD PTR [esi+40]
	mov	DWORD PTR [esi+4], 305419896		; 12345678H
	test	eax, eax
	jne	SHORT $L52604
	mov	eax, DWORD PTR _inSetClass$[esp+4]
	mov	DWORD PTR [esi+40], eax
$L52604:
	mov	ecx, DWORD PTR _inParent$[esp+4]
	push	ecx
	mov	ecx, esi
	call	?PreConstruct@OObject@@QAEXPAV1@@Z	; OObject::PreConstruct
	mov	eax, esi
	pop	edi
	pop	esi
	ret	0
??2OMacChannel@@CAPAXIPAVOObject@@PAVCObjClass@@@Z ENDP	; OMacChannel::operator new
; Function compile flags: /Ogty
; File C:\duke4\Cannibal\CorMain.h
_TEXT	ENDS
;	COMDAT ?Remove@?$TCorArray@VCCpjSklWeight@@@@QAEXKK@Z
_TEXT	SEGMENT
_inIndex$ = 8
_inCount$ = 12
?Remove@?$TCorArray@VCCpjSklWeight@@@@QAEXKK@Z PROC NEAR ; TCorArray<CCpjSklWeight>::Remove, COMDAT
; _this$ = ecx

; 374  : 	{

	push	ebx

; 375  : 		for (NDword i=inIndex; i<(inIndex+inCount); i++)

	mov	ebx, DWORD PTR _inCount$[esp]
	push	esi
	push	edi
	mov	edi, DWORD PTR _inIndex$[esp+8]
	mov	esi, ecx

; 376  : 			(&(*this)[i])->~T();
; 377  : 		CCorArray::Remove(inIndex, inCount, sizeof(T));

	test	ebx, ebx
	lea	eax, DWORD PTR [edi+ebx]
	je	SHORT $L52612
	mov	edx, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [eax+eax*4]
	lea	edx, DWORD PTR [edx+edx*4]
	shl	eax, 2
	shl	edx, 2
	sub	edx, eax
	add	eax, ecx
	push	edx
	lea	edx, DWORD PTR [edi+edi*4]
	push	eax
	lea	eax, DWORD PTR [ecx+edx*4]
	push	eax
	call	DWORD PTR __imp__memmove
	mov	eax, DWORD PTR [esi+4]
	add	esp, 12					; 0000000cH
	sub	eax, ebx
	mov	DWORD PTR [esi+4], eax
$L52612:
	pop	edi
	pop	esi
	pop	ebx

; 378  : 	}

	ret	8
?Remove@?$TCorArray@VCCpjSklWeight@@@@QAEXKK@Z ENDP	; TCorArray<CCpjSklWeight>::Remove
_TEXT	ENDS
PUBLIC	??3OMacChannel@@CAXPAX@Z			; OMacChannel::operator delete
; Function compile flags: /Ogty
; File C:\duke4\Cannibal\MacMain.h
;	COMDAT ??3OMacChannel@@CAXPAX@Z
_TEXT	SEGMENT
_ptr$ = 8
??3OMacChannel@@CAXPAX@Z PROC NEAR			; OMacChannel::operator delete, COMDAT

; 199  : 	OBJ_CLASS_DEFINE(OMacChannel, OObject);

	push	esi
	mov	esi, DWORD PTR _ptr$[esp]
	mov	DWORD PTR [esi+4], 0
	mov	edx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	dec	edx
	mov	DWORD PTR ?sObjCount@OObject@@1KA, edx	; OObject::sObjCount
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	ecx, eax
	call	DWORD PTR [edx+8]
	pop	esi
	ret	0
??3OMacChannel@@CAXPAX@Z ENDP				; OMacChannel::operator delete
_TEXT	ENDS
PUBLIC	??3OMacChannel@@CAXPAXPAVOObject@@PAVCObjClass@@@Z ; OMacChannel::operator delete
; Function compile flags: /Ogty
;	COMDAT ??3OMacChannel@@CAXPAXPAVOObject@@PAVCObjClass@@@Z
_TEXT	SEGMENT
_ptr$ = 8
??3OMacChannel@@CAXPAXPAVOObject@@PAVCObjClass@@@Z PROC NEAR ; OMacChannel::operator delete, COMDAT

; 199  : 	OBJ_CLASS_DEFINE(OMacChannel, OObject);

	push	esi
	mov	esi, DWORD PTR _ptr$[esp]
	mov	DWORD PTR [esi+4], 0
	mov	edx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	dec	edx
	mov	DWORD PTR ?sObjCount@OObject@@1KA, edx	; OObject::sObjCount
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	ecx, eax
	call	DWORD PTR [edx+8]
	pop	esi
	ret	0
??3OMacChannel@@CAXPAXPAVOObject@@PAVCObjClass@@@Z ENDP	; OMacChannel::operator delete
_TEXT	ENDS
PUBLIC	?GetStaticClass@OMacChannel@@SAPAVCObjClass@@XZ	; OMacChannel::GetStaticClass
; Function compile flags: /Ogty
;	COMDAT ?GetStaticClass@OMacChannel@@SAPAVCObjClass@@XZ
_TEXT	SEGMENT
?GetStaticClass@OMacChannel@@SAPAVCObjClass@@XZ PROC NEAR ; OMacChannel::GetStaticClass, COMDAT

; 199  : 	OBJ_CLASS_DEFINE(OMacChannel, OObject);

	mov	eax, DWORD PTR ?staticObjClass@OMacChannel@@0PAVCObjClass@@A ; OMacChannel::staticObjClass
	ret	0
?GetStaticClass@OMacChannel@@SAPAVCObjClass@@XZ ENDP	; OMacChannel::GetStaticClass
_TEXT	ENDS
PUBLIC	?GetClass@OMacChannel@@UAEPAVCObjClass@@XZ	; OMacChannel::GetClass
PUBLIC	?EvalBones@OMacChannel@@UAE_NPAVOMacActor@@@Z	; OMacChannel::EvalBones
PUBLIC	?EvalVerts@OMacChannel@@UAE_NPAVOMacActor@@KPAGPAVVVec3@@@Z ; OMacChannel::EvalVerts
PUBLIC	??_7OMacChannel@@6B@				; OMacChannel::`vftable'
PUBLIC	??_EOMacChannel@@UAEPAXI@Z			; OMacChannel::`vector deleting destructor'
;	COMDAT xdata$x
xdata$x	SEGMENT
$T52673	DD	0ffffffffH
	DD	FLAT:$L52642
$T52671	DD	019930520H
	DD	01H
	DD	FLAT:$T52673
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_7OMacChannel@@6B@
CONST	SEGMENT
??_7OMacChannel@@6B@ DD FLAT:?Msg@OObject@@UAE_NPAVIMsg@@@Z ; OMacChannel::`vftable'
	DD	FLAT:?MsgGetChild@OObject@@UAEPAVIMsgTarget@@PAD@Z
	DD	FLAT:?MsgGetParent@OObject@@UAEPAVIMsgTarget@@XZ
	DD	FLAT:?MsgGetRoot@OObject@@UAEPAVIMsgTarget@@XZ
	DD	FLAT:?GetClass@OMacChannel@@UAEPAVCObjClass@@XZ
	DD	FLAT:??_EOMacChannel@@UAEPAXI@Z
	DD	FLAT:?Create@OObject@@UAEXXZ
	DD	FLAT:?Destroy@OObject@@UAEXXZ
	DD	FLAT:?GetParent@OObject@@UAEPAV1@XZ
	DD	FLAT:?SetParent@OObject@@UAEXPAV1@_N@Z
	DD	FLAT:?HasChildren@OObject@@UAE_NXZ
	DD	FLAT:?IsA@OObject@@UAE_NPAVCObjClass@@@Z
	DD	FLAT:?EvalBones@OMacChannel@@UAE_NPAVOMacActor@@@Z
	DD	FLAT:?EvalVerts@OMacChannel@@UAE_NPAVOMacActor@@KPAGPAVVVec3@@@Z
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?New@OMacChannel@@SAPAV1@PAVOObject@@PAVCObjClass@@@Z
_TEXT	SEGMENT
$T52639 = -16
__$EHRec$ = -12
_inParent$ = 8
_inSetClass$ = 12
?New@OMacChannel@@SAPAV1@PAVOObject@@PAVCObjClass@@@Z PROC NEAR ; OMacChannel::New, COMDAT

; 199  : 	OBJ_CLASS_DEFINE(OMacChannel, OObject);

	push	-1
	push	$L52672
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	push	ebx
	mov	ebx, DWORD PTR _inSetClass$[esp+16]
	test	ebx, ebx
	push	esi
	jne	SHORT $L11077
	mov	ebx, DWORD PTR ?staticObjClass@OMacChannel@@0PAVCObjClass@@A ; OMacChannel::staticObjClass
	mov	DWORD PTR _inSetClass$[esp+20], ebx
$L11077:
	push	edi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	56					; 00000038H
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	ecx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	mov	esi, eax
	inc	ecx
	xor	eax, eax
	mov	DWORD PTR ?sObjCount@OObject@@1KA, ecx	; OObject::sObjCount
	mov	ecx, 14					; 0000000eH
	mov	edi, esi
	rep stosd
	mov	eax, DWORD PTR [esi+40]
	mov	DWORD PTR [esi+4], 305419896		; 12345678H
	test	eax, eax
	pop	edi
	jne	SHORT $L52661
	mov	DWORD PTR [esi+40], ebx
$L52661:
	mov	eax, DWORD PTR _inParent$[esp+20]
	mov	ecx, esi
	push	eax
	call	?PreConstruct@OObject@@QAEXPAV1@@Z	; OObject::PreConstruct
	mov	DWORD PTR $T52639[esp+24], esi
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+32], 0
	call	??0OObject@@QAE@XZ			; OObject::OObject
	mov	DWORD PTR [esi], OFFSET FLAT:??_7OMacChannel@@6B@ ; OMacChannel::`vftable'
	mov	edx, DWORD PTR [esi]
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+32], -1
	call	DWORD PTR [edx+24]
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	eax, esi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L52642:
	mov	eax, DWORD PTR _inSetClass$[ebp-4]
	push	eax
	mov	ecx, DWORD PTR _inParent$[ebp-4]
	push	ecx
	mov	edx, DWORD PTR $T52639[ebp]
	push	edx
	call	??3OMacChannel@@CAXPAXPAVOObject@@PAVCObjClass@@@Z ; OMacChannel::operator delete
	add	esp, 12					; 0000000cH
	ret	0
$L52672:
	mov	eax, OFFSET FLAT:$T52671
	jmp	___CxxFrameHandler
text$x	ENDS
?New@OMacChannel@@SAPAV1@PAVOObject@@PAVCObjClass@@@Z ENDP ; OMacChannel::New
; Function compile flags: /Ogty
;	COMDAT ?GetClass@OMacChannel@@UAEPAVCObjClass@@XZ
_TEXT	SEGMENT
?GetClass@OMacChannel@@UAEPAVCObjClass@@XZ PROC NEAR	; OMacChannel::GetClass, COMDAT
; _this$ = ecx

; 199  : 	OBJ_CLASS_DEFINE(OMacChannel, OObject);

	mov	eax, DWORD PTR [ecx+40]
	ret	0
?GetClass@OMacChannel@@UAEPAVCObjClass@@XZ ENDP		; OMacChannel::GetClass
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?EvalBones@OMacChannel@@UAE_NPAVOMacActor@@@Z
_TEXT	SEGMENT
?EvalBones@OMacChannel@@UAE_NPAVOMacActor@@@Z PROC NEAR	; OMacChannel::EvalBones, COMDAT
; _this$ = ecx

; 201  : 	virtual NBool EvalBones(OMacActor* inActor) { return(0); } // returns true if change was performed

	xor	al, al
	ret	4
?EvalBones@OMacChannel@@UAE_NPAVOMacActor@@@Z ENDP	; OMacChannel::EvalBones
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?EvalVerts@OMacChannel@@UAE_NPAVOMacActor@@KPAGPAVVVec3@@@Z
_TEXT	SEGMENT
?EvalVerts@OMacChannel@@UAE_NPAVOMacActor@@KPAGPAVVVec3@@@Z PROC NEAR ; OMacChannel::EvalVerts, COMDAT
; _this$ = ecx

; 202  : 	virtual NBool EvalVerts(OMacActor* inActor, NDword inNumVerts, NWord* inVertRelay, VVec3* ioVerts) { return(0); } // returns true if change was performed

	xor	al, al
	ret	16					; 00000010H
?EvalVerts@OMacChannel@@UAE_NPAVOMacActor@@KPAGPAVVVec3@@@Z ENDP ; OMacChannel::EvalVerts
_TEXT	ENDS
PUBLIC	??0OMacChannel@@QAE@XZ				; OMacChannel::OMacChannel
; Function compile flags: /Ogty
;	COMDAT ??0OMacChannel@@QAE@XZ
_TEXT	SEGMENT
??0OMacChannel@@QAE@XZ PROC NEAR			; OMacChannel::OMacChannel, COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??0OObject@@QAE@XZ			; OObject::OObject
	mov	DWORD PTR [esi], OFFSET FLAT:??_7OMacChannel@@6B@ ; OMacChannel::`vftable'
	mov	eax, esi
	pop	esi
	ret	0
??0OMacChannel@@QAE@XZ ENDP				; OMacChannel::OMacChannel
_TEXT	ENDS
PUBLIC	??0OMacChannel@@QAE@ABV0@@Z			; OMacChannel::OMacChannel
;	COMDAT xdata$x
xdata$x	SEGMENT
$T52741	DD	0ffffffffH
	DD	FLAT:$L52694
	DD	00H
	DD	FLAT:$L52695
$T52738	DD	019930520H
	DD	02H
	DD	FLAT:$T52741
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ??0OMacChannel@@QAE@ABV0@@Z
_TEXT	SEGMENT
__$EHRec$ = -12
___that$ = 8
_this$ = -16
??0OMacChannel@@QAE@ABV0@@Z PROC NEAR			; OMacChannel::OMacChannel, COMDAT
; _this$ = ecx
	push	-1
	push	$L52740
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	push	ebx
	mov	ebx, DWORD PTR ___that$[esp+16]
	push	ebp
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [ebx+8]
	push	edi
	mov	DWORD PTR _this$[esp+32], esi
	mov	DWORD PTR [esi], OFFSET FLAT:??_7IMsgTarget@@6B@ ; IMsgTarget::`vftable'
	mov	eax, DWORD PTR [ebx+4]
	mov	DWORD PTR [esi+4], eax
	mov	eax, DWORD PTR [ecx]
	lea	edx, DWORD PTR [esi+8]
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], ecx
	lea	edx, DWORD PTR [ebx+24]
	lea	ecx, DWORD PTR [esi+24]
	xor	eax, eax
	mov	edi, DWORD PTR [edx]
	mov	DWORD PTR __$EHRec$[esp+40], eax
	mov	DWORD PTR [ecx], edi
	mov	edi, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], edi
	mov	edi, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], edi
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [ecx+12], edx
	mov	ecx, DWORD PTR [ebx+40]
	mov	BYTE PTR __$EHRec$[esp+40], 1
	mov	DWORD PTR [esi+40], ecx
	mov	DWORD PTR [esi+44], eax
	mov	ebp, DWORD PTR [ebx+44]
	cmp	ebp, eax
	je	SHORT $L52731
	cmp	BYTE PTR [ebp], 0
	jne	SHORT $L52731
	xor	ebp, ebp
$L52731:
	cmp	ebp, eax
	mov	DWORD PTR [esi+44], eax
	je	SHORT $L52734
	mov	edi, ebp
	or	ecx, -1
	xor	eax, eax
	repne scasb
	not	ecx
	dec	ecx
	mov	edi, ecx
	inc	edi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	edi
	mov	ecx, eax
	call	DWORD PTR [edx]
	test	eax, eax
	mov	DWORD PTR [esi+44], eax
	je	SHORT $L52734
	mov	ecx, eax
$L52736:
	mov	al, BYTE PTR [ebp]
	inc	ebp
	mov	BYTE PTR [ecx], al
	inc	ecx
	test	al, al
	jne	SHORT $L52736
	add	DWORD PTR ?sMemTotal@CCorString@@0KA, edi ; CCorString::sMemTotal
$L52734:
	mov	eax, DWORD PTR [ebx+48]
	pop	edi
	mov	DWORD PTR [esi+48], eax
	mov	ecx, DWORD PTR [ebx+52]
	mov	DWORD PTR [esi+52], ecx
	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR [esi], OFFSET FLAT:??_7OMacChannel@@6B@ ; OMacChannel::`vftable'
	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L52694:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1CObjLink@@QAE@XZ			; CObjLink::~CObjLink
$L52695:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	jmp	??1CObjLink@@QAE@XZ			; CObjLink::~CObjLink
$L52740:
	mov	eax, OFFSET FLAT:$T52738
	jmp	___CxxFrameHandler
text$x	ENDS
??0OMacChannel@@QAE@ABV0@@Z ENDP			; OMacChannel::OMacChannel
PUBLIC	??4OMacChannel@@QAEAAV0@ABV0@@Z			; OMacChannel::operator=
; Function compile flags: /Ogty
;	COMDAT ??4OMacChannel@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8
??4OMacChannel@@QAEAAV0@ABV0@@Z PROC NEAR		; OMacChannel::operator=, COMDAT
; _this$ = ecx
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR ___that$[esp+4]
	push	esi
	mov	esi, ecx
	push	edi
	mov	eax, DWORD PTR [ebp+4]
	lea	ecx, DWORD PTR [ebp+8]
	mov	DWORD PTR [esi+4], eax
	lea	edx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	lea	eax, DWORD PTR [esi+24]
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], ecx
	lea	edx, DWORD PTR [ebp+24]
	mov	ecx, DWORD PTR [ebp+24]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR [ebp+40]
	mov	DWORD PTR [esi+40], eax
	mov	ebx, DWORD PTR [ebp+44]
	test	ebx, ebx
	je	SHORT $L52781
	cmp	BYTE PTR [ebx], 0
	jne	SHORT $L52781
	xor	ebx, ebx
$L52781:
	mov	edi, DWORD PTR [esi+44]
	test	edi, edi
	je	SHORT $L52782
	or	ecx, -1
	xor	eax, eax
	repne scasb
	mov	eax, DWORD PTR ?sMemTotal@CCorString@@0KA ; CCorString::sMemTotal
	or	edx, -1
	not	ecx
	dec	ecx
	sub	edx, ecx
	add	eax, edx
	mov	DWORD PTR ?sMemTotal@CCorString@@0KA, eax ; CCorString::sMemTotal
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+44]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L52782:
	test	ebx, ebx
	mov	DWORD PTR [esi+44], 0
	je	SHORT $L52785
	mov	edi, ebx
	or	ecx, -1
	xor	eax, eax
	repne scasb
	not	ecx
	dec	ecx
	mov	edi, ecx
	inc	edi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	edi
	mov	ecx, eax
	call	DWORD PTR [edx]
	test	eax, eax
	mov	DWORD PTR [esi+44], eax
	je	SHORT $L52785
$L52787:
	mov	cl, BYTE PTR [ebx]
	inc	ebx
	mov	BYTE PTR [eax], cl
	inc	eax
	test	cl, cl
	jne	SHORT $L52787
	add	DWORD PTR ?sMemTotal@CCorString@@0KA, edi ; CCorString::sMemTotal
$L52785:
	mov	eax, DWORD PTR [ebp+48]
	pop	edi
	mov	DWORD PTR [esi+48], eax
	mov	ecx, DWORD PTR [ebp+52]
	mov	DWORD PTR [esi+52], ecx
	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx
	ret	4
??4OMacChannel@@QAEAAV0@ABV0@@Z ENDP			; OMacChannel::operator=
_TEXT	ENDS
PUBLIC	??1OMacChannel@@UAE@XZ				; OMacChannel::~OMacChannel
; Function compile flags: /Ogty
;	COMDAT ??1OMacChannel@@UAE@XZ
_TEXT	SEGMENT
??1OMacChannel@@UAE@XZ PROC NEAR			; OMacChannel::~OMacChannel, COMDAT
; _this$ = ecx
	jmp	??1OObject@@UAE@XZ			; OObject::~OObject
??1OMacChannel@@UAE@XZ ENDP				; OMacChannel::~OMacChannel
_TEXT	ENDS
PUBLIC	??_GOMacChannel@@UAEPAXI@Z			; OMacChannel::`scalar deleting destructor'
; Function compile flags: /Ogty
;	COMDAT ??_GOMacChannel@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_GOMacChannel@@UAEPAXI@Z PROC NEAR			; OMacChannel::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1OMacChannel@@UAE@XZ			; OMacChannel::~OMacChannel
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $L52808
	mov	DWORD PTR [esi+4], 0
	mov	edx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	dec	edx
	mov	DWORD PTR ?sObjCount@OObject@@1KA, edx	; OObject::sObjCount
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L52808:
	mov	eax, esi
	pop	esi
	ret	4
??_GOMacChannel@@UAEPAXI@Z ENDP				; OMacChannel::`scalar deleting destructor'
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??_EOMacChannel@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_EOMacChannel@@UAEPAXI@Z PROC NEAR			; OMacChannel::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebx
	mov	bl, BYTE PTR ___flags$[esp]
	push	esi
	mov	esi, ecx
	test	bl, 2
	je	SHORT $L11108
	mov	eax, DWORD PTR [esi-4]
	push	edi
	lea	edi, DWORD PTR [esi-4]
	push	OFFSET FLAT:??1OMacChannel@@UAE@XZ	; OMacChannel::~OMacChannel
	push	eax
	push	56					; 00000038H
	push	esi
	call	??_M@YGXPAXIHP6EX0@Z@Z			; `eh vector destructor iterator'
	test	bl, 1
	je	SHORT $L11109
	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L11109:
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	ret	4
$L11108:
	mov	ecx, esi
	call	??1OMacChannel@@UAE@XZ			; OMacChannel::~OMacChannel
	test	bl, 1
	je	SHORT $L52818
	mov	DWORD PTR [esi+4], 0
	mov	edx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	dec	edx
	mov	DWORD PTR ?sObjCount@OObject@@1KA, edx	; OObject::sObjCount
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L52818:
	mov	eax, esi
	pop	esi
	pop	ebx
	ret	4
??_EOMacChannel@@UAEPAXI@Z ENDP				; OMacChannel::`vector deleting destructor'
; Function compile flags: /Ogty
; File C:\duke4\Cannibal\CorMain.h
_TEXT	ENDS
;	COMDAT ?AddNoConstruct@?$TCorArray@VCCpjSeqTranslate@@@@QAEKK@Z
_TEXT	SEGMENT
_inCount$ = 8
?AddNoConstruct@?$TCorArray@VCCpjSeqTranslate@@@@QAEKK@Z PROC NEAR ; TCorArray<CCpjSeqTranslate>::AddNoConstruct, COMDAT
; _this$ = ecx

; 322  : 		NDword i = m_Count;
; 323  : 		if ((m_Count+=inCount)>m_Limit)

	mov	eax, DWORD PTR _inCount$[esp-4]
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	add	eax, edi
	cmp	eax, ecx
	mov	DWORD PTR [esi+4], eax
	jbe	SHORT $L52838

; 324  : 		{
; 325  : 			m_Limit = m_Count + (m_Count>>2) + 32;

	mov	ecx, eax

; 326  : 			Realloc(sizeof(T));

	mov	DWORD PTR [esi+12], 16			; 00000010H
	shr	ecx, 2
	lea	eax, DWORD PTR [ecx+eax+32]
	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	mov	DWORD PTR [esi+8], eax
	je	SHORT $L52829
	test	eax, eax
	je	SHORT $L52831
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [esi+8]
	push	ecx
	mov	ecx, DWORD PTR [esi]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+4]
	mov	DWORD PTR [esi], eax

; 327  : 		}
; 328  : 		return(i);

	mov	eax, edi
	pop	edi
	pop	esi

; 329  : 	}

	ret	4

; 326  : 			Realloc(sizeof(T));

$L52831:
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L52835:
	mov	DWORD PTR [esi], 0
$L52838:

; 327  : 		}
; 328  : 		return(i);

	mov	eax, edi
	pop	edi
	pop	esi

; 329  : 	}

	ret	4

; 326  : 			Realloc(sizeof(T));

$L52829:
	test	eax, eax
	je	SHORT $L52835
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [esi+8]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	DWORD PTR [esi], eax

; 327  : 		}
; 328  : 		return(i);

	mov	eax, edi
	pop	edi
	pop	esi

; 329  : 	}

	ret	4
?AddNoConstruct@?$TCorArray@VCCpjSeqTranslate@@@@QAEKK@Z ENDP ; TCorArray<CCpjSeqTranslate>::AddNoConstruct
_TEXT	ENDS
PUBLIC	??2OMacSequenceChannel@@CAPAXIPAVOObject@@PAVCObjClass@@@Z ; OMacSequenceChannel::operator new
; Function compile flags: /Ogty
; File C:\duke4\Cannibal\MacMain.h
;	COMDAT ??2OMacSequenceChannel@@CAPAXIPAVOObject@@PAVCObjClass@@@Z
_TEXT	SEGMENT
_inParent$ = 12
_inSetClass$ = 16
??2OMacSequenceChannel@@CAPAXIPAVOObject@@PAVCObjClass@@@Z PROC NEAR ; OMacSequenceChannel::operator new, COMDAT

; 218  : 	OBJ_CLASS_DEFINE(OMacSequenceChannel, OMacChannel);

	push	esi
	push	edi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	72					; 00000048H
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	ecx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	mov	esi, eax
	inc	ecx
	xor	eax, eax
	mov	DWORD PTR ?sObjCount@OObject@@1KA, ecx	; OObject::sObjCount
	mov	ecx, 18					; 00000012H
	mov	edi, esi
	rep stosd
	mov	eax, DWORD PTR [esi+40]
	mov	DWORD PTR [esi+4], 305419896		; 12345678H
	test	eax, eax
	jne	SHORT $L52849
	mov	eax, DWORD PTR _inSetClass$[esp+4]
	mov	DWORD PTR [esi+40], eax
$L52849:
	mov	ecx, DWORD PTR _inParent$[esp+4]
	push	ecx
	mov	ecx, esi
	call	?PreConstruct@OObject@@QAEXPAV1@@Z	; OObject::PreConstruct
	mov	eax, esi
	pop	edi
	pop	esi
	ret	0
??2OMacSequenceChannel@@CAPAXIPAVOObject@@PAVCObjClass@@@Z ENDP ; OMacSequenceChannel::operator new
_TEXT	ENDS
PUBLIC	??3OMacSequenceChannel@@CAXPAX@Z		; OMacSequenceChannel::operator delete
; Function compile flags: /Ogty
;	COMDAT ??3OMacSequenceChannel@@CAXPAX@Z
_TEXT	SEGMENT
_ptr$ = 8
??3OMacSequenceChannel@@CAXPAX@Z PROC NEAR		; OMacSequenceChannel::operator delete, COMDAT

; 218  : 	OBJ_CLASS_DEFINE(OMacSequenceChannel, OMacChannel);

	push	esi
	mov	esi, DWORD PTR _ptr$[esp]
	mov	DWORD PTR [esi+4], 0
	mov	edx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	dec	edx
	mov	DWORD PTR ?sObjCount@OObject@@1KA, edx	; OObject::sObjCount
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	ecx, eax
	call	DWORD PTR [edx+8]
	pop	esi
	ret	0
??3OMacSequenceChannel@@CAXPAX@Z ENDP			; OMacSequenceChannel::operator delete
_TEXT	ENDS
PUBLIC	??3OMacSequenceChannel@@CAXPAXPAVOObject@@PAVCObjClass@@@Z ; OMacSequenceChannel::operator delete
; Function compile flags: /Ogty
;	COMDAT ??3OMacSequenceChannel@@CAXPAXPAVOObject@@PAVCObjClass@@@Z
_TEXT	SEGMENT
_ptr$ = 8
??3OMacSequenceChannel@@CAXPAXPAVOObject@@PAVCObjClass@@@Z PROC NEAR ; OMacSequenceChannel::operator delete, COMDAT

; 218  : 	OBJ_CLASS_DEFINE(OMacSequenceChannel, OMacChannel);

	push	esi
	mov	esi, DWORD PTR _ptr$[esp]
	mov	DWORD PTR [esi+4], 0
	mov	edx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	dec	edx
	mov	DWORD PTR ?sObjCount@OObject@@1KA, edx	; OObject::sObjCount
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	ecx, eax
	call	DWORD PTR [edx+8]
	pop	esi
	ret	0
??3OMacSequenceChannel@@CAXPAXPAVOObject@@PAVCObjClass@@@Z ENDP ; OMacSequenceChannel::operator delete
; Function compile flags: /Ogty
; File C:\duke4\Cannibal\CorMain.h
_TEXT	ENDS
;	COMDAT ?AddNoConstruct@?$TCorArray@VCCpjSeqRotate@@@@QAEKK@Z
_TEXT	SEGMENT
_inCount$ = 8
?AddNoConstruct@?$TCorArray@VCCpjSeqRotate@@@@QAEKK@Z PROC NEAR ; TCorArray<CCpjSeqRotate>::AddNoConstruct, COMDAT
; _this$ = ecx

; 322  : 		NDword i = m_Count;
; 323  : 		if ((m_Count+=inCount)>m_Limit)

	mov	eax, DWORD PTR _inCount$[esp-4]
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	add	eax, edi
	cmp	eax, ecx
	mov	DWORD PTR [esi+4], eax
	jbe	SHORT $L52881

; 324  : 		{
; 325  : 			m_Limit = m_Count + (m_Count>>2) + 32;

	mov	ecx, eax

; 326  : 			Realloc(sizeof(T));

	mov	DWORD PTR [esi+12], 24			; 00000018H
	shr	ecx, 2
	lea	eax, DWORD PTR [ecx+eax+32]
	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	mov	DWORD PTR [esi+8], eax
	je	SHORT $L52873
	test	eax, eax
	je	SHORT $L52875
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [esi+8]
	push	ecx
	mov	ecx, DWORD PTR [esi]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+4]
	mov	DWORD PTR [esi], eax

; 327  : 		}
; 328  : 		return(i);

	mov	eax, edi
	pop	edi
	pop	esi

; 329  : 	}

	ret	4

; 326  : 			Realloc(sizeof(T));

$L52875:
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L52879:
	mov	DWORD PTR [esi], 0
$L52881:

; 327  : 		}
; 328  : 		return(i);

	mov	eax, edi
	pop	edi
	pop	esi

; 329  : 	}

	ret	4

; 326  : 			Realloc(sizeof(T));

$L52873:
	test	eax, eax
	je	SHORT $L52879
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [esi+8]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	DWORD PTR [esi], eax

; 327  : 		}
; 328  : 		return(i);

	mov	eax, edi
	pop	edi
	pop	esi

; 329  : 	}

	ret	4
?AddNoConstruct@?$TCorArray@VCCpjSeqRotate@@@@QAEKK@Z ENDP ; TCorArray<CCpjSeqRotate>::AddNoConstruct
_TEXT	ENDS
PUBLIC	?GetStaticClass@OMacSequenceChannel@@SAPAVCObjClass@@XZ ; OMacSequenceChannel::GetStaticClass
; Function compile flags: /Ogty
; File C:\duke4\Cannibal\MacMain.h
;	COMDAT ?GetStaticClass@OMacSequenceChannel@@SAPAVCObjClass@@XZ
_TEXT	SEGMENT
?GetStaticClass@OMacSequenceChannel@@SAPAVCObjClass@@XZ PROC NEAR ; OMacSequenceChannel::GetStaticClass, COMDAT

; 218  : 	OBJ_CLASS_DEFINE(OMacSequenceChannel, OMacChannel);

	mov	eax, DWORD PTR ?staticObjClass@OMacSequenceChannel@@0PAVCObjClass@@A ; OMacSequenceChannel::staticObjClass
	ret	0
?GetStaticClass@OMacSequenceChannel@@SAPAVCObjClass@@XZ ENDP ; OMacSequenceChannel::GetStaticClass
_TEXT	ENDS
PUBLIC	?GetClass@OMacSequenceChannel@@UAEPAVCObjClass@@XZ ; OMacSequenceChannel::GetClass
PUBLIC	?Create@OMacSequenceChannel@@UAEXXZ		; OMacSequenceChannel::Create
PUBLIC	??_7OMacSequenceChannel@@6B@			; OMacSequenceChannel::`vftable'
PUBLIC	??_EOMacSequenceChannel@@UAEPAXI@Z		; OMacSequenceChannel::`vector deleting destructor'
;	COMDAT xdata$x
xdata$x	SEGMENT
$T52929	DD	0ffffffffH
	DD	FLAT:$L52892
$T52927	DD	019930520H
	DD	01H
	DD	FLAT:$T52929
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_7OMacSequenceChannel@@6B@
CONST	SEGMENT
??_7OMacSequenceChannel@@6B@ DD FLAT:?Msg@OObject@@UAE_NPAVIMsg@@@Z ; OMacSequenceChannel::`vftable'
	DD	FLAT:?MsgGetChild@OObject@@UAEPAVIMsgTarget@@PAD@Z
	DD	FLAT:?MsgGetParent@OObject@@UAEPAVIMsgTarget@@XZ
	DD	FLAT:?MsgGetRoot@OObject@@UAEPAVIMsgTarget@@XZ
	DD	FLAT:?GetClass@OMacSequenceChannel@@UAEPAVCObjClass@@XZ
	DD	FLAT:??_EOMacSequenceChannel@@UAEPAXI@Z
	DD	FLAT:?Create@OMacSequenceChannel@@UAEXXZ
	DD	FLAT:?Destroy@OObject@@UAEXXZ
	DD	FLAT:?GetParent@OObject@@UAEPAV1@XZ
	DD	FLAT:?SetParent@OObject@@UAEXPAV1@_N@Z
	DD	FLAT:?HasChildren@OObject@@UAE_NXZ
	DD	FLAT:?IsA@OObject@@UAE_NPAVCObjClass@@@Z
	DD	FLAT:?EvalBones@OMacSequenceChannel@@UAE_NPAVOMacActor@@@Z
	DD	FLAT:?EvalVerts@OMacSequenceChannel@@UAE_NPAVOMacActor@@KPAGPAVVVec3@@@Z
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?New@OMacSequenceChannel@@SAPAV1@PAVOObject@@PAVCObjClass@@@Z
_TEXT	SEGMENT
$T52889 = -16
__$EHRec$ = -12
_inParent$ = 8
_inSetClass$ = 12
?New@OMacSequenceChannel@@SAPAV1@PAVOObject@@PAVCObjClass@@@Z PROC NEAR ; OMacSequenceChannel::New, COMDAT

; 218  : 	OBJ_CLASS_DEFINE(OMacSequenceChannel, OMacChannel);

	push	-1
	push	$L52928
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	push	ebx
	mov	ebx, DWORD PTR _inSetClass$[esp+16]
	test	ebx, ebx
	push	esi
	jne	SHORT $L11173
	mov	ebx, DWORD PTR ?staticObjClass@OMacSequenceChannel@@0PAVCObjClass@@A ; OMacSequenceChannel::staticObjClass
	mov	DWORD PTR _inSetClass$[esp+20], ebx
$L11173:
	push	edi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	72					; 00000048H
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	ecx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	mov	esi, eax
	inc	ecx
	xor	eax, eax
	mov	DWORD PTR ?sObjCount@OObject@@1KA, ecx	; OObject::sObjCount
	mov	ecx, 18					; 00000012H
	mov	edi, esi
	rep stosd
	mov	eax, DWORD PTR [esi+40]
	mov	DWORD PTR [esi+4], 305419896		; 12345678H
	test	eax, eax
	pop	edi
	jne	SHORT $L52912
	mov	DWORD PTR [esi+40], ebx
$L52912:
	mov	eax, DWORD PTR _inParent$[esp+20]
	mov	ecx, esi
	push	eax
	call	?PreConstruct@OObject@@QAEXPAV1@@Z	; OObject::PreConstruct
	mov	DWORD PTR $T52889[esp+24], esi
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+32], 0
	call	??0OObject@@QAE@XZ			; OObject::OObject
	mov	DWORD PTR [esi], OFFSET FLAT:??_7OMacSequenceChannel@@6B@ ; OMacSequenceChannel::`vftable'
	mov	edx, DWORD PTR [esi]
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+32], -1
	call	DWORD PTR [edx+24]
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	eax, esi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L52892:
	mov	eax, DWORD PTR _inSetClass$[ebp-4]
	push	eax
	mov	ecx, DWORD PTR _inParent$[ebp-4]
	push	ecx
	mov	edx, DWORD PTR $T52889[ebp]
	push	edx
	call	??3OMacSequenceChannel@@CAXPAXPAVOObject@@PAVCObjClass@@@Z ; OMacSequenceChannel::operator delete
	add	esp, 12					; 0000000cH
	ret	0
$L52928:
	mov	eax, OFFSET FLAT:$T52927
	jmp	___CxxFrameHandler
text$x	ENDS
?New@OMacSequenceChannel@@SAPAV1@PAVOObject@@PAVCObjClass@@@Z ENDP ; OMacSequenceChannel::New
; Function compile flags: /Ogty
; File C:\duke4\Cannibal\CorMain.h
;	COMDAT ?Remove@?$TCorArray@VCCpjSeqRotate@@@@QAEXKK@Z
_TEXT	SEGMENT
_inIndex$ = 8
_inCount$ = 12
?Remove@?$TCorArray@VCCpjSeqRotate@@@@QAEXKK@Z PROC NEAR ; TCorArray<CCpjSeqRotate>::Remove, COMDAT
; _this$ = ecx

; 374  : 	{

	push	ebx

; 375  : 		for (NDword i=inIndex; i<(inIndex+inCount); i++)

	mov	ebx, DWORD PTR _inCount$[esp]
	push	esi
	push	edi
	mov	edi, DWORD PTR _inIndex$[esp+8]
	mov	esi, ecx

; 376  : 			(&(*this)[i])->~T();
; 377  : 		CCorArray::Remove(inIndex, inCount, sizeof(T));

	test	ebx, ebx
	lea	eax, DWORD PTR [edi+ebx]
	je	SHORT $L52937
	mov	edx, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [eax+eax*2]
	lea	edx, DWORD PTR [edx+edx*2]
	shl	eax, 3
	shl	edx, 3
	sub	edx, eax
	add	eax, ecx
	push	edx
	lea	edx, DWORD PTR [edi+edi*2]
	push	eax
	lea	eax, DWORD PTR [ecx+edx*8]
	push	eax
	call	DWORD PTR __imp__memmove
	mov	eax, DWORD PTR [esi+4]
	add	esp, 12					; 0000000cH
	sub	eax, ebx
	mov	DWORD PTR [esi+4], eax
$L52937:
	pop	edi
	pop	esi
	pop	ebx

; 378  : 	}

	ret	8
?Remove@?$TCorArray@VCCpjSeqRotate@@@@QAEXKK@Z ENDP	; TCorArray<CCpjSeqRotate>::Remove
; Function compile flags: /Ogty
; File C:\duke4\Cannibal\MacMain.h
_TEXT	ENDS
;	COMDAT ?GetClass@OMacSequenceChannel@@UAEPAVCObjClass@@XZ
_TEXT	SEGMENT
?GetClass@OMacSequenceChannel@@UAEPAVCObjClass@@XZ PROC NEAR ; OMacSequenceChannel::GetClass, COMDAT
; _this$ = ecx

; 218  : 	OBJ_CLASS_DEFINE(OMacSequenceChannel, OMacChannel);

	mov	eax, DWORD PTR [ecx+40]
	ret	0
?GetClass@OMacSequenceChannel@@UAEPAVCObjClass@@XZ ENDP	; OMacSequenceChannel::GetClass
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?Create@OMacSequenceChannel@@UAEXXZ
_TEXT	SEGMENT
?Create@OMacSequenceChannel@@UAEXXZ PROC NEAR		; OMacSequenceChannel::Create, COMDAT
; _this$ = ecx

; 225  : 	void Create() { Super::Create(); mSequence = NULL; mTime = 0.f; mBlendAlpha = 1.f; mBlendMode = MACSEQBLEND_SET; }

	push	esi
	mov	esi, ecx
	call	?Create@OObject@@UAEXXZ			; OObject::Create
	xor	eax, eax
	mov	DWORD PTR [esi+64], 1065353216		; 3f800000H
	mov	DWORD PTR [esi+56], eax
	mov	DWORD PTR [esi+60], eax
	mov	DWORD PTR [esi+68], eax
	pop	esi
	ret	0
?Create@OMacSequenceChannel@@UAEXXZ ENDP		; OMacSequenceChannel::Create
; Function compile flags: /Ogty
; File C:\duke4\Cannibal\CorMain.h
_TEXT	ENDS
;	COMDAT ?AddNoConstruct@?$TCorArray@VCCpjSeqScale@@@@QAEKK@Z
_TEXT	SEGMENT
_inCount$ = 8
?AddNoConstruct@?$TCorArray@VCCpjSeqScale@@@@QAEKK@Z PROC NEAR ; TCorArray<CCpjSeqScale>::AddNoConstruct, COMDAT
; _this$ = ecx

; 322  : 		NDword i = m_Count;
; 323  : 		if ((m_Count+=inCount)>m_Limit)

	mov	eax, DWORD PTR _inCount$[esp-4]
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	add	eax, edi
	cmp	eax, ecx
	mov	DWORD PTR [esi+4], eax
	jbe	SHORT $L52961

; 324  : 		{
; 325  : 			m_Limit = m_Count + (m_Count>>2) + 32;

	mov	ecx, eax

; 326  : 			Realloc(sizeof(T));

	mov	DWORD PTR [esi+12], 16			; 00000010H
	shr	ecx, 2
	lea	eax, DWORD PTR [ecx+eax+32]
	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	mov	DWORD PTR [esi+8], eax
	je	SHORT $L52953
	test	eax, eax
	je	SHORT $L52955
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [esi+8]
	push	ecx
	mov	ecx, DWORD PTR [esi]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+4]
	mov	DWORD PTR [esi], eax

; 327  : 		}
; 328  : 		return(i);

	mov	eax, edi
	pop	edi
	pop	esi

; 329  : 	}

	ret	4

; 326  : 			Realloc(sizeof(T));

$L52955:
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L52959:
	mov	DWORD PTR [esi], 0
$L52961:

; 327  : 		}
; 328  : 		return(i);

	mov	eax, edi
	pop	edi
	pop	esi

; 329  : 	}

	ret	4

; 326  : 			Realloc(sizeof(T));

$L52953:
	test	eax, eax
	je	SHORT $L52959
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [esi+8]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	DWORD PTR [esi], eax

; 327  : 		}
; 328  : 		return(i);

	mov	eax, edi
	pop	edi
	pop	esi

; 329  : 	}

	ret	4
?AddNoConstruct@?$TCorArray@VCCpjSeqScale@@@@QAEKK@Z ENDP ; TCorArray<CCpjSeqScale>::AddNoConstruct
_TEXT	ENDS
PUBLIC	??0OMacSequenceChannel@@QAE@XZ			; OMacSequenceChannel::OMacSequenceChannel
; Function compile flags: /Ogty
;	COMDAT ??0OMacSequenceChannel@@QAE@XZ
_TEXT	SEGMENT
??0OMacSequenceChannel@@QAE@XZ PROC NEAR		; OMacSequenceChannel::OMacSequenceChannel, COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??0OObject@@QAE@XZ			; OObject::OObject
	mov	DWORD PTR [esi], OFFSET FLAT:??_7OMacSequenceChannel@@6B@ ; OMacSequenceChannel::`vftable'
	mov	eax, esi
	pop	esi
	ret	0
??0OMacSequenceChannel@@QAE@XZ ENDP			; OMacSequenceChannel::OMacSequenceChannel
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?Remove@?$TCorArray@VCCpjSeqScale@@@@QAEXKK@Z
_TEXT	SEGMENT
_inIndex$ = 8
_inCount$ = 12
?Remove@?$TCorArray@VCCpjSeqScale@@@@QAEXKK@Z PROC NEAR	; TCorArray<CCpjSeqScale>::Remove, COMDAT
; _this$ = ecx

; 374  : 	{

	push	esi
	push	edi

; 375  : 		for (NDword i=inIndex; i<(inIndex+inCount); i++)

	mov	edi, DWORD PTR _inCount$[esp+4]
	mov	esi, ecx
	mov	ecx, DWORD PTR _inIndex$[esp+4]

; 376  : 			(&(*this)[i])->~T();
; 377  : 		CCorArray::Remove(inIndex, inCount, sizeof(T));

	test	edi, edi
	lea	eax, DWORD PTR [ecx+edi]
	je	SHORT $L52975
	mov	edx, DWORD PTR [esi]
	push	ebx
	mov	ebx, DWORD PTR [esi+4]
	sub	ebx, eax
	shl	eax, 4
	shl	ebx, 4
	shl	ecx, 4
	add	eax, edx
	push	ebx
	add	ecx, edx
	push	eax
	push	ecx
	call	DWORD PTR __imp__memmove
	mov	eax, DWORD PTR [esi+4]
	add	esp, 12					; 0000000cH
	sub	eax, edi
	mov	DWORD PTR [esi+4], eax
	pop	ebx
$L52975:
	pop	edi
	pop	esi

; 378  : 	}

	ret	8
?Remove@?$TCorArray@VCCpjSeqScale@@@@QAEXKK@Z ENDP	; TCorArray<CCpjSeqScale>::Remove
_TEXT	ENDS
PUBLIC	??0OMacSequenceChannel@@QAE@ABV0@@Z		; OMacSequenceChannel::OMacSequenceChannel
;	COMDAT xdata$x
xdata$x	SEGMENT
$T53049	DD	0ffffffffH
	DD	FLAT:$L52986
	DD	00H
	DD	FLAT:$L52987
$T53046	DD	019930520H
	DD	02H
	DD	FLAT:$T53049
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ??0OMacSequenceChannel@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8
_this$ = -16
__$EHRec$ = -12
??0OMacSequenceChannel@@QAE@ABV0@@Z PROC NEAR		; OMacSequenceChannel::OMacSequenceChannel, COMDAT
; _this$ = ecx
	push	-1
	push	$L53048
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	push	ebx
	mov	ebx, DWORD PTR ___that$[esp+16]
	push	ebp
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [ebx+8]
	push	edi
	mov	DWORD PTR _this$[esp+32], esi
	mov	DWORD PTR [esi], OFFSET FLAT:??_7IMsgTarget@@6B@ ; IMsgTarget::`vftable'
	mov	eax, DWORD PTR [ebx+4]
	mov	DWORD PTR [esi+4], eax
	mov	eax, DWORD PTR [ecx]
	lea	edx, DWORD PTR [esi+8]
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], ecx
	lea	edx, DWORD PTR [ebx+24]
	lea	ecx, DWORD PTR [esi+24]
	xor	eax, eax
	mov	edi, DWORD PTR [edx]
	mov	DWORD PTR __$EHRec$[esp+40], eax
	mov	DWORD PTR [ecx], edi
	mov	edi, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], edi
	mov	edi, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], edi
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [ecx+12], edx
	mov	ecx, DWORD PTR [ebx+40]
	mov	BYTE PTR __$EHRec$[esp+40], 1
	mov	DWORD PTR [esi+40], ecx
	mov	DWORD PTR [esi+44], eax
	mov	ebp, DWORD PTR [ebx+44]
	cmp	ebp, eax
	je	SHORT $L53038
	cmp	BYTE PTR [ebp], 0
	jne	SHORT $L53038
	xor	ebp, ebp
$L53038:
	cmp	ebp, eax
	mov	DWORD PTR [esi+44], eax
	je	SHORT $L53041
	mov	edi, ebp
	or	ecx, -1
	xor	eax, eax
	repne scasb
	not	ecx
	dec	ecx
	mov	edi, ecx
	inc	edi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	edi
	mov	ecx, eax
	call	DWORD PTR [edx]
	test	eax, eax
	mov	DWORD PTR [esi+44], eax
	je	SHORT $L53041
	mov	ecx, eax
$L53035:
	mov	al, BYTE PTR [ebp]
	inc	ebp
	mov	BYTE PTR [ecx], al
	inc	ecx
	test	al, al
	jne	SHORT $L53035
	add	DWORD PTR ?sMemTotal@CCorString@@0KA, edi ; CCorString::sMemTotal
$L53041:
	mov	eax, DWORD PTR [ebx+48]
	pop	edi
	mov	DWORD PTR [esi+48], eax
	mov	ecx, DWORD PTR [ebx+52]
	mov	DWORD PTR [esi+52], ecx
	mov	DWORD PTR [esi], OFFSET FLAT:??_7OMacChannel@@6B@ ; OMacChannel::`vftable'
	mov	edx, DWORD PTR [ebx+56]
	mov	DWORD PTR [esi+56], edx
	mov	eax, DWORD PTR [ebx+60]
	mov	DWORD PTR [esi+60], eax
	mov	ecx, DWORD PTR [ebx+64]
	mov	DWORD PTR [esi+64], ecx
	mov	edx, DWORD PTR [ebx+68]
	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR [esi+68], edx
	mov	DWORD PTR [esi], OFFSET FLAT:??_7OMacSequenceChannel@@6B@ ; OMacSequenceChannel::`vftable'
	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L52986:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1CObjLink@@QAE@XZ			; CObjLink::~CObjLink
$L52987:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	jmp	??1CObjLink@@QAE@XZ			; CObjLink::~CObjLink
$L53048:
	mov	eax, OFFSET FLAT:$T53046
	jmp	___CxxFrameHandler
text$x	ENDS
??0OMacSequenceChannel@@QAE@ABV0@@Z ENDP		; OMacSequenceChannel::OMacSequenceChannel
PUBLIC	??4OMacSequenceChannel@@QAEAAV0@ABV0@@Z		; OMacSequenceChannel::operator=
; Function compile flags: /Ogty
;	COMDAT ??4OMacSequenceChannel@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8
??4OMacSequenceChannel@@QAEAAV0@ABV0@@Z PROC NEAR	; OMacSequenceChannel::operator=, COMDAT
; _this$ = ecx
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR ___that$[esp+4]
	push	esi
	mov	esi, ecx
	push	edi
	mov	eax, DWORD PTR [ebp+4]
	lea	ecx, DWORD PTR [ebp+8]
	mov	DWORD PTR [esi+4], eax
	lea	edx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	lea	eax, DWORD PTR [esi+24]
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], ecx
	lea	edx, DWORD PTR [ebp+24]
	mov	ecx, DWORD PTR [ebp+24]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR [ebp+40]
	mov	DWORD PTR [esi+40], eax
	mov	ebx, DWORD PTR [ebp+44]
	test	ebx, ebx
	je	SHORT $L53105
	cmp	BYTE PTR [ebx], 0
	jne	SHORT $L53105
	xor	ebx, ebx
$L53105:
	mov	edi, DWORD PTR [esi+44]
	test	edi, edi
	je	SHORT $L53106
	or	ecx, -1
	xor	eax, eax
	repne scasb
	mov	eax, DWORD PTR ?sMemTotal@CCorString@@0KA ; CCorString::sMemTotal
	or	edx, -1
	not	ecx
	dec	ecx
	sub	edx, ecx
	add	eax, edx
	mov	DWORD PTR ?sMemTotal@CCorString@@0KA, eax ; CCorString::sMemTotal
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+44]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L53106:
	test	ebx, ebx
	mov	DWORD PTR [esi+44], 0
	je	SHORT $L53109
	mov	edi, ebx
	or	ecx, -1
	xor	eax, eax
	repne scasb
	not	ecx
	dec	ecx
	mov	edi, ecx
	inc	edi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	edi
	mov	ecx, eax
	call	DWORD PTR [edx]
	test	eax, eax
	mov	DWORD PTR [esi+44], eax
	je	SHORT $L53109
$L53103:
	mov	cl, BYTE PTR [ebx]
	inc	ebx
	mov	BYTE PTR [eax], cl
	inc	eax
	test	cl, cl
	jne	SHORT $L53103
	add	DWORD PTR ?sMemTotal@CCorString@@0KA, edi ; CCorString::sMemTotal
$L53109:
	mov	eax, DWORD PTR [ebp+48]
	pop	edi
	mov	DWORD PTR [esi+48], eax
	mov	ecx, DWORD PTR [ebp+52]
	mov	DWORD PTR [esi+52], ecx
	mov	edx, DWORD PTR [ebp+56]
	mov	DWORD PTR [esi+56], edx
	mov	eax, DWORD PTR [ebp+60]
	mov	DWORD PTR [esi+60], eax
	mov	ecx, DWORD PTR [ebp+64]
	mov	DWORD PTR [esi+64], ecx
	mov	edx, DWORD PTR [ebp+68]
	mov	DWORD PTR [esi+68], edx
	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx
	ret	4
??4OMacSequenceChannel@@QAEAAV0@ABV0@@Z ENDP		; OMacSequenceChannel::operator=
_TEXT	ENDS
PUBLIC	??1OMacSequenceChannel@@UAE@XZ			; OMacSequenceChannel::~OMacSequenceChannel
; Function compile flags: /Ogty
;	COMDAT ??1OMacSequenceChannel@@UAE@XZ
_TEXT	SEGMENT
??1OMacSequenceChannel@@UAE@XZ PROC NEAR		; OMacSequenceChannel::~OMacSequenceChannel, COMDAT
; _this$ = ecx
	jmp	??1OObject@@UAE@XZ			; OObject::~OObject
??1OMacSequenceChannel@@UAE@XZ ENDP			; OMacSequenceChannel::~OMacSequenceChannel
_TEXT	ENDS
PUBLIC	??_GOMacSequenceChannel@@UAEPAXI@Z		; OMacSequenceChannel::`scalar deleting destructor'
; Function compile flags: /Ogty
;	COMDAT ??_GOMacSequenceChannel@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_GOMacSequenceChannel@@UAEPAXI@Z PROC NEAR		; OMacSequenceChannel::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1OMacSequenceChannel@@UAE@XZ		; OMacSequenceChannel::~OMacSequenceChannel
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $L53137
	mov	DWORD PTR [esi+4], 0
	mov	edx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	dec	edx
	mov	DWORD PTR ?sObjCount@OObject@@1KA, edx	; OObject::sObjCount
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L53137:
	mov	eax, esi
	pop	esi
	ret	4
??_GOMacSequenceChannel@@UAEPAXI@Z ENDP			; OMacSequenceChannel::`scalar deleting destructor'
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??_EOMacSequenceChannel@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_EOMacSequenceChannel@@UAEPAXI@Z PROC NEAR		; OMacSequenceChannel::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebx
	mov	bl, BYTE PTR ___flags$[esp]
	push	esi
	mov	esi, ecx
	test	bl, 2
	je	SHORT $L11202
	mov	eax, DWORD PTR [esi-4]
	push	edi
	lea	edi, DWORD PTR [esi-4]
	push	OFFSET FLAT:??1OMacSequenceChannel@@UAE@XZ ; OMacSequenceChannel::~OMacSequenceChannel
	push	eax
	push	72					; 00000048H
	push	esi
	call	??_M@YGXPAXIHP6EX0@Z@Z			; `eh vector destructor iterator'
	test	bl, 1
	je	SHORT $L11203
	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L11203:
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	ret	4
$L11202:
	mov	ecx, esi
	call	??1OMacSequenceChannel@@UAE@XZ		; OMacSequenceChannel::~OMacSequenceChannel
	test	bl, 1
	je	SHORT $L53152
	mov	DWORD PTR [esi+4], 0
	mov	edx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	dec	edx
	mov	DWORD PTR ?sObjCount@OObject@@1KA, edx	; OObject::sObjCount
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L53152:
	mov	eax, esi
	pop	esi
	pop	ebx
	ret	4
??_EOMacSequenceChannel@@UAEPAXI@Z ENDP			; OMacSequenceChannel::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??2OMacIKChannel@@CAPAXIPAVOObject@@PAVCObjClass@@@Z ; OMacIKChannel::operator new
; Function compile flags: /Ogty
; File C:\duke4\Cannibal\MacMain.h
;	COMDAT ??2OMacIKChannel@@CAPAXIPAVOObject@@PAVCObjClass@@@Z
_TEXT	SEGMENT
_inParent$ = 12
_inSetClass$ = 16
??2OMacIKChannel@@CAPAXIPAVOObject@@PAVCObjClass@@@Z PROC NEAR ; OMacIKChannel::operator new, COMDAT

; 239  : 	OBJ_CLASS_DEFINE(OMacIKChannel, OMacChannel);

	push	esi
	push	edi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	132					; 00000084H
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	ecx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	mov	esi, eax
	inc	ecx
	xor	eax, eax
	mov	DWORD PTR ?sObjCount@OObject@@1KA, ecx	; OObject::sObjCount
	mov	ecx, 33					; 00000021H
	mov	edi, esi
	rep stosd
	mov	eax, DWORD PTR [esi+40]
	mov	DWORD PTR [esi+4], 305419896		; 12345678H
	test	eax, eax
	jne	SHORT $L53163
	mov	eax, DWORD PTR _inSetClass$[esp+4]
	mov	DWORD PTR [esi+40], eax
$L53163:
	mov	ecx, DWORD PTR _inParent$[esp+4]
	push	ecx
	mov	ecx, esi
	call	?PreConstruct@OObject@@QAEXPAV1@@Z	; OObject::PreConstruct
	mov	eax, esi
	pop	edi
	pop	esi
	ret	0
??2OMacIKChannel@@CAPAXIPAVOObject@@PAVCObjClass@@@Z ENDP ; OMacIKChannel::operator new
_TEXT	ENDS
PUBLIC	??3OMacIKChannel@@CAXPAX@Z			; OMacIKChannel::operator delete
; Function compile flags: /Ogty
;	COMDAT ??3OMacIKChannel@@CAXPAX@Z
_TEXT	SEGMENT
_ptr$ = 8
??3OMacIKChannel@@CAXPAX@Z PROC NEAR			; OMacIKChannel::operator delete, COMDAT

; 239  : 	OBJ_CLASS_DEFINE(OMacIKChannel, OMacChannel);

	push	esi
	mov	esi, DWORD PTR _ptr$[esp]
	mov	DWORD PTR [esi+4], 0
	mov	edx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	dec	edx
	mov	DWORD PTR ?sObjCount@OObject@@1KA, edx	; OObject::sObjCount
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	ecx, eax
	call	DWORD PTR [edx+8]
	pop	esi
	ret	0
??3OMacIKChannel@@CAXPAX@Z ENDP				; OMacIKChannel::operator delete
_TEXT	ENDS
PUBLIC	??3OMacIKChannel@@CAXPAXPAVOObject@@PAVCObjClass@@@Z ; OMacIKChannel::operator delete
; Function compile flags: /Ogty
;	COMDAT ??3OMacIKChannel@@CAXPAXPAVOObject@@PAVCObjClass@@@Z
_TEXT	SEGMENT
_ptr$ = 8
??3OMacIKChannel@@CAXPAXPAVOObject@@PAVCObjClass@@@Z PROC NEAR ; OMacIKChannel::operator delete, COMDAT

; 239  : 	OBJ_CLASS_DEFINE(OMacIKChannel, OMacChannel);

	push	esi
	mov	esi, DWORD PTR _ptr$[esp]
	mov	DWORD PTR [esi+4], 0
	mov	edx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	dec	edx
	mov	DWORD PTR ?sObjCount@OObject@@1KA, edx	; OObject::sObjCount
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	ecx, eax
	call	DWORD PTR [edx+8]
	pop	esi
	ret	0
??3OMacIKChannel@@CAXPAXPAVOObject@@PAVCObjClass@@@Z ENDP ; OMacIKChannel::operator delete
; Function compile flags: /Ogty
; File C:\duke4\Cannibal\CorMain.h
_TEXT	ENDS
;	COMDAT ?Remove@?$TCorArray@VVBox3@@@@QAEXKK@Z
_TEXT	SEGMENT
_inIndex$ = 8
_inCount$ = 12
?Remove@?$TCorArray@VVBox3@@@@QAEXKK@Z PROC NEAR	; TCorArray<VBox3>::Remove, COMDAT
; _this$ = ecx

; 374  : 	{

	push	ebx

; 375  : 		for (NDword i=inIndex; i<(inIndex+inCount); i++)

	mov	ebx, DWORD PTR _inCount$[esp]
	push	esi
	push	edi
	mov	edi, DWORD PTR _inIndex$[esp+8]
	mov	esi, ecx

; 376  : 			(&(*this)[i])->~T();
; 377  : 		CCorArray::Remove(inIndex, inCount, sizeof(T));

	test	ebx, ebx
	lea	eax, DWORD PTR [edi+ebx]
	je	SHORT $L53186
	mov	edx, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [eax+eax*2]
	lea	edx, DWORD PTR [edx+edx*2]
	lea	eax, DWORD PTR [eax+eax*4]
	lea	edx, DWORD PTR [edx+edx*4]
	shl	eax, 2
	shl	edx, 2
	sub	edx, eax
	add	eax, ecx
	push	edx
	push	eax
	lea	eax, DWORD PTR [edi+edi*2]
	lea	edx, DWORD PTR [eax+eax*4]
	lea	eax, DWORD PTR [ecx+edx*4]
	push	eax
	call	DWORD PTR __imp__memmove
	mov	eax, DWORD PTR [esi+4]
	add	esp, 12					; 0000000cH
	sub	eax, ebx
	mov	DWORD PTR [esi+4], eax
$L53186:
	pop	edi
	pop	esi
	pop	ebx

; 378  : 	}

	ret	8
?Remove@?$TCorArray@VVBox3@@@@QAEXKK@Z ENDP		; TCorArray<VBox3>::Remove
_TEXT	ENDS
PUBLIC	?GetStaticClass@OMacIKChannel@@SAPAVCObjClass@@XZ ; OMacIKChannel::GetStaticClass
; Function compile flags: /Ogty
; File C:\duke4\Cannibal\MacMain.h
;	COMDAT ?GetStaticClass@OMacIKChannel@@SAPAVCObjClass@@XZ
_TEXT	SEGMENT
?GetStaticClass@OMacIKChannel@@SAPAVCObjClass@@XZ PROC NEAR ; OMacIKChannel::GetStaticClass, COMDAT

; 239  : 	OBJ_CLASS_DEFINE(OMacIKChannel, OMacChannel);

	mov	eax, DWORD PTR ?staticObjClass@OMacIKChannel@@0PAVCObjClass@@A ; OMacIKChannel::staticObjClass
	ret	0
?GetStaticClass@OMacIKChannel@@SAPAVCObjClass@@XZ ENDP	; OMacIKChannel::GetStaticClass
_TEXT	ENDS
PUBLIC	?GetClass@OMacIKChannel@@UAEPAVCObjClass@@XZ	; OMacIKChannel::GetClass
PUBLIC	?Create@OMacIKChannel@@UAEXXZ			; OMacIKChannel::Create
PUBLIC	??_7OMacIKChannel@@6B@				; OMacIKChannel::`vftable'
PUBLIC	??_EOMacIKChannel@@UAEPAXI@Z			; OMacIKChannel::`vector deleting destructor'
;	COMDAT xdata$x
; File C:\duke4\Cannibal\VecMain.h
xdata$x	SEGMENT
$T53276	DD	0ffffffffH
	DD	FLAT:$L53200
$T53274	DD	019930520H
	DD	01H
	DD	FLAT:$T53276
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_7OMacIKChannel@@6B@
CONST	SEGMENT
??_7OMacIKChannel@@6B@ DD FLAT:?Msg@OObject@@UAE_NPAVIMsg@@@Z ; OMacIKChannel::`vftable'
	DD	FLAT:?MsgGetChild@OObject@@UAEPAVIMsgTarget@@PAD@Z
	DD	FLAT:?MsgGetParent@OObject@@UAEPAVIMsgTarget@@XZ
	DD	FLAT:?MsgGetRoot@OObject@@UAEPAVIMsgTarget@@XZ
	DD	FLAT:?GetClass@OMacIKChannel@@UAEPAVCObjClass@@XZ
	DD	FLAT:??_EOMacIKChannel@@UAEPAXI@Z
	DD	FLAT:?Create@OMacIKChannel@@UAEXXZ
	DD	FLAT:?Destroy@OObject@@UAEXXZ
	DD	FLAT:?GetParent@OObject@@UAEPAV1@XZ
	DD	FLAT:?SetParent@OObject@@UAEXPAV1@_N@Z
	DD	FLAT:?HasChildren@OObject@@UAE_NXZ
	DD	FLAT:?IsA@OObject@@UAE_NPAVCObjClass@@@Z
	DD	FLAT:?EvalBones@OMacIKChannel@@UAE_NPAVOMacActor@@@Z
	DD	FLAT:?EvalVerts@OMacChannel@@UAE_NPAVOMacActor@@KPAGPAVVVec3@@@Z
; Function compile flags: /Ogty
; File C:\duke4\Cannibal\MacMain.h
CONST	ENDS
;	COMDAT ?New@OMacIKChannel@@SAPAV1@PAVOObject@@PAVCObjClass@@@Z
_TEXT	SEGMENT
_inParent$ = 8
_inSetClass$ = 12
$T53197 = -16
__$EHRec$ = -12
?New@OMacIKChannel@@SAPAV1@PAVOObject@@PAVCObjClass@@@Z PROC NEAR ; OMacIKChannel::New, COMDAT

; 239  : 	OBJ_CLASS_DEFINE(OMacIKChannel, OMacChannel);

	push	-1
	push	$L53275
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _inSetClass$[esp+20]
	xor	ebx, ebx
	cmp	ebp, ebx
	push	esi
	jne	SHORT $L11262
	mov	ebp, DWORD PTR ?staticObjClass@OMacIKChannel@@0PAVCObjClass@@A ; OMacIKChannel::staticObjClass
	mov	DWORD PTR _inSetClass$[esp+24], ebp
$L11262:
	push	edi
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	132					; 00000084H
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	ecx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	mov	esi, eax
	inc	ecx
	xor	eax, eax
	mov	DWORD PTR ?sObjCount@OObject@@1KA, ecx	; OObject::sObjCount
	mov	ecx, 33					; 00000021H
	mov	edi, esi
	rep stosd
	mov	eax, DWORD PTR [esi+40]
	mov	DWORD PTR [esi+4], 305419896		; 12345678H
	cmp	eax, ebx
	pop	edi
	jne	SHORT $L53222
	mov	DWORD PTR [esi+40], ebp
$L53222:
	mov	eax, DWORD PTR _inParent$[esp+24]
	mov	ecx, esi
	push	eax
	call	?PreConstruct@OObject@@QAEXPAV1@@Z	; OObject::PreConstruct
	mov	DWORD PTR $T53197[esp+28], esi
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+36], ebx
	call	??0OObject@@QAE@XZ			; OObject::OObject
	mov	eax, 1065353216				; 3f800000H
	mov	DWORD PTR [esi+96], ebx
	mov	DWORD PTR [esi+92], eax
	mov	DWORD PTR [esi+100], ebx
	mov	DWORD PTR [esi+104], ebx
	mov	DWORD PTR [esi+108], eax
	mov	DWORD PTR [esi+112], ebx
	mov	DWORD PTR [esi+116], ebx
	mov	DWORD PTR [esi+120], ebx
	mov	DWORD PTR [esi+124], eax
	mov	DWORD PTR [esi], OFFSET FLAT:??_7OMacIKChannel@@6B@ ; OMacIKChannel::`vftable'
	mov	edx, DWORD PTR [esi]
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+36], -1
	call	DWORD PTR [edx+24]
	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L53200:
	mov	eax, DWORD PTR _inSetClass$[ebp-4]
	push	eax
	mov	ecx, DWORD PTR _inParent$[ebp-4]
	push	ecx
	mov	edx, DWORD PTR $T53197[ebp]
	push	edx
	call	??3OMacIKChannel@@CAXPAXPAVOObject@@PAVCObjClass@@@Z ; OMacIKChannel::operator delete
	add	esp, 12					; 0000000cH
	ret	0
$L53275:
	mov	eax, OFFSET FLAT:$T53274
	jmp	___CxxFrameHandler
text$x	ENDS
?New@OMacIKChannel@@SAPAV1@PAVOObject@@PAVCObjClass@@@Z ENDP ; OMacIKChannel::New
; Function compile flags: /Ogty
; File C:\duke4\Cannibal\CorMain.h
;	COMDAT ?Add@?$TCorArray@PAVOCpjProject@@@@QAEKK@Z
_TEXT	SEGMENT
_inCount$ = 8
?Add@?$TCorArray@PAVOCpjProject@@@@QAEKK@Z PROC NEAR	; TCorArray<OCpjProject *>::Add, COMDAT
; _this$ = ecx

; 332  : 		NDword index = AddNoConstruct(inCount);

	mov	eax, DWORD PTR _inCount$[esp-4]
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	add	eax, edi
	cmp	eax, ecx
	mov	DWORD PTR [esi+4], eax
	jbe	SHORT $L53317
	mov	ecx, eax
	mov	DWORD PTR [esi+12], 4
	shr	ecx, 2
	lea	eax, DWORD PTR [ecx+eax+32]
	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	mov	DWORD PTR [esi+8], eax
	je	SHORT $L53301
	test	eax, eax
	je	SHORT $L53303
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [esi+8]
	push	ecx
	mov	ecx, DWORD PTR [esi]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+4]
	mov	DWORD PTR [esi], eax

; 333  : 		for (NDword i=index; i<index+inCount; i++)
; 334  : 			new(&(*this)[i]) T;
; 335  : 		return(index);

	mov	eax, edi
	pop	edi
	pop	esi

; 336  : 	}

	ret	4

; 332  : 		NDword index = AddNoConstruct(inCount);

$L53303:
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L53307:
	mov	DWORD PTR [esi], 0
$L53317:

; 333  : 		for (NDword i=index; i<index+inCount; i++)
; 334  : 			new(&(*this)[i]) T;
; 335  : 		return(index);

	mov	eax, edi
	pop	edi
	pop	esi

; 336  : 	}

	ret	4

; 332  : 		NDword index = AddNoConstruct(inCount);

$L53301:
	test	eax, eax
	je	SHORT $L53307
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [esi+8]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	DWORD PTR [esi], eax

; 333  : 		for (NDword i=index; i<index+inCount; i++)
; 334  : 			new(&(*this)[i]) T;
; 335  : 		return(index);

	mov	eax, edi
	pop	edi
	pop	esi

; 336  : 	}

	ret	4
?Add@?$TCorArray@PAVOCpjProject@@@@QAEKK@Z ENDP		; TCorArray<OCpjProject *>::Add
; Function compile flags: /Ogty
; File C:\duke4\Cannibal\MacMain.h
_TEXT	ENDS
;	COMDAT ?GetClass@OMacIKChannel@@UAEPAVCObjClass@@XZ
_TEXT	SEGMENT
?GetClass@OMacIKChannel@@UAEPAVCObjClass@@XZ PROC NEAR	; OMacIKChannel::GetClass, COMDAT
; _this$ = ecx

; 239  : 	OBJ_CLASS_DEFINE(OMacIKChannel, OMacChannel);

	mov	eax, DWORD PTR [ecx+40]
	ret	0
?GetClass@OMacIKChannel@@UAEPAVCObjClass@@XZ ENDP	; OMacIKChannel::GetClass
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?Create@OMacIKChannel@@UAEXXZ
_TEXT	SEGMENT
?Create@OMacIKChannel@@UAEXXZ PROC NEAR			; OMacIKChannel::Create, COMDAT
; _this$ = ecx

; 249  : 	void Create() { Super::Create(); mGoalBone = mChildLimit = mParentLimit = NULL; mGoalBoneOffset = mGoalPosition = VVec3(0,0,0); mRigidity = 1.f; }

	push	esi
	mov	esi, ecx
	call	?Create@OObject@@UAEXXZ			; OObject::Create
	xor	eax, eax
	mov	DWORD PTR [esi+64], eax
	mov	DWORD PTR [esi+60], eax
	mov	DWORD PTR [esi+56], eax
	mov	DWORD PTR [esi+80], eax
	mov	DWORD PTR [esi+84], eax
	mov	DWORD PTR [esi+88], eax
	mov	DWORD PTR [esi+68], eax
	mov	eax, DWORD PTR [esi+84]
	mov	DWORD PTR [esi+72], eax
	mov	ecx, DWORD PTR [esi+88]
	mov	DWORD PTR [esi+76], ecx
	mov	DWORD PTR [esi+128], 1065353216		; 3f800000H
	pop	esi
	ret	0
?Create@OMacIKChannel@@UAEXXZ ENDP			; OMacIKChannel::Create
_TEXT	ENDS
PUBLIC	??0OMacIKChannel@@QAE@XZ			; OMacIKChannel::OMacIKChannel
; Function compile flags: /Ogty
;	COMDAT ??0OMacIKChannel@@QAE@XZ
_TEXT	SEGMENT
??0OMacIKChannel@@QAE@XZ PROC NEAR			; OMacIKChannel::OMacIKChannel, COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??0OObject@@QAE@XZ			; OObject::OObject
	mov	ecx, 1065353216				; 3f800000H
	xor	eax, eax
	mov	DWORD PTR [esi+92], ecx
	mov	DWORD PTR [esi+96], eax
	mov	DWORD PTR [esi+100], eax
	mov	DWORD PTR [esi+104], eax
	mov	DWORD PTR [esi+108], ecx
	mov	DWORD PTR [esi+112], eax
	mov	DWORD PTR [esi+116], eax
	mov	DWORD PTR [esi+120], eax
	mov	DWORD PTR [esi+124], ecx
	mov	DWORD PTR [esi], OFFSET FLAT:??_7OMacIKChannel@@6B@ ; OMacIKChannel::`vftable'
	mov	eax, esi
	pop	esi
	ret	0
??0OMacIKChannel@@QAE@XZ ENDP				; OMacIKChannel::OMacIKChannel
_TEXT	ENDS
PUBLIC	??1CCpjGeoVert@@QAE@XZ				; CCpjGeoVert::~CCpjGeoVert
; Function compile flags: /Ogty
;	COMDAT ??_GCCpjGeoVert@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_GCCpjGeoVert@@QAEPAXI@Z PROC NEAR			; CCpjGeoVert::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1CCpjGeoVert@@QAE@XZ			; CCpjGeoVert::~CCpjGeoVert
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $L53374
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L53374:
	mov	eax, esi
	pop	esi
	ret	4
??_GCCpjGeoVert@@QAEPAXI@Z ENDP				; CCpjGeoVert::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??1CCpjGeoEdge@@QAE@XZ				; CCpjGeoEdge::~CCpjGeoEdge
; Function compile flags: /Ogty
;	COMDAT ??_GCCpjGeoEdge@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_GCCpjGeoEdge@@QAEPAXI@Z PROC NEAR			; CCpjGeoEdge::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1CCpjGeoEdge@@QAE@XZ			; CCpjGeoEdge::~CCpjGeoEdge
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $L53378
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L53378:
	mov	eax, esi
	pop	esi
	ret	4
??_GCCpjGeoEdge@@QAEPAXI@Z ENDP				; CCpjGeoEdge::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??0OMacIKChannel@@QAE@ABV0@@Z			; OMacIKChannel::OMacIKChannel
;	COMDAT xdata$x
xdata$x	SEGMENT
$T53462	DD	0ffffffffH
	DD	FLAT:$L53386
	DD	00H
	DD	FLAT:$L53387
$T53460	DD	019930520H
	DD	02H
	DD	FLAT:$T53462
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ??0OMacIKChannel@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8
_this$ = -16
__$EHRec$ = -12
??0OMacIKChannel@@QAE@ABV0@@Z PROC NEAR			; OMacIKChannel::OMacIKChannel, COMDAT
; _this$ = ecx
	push	-1
	push	$L53461
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	push	esi
	push	edi
	mov	edi, DWORD PTR ___that$[esp+20]
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+24], esi
	mov	DWORD PTR [esi], OFFSET FLAT:??_7IMsgTarget@@6B@ ; IMsgTarget::`vftable'
	mov	eax, DWORD PTR [edi+4]
	lea	ecx, DWORD PTR [edi+8]
	mov	DWORD PTR [esi+4], eax
	lea	edx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], ecx
	lea	edx, DWORD PTR [edi+24]
	lea	eax, DWORD PTR [esi+24]
	mov	DWORD PTR __$EHRec$[esp+32], 0
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR [edi+40]
	lea	ecx, DWORD PTR [esi+44]
	mov	DWORD PTR [esi+40], eax
	mov	BYTE PTR __$EHRec$[esp+32], 1
	mov	DWORD PTR [ecx], 0
	mov	edx, DWORD PTR [edi+44]
	push	edx
	call	?Set@CCorString@@QAEXPAD@Z		; CCorString::Set
	mov	eax, DWORD PTR [edi+48]
	mov	DWORD PTR [esi+48], eax
	mov	ecx, DWORD PTR [edi+52]
	mov	DWORD PTR [esi+52], ecx
	mov	DWORD PTR [esi], OFFSET FLAT:??_7OMacChannel@@6B@ ; OMacChannel::`vftable'
	mov	edx, DWORD PTR [edi+56]
	mov	DWORD PTR [esi+56], edx
	mov	eax, DWORD PTR [edi+60]
	mov	DWORD PTR [esi+60], eax
	mov	ecx, DWORD PTR [edi+64]
	mov	DWORD PTR [esi+64], ecx
	mov	edx, DWORD PTR [edi+68]
	mov	DWORD PTR [esi+68], edx
	mov	eax, DWORD PTR [edi+72]
	mov	DWORD PTR [esi+72], eax
	mov	ecx, DWORD PTR [edi+76]
	mov	DWORD PTR [esi+76], ecx
	mov	edx, DWORD PTR [edi+80]
	mov	DWORD PTR [esi+80], edx
	mov	eax, DWORD PTR [edi+84]
	mov	DWORD PTR [esi+84], eax
	mov	ecx, DWORD PTR [edi+88]
	mov	DWORD PTR [esi+88], ecx
	mov	edx, DWORD PTR [edi+92]
	mov	DWORD PTR [esi+92], edx
	mov	eax, DWORD PTR [edi+96]
	mov	DWORD PTR [esi+96], eax
	mov	ecx, DWORD PTR [edi+100]
	mov	DWORD PTR [esi+100], ecx
	mov	edx, DWORD PTR [edi+104]
	mov	DWORD PTR [esi+104], edx
	mov	eax, DWORD PTR [edi+108]
	mov	DWORD PTR [esi+108], eax
	mov	ecx, DWORD PTR [edi+112]
	mov	DWORD PTR [esi+112], ecx
	mov	edx, DWORD PTR [edi+116]
	mov	DWORD PTR [esi+116], edx
	mov	eax, DWORD PTR [edi+120]
	mov	DWORD PTR [esi+120], eax
	mov	ecx, DWORD PTR [edi+124]
	mov	DWORD PTR [esi+124], ecx
	mov	edx, DWORD PTR [edi+128]
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR [esi+128], edx
	mov	DWORD PTR [esi], OFFSET FLAT:??_7OMacIKChannel@@6B@ ; OMacIKChannel::`vftable'
	mov	eax, esi
	pop	edi
	pop	esi
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L53386:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1CObjLink@@QAE@XZ			; CObjLink::~CObjLink
$L53387:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	jmp	??1CObjLink@@QAE@XZ			; CObjLink::~CObjLink
$L53461:
	mov	eax, OFFSET FLAT:$T53460
	jmp	___CxxFrameHandler
text$x	ENDS
??0OMacIKChannel@@QAE@ABV0@@Z ENDP			; OMacIKChannel::OMacIKChannel
PUBLIC	??1CCpjSklVert@@QAE@XZ				; CCpjSklVert::~CCpjSklVert
; Function compile flags: /Ogty
;	COMDAT ??_GCCpjSklVert@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_GCCpjSklVert@@QAEPAXI@Z PROC NEAR			; CCpjSklVert::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1CCpjSklVert@@QAE@XZ			; CCpjSklVert::~CCpjSklVert
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $L53468
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L53468:
	mov	eax, esi
	pop	esi
	ret	4
??_GCCpjSklVert@@QAEPAXI@Z ENDP				; CCpjSklVert::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??4OMacIKChannel@@QAEAAV0@ABV0@@Z		; OMacIKChannel::operator=
; Function compile flags: /Ogty
;	COMDAT ??4OMacIKChannel@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8
??4OMacIKChannel@@QAEAAV0@ABV0@@Z PROC NEAR		; OMacIKChannel::operator=, COMDAT
; _this$ = ecx
	push	esi
	push	edi
	mov	edi, DWORD PTR ___that$[esp+4]
	mov	esi, ecx
	mov	eax, DWORD PTR [edi+4]
	lea	ecx, DWORD PTR [edi+8]
	mov	DWORD PTR [esi+4], eax
	lea	edx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	lea	eax, DWORD PTR [esi+24]
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], ecx
	lea	edx, DWORD PTR [edi+24]
	mov	ecx, DWORD PTR [edi+24]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR [edi+40]
	mov	DWORD PTR [esi+40], eax
	mov	ecx, DWORD PTR [edi+44]
	push	ecx
	lea	ecx, DWORD PTR [esi+44]
	call	?Set@CCorString@@QAEXPAD@Z		; CCorString::Set
	mov	edx, DWORD PTR [edi+48]
	mov	DWORD PTR [esi+48], edx
	mov	eax, DWORD PTR [edi+52]
	mov	DWORD PTR [esi+52], eax
	mov	ecx, DWORD PTR [edi+56]
	mov	DWORD PTR [esi+56], ecx
	mov	edx, DWORD PTR [edi+60]
	mov	DWORD PTR [esi+60], edx
	mov	eax, DWORD PTR [edi+64]
	mov	DWORD PTR [esi+64], eax
	mov	ecx, DWORD PTR [edi+68]
	mov	DWORD PTR [esi+68], ecx
	mov	edx, DWORD PTR [edi+72]
	mov	DWORD PTR [esi+72], edx
	mov	eax, DWORD PTR [edi+76]
	mov	DWORD PTR [esi+76], eax
	mov	ecx, DWORD PTR [edi+80]
	mov	DWORD PTR [esi+80], ecx
	mov	edx, DWORD PTR [edi+84]
	mov	DWORD PTR [esi+84], edx
	mov	eax, DWORD PTR [edi+88]
	mov	DWORD PTR [esi+88], eax
	mov	ecx, DWORD PTR [edi+92]
	mov	DWORD PTR [esi+92], ecx
	mov	edx, DWORD PTR [edi+96]
	mov	DWORD PTR [esi+96], edx
	mov	eax, DWORD PTR [edi+100]
	mov	DWORD PTR [esi+100], eax
	mov	ecx, DWORD PTR [edi+104]
	mov	DWORD PTR [esi+104], ecx
	mov	edx, DWORD PTR [edi+108]
	mov	DWORD PTR [esi+108], edx
	mov	eax, DWORD PTR [edi+112]
	mov	DWORD PTR [esi+112], eax
	mov	ecx, DWORD PTR [edi+116]
	mov	DWORD PTR [esi+116], ecx
	mov	edx, DWORD PTR [edi+120]
	mov	DWORD PTR [esi+120], edx
	mov	eax, DWORD PTR [edi+124]
	mov	DWORD PTR [esi+124], eax
	mov	ecx, DWORD PTR [edi+128]
	mov	DWORD PTR [esi+128], ecx
	mov	eax, esi
	pop	edi
	pop	esi
	ret	4
??4OMacIKChannel@@QAEAAV0@ABV0@@Z ENDP			; OMacIKChannel::operator=
_TEXT	ENDS
PUBLIC	??1CCpjSklMount@@QAE@XZ				; CCpjSklMount::~CCpjSklMount
; Function compile flags: /Ogty
;	COMDAT ??_GCCpjSklMount@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_GCCpjSklMount@@QAEPAXI@Z PROC NEAR			; CCpjSklMount::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1CCpjSklMount@@QAE@XZ			; CCpjSklMount::~CCpjSklMount
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $L53532
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L53532:
	mov	eax, esi
	pop	esi
	ret	4
??_GCCpjSklMount@@QAEPAXI@Z ENDP			; CCpjSklMount::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??1OMacIKChannel@@UAE@XZ			; OMacIKChannel::~OMacIKChannel
; Function compile flags: /Ogty
;	COMDAT ??1OMacIKChannel@@UAE@XZ
_TEXT	SEGMENT
??1OMacIKChannel@@UAE@XZ PROC NEAR			; OMacIKChannel::~OMacIKChannel, COMDAT
; _this$ = ecx
	jmp	??1OObject@@UAE@XZ			; OObject::~OObject
??1OMacIKChannel@@UAE@XZ ENDP				; OMacIKChannel::~OMacIKChannel
_TEXT	ENDS
PUBLIC	??_GOMacIKChannel@@UAEPAXI@Z			; OMacIKChannel::`scalar deleting destructor'
; Function compile flags: /Ogty
;	COMDAT ??_GOMacIKChannel@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_GOMacIKChannel@@UAEPAXI@Z PROC NEAR			; OMacIKChannel::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1OMacIKChannel@@UAE@XZ		; OMacIKChannel::~OMacIKChannel
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $L53556
	mov	DWORD PTR [esi+4], 0
	mov	edx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	dec	edx
	mov	DWORD PTR ?sObjCount@OObject@@1KA, edx	; OObject::sObjCount
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L53556:
	mov	eax, esi
	pop	esi
	ret	4
??_GOMacIKChannel@@UAEPAXI@Z ENDP			; OMacIKChannel::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??1CCpjSeqEvent@@QAE@XZ				; CCpjSeqEvent::~CCpjSeqEvent
; Function compile flags: /Ogty
;	COMDAT ??_GCCpjSeqEvent@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_GCCpjSeqEvent@@QAEPAXI@Z PROC NEAR			; CCpjSeqEvent::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1CCpjSeqEvent@@QAE@XZ			; CCpjSeqEvent::~CCpjSeqEvent
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $L53560
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L53560:
	mov	eax, esi
	pop	esi
	ret	4
??_GCCpjSeqEvent@@QAEPAXI@Z ENDP			; CCpjSeqEvent::`scalar deleting destructor'
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??_EOMacIKChannel@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_EOMacIKChannel@@UAEPAXI@Z PROC NEAR			; OMacIKChannel::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebx
	mov	bl, BYTE PTR ___flags$[esp]
	push	esi
	mov	esi, ecx
	test	bl, 2
	je	SHORT $L11292
	mov	eax, DWORD PTR [esi-4]
	push	edi
	lea	edi, DWORD PTR [esi-4]
	push	OFFSET FLAT:??1OMacIKChannel@@UAE@XZ	; OMacIKChannel::~OMacIKChannel
	push	eax
	push	132					; 00000084H
	push	esi
	call	??_M@YGXPAXIHP6EX0@Z@Z			; `eh vector destructor iterator'
	test	bl, 1
	je	SHORT $L11293
	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L11293:
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	ret	4
$L11292:
	mov	ecx, esi
	call	??1OMacIKChannel@@UAE@XZ		; OMacIKChannel::~OMacIKChannel
	test	bl, 1
	je	SHORT $L53570
	mov	DWORD PTR [esi+4], 0
	mov	edx, DWORD PTR ?sObjCount@OObject@@1KA	; OObject::sObjCount
	dec	edx
	mov	DWORD PTR ?sObjCount@OObject@@1KA, edx	; OObject::sObjCount
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L53570:
	mov	eax, esi
	pop	esi
	pop	ebx
	ret	4
??_EOMacIKChannel@@UAEPAXI@Z ENDP			; OMacIKChannel::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??1CCpjSeqBoneInfo@@QAE@XZ			; CCpjSeqBoneInfo::~CCpjSeqBoneInfo
; Function compile flags: /Ogty
;	COMDAT ??_GCCpjSeqBoneInfo@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_GCCpjSeqBoneInfo@@QAEPAXI@Z PROC NEAR		; CCpjSeqBoneInfo::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1CCpjSeqBoneInfo@@QAE@XZ		; CCpjSeqBoneInfo::~CCpjSeqBoneInfo
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $L53579
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L53579:
	mov	eax, esi
	pop	esi
	ret	4
??_GCCpjSeqBoneInfo@@QAEPAXI@Z ENDP			; CCpjSeqBoneInfo::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??0CMacTraceInfo@@QAE@XZ			; CMacTraceInfo::CMacTraceInfo
;	COMDAT xdata$x
xdata$x	SEGMENT
$T53670	DD	0ffffffffH
	DD	FLAT:$L53583
$T53668	DD	019930520H
	DD	01H
	DD	FLAT:$T53670
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ??0CMacTraceInfo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -24
__$EHRec$ = -12
??0CMacTraceInfo@@QAE@XZ PROC NEAR			; CMacTraceInfo::CMacTraceInfo, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR fs:__except_list
	push	-1
	push	$L53669
	push	eax
	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR fs:__except_list, esp
	mov	DWORD PTR [eax+12], ecx
	mov	DWORD PTR [eax+16], ecx
	mov	DWORD PTR [eax+20], 1
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+28], ecx
	mov	DWORD PTR [eax+32], ecx
	mov	DWORD PTR [eax+24], ecx
	mov	ecx, DWORD PTR __$EHRec$[esp+12]
	mov	DWORD PTR [eax+36], 60			; 0000003cH
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 12					; 0000000cH
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L53583:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1?$TCorArray@E@@QAE@XZ		; TCorArray<unsigned char>::~TCorArray<unsigned char>
$L53669:
	mov	eax, OFFSET FLAT:$T53668
	jmp	___CxxFrameHandler
text$x	ENDS
??0CMacTraceInfo@@QAE@XZ ENDP				; CMacTraceInfo::CMacTraceInfo
;	COMDAT xdata$x
xdata$x	SEGMENT
$T53785	DD	0ffffffffH
	DD	FLAT:$L53676
$T53779	DD	019930520H
	DD	01H
	DD	FLAT:$T53785
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ??1CCpjGeoVert@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16
__$EHRec$ = -12
??1CCpjGeoVert@@QAE@XZ PROC NEAR			; CCpjGeoVert::~CCpjGeoVert, COMDAT
; _this$ = ecx
	push	-1
	push	$L53784
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	push	ebx
	push	esi
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+28], esi
	mov	edi, DWORD PTR [esi+36]
	mov	ebx, DWORD PTR __imp__memmove
	test	edi, edi
	mov	DWORD PTR __$EHRec$[esp+36], 0
	je	SHORT $L53717
	mov	eax, DWORD PTR [esi+32]
	mov	ecx, edi
	sub	ecx, edi
	shl	ecx, 2
	lea	edx, DWORD PTR [eax+edi*4]
	push	ecx
	push	edx
	push	eax
	call	ebx
	mov	eax, DWORD PTR [esi+36]
	add	esp, 12					; 0000000cH
	sub	eax, edi
	mov	DWORD PTR [esi+36], eax
$L53717:
	mov	eax, DWORD PTR [esi+32]
	test	eax, eax
	je	SHORT $L53726
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+32]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L53726:
	mov	edi, DWORD PTR [esi+20]
	mov	DWORD PTR __$EHRec$[esp+36], -1
	test	edi, edi
	je	SHORT $L53767
	mov	eax, DWORD PTR [esi+16]
	mov	edx, edi
	sub	edx, edi
	shl	edx, 2
	lea	ecx, DWORD PTR [eax+edi*4]
	push	edx
	push	ecx
	push	eax
	call	ebx
	mov	eax, DWORD PTR [esi+20]
	add	esp, 12					; 0000000cH
	sub	eax, edi
	mov	DWORD PTR [esi+20], eax
$L53767:
	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
	je	SHORT $L53775
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+16]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L53775:
	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	pop	edi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L53676:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	jmp	??1?$TCorArray@PAVCCpjGeoEdge@@@@QAE@XZ	; TCorArray<CCpjGeoEdge *>::~TCorArray<CCpjGeoEdge *>
$L53784:
	mov	eax, OFFSET FLAT:$T53779
	jmp	___CxxFrameHandler
text$x	ENDS
??1CCpjGeoVert@@QAE@XZ ENDP				; CCpjGeoVert::~CCpjGeoVert
PUBLIC	??0CMacTraceInfo@@QAE@AAV0@@Z			; CMacTraceInfo::CMacTraceInfo
;	COMDAT xdata$x
xdata$x	SEGMENT
$T54055	DD	0ffffffffH
	DD	FLAT:$L53799
	DD	0ffffffffH
	DD	FLAT:$L53791
	DD	01H
	DD	FLAT:$L53850
$T54048	DD	019930520H
	DD	03H
	DD	FLAT:$T54055
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ??0CMacTraceInfo@@QAE@AAV0@@Z
_TEXT	SEGMENT
_i$54037 = -24
$T54045 = -16
__$EHRec$ = -12
___that$ = 8
_this$ = -20
_i$53820 = 8
$T53842 = -16
??0CMacTraceInfo@@QAE@AAV0@@Z PROC NEAR			; CMacTraceInfo::CMacTraceInfo, COMDAT
; _this$ = ecx
	push	-1
	push	$L54054
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, DWORD PTR ___that$[esp+36]
	mov	ebp, ecx
	xor	ebx, ebx
	push	1
	mov	eax, DWORD PTR [edi]
	lea	esi, DWORD PTR [ebp+8]
	mov	DWORD PTR [ebp], eax
	mov	ecx, DWORD PTR [edi+4]
	mov	DWORD PTR [ebp+4], ecx
	mov	eax, DWORD PTR [edi+12]
	mov	ecx, esi
	mov	DWORD PTR _this$[esp+44], ebp
	mov	DWORD PTR $T53842[esp+44], esi
	mov	DWORD PTR [esi], ebx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], 1
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
	mov	DWORD PTR [esi+4], ebx
	mov	eax, DWORD PTR [edi+12]
	xor	edx, edx
	cmp	eax, ebx
	mov	DWORD PTR __$EHRec$[esp+48], ebx
	mov	DWORD PTR _i$53820[esp+36], edx
	jbe	SHORT $L53823
$L53821:
	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR -24+[esp+40], ecx
	lea	eax, DWORD PTR [ecx+1]
	cmp	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [esi+4], eax
	jbe	SHORT $L53834
	mov	edx, eax
	push	1
	shr	edx, 2
	mov	ecx, esi
	lea	eax, DWORD PTR [edx+eax+32]
	mov	DWORD PTR [esi+8], eax
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
	mov	ecx, DWORD PTR -24+[esp+40]
	mov	edx, DWORD PTR _i$53820[esp+36]
$L53834:
	mov	eax, DWORD PTR [esi]
	add	eax, ecx
	je	SHORT $L53828
	mov	ecx, DWORD PTR [edi+8]
	mov	cl, BYTE PTR [edx+ecx]
	mov	BYTE PTR [eax], cl
$L53828:
	mov	eax, DWORD PTR [edi+12]
	inc	edx
	cmp	edx, eax
	mov	DWORD PTR _i$53820[esp+36], edx
	jb	SHORT $L53821
$L53823:
	mov	eax, DWORD PTR [edi+28]
	lea	esi, DWORD PTR [ebp+24]
	push	60					; 0000003cH
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+52], 1
	mov	DWORD PTR $T54045[esp+44], esi
	mov	DWORD PTR [esi], ebx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], 60			; 0000003cH
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
	mov	DWORD PTR [esi+4], ebx
	mov	eax, DWORD PTR [edi+28]
	cmp	eax, ebx
	mov	BYTE PTR __$EHRec$[esp+48], 2
	mov	DWORD PTR _i$54037[esp+40], ebx
	jbe	$L54053
	mov	DWORD PTR 8+[esp+36], ebx
$L54038:
	mov	ebp, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	lea	eax, DWORD PTR [ebp+1]
	cmp	eax, ecx
	mov	DWORD PTR [esi+4], eax
	jbe	SHORT $L53999
	mov	edx, eax
	push	60					; 0000003cH
	shr	edx, 2
	mov	ecx, esi
	lea	eax, DWORD PTR [edx+eax+32]
	mov	DWORD PTR [esi+8], eax
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
$L53999:
	mov	edx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ebp+ebp*2]
	lea	ecx, DWORD PTR [eax+eax*4]
	lea	eax, DWORD PTR [edx+ecx*4]
	cmp	eax, ebx
	je	$L53992
	mov	ecx, DWORD PTR [edi+24]
	mov	edx, DWORD PTR 8+[esp+36]
	add	ecx, edx
	mov	edx, 1065353216				; 3f800000H
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	DWORD PTR [eax+16], edx
	mov	DWORD PTR [eax+20], ebx
	mov	DWORD PTR [eax+24], ebx
	mov	DWORD PTR [eax+28], ebx
	mov	DWORD PTR [eax+32], edx
	mov	DWORD PTR [eax+36], ebx
	mov	DWORD PTR [eax+40], ebx
	mov	DWORD PTR [eax+44], ebx
	mov	DWORD PTR [eax+48], edx
	mov	DWORD PTR [eax+52], edx
	mov	DWORD PTR [eax+56], edx
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+20], edx
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax+24], edx
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR [eax+28], edx
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR [eax+32], edx
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [eax+36], edx
	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR [eax+40], edx
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR [eax+44], edx
	mov	edx, DWORD PTR [ecx+48]
	mov	DWORD PTR [eax+48], edx
	mov	edx, DWORD PTR [ecx+52]
	mov	DWORD PTR [eax+52], edx
	mov	ecx, DWORD PTR [ecx+56]
	mov	DWORD PTR [eax+56], ecx
$L53992:
	mov	eax, DWORD PTR _i$54037[esp+40]
	mov	edx, DWORD PTR 8+[esp+36]
	mov	ecx, DWORD PTR [edi+28]
	inc	eax
	add	edx, 60					; 0000003cH
	cmp	eax, ecx
	mov	DWORD PTR _i$54037[esp+40], eax
	mov	DWORD PTR 8+[esp+36], edx
	jb	$L54038
	mov	eax, DWORD PTR _this$[esp+40]
	jmp	SHORT $L54040
$L54053:
	mov	eax, ebp
$L54040:
	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 24					; 00000018H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L53799:
	mov	ecx, DWORD PTR $T53842[ebp]
	jmp	??1CCorArray@@IAE@XZ			; CCorArray::~CCorArray
$L53791:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1?$TCorArray@E@@QAE@XZ		; TCorArray<unsigned char>::~TCorArray<unsigned char>
$L53850:
	mov	ecx, DWORD PTR $T54045[ebp]
	jmp	??1CCorArray@@IAE@XZ			; CCorArray::~CCorArray
$L54054:
	mov	eax, OFFSET FLAT:$T54048
	jmp	___CxxFrameHandler
text$x	ENDS
??0CMacTraceInfo@@QAE@AAV0@@Z ENDP			; CMacTraceInfo::CMacTraceInfo
; Function compile flags: /Ogty
;	COMDAT ??1CCpjGeoEdge@@QAE@XZ
_TEXT	SEGMENT
??1CCpjGeoEdge@@QAE@XZ PROC NEAR			; CCpjGeoEdge::~CCpjGeoEdge, COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR [esi+16]
	test	edi, edi
	je	SHORT $L54099
	mov	eax, DWORD PTR [esi+12]
	mov	ecx, edi
	sub	ecx, edi
	shl	ecx, 2
	lea	edx, DWORD PTR [eax+edi*4]
	push	ecx
	push	edx
	push	eax
	call	DWORD PTR __imp__memmove
	mov	eax, DWORD PTR [esi+16]
	add	esp, 12					; 0000000cH
	sub	eax, edi
	mov	DWORD PTR [esi+16], eax
$L54099:
	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $L54109
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L54109:
	pop	edi
	pop	esi
	ret	0
??1CCpjGeoEdge@@QAE@XZ ENDP				; CCpjGeoEdge::~CCpjGeoEdge
_TEXT	ENDS
PUBLIC	??4?$TCorArray@VVBox3@@@@QAEAAV0@AAV0@@Z	; TCorArray<VBox3>::operator=
PUBLIC	??4CMacTraceInfo@@QAEAAV0@AAV0@@Z		; CMacTraceInfo::operator=
; Function compile flags: /Ogty
;	COMDAT ??4CMacTraceInfo@@QAEAAV0@AAV0@@Z
_TEXT	SEGMENT
___that$ = 8
??4CMacTraceInfo@@QAEAAV0@AAV0@@Z PROC NEAR		; CMacTraceInfo::operator=, COMDAT
; _this$ = ecx
	push	esi
	push	edi
	mov	edi, DWORD PTR ___that$[esp+4]
	mov	esi, ecx
	mov	eax, DWORD PTR [edi]
	lea	edx, DWORD PTR [edi+8]
	mov	DWORD PTR [esi], eax
	mov	ecx, DWORD PTR [edi+4]
	mov	DWORD PTR [esi+4], ecx
	push	edx
	lea	ecx, DWORD PTR [esi+8]
	call	??4?$TCorArray@E@@QAEAAV0@AAV0@@Z	; TCorArray<unsigned char>::operator=
	add	edi, 24					; 00000018H
	lea	ecx, DWORD PTR [esi+24]
	push	edi
	call	??4?$TCorArray@VVBox3@@@@QAEAAV0@AAV0@@Z ; TCorArray<VBox3>::operator=
	mov	eax, esi
	pop	edi
	pop	esi
	ret	4
??4CMacTraceInfo@@QAEAAV0@AAV0@@Z ENDP			; CMacTraceInfo::operator=
; Function compile flags: /Ogty
; File C:\duke4\Cannibal\CorMain.h
_TEXT	ENDS
;	COMDAT ??4?$TCorArray@VVBox3@@@@QAEAAV0@AAV0@@Z
_TEXT	SEGMENT
_inArray$ = 8
_i$ = -4
??4?$TCorArray@VVBox3@@@@QAEAAV0@AAV0@@Z PROC NEAR	; TCorArray<VBox3>::operator=, COMDAT
; _this$ = ecx

; 269  : 	{

	sub	esp, 8
	push	ebx

; 270  : 		if (this == &inArray)

	mov	ebx, DWORD PTR _inArray$[esp+8]
	push	esi
	mov	esi, ecx
	cmp	esi, ebx

; 271  : 			return(*this);

	je	$L54276
	push	edi

; 272  : 		m_Count = 0;

	xor	edi, edi
	mov	DWORD PTR [esi+4], edi

; 273  : 		m_Limit = inArray.m_Count;

	mov	eax, DWORD PTR [ebx+4]
	mov	DWORD PTR [esi+8], eax

; 274  : 		Realloc(sizeof(T));

	mov	eax, DWORD PTR [esi]
	cmp	eax, edi
	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [esi+12], 60			; 0000003cH
	je	$L54129
	cmp	eax, edi
	je	SHORT $L54131
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [esi+8]
	push	ecx
	mov	ecx, DWORD PTR [esi]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+4]
	mov	DWORD PTR [esi], eax
	jmp	SHORT $L54136
$L54131:
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L54135:
	mov	DWORD PTR [esi], edi
$L54136:

; 275  : 		for (NDword i=0;i<inArray.m_Count;i++)

	mov	eax, DWORD PTR [ebx+4]
	mov	DWORD PTR _i$[esp+20], edi
	cmp	eax, edi
	jbe	$L14630
	push	ebp
	mov	DWORD PTR -8+[esp+24], edi
	mov	ebp, 1065353216				; 3f800000H
$L14628:

; 276  : 			new(&(*this)[AddNoConstruct()]) T(inArray[i]);

	mov	ebx, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	lea	eax, DWORD PTR [ebx+1]
	cmp	eax, ecx
	mov	DWORD PTR [esi+4], eax
	jbe	SHORT $L54141
	mov	edx, eax
	push	60					; 0000003cH
	shr	edx, 2
	mov	ecx, esi
	lea	eax, DWORD PTR [edx+eax+32]
	mov	DWORD PTR [esi+8], eax
	call	?Realloc@CCorArray@@IAEXK@Z		; CCorArray::Realloc
$L54141:
	mov	edx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ebx+ebx*2]
	lea	ecx, DWORD PTR [eax+eax*4]
	lea	eax, DWORD PTR [edx+ecx*4]
	cmp	eax, edi
	je	$L54123
	mov	ecx, DWORD PTR _inArray$[esp+20]
	mov	edx, DWORD PTR -8+[esp+24]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ebp
	mov	DWORD PTR [eax+4], edi
	mov	DWORD PTR [eax+8], edi
	mov	DWORD PTR [eax+12], edi
	mov	DWORD PTR [eax+16], ebp
	mov	DWORD PTR [eax+20], edi
	mov	DWORD PTR [eax+24], edi
	mov	DWORD PTR [eax+28], edi
	mov	DWORD PTR [eax+32], ebp
	add	ecx, edx
	mov	DWORD PTR [eax+36], edi
	mov	DWORD PTR [eax+40], edi
	mov	DWORD PTR [eax+44], edi
	mov	DWORD PTR [eax+48], ebp
	mov	DWORD PTR [eax+52], ebp
	mov	DWORD PTR [eax+56], ebp
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+20], edx
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax+24], edx
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR [eax+28], edx
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR [eax+32], edx
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [eax+36], edx
	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR [eax+40], edx
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR [eax+44], edx
	mov	edx, DWORD PTR [ecx+48]
	mov	DWORD PTR [eax+48], edx
	mov	edx, DWORD PTR [ecx+52]
	mov	DWORD PTR [eax+52], edx
	mov	ecx, DWORD PTR [ecx+56]
	mov	DWORD PTR [eax+56], ecx
$L54123:
	mov	edx, DWORD PTR -8+[esp+24]
	mov	eax, DWORD PTR _i$[esp+24]
	add	edx, 60					; 0000003cH
	inc	eax
	mov	DWORD PTR -8+[esp+24], edx
	mov	edx, DWORD PTR _inArray$[esp+20]
	mov	DWORD PTR _i$[esp+24], eax
	cmp	eax, DWORD PTR [edx+4]
	jb	$L14628
	pop	ebp
$L14630:
	pop	edi
$L54276:

; 277  : 		return(*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 278  : 	}

	add	esp, 8
	ret	4

; 274  : 		Realloc(sizeof(T));

$L54129:
	cmp	eax, edi
	je	$L54135
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [eax]
	imul	ecx, DWORD PTR [esi+8]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx]
	mov	DWORD PTR [esi], eax
	jmp	$L54136
??4?$TCorArray@VVBox3@@@@QAEAAV0@AAV0@@Z ENDP		; TCorArray<VBox3>::operator=
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??1CCpjSklVert@@QAE@XZ
_TEXT	SEGMENT
??1CCpjSklVert@@QAE@XZ PROC NEAR			; CCpjSklVert::~CCpjSklVert, COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR [esi+4]
	test	edi, edi
	je	SHORT $L54323
	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [edi+edi*4]
	shl	eax, 2
	mov	edx, eax
	sub	edx, eax
	add	eax, ecx
	push	edx
	push	eax
	push	ecx
	call	DWORD PTR __imp__memmove
	mov	eax, DWORD PTR [esi+4]
	add	esp, 12					; 0000000cH
	sub	eax, edi
	mov	DWORD PTR [esi+4], eax
$L54323:
	cmp	DWORD PTR [esi], 0
	je	SHORT $L54328
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L54328:
	pop	edi
	pop	esi
	ret	0
??1CCpjSklVert@@QAE@XZ ENDP				; CCpjSklVert::~CCpjSklVert
_TEXT	ENDS
PUBLIC	??1CMacTraceInfo@@QAE@XZ			; CMacTraceInfo::~CMacTraceInfo
;	COMDAT xdata$x
xdata$x	SEGMENT
$T54444	DD	0ffffffffH
	DD	FLAT:$L54335
$T54438	DD	019930520H
	DD	01H
	DD	FLAT:$T54444
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ??1CMacTraceInfo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16
__$EHRec$ = -12
??1CMacTraceInfo@@QAE@XZ PROC NEAR			; CMacTraceInfo::~CMacTraceInfo, COMDAT
; _this$ = ecx
	push	-1
	push	$L54443
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	push	ebx
	push	esi
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+28], esi
	mov	edi, DWORD PTR [esi+28]
	mov	ebx, DWORD PTR __imp__memmove
	test	edi, edi
	mov	DWORD PTR __$EHRec$[esp+36], 0
	je	SHORT $L54380
	lea	eax, DWORD PTR [edi+edi*2]
	mov	ecx, DWORD PTR [esi+24]
	lea	eax, DWORD PTR [eax+eax*4]
	shl	eax, 2
	mov	edx, eax
	sub	edx, eax
	add	eax, ecx
	push	edx
	push	eax
	push	ecx
	call	ebx
	mov	eax, DWORD PTR [esi+28]
	add	esp, 12					; 0000000cH
	sub	eax, edi
	mov	DWORD PTR [esi+28], eax
$L54380:
	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	je	SHORT $L54385
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+24]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L54385:
	mov	edi, DWORD PTR [esi+12]
	mov	DWORD PTR __$EHRec$[esp+36], -1
	test	edi, edi
	je	SHORT $L54431
	mov	eax, DWORD PTR [esi+8]
	mov	edx, edi
	sub	edx, edi
	lea	ecx, DWORD PTR [eax+edi]
	push	edx
	push	ecx
	push	eax
	call	ebx
	mov	eax, DWORD PTR [esi+12]
	add	esp, 12					; 0000000cH
	sub	eax, edi
	mov	DWORD PTR [esi+12], eax
$L54431:
	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $L54435
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+8]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L54435:
	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	pop	edi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L54335:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1?$TCorArray@E@@QAE@XZ		; TCorArray<unsigned char>::~TCorArray<unsigned char>
$L54443:
	mov	eax, OFFSET FLAT:$T54438
	jmp	___CxxFrameHandler
text$x	ENDS
??1CMacTraceInfo@@QAE@XZ ENDP				; CMacTraceInfo::~CMacTraceInfo
; Function compile flags: /Ogty
;	COMDAT ??1CCpjSklMount@@QAE@XZ
_TEXT	SEGMENT
??1CCpjSklMount@@QAE@XZ PROC NEAR			; CCpjSklMount::~CCpjSklMount, COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR [esi]
	test	edi, edi
	je	SHORT $L54474
	or	ecx, -1
	xor	eax, eax
	repne scasb
	not	ecx
	dec	ecx
	or	eax, -1
	sub	eax, ecx
	mov	ecx, DWORD PTR ?sMemTotal@CCorString@@0KA ; CCorString::sMemTotal
	add	ecx, eax
	mov	DWORD PTR ?sMemTotal@CCorString@@0KA, ecx ; CCorString::sMemTotal
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L54474:
	mov	DWORD PTR [esi], 0
	pop	edi
	pop	esi
	ret	0
??1CCpjSklMount@@QAE@XZ ENDP				; CCpjSklMount::~CCpjSklMount
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
$T54626	DD	0ffffffffH
	DD	FLAT:$L54478
	DD	00H
	DD	FLAT:$L54479
	DD	01H
	DD	FLAT:$L54480
$T54616	DD	019930520H
	DD	03H
	DD	FLAT:$T54626
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ??1CCpjSeqFrame@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16
__$EHRec$ = -12
??1CCpjSeqFrame@@QAE@XZ PROC NEAR			; CCpjSeqFrame::~CCpjSeqFrame, COMDAT
; _this$ = ecx
	push	-1
	push	$L54625
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	push	esi
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+24], esi
	mov	eax, DWORD PTR [esi+40]
	lea	edi, DWORD PTR [esi+36]
	push	16					; 00000010H
	push	eax
	push	0
	mov	ecx, edi
	mov	DWORD PTR __$EHRec$[esp+44], 2
	call	?Remove@CCorArray@@QAEXKKK@Z		; CCorArray::Remove
	cmp	DWORD PTR [edi], 0
	je	SHORT $L54516
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L54516:
	mov	eax, DWORD PTR [esi+24]
	lea	edi, DWORD PTR [esi+20]
	push	24					; 00000018H
	push	eax
	push	0
	mov	ecx, edi
	mov	BYTE PTR __$EHRec$[esp+44], 1
	call	?Remove@CCorArray@@QAEXKKK@Z		; CCorArray::Remove
	cmp	DWORD PTR [edi], 0
	je	SHORT $L54553
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L54553:
	mov	eax, DWORD PTR [esi+8]
	lea	edi, DWORD PTR [esi+4]
	push	16					; 00000010H
	push	eax
	push	0
	mov	ecx, edi
	mov	BYTE PTR __$EHRec$[esp+44], 0
	call	?Remove@CCorArray@@QAEXKKK@Z		; CCorArray::Remove
	cmp	DWORD PTR [edi], 0
	je	SHORT $L54590
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L54590:
	mov	edi, DWORD PTR [esi]
	mov	DWORD PTR __$EHRec$[esp+32], -1
	test	edi, edi
	je	SHORT $L54624
	or	ecx, -1
	xor	eax, eax
	repne scasb
	mov	eax, DWORD PTR ?sMemTotal@CCorString@@0KA ; CCorString::sMemTotal
	or	edx, -1
	not	ecx
	dec	ecx
	sub	edx, ecx
	add	eax, edx
	mov	DWORD PTR ?sMemTotal@CCorString@@0KA, eax ; CCorString::sMemTotal
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L54624:
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR [esi], 0
	pop	edi
	pop	esi
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L54478:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CCorString@@QAE@XZ			; CCorString::~CCorString
$L54479:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	??1?$TCorArray@VCCpjSeqTranslate@@@@QAE@XZ ; TCorArray<CCpjSeqTranslate>::~TCorArray<CCpjSeqTranslate>
$L54480:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	jmp	??1?$TCorArray@VCCpjSeqRotate@@@@QAE@XZ	; TCorArray<CCpjSeqRotate>::~TCorArray<CCpjSeqRotate>
$L54625:
	mov	eax, OFFSET FLAT:$T54616
	jmp	___CxxFrameHandler
text$x	ENDS
??1CCpjSeqFrame@@QAE@XZ ENDP				; CCpjSeqFrame::~CCpjSeqFrame
; Function compile flags: /Ogty
;	COMDAT ??1CCpjSeqEvent@@QAE@XZ
_TEXT	SEGMENT
??1CCpjSeqEvent@@QAE@XZ PROC NEAR			; CCpjSeqEvent::~CCpjSeqEvent, COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR [esi+8]
	test	edi, edi
	je	SHORT $L54657
	or	ecx, -1
	xor	eax, eax
	repne scasb
	not	ecx
	dec	ecx
	or	eax, -1
	sub	eax, ecx
	mov	ecx, DWORD PTR ?sMemTotal@CCorString@@0KA ; CCorString::sMemTotal
	add	ecx, eax
	mov	DWORD PTR ?sMemTotal@CCorString@@0KA, ecx ; CCorString::sMemTotal
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi+8]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L54657:
	mov	DWORD PTR [esi+8], 0
	pop	edi
	pop	esi
	ret	0
??1CCpjSeqEvent@@QAE@XZ ENDP				; CCpjSeqEvent::~CCpjSeqEvent
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??1CCpjSeqBoneInfo@@QAE@XZ
_TEXT	SEGMENT
??1CCpjSeqBoneInfo@@QAE@XZ PROC NEAR			; CCpjSeqBoneInfo::~CCpjSeqBoneInfo, COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR [esi]
	test	edi, edi
	je	SHORT $L54685
	or	ecx, -1
	xor	eax, eax
	repne scasb
	not	ecx
	dec	ecx
	or	eax, -1
	sub	eax, ecx
	mov	ecx, DWORD PTR ?sMemTotal@CCorString@@0KA ; CCorString::sMemTotal
	add	ecx, eax
	mov	DWORD PTR ?sMemTotal@CCorString@@0KA, ecx ; CCorString::sMemTotal
	call	?MEM_GetAlloc@@YAPAVIMemAlloc@@XZ	; MEM_GetAlloc
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR [edx+8]
$L54685:
	mov	DWORD PTR [esi], 0
	pop	edi
	pop	esi
	ret	0
??1CCpjSeqBoneInfo@@QAE@XZ ENDP				; CCpjSeqBoneInfo::~CCpjSeqBoneInfo
_TEXT	ENDS
END
