; Listing generated by Microsoft (R) Optimizing Compiler Version 12.00.8943.0 

	TITLE	C:\duke4\xcore\win.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0BF@MBIJ@Cannot?5init?5CPrintfT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
drectve	SEGMENT DWORD USE32 PUBLIC ''
drectve	ENDS
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
CRT$XCA	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCA	ENDS
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
CRT$XCL	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCL	ENDS
CRT$XCC	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCC	ENDS
CRT$XCZ	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCZ	ENDS
;	COMDAT ??0?$XChain@VXStatistic@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?get_head@?$XList@VXStatistic@@@@QAEPAVXStatistic@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$XChain@VCSysObj@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$XChain@VCSysObj@@@@QAE@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?get_next@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?get_prev@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?get_head@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?get_tail@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$XChain@VXStatistic@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?free_list@?$XChain@VXStatistic@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$XList@VXStatistic@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$XList@VXStatistic@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?free_list@?$XList@VXStatistic@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?add_head@?$XList@VXStatistic@@@@QAEPAU_XPos@@PAVXStatistic@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?remove_head@?$XList@VXStatistic@@@@QAEPAVXStatistic@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$XChain@VCSysObj@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lose_list@?$XChain@VCSysObj@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?free_list@?$XChain@VCSysObj@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?add_head@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?add_tail@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?remove_head@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?remove_tail@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?remove@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$XList@PAX@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$XRcBase@VCStrObj@@@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$XRcBase@VCStrObj@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$XRcBase@VCStrObj@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$XRcBase@VCStrObj@@@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$XRcPtr@VCPathObj@@@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$XRcPtr@VCPathObj@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$XRcPtr@VCPathObj@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$XRcPtr@VCPathObj@@@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$XList@VXFindLevel@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$XList@VXFindLevel@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCSysObj@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GXFindLevel@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?new_node@?$XList@VXStatistic@@@@IAEPAUXNode@1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?free_nodes@?$XList@VXStatistic@@@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?free_nodes@?$XList@PAX@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?free_nodes@?$XList@VXFindLevel@@@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddRef@?$XRcBase@VCStrObj@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DelRef@?$XRcBase@VCStrObj@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddRef@?$XRcPtr@VCPathObj@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DelRef@?$XRcPtr@VCPathObj@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCStrObj@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCPathObj@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GXStreamWrDirect@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1XStreamWrDirect@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7XStreamWrDirect@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??1XBufferWriteInt@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7XBufferWriteInt@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??3XStreamWrDirect@@SAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_EXStreamWrDirect@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?flush@XStreamWrDirect@@UAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?seek@XStreamWrDirect@@UAEKJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GXStreamRdDirect@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1XStreamRdDirect@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7XStreamRdDirect@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??1XBufferReadInt@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7XBufferReadInt@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??3XStreamRdDirect@@SAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_EXStreamRdDirect@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?seek@XStreamRdDirect@@UAEKJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?base_init@XFile@@EAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GXBufferWriteInt@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_EXBufferWriteInt@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GXBufferReadInt@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_EXBufferReadInt@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pos_wr@CBaseStream@@UAEXKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pos_rd@CBaseStream@@UAEXKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?put@CBaseStream@@UAEKD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ioctl_write@CBaseStream@@UAEKKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ioctl_read@CBaseStream@@UAEKKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?seek_int@CBaseStream@@MAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GXMemRdBuffer@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1XMemRdBuffer@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7XMemRdBuffer@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??3XMemRdBuffer@@SAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_EXMemRdBuffer@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3CStrObj@@SAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CStrObj@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1XFindLevel@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0XListState@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3XStatistic@@SAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0XChainState@@QAE@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0XChainState@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __CTA1K
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0K@84
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0K@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT __TI1K
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ?get_str@CPrintf@@QAEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6CPrintf@@QAEAAV0@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6CPrintf@@QAEAAV0@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CPrintf@@QAE@PADK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0WinMsgDef@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CError@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CError@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7WinMsgDef@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CMemMap@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7XEvent@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??BCStr@@QBEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4autochar@@QAEAAV0@PAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3@YAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Bautochar@@QAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7XMutex@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??1autochar@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0autochar@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CSysObj@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CSysObj@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??0CSysObj@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
FLAT	GROUP _DATA, CONST, _BSS, drectve, xdata$x, CRT$XCA, CRT$XCU, CRT$XCL, CRT$XCC, CRT$XCZ
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?_win_error@@3VWinMsgDef@@A			; _win_error
_BSS	SEGMENT
?_win_error@@3VWinMsgDef@@A DQ 01H DUP (?)		; _win_error
_BSS	ENDS
CRT$XCU	SEGMENT
_$S3	DD	FLAT:_$E2
CRT$XCU	ENDS
drectve	SEGMENT
$SG56785 DB	'-INCLUDE:___@@_PchSym_@00@UwfpvEUcxlivUlyqUhgwxlivOlyq@', 00H
drectve	ENDS
PUBLIC	??1autochar@@QAE@XZ				; autochar::~autochar
PUBLIC	?destroy@XMutex@@EAEKXZ				; XMutex::destroy
PUBLIC	??0XMutex@@QAE@KKPBD@Z				; XMutex::XMutex
PUBLIC	?init@XMutex@@QAEKKKPBD@Z			; XMutex::init
PUBLIC	??_7XMutex@@6B@					; XMutex::`vftable'
PUBLIC	??1CSysObj@@QAE@XZ				; CSysObj::~CSysObj
PUBLIC	??_7CSysObj@@6B@				; CSysObj::`vftable'
EXTRN	__purecall:NEAR
EXTRN	?_global@@3PAVXGlobal@@A:DWORD			; _global
EXTRN	?reg_global_object@XGlobal@@QAEXPAVCSysObj@@@Z:NEAR ; XGlobal::reg_global_object
EXTRN	__except_list:DWORD
EXTRN	___CxxFrameHandler:NEAR
EXTRN	@xxx_throw@4:NEAR
xdata$x	SEGMENT
$T57363	DD	0ffffffffH
	DD	FLAT:$L57345
	DD	00H
	DD	FLAT:$L57346
$T57357	DD	019930520H
	DD	02H
	DD	FLAT:$T57363
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_7CSysObj@@6B@
; File C:\duke4\xcore\xclass.h
CONST	SEGMENT
??_7CSysObj@@6B@ DD FLAT:__purecall			; CSysObj::`vftable'
CONST	ENDS
;	COMDAT ??_7XMutex@@6B@
CONST	SEGMENT
??_7XMutex@@6B@ DD FLAT:?destroy@XMutex@@EAEKXZ		; XMutex::`vftable'
CONST	ENDS
_DATA	SEGMENT
$SG56794 DB	'XMutex: Unable to create mutex', 00H
; Function compile flags: /Ogty
; File C:\duke4\xcore\win.cpp
_DATA	ENDS
_TEXT	SEGMENT
__$EHRec$ = -12
_create$ = 8
_own$ = 12
_Name$ = 16
_this$ = -16
??0XMutex@@QAE@KKPBD@Z PROC NEAR			; XMutex::XMutex
; _this$ = ecx

; 4    : {

	push	-1
	push	$L57361
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	push	esi
	mov	esi, ecx
	push	esi
	mov	DWORD PTR _this$[esp+24], esi
	mov	DWORD PTR [esi], OFFSET FLAT:??_7CSysObj@@6B@ ; CSysObj::`vftable'
	mov	ecx, DWORD PTR ?_global@@3PAVXGlobal@@A	; _global
	call	?reg_global_object@XGlobal@@QAEXPAVCSysObj@@@Z ; XGlobal::reg_global_object
	xor	eax, eax
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR __$EHRec$[esp+28], eax
	mov	DWORD PTR [esi+16], eax

; 5    : 	if (!init(create,own,Name))

	mov	eax, DWORD PTR _Name$[esp+16]
	mov	ecx, DWORD PTR _own$[esp+16]
	mov	edx, DWORD PTR _create$[esp+16]
	push	eax
	push	ecx
	push	edx
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+40], 1
	mov	DWORD PTR [esi], OFFSET FLAT:??_7XMutex@@6B@ ; XMutex::`vftable'
	call	?init@XMutex@@QAEKKKPBD@Z		; XMutex::init
	test	eax, eax
	jne	SHORT $L57360

; 6    : 		xxx_throw("XMutex: Unable to create mutex");

	mov	ecx, OFFSET FLAT:$SG56794
	call	@xxx_throw@4
$L57360:

; 7    : }

	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	ret	12					; 0000000cH
_TEXT	ENDS
text$x	SEGMENT
$L57345:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CSysObj@@QAE@XZ			; CSysObj::~CSysObj
$L57346:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	jmp	??1autochar@@QAE@XZ			; autochar::~autochar
$L57361:
	mov	eax, OFFSET FLAT:$T57357
	jmp	___CxxFrameHandler
text$x	ENDS
??0XMutex@@QAE@KKPBD@Z ENDP				; XMutex::XMutex
EXTRN	__imp__CreateMutexA@12:NEAR
EXTRN	__imp__OpenMutexA@12:NEAR
EXTRN	__imp__GetLastError@0:NEAR
EXTRN	@xxx_bitch@4:NEAR
EXTRN	??0CStr@@QAE@PBD@Z:NEAR				; CStr::CStr
EXTRN	@xfree@4:NEAR
_DATA	SEGMENT
	ORG $+1
$SG56807 DB	'XMutex::init Unable to create mutex', 00H
$SG56810 DB	'XMutex::init: mutex already exists', 00H
	ORG $+1
$SG56812 DB	'XMutex::init Unable to open mutex', 00H
; Function compile flags: /Ogty
_DATA	ENDS
_TEXT	SEGMENT
$T57367 = -8
_create$ = 8
_own$ = 12
_Name$ = 16
?init@XMutex@@QAEKKKPBD@Z PROC NEAR			; XMutex::init
; _this$ = ecx

; 10   : {

	sub	esp, 8
	push	esi
	mov	esi, ecx
	push	edi

; 11   : 	if (name)

	mov	ecx, DWORD PTR [esi+16]
	test	ecx, ecx
	je	SHORT $L57377

; 12   : 		delete name;

	call	@xfree@4
$L57377:

; 13   : 
; 14   : 	if (Name)

	mov	eax, DWORD PTR _Name$[esp+12]
	test	eax, eax
	je	SHORT $L57384

; 15   : 		name=CStr(Name);

	push	eax
	lea	ecx, DWORD PTR $T57367[esp+20]
	call	??0CStr@@QAE@PBD@Z			; CStr::CStr
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [esi+16], eax
$L57384:

; 16   : 
; 17   : 	flags=0;
; 18   : 	if (create)

	mov	eax, DWORD PTR _create$[esp+12]
	mov	DWORD PTR [esi+20], 0
	test	eax, eax

; 19   : 	{
; 20   : 		handle=CreateMutex(null,own,name);

	mov	eax, DWORD PTR [esi+16]
	push	eax
	je	SHORT $L56805
	mov	edi, DWORD PTR _own$[esp+16]
	push	edi
	push	0
	call	DWORD PTR __imp__CreateMutexA@12

; 21   : 		if (!handle)

	test	eax, eax
	mov	DWORD PTR [esi+12], eax
	jne	SHORT $L56806

; 22   : 		{
; 23   : 			xxx_bitch("XMutex::init Unable to create mutex");

	mov	ecx, OFFSET FLAT:$SG56807
	call	@xxx_bitch@4

; 24   : 			U32 err=GetLastError();

	call	DWORD PTR __imp__GetLastError@0

; 25   : 			if (err==ERROR_ALREADY_EXISTS)

	cmp	eax, 183				; 000000b7H
	jne	SHORT $L56809

; 26   : 				xxx_bitch("XMutex::init: mutex already exists");

	mov	ecx, OFFSET FLAT:$SG56810

; 33   : 		xxx_bitch("XMutex::init Unable to open mutex");

	call	@xxx_bitch@4
	pop	edi

; 34   : 		return FALSE;

	xor	eax, eax
	pop	esi

; 38   : 
; 39   : 	return TRUE;
; 40   : }

	add	esp, 8
	ret	12					; 0000000cH
$L56806:

; 35   : 	}
; 36   : 	if (own)

	test	edi, edi
	mov	eax, 1
	je	SHORT $L56800

; 37   : 		flags|=IS_LOCKED;

	mov	ecx, DWORD PTR [esi+20]
	pop	edi
	or	ecx, eax
	mov	DWORD PTR [esi+20], ecx
	pop	esi

; 38   : 
; 39   : 	return TRUE;
; 40   : }

	add	esp, 8
	ret	12					; 0000000cH
$L56805:

; 27   : 			return FALSE;
; 28   : 		}
; 29   : 	}
; 30   : 	else
; 31   : 	{
; 32   : 		handle=OpenMutex(MUTEX_ALL_ACCESS,own,name);

	mov	ecx, DWORD PTR _own$[esp+16]
	push	ecx
	push	2031617					; 001f0001H
	call	DWORD PTR __imp__OpenMutexA@12

; 33   : 		xxx_bitch("XMutex::init Unable to open mutex");

	mov	ecx, OFFSET FLAT:$SG56812
	mov	DWORD PTR [esi+12], eax
	call	@xxx_bitch@4
$L56809:

; 34   : 		return FALSE;

	xor	eax, eax
$L56800:
	pop	edi
	pop	esi

; 38   : 
; 39   : 	return TRUE;
; 40   : }

	add	esp, 8
	ret	12					; 0000000cH
?init@XMutex@@QAEKKKPBD@Z ENDP				; XMutex::init
_TEXT	ENDS
PUBLIC	?lock@XMutex@@QAEKK@Z				; XMutex::lock
EXTRN	__imp__WaitForSingleObject@8:NEAR
_DATA	SEGMENT
	ORG $+2
$SG56819 DB	'XMutex::lock: already locked', 00H
; Function compile flags: /Ogty
_DATA	ENDS
_TEXT	SEGMENT
_timeout$ = 8
?lock@XMutex@@QAEKK@Z PROC NEAR				; XMutex::lock
; _this$ = ecx

; 43   : {

	push	esi
	mov	esi, ecx

; 44   : 	if (flags & IS_LOCKED)

	test	BYTE PTR [esi+20], 1
	je	SHORT $L56818

; 45   : 	{
; 46   : 		xxx_bitch("XMutex::lock: already locked");

	mov	ecx, OFFSET FLAT:$SG56819
	call	@xxx_bitch@4
$L56822:

; 58   : 	}
; 59   : 	return TRUE;

	mov	eax, 1
	pop	esi

; 60   : }

	ret	4
$L56818:

; 47   : 		return TRUE;
; 48   : 	}
; 49   : 	err=ERR_NONE;
; 50   : 	U32 ret=WaitForSingleObject(handle,timeout);

	mov	eax, DWORD PTR _timeout$[esp]
	mov	ecx, DWORD PTR [esi+12]
	push	eax
	push	ecx
	mov	DWORD PTR [esi+24], 0
	call	DWORD PTR __imp__WaitForSingleObject@8

; 51   : 	if (ret!=WAIT_OBJECT_0)

	test	eax, eax
	je	SHORT $L56822

; 52   : 	{
; 53   : 		if (ret==WAIT_TIMEOUT)

	cmp	eax, 258				; 00000102H
	jne	SHORT $L56824

; 54   : 			err=ERR_TIMEOUT;

	mov	DWORD PTR [esi+24], 1

; 57   : 		return FALSE;

	xor	eax, eax
	pop	esi

; 60   : }

	ret	4
$L56824:

; 55   : 		if (ret==WAIT_ABANDONED)

	cmp	eax, 128				; 00000080H
	jne	SHORT $L56826

; 56   : 			err=ERR_ABANDONED;

	mov	DWORD PTR [esi+24], 2
$L56826:

; 57   : 		return FALSE;

	xor	eax, eax
	pop	esi

; 60   : }

	ret	4
?lock@XMutex@@QAEKK@Z ENDP				; XMutex::lock
_TEXT	ENDS
PUBLIC	?unlock@XMutex@@QAEKXZ				; XMutex::unlock
EXTRN	__imp__ReleaseMutex@4:NEAR
_DATA	SEGMENT
	ORG $+3
$SG56832 DB	'XMutex::unlock: not locked', 00H
; Function compile flags: /Ogty
_DATA	ENDS
_TEXT	SEGMENT
?unlock@XMutex@@QAEKXZ PROC NEAR			; XMutex::unlock
; _this$ = ecx

; 64   : 	if (!(flags & IS_LOCKED))

	test	BYTE PTR [ecx+20], 1
	jne	SHORT $L56831

; 65   : 	{
; 66   : 		xxx_bitch("XMutex::unlock: not locked");

	mov	ecx, OFFSET FLAT:$SG56832
	call	@xxx_bitch@4

; 67   : 		return TRUE;

	mov	eax, 1

; 71   : 		return FALSE;
; 72   : 
; 73   : 	return TRUE;
; 74   : }

	ret	0
$L56831:

; 68   : 	}
; 69   : 	
; 70   : 	if (!ReleaseMutex(handle))

	mov	eax, DWORD PTR [ecx+12]
	push	eax
	call	DWORD PTR __imp__ReleaseMutex@4
	neg	eax
	sbb	eax, eax
	neg	eax

; 71   : 		return FALSE;
; 72   : 
; 73   : 	return TRUE;
; 74   : }

	ret	0
?unlock@XMutex@@QAEKXZ ENDP				; XMutex::unlock
_TEXT	ENDS
EXTRN	__imp__CloseHandle@4:NEAR
; Function compile flags: /Ogty
_TEXT	SEGMENT
?destroy@XMutex@@EAEKXZ PROC NEAR			; XMutex::destroy
; _this$ = ecx

; 77   : {

	push	esi
	mov	esi, ecx

; 78   : 	if (handle)

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $L57399

; 79   : 		CloseHandle(handle);

	push	eax
	call	DWORD PTR __imp__CloseHandle@4
$L57399:

; 80   : 	handle=null;

	mov	DWORD PTR [esi+12], 0

; 81   : 	return TRUE;

	mov	eax, 1
	pop	esi

; 82   : }

	ret	0
?destroy@XMutex@@EAEKXZ ENDP				; XMutex::destroy
_TEXT	ENDS
PUBLIC	?destroy@XEvent@@EAEKXZ				; XEvent::destroy
PUBLIC	??0XEvent@@QAE@KKKPBD@Z				; XEvent::XEvent
PUBLIC	?init@XEvent@@QAEKKKKPBD@Z			; XEvent::init
PUBLIC	??_7XEvent@@6B@					; XEvent::`vftable'
xdata$x	SEGMENT
$T57414	DD	0ffffffffH
	DD	FLAT:$L57401
	DD	00H
	DD	FLAT:$L57402
$T57411	DD	019930520H
	DD	02H
	DD	FLAT:$T57414
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_7XEvent@@6B@
; File C:\duke4\xcore\xclass.h
CONST	SEGMENT
??_7XEvent@@6B@ DD FLAT:?destroy@XEvent@@EAEKXZ		; XEvent::`vftable'
CONST	ENDS
_DATA	SEGMENT
	ORG $+1
$SG56847 DB	'XEvent: Unable to initialize', 00H
; Function compile flags: /Ogty
; File C:\duke4\xcore\win.cpp
_DATA	ENDS
_TEXT	SEGMENT
__$EHRec$ = -12
_create$ = 8
_manual_reset$ = 12
_state$ = 16
_Name$ = 20
_this$ = -16
??0XEvent@@QAE@KKKPBD@Z PROC NEAR			; XEvent::XEvent
; _this$ = ecx

; 85   : {

	push	-1
	push	$L57413
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	push	esi
	mov	esi, ecx
	push	esi
	mov	DWORD PTR _this$[esp+24], esi
	mov	DWORD PTR [esi], OFFSET FLAT:??_7CSysObj@@6B@ ; CSysObj::`vftable'
	mov	ecx, DWORD PTR ?_global@@3PAVXGlobal@@A	; _global
	call	?reg_global_object@XGlobal@@QAEXPAVCSysObj@@@Z ; XGlobal::reg_global_object
	xor	eax, eax
	mov	DWORD PTR __$EHRec$[esp+28], eax
	mov	DWORD PTR [esi+16], eax

; 86   : 	if (!init(create,manual_reset,state,Name))

	mov	eax, DWORD PTR _Name$[esp+16]
	mov	ecx, DWORD PTR _state$[esp+16]
	mov	edx, DWORD PTR _manual_reset$[esp+16]
	push	eax
	mov	eax, DWORD PTR _create$[esp+20]
	push	ecx
	push	edx
	push	eax
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+44], 1
	mov	DWORD PTR [esi], OFFSET FLAT:??_7XEvent@@6B@ ; XEvent::`vftable'
	call	?init@XEvent@@QAEKKKKPBD@Z		; XEvent::init
	test	eax, eax
	jne	SHORT $L57412

; 87   : 		xxx_throw("XEvent: Unable to initialize");

	mov	ecx, OFFSET FLAT:$SG56847
	call	@xxx_throw@4
$L57412:

; 88   : }

	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	ret	16					; 00000010H
_TEXT	ENDS
text$x	SEGMENT
$L57401:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CSysObj@@QAE@XZ			; CSysObj::~CSysObj
$L57402:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	jmp	??1autochar@@QAE@XZ			; autochar::~autochar
$L57413:
	mov	eax, OFFSET FLAT:$T57411
	jmp	___CxxFrameHandler
text$x	ENDS
??0XEvent@@QAE@KKKPBD@Z ENDP				; XEvent::XEvent
EXTRN	__imp__CreateEventA@16:NEAR
EXTRN	__imp__OpenEventA@12:NEAR
_DATA	SEGMENT
	ORG $+3
$SG56860 DB	'XEvent::init: Unable to create event', 00H
	ORG $+3
$SG56863 DB	'XEvent::init: Event already exists', 00H
	ORG $+1
$SG56866 DB	'XEvent::init: Unable to open event', 00H
; Function compile flags: /Ogty
_DATA	ENDS
_TEXT	SEGMENT
$T57417 = -8
_create$ = 8
_manual_reset$ = 12
_state$ = 16
_Name$ = 20
?init@XEvent@@QAEKKKKPBD@Z PROC NEAR			; XEvent::init
; _this$ = ecx

; 91   : {

	sub	esp, 8
	push	esi
	mov	esi, ecx

; 92   : 	if (name)

	mov	ecx, DWORD PTR [esi+16]
	test	ecx, ecx
	je	SHORT $L57427

; 93   : 		delete name;

	call	@xfree@4
$L57427:

; 94   : 
; 95   : 	name=CStr(Name);

	mov	eax, DWORD PTR _Name$[esp+8]
	lea	ecx, DWORD PTR $T57417[esp+12]
	push	eax
	call	??0CStr@@QAE@PBD@Z			; CStr::CStr
	mov	ecx, DWORD PTR [eax+4]

; 96   : 
; 97   : 	if (create)

	mov	eax, DWORD PTR _create$[esp+8]
	test	eax, eax

; 98   : 	{
; 99   : 		handle=CreateEvent(null,manual_reset,state,name);

	mov	eax, ecx
	mov	DWORD PTR [esi+16], ecx
	push	eax
	je	SHORT $L56858
	mov	edx, DWORD PTR _state$[esp+12]
	mov	eax, DWORD PTR _manual_reset$[esp+12]
	push	edx
	push	eax
	push	0
	call	DWORD PTR __imp__CreateEventA@16

; 100  : 		
; 101  : 		if (!handle)

	test	eax, eax
	mov	DWORD PTR [esi+12], eax
	jne	SHORT $L56859

; 102  : 		{
; 103  : 			xxx_bitch("XEvent::init: Unable to create event");

	mov	ecx, OFFSET FLAT:$SG56860
	call	@xxx_bitch@4

; 104  : 			return FALSE;

	xor	eax, eax
	pop	esi

; 120  : }

	add	esp, 8
	ret	16					; 00000010H
$L56859:

; 105  : 		}
; 106  : 		U32 ret=GetLastError();

	call	DWORD PTR __imp__GetLastError@0

; 107  : 		if (ret==ERROR_ALREADY_EXISTS)

	cmp	eax, 183				; 000000b7H
	jne	SHORT $L56865

; 108  : 			xxx_bitch("XEvent::init: Event already exists");

	mov	ecx, OFFSET FLAT:$SG56863
	call	@xxx_bitch@4
$L56865:

; 117  : 		}
; 118  : 	}
; 119  : 	return TRUE;

	mov	eax, 1
	pop	esi

; 120  : }

	add	esp, 8
	ret	16					; 00000010H
$L56858:

; 109  : 	}
; 110  : 	else
; 111  : 	{
; 112  : 		handle=OpenEvent(EVENT_ALL_ACCESS,FALSE,name);

	push	0
	push	2031619					; 001f0003H
	call	DWORD PTR __imp__OpenEventA@12

; 113  : 		if (!handle)

	test	eax, eax
	mov	DWORD PTR [esi+12], eax
	jne	SHORT $L56865

; 114  : 		{
; 115  : 			xxx_bitch("XEvent::init: Unable to open event");

	mov	ecx, OFFSET FLAT:$SG56866
	call	@xxx_bitch@4

; 116  : 			return FALSE;

	xor	eax, eax
	pop	esi

; 120  : }

	add	esp, 8
	ret	16					; 00000010H
?init@XEvent@@QAEKKKKPBD@Z ENDP				; XEvent::init
; Function compile flags: /Ogty
?destroy@XEvent@@EAEKXZ PROC NEAR			; XEvent::destroy
; _this$ = ecx

; 123  : {

	push	esi
	mov	esi, ecx

; 124  : 	if (handle)

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $L57446

; 125  : 		CloseHandle(handle);

	push	eax
	call	DWORD PTR __imp__CloseHandle@4
$L57446:

; 126  : 
; 127  : 	handle=null;

	mov	DWORD PTR [esi+12], 0

; 128  : 	return TRUE;

	mov	eax, 1
	pop	esi

; 129  : }

	ret	0
?destroy@XEvent@@EAEKXZ ENDP				; XEvent::destroy
_TEXT	ENDS
PUBLIC	?destroy@CMemMap@@EAEKXZ			; CMemMap::destroy
PUBLIC	??0CMemMap@@QAE@KPBDK@Z				; CMemMap::CMemMap
PUBLIC	?init@CMemMap@@QAEKKPBDK@Z			; CMemMap::init
PUBLIC	??_7CMemMap@@6B@				; CMemMap::`vftable'
xdata$x	SEGMENT
$T57461	DD	0ffffffffH
	DD	FLAT:$L57448
	DD	00H
	DD	FLAT:$L57449
$T57458	DD	019930520H
	DD	02H
	DD	FLAT:$T57461
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_7CMemMap@@6B@
; File C:\duke4\xcore\xclass.h
CONST	SEGMENT
??_7CMemMap@@6B@ DD FLAT:?destroy@CMemMap@@EAEKXZ	; CMemMap::`vftable'
CONST	ENDS
_DATA	SEGMENT
	ORG $+1
$SG56879 DB	'CMemMap: Unable to initialize', 00H
; Function compile flags: /Ogty
; File C:\duke4\xcore\win.cpp
_DATA	ENDS
_TEXT	SEGMENT
__$EHRec$ = -12
_create$ = 8
_Name$ = 12
_size$ = 16
_this$ = -16
??0CMemMap@@QAE@KPBDK@Z PROC NEAR			; CMemMap::CMemMap
; _this$ = ecx

; 132  : {

	push	-1
	push	$L57460
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	push	esi
	mov	esi, ecx
	push	esi
	mov	DWORD PTR _this$[esp+24], esi
	mov	DWORD PTR [esi], OFFSET FLAT:??_7CSysObj@@6B@ ; CSysObj::`vftable'
	mov	ecx, DWORD PTR ?_global@@3PAVXGlobal@@A	; _global
	call	?reg_global_object@XGlobal@@QAEXPAVCSysObj@@@Z ; XGlobal::reg_global_object
	xor	eax, eax
	mov	DWORD PTR __$EHRec$[esp+28], eax
	mov	DWORD PTR [esi+12], eax

; 133  : 	if (!init(create,Name,size))

	mov	eax, DWORD PTR _size$[esp+16]
	mov	ecx, DWORD PTR _Name$[esp+16]
	mov	edx, DWORD PTR _create$[esp+16]
	push	eax
	push	ecx
	push	edx
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+40], 1
	mov	DWORD PTR [esi], OFFSET FLAT:??_7CMemMap@@6B@ ; CMemMap::`vftable'
	call	?init@CMemMap@@QAEKKPBDK@Z		; CMemMap::init
	test	eax, eax
	jne	SHORT $L57459

; 134  : 		xxx_throw("CMemMap: Unable to initialize");

	mov	ecx, OFFSET FLAT:$SG56879
	call	@xxx_throw@4
$L57459:

; 135  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	ret	12					; 0000000cH
_TEXT	ENDS
text$x	SEGMENT
$L57448:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CSysObj@@QAE@XZ			; CSysObj::~CSysObj
$L57449:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	jmp	??1autochar@@QAE@XZ			; autochar::~autochar
$L57460:
	mov	eax, OFFSET FLAT:$T57458
	jmp	___CxxFrameHandler
text$x	ENDS
??0CMemMap@@QAE@KPBDK@Z ENDP				; CMemMap::CMemMap
PUBLIC	??0CMemMap@@QAE@PBD@Z				; CMemMap::CMemMap
xdata$x	SEGMENT
$T57476	DD	0ffffffffH
	DD	FLAT:$L57463
	DD	00H
	DD	FLAT:$L57464
$T57473	DD	019930520H
	DD	02H
	DD	FLAT:$T57476
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
_DATA	SEGMENT
	ORG $+2
$SG56885 DB	'CMemMap: Unable to initialize', 00H
; Function compile flags: /Ogty
_DATA	ENDS
_TEXT	SEGMENT
__$EHRec$ = -12
_Name$ = 8
_this$ = -16
??0CMemMap@@QAE@PBD@Z PROC NEAR				; CMemMap::CMemMap
; _this$ = ecx

; 138  : {

	push	-1
	push	$L57475
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	push	esi
	mov	esi, ecx
	push	esi
	mov	DWORD PTR _this$[esp+24], esi
	mov	DWORD PTR [esi], OFFSET FLAT:??_7CSysObj@@6B@ ; CSysObj::`vftable'
	mov	ecx, DWORD PTR ?_global@@3PAVXGlobal@@A	; _global
	call	?reg_global_object@XGlobal@@QAEXPAVCSysObj@@@Z ; XGlobal::reg_global_object
	xor	eax, eax
	mov	DWORD PTR __$EHRec$[esp+28], eax
	mov	DWORD PTR [esi+12], eax

; 139  : 	if (!init(FALSE,Name,0))

	mov	ecx, DWORD PTR _Name$[esp+16]
	push	eax
	push	ecx
	push	eax
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+40], 1
	mov	DWORD PTR [esi], OFFSET FLAT:??_7CMemMap@@6B@ ; CMemMap::`vftable'
	call	?init@CMemMap@@QAEKKPBDK@Z		; CMemMap::init
	test	eax, eax
	jne	SHORT $L57474

; 140  : 		xxx_throw("CMemMap: Unable to initialize");

	mov	ecx, OFFSET FLAT:$SG56885
	call	@xxx_throw@4
$L57474:

; 141  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
text$x	SEGMENT
$L57463:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CSysObj@@QAE@XZ			; CSysObj::~CSysObj
$L57464:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	jmp	??1autochar@@QAE@XZ			; autochar::~autochar
$L57475:
	mov	eax, OFFSET FLAT:$T57473
	jmp	___CxxFrameHandler
text$x	ENDS
??0CMemMap@@QAE@PBD@Z ENDP				; CMemMap::CMemMap
EXTRN	__imp__CreateFileMappingA@24:NEAR
EXTRN	__imp__OpenFileMappingA@12:NEAR
_DATA	SEGMENT
	ORG $+2
$SG56905 DB	'CMemMap::init: Unable to create memory map', 00H
	ORG $+1
$SG56908 DB	'CMemMAp::init: Mapping already exists', 00H
	ORG $+2
$SG56911 DB	'CMemMap::init: Unable to open memory map', 00H
; Function compile flags: /Ogty
_DATA	ENDS
_TEXT	SEGMENT
$T57479 = -8
_create$ = 8
_Name$ = 12
_size$ = 16
?init@CMemMap@@QAEKKPBDK@Z PROC NEAR			; CMemMap::init
; _this$ = ecx

; 144  : {

	sub	esp, 8
	push	esi
	mov	esi, ecx

; 145  : 	D_ASSERT(Name);
; 146  : 	
; 147  : 	if (name)

	mov	ecx, DWORD PTR [esi+12]
	test	ecx, ecx
	je	SHORT $L57489

; 148  : 		delete name;

	call	@xfree@4
$L57489:

; 149  : 
; 150  : 	name=CStr(Name);

	mov	eax, DWORD PTR _Name$[esp+8]
	lea	ecx, DWORD PTR $T57479[esp+12]
	push	eax
	call	??0CStr@@QAE@PBD@Z			; CStr::CStr
	mov	ecx, DWORD PTR [eax+4]

; 151  : 
; 152  : 	size=ALIGN_POW2(size,32*1024);
; 153  : 	if (create)

	mov	eax, DWORD PTR _create$[esp+8]
	test	eax, eax

; 154  : 	{
; 155  : 		handle=CreateFileMapping(INVALID_HANDLE_VALUE,null,PAGE_READWRITE,0,size,name);

	mov	eax, ecx
	mov	DWORD PTR [esi+12], ecx
	push	eax
	je	SHORT $L56902
	mov	edx, DWORD PTR _size$[esp+12]
	add	edx, 32767				; 00007fffH
	and	edx, -32768				; ffff8000H
	push	edx
	push	0
	push	4
	push	0
	push	-1
	call	DWORD PTR __imp__CreateFileMappingA@24

; 156  : 		if (!handle)

	test	eax, eax
	mov	DWORD PTR [esi+20], eax
	jne	SHORT $L56904

; 157  : 		{
; 158  : 			xxx_bitch("CMemMap::init: Unable to create memory map");

	mov	ecx, OFFSET FLAT:$SG56905
	call	@xxx_bitch@4

; 159  : 			return FALSE;

	xor	eax, eax
	pop	esi

; 175  : }

	add	esp, 8
	ret	12					; 0000000cH
$L56904:

; 160  : 		}
; 161  : 		U32 err=GetLastError();

	call	DWORD PTR __imp__GetLastError@0

; 162  : 		if (err==ERROR_ALREADY_EXISTS)

	cmp	eax, 183				; 000000b7H
	jne	SHORT $L56910

; 163  : 			xxx_bitch("CMemMAp::init: Mapping already exists");

	mov	ecx, OFFSET FLAT:$SG56908
	call	@xxx_bitch@4
$L56910:

; 172  : 		}
; 173  : 	}
; 174  : 	return TRUE;

	mov	eax, 1
	pop	esi

; 175  : }

	add	esp, 8
	ret	12					; 0000000cH
$L56902:

; 164  : 	}
; 165  : 	else
; 166  : 	{
; 167  : 		handle=OpenFileMapping(FILE_MAP_ALL_ACCESS,FALSE,name);

	push	0
	push	983071					; 000f001fH
	call	DWORD PTR __imp__OpenFileMappingA@12

; 168  : 		if (!handle)

	test	eax, eax
	mov	DWORD PTR [esi+20], eax
	jne	SHORT $L56910

; 169  : 		{
; 170  : 			xxx_bitch("CMemMap::init: Unable to open memory map");

	mov	ecx, OFFSET FLAT:$SG56911
	call	@xxx_bitch@4

; 171  : 			return FALSE;

	xor	eax, eax
	pop	esi

; 175  : }

	add	esp, 8
	ret	12					; 0000000cH
?init@CMemMap@@QAEKKPBDK@Z ENDP				; CMemMap::init
_TEXT	ENDS
PUBLIC	??3@YAXPAX@Z					; operator delete
; Function compile flags: /Ogty
; File C:\duke4\xcore\xcore.h
;	COMDAT ??3@YAXPAX@Z
_TEXT	SEGMENT
_ptr$ = 8
??3@YAXPAX@Z PROC NEAR					; operator delete, COMDAT

; 130  : __inline void operator delete(void *ptr){xfree(ptr);}

	mov	ecx, DWORD PTR _ptr$[esp-4]
	jmp	@xfree@4
??3@YAXPAX@Z ENDP					; operator delete
; Function compile flags: /Ogty
; File C:\duke4\xcore\xclass.h
_TEXT	ENDS
;	COMDAT ??1autochar@@QAE@XZ
_TEXT	SEGMENT
??1autochar@@QAE@XZ PROC NEAR				; autochar::~autochar, COMDAT
; _this$ = ecx

; 69   : 	inline ~autochar(void){xfree(ptr);ptr=null;}

	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR [esi]
	call	@xfree@4
	mov	DWORD PTR [esi], 0
	pop	esi
	ret	0
??1autochar@@QAE@XZ ENDP				; autochar::~autochar
; Function compile flags: /Ogty
; File C:\duke4\xcore\win.cpp
_TEXT	ENDS
_TEXT	SEGMENT
?destroy@CMemMap@@EAEKXZ PROC NEAR			; CMemMap::destroy
; _this$ = ecx

; 178  : {

	push	esi
	mov	esi, ecx

; 179  : 	if (handle)

	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	je	SHORT $L57512

; 180  : 		CloseHandle(handle);

	push	eax
	call	DWORD PTR __imp__CloseHandle@4
$L57512:

; 181  : 
; 182  : 	handle=null;

	mov	DWORD PTR [esi+20], 0

; 183  : 	return TRUE;

	mov	eax, 1
	pop	esi

; 184  : }

	ret	0
?destroy@CMemMap@@EAEKXZ ENDP				; CMemMap::destroy
; Function compile flags: /Ogty
_$E2	PROC NEAR
	jmp	_$E1
_$E2	ENDP
_TEXT	ENDS
PUBLIC	??_7WinMsgDef@@6B@				; WinMsgDef::`vftable'
PUBLIC	?message@WinMsgDef@@UAEXKPBD@Z			; WinMsgDef::message
PUBLIC	?throw_msg@WinMsgDef@@UAEXKPBD@Z		; WinMsgDef::throw_msg
PUBLIC	?assert@WinMsgDef@@UAEXPBDK@Z			; WinMsgDef::assert
PUBLIC	?set_window@WinMsgDef@@UAEXPAUHWND__@@@Z	; WinMsgDef::set_window
PUBLIC	?no_window@WinMsgDef@@UAEXXZ			; WinMsgDef::no_window
;	COMDAT ??_7WinMsgDef@@6B@
; File C:\duke4\xcore\xclass.h
CONST	SEGMENT
??_7WinMsgDef@@6B@ DD FLAT:?message@WinMsgDef@@UAEXKPBD@Z ; WinMsgDef::`vftable'
	DD	FLAT:?throw_msg@WinMsgDef@@UAEXKPBD@Z
	DD	FLAT:?assert@WinMsgDef@@UAEXPBDK@Z
	DD	FLAT:?set_window@WinMsgDef@@UAEXPAUHWND__@@@Z
	DD	FLAT:?no_window@WinMsgDef@@UAEXXZ
; Function compile flags: /Ogty
; File C:\duke4\xcore\win.cpp
CONST	ENDS
_TEXT	SEGMENT
_$E1	PROC NEAR

; 186  : WinMsgDef _win_error;

	mov	DWORD PTR ?_win_error@@3VWinMsgDef@@A+4, 0
	mov	DWORD PTR ?_win_error@@3VWinMsgDef@@A, OFFSET FLAT:??_7WinMsgDef@@6B@ ; WinMsgDef::`vftable'
	ret	0
_$E1	ENDP
; Function compile flags: /Ogty
_Hwnd$ = 8
?set_window@WinMsgDef@@UAEXPAUHWND__@@@Z PROC NEAR	; WinMsgDef::set_window
; _this$ = ecx

; 190  : 	hwnd=Hwnd;

	mov	eax, DWORD PTR _Hwnd$[esp-4]
	mov	DWORD PTR [ecx+4], eax

; 191  : }

	ret	4
?set_window@WinMsgDef@@UAEXPAUHWND__@@@Z ENDP		; WinMsgDef::set_window
; Function compile flags: /Ogty
?no_window@WinMsgDef@@UAEXXZ PROC NEAR			; WinMsgDef::no_window
; _this$ = ecx

; 195  : 	hwnd=null;

	mov	DWORD PTR [ecx+4], 0

; 196  : }

	ret	0
?no_window@WinMsgDef@@UAEXXZ ENDP			; WinMsgDef::no_window
_TEXT	ENDS
PUBLIC	?WinMessage@@YAXPAUHWND__@@PBD@Z		; WinMessage
EXTRN	?fatal@XGlobal@@QAEXXZ:NEAR			; XGlobal::fatal
EXTRN	?fstrcpy_lim@CPrintf@@IAEKPBD@Z:NEAR		; CPrintf::fstrcpy_lim
EXTRN	?num@CPrintf@@QAEKK@Z:NEAR			; CPrintf::num
EXTRN	__err_printf_string:BYTE
_DATA	SEGMENT
	ORG $+3
$SG56941 DB	'Assertion Failure: ', 00H
$SG56942 DB	' line ', 00H
; Function compile flags: /Ogty
_DATA	ENDS
_TEXT	SEGMENT
_file$ = 8
_line$ = 12
_obj$ = -20
?assert@WinMsgDef@@UAEXPBDK@Z PROC NEAR			; WinMsgDef::assert
; _this$ = ecx

; 199  : {

	sub	esp, 20					; 00000014H

; 200  : 	CPrintf obj(_err_printf_string,MAX_PRINTF_SIZE);

	mov	eax, OFFSET FLAT:__err_printf_string
	push	esi
	mov	DWORD PTR _obj$[esp+24], eax
	mov	DWORD PTR _obj$[esp+28], eax
	mov	esi, ecx
	xor	eax, eax

; 201  : 
; 202  : 	obj << "Assertion Failure: " << file << " line " << line;

	push	OFFSET FLAT:$SG56941
	lea	ecx, DWORD PTR _obj$[esp+28]
	mov	DWORD PTR _obj$[esp+36], 4095		; 00000fffH
	mov	DWORD PTR _obj$[esp+40], 4096		; 00001000H
	mov	DWORD PTR _obj$[esp+44], eax
	mov	BYTE PTR __err_printf_string, al
	call	?fstrcpy_lim@CPrintf@@IAEKPBD@Z		; CPrintf::fstrcpy_lim
	mov	eax, DWORD PTR _file$[esp+20]
	lea	ecx, DWORD PTR _obj$[esp+24]
	push	eax
	call	?fstrcpy_lim@CPrintf@@IAEKPBD@Z		; CPrintf::fstrcpy_lim
	push	OFFSET FLAT:$SG56942
	lea	ecx, DWORD PTR _obj$[esp+28]
	call	?fstrcpy_lim@CPrintf@@IAEKPBD@Z		; CPrintf::fstrcpy_lim
	mov	ecx, DWORD PTR _line$[esp+20]
	push	ecx
	lea	ecx, DWORD PTR _obj$[esp+28]
	call	?num@CPrintf@@QAEKK@Z			; CPrintf::num

; 203  : 	
; 204  : 	WinMessage(hwnd,obj.get_str());

	mov	edx, DWORD PTR _obj$[esp+24]
	mov	eax, DWORD PTR [esi+4]
	push	edx
	push	eax
	call	?WinMessage@@YAXPAUHWND__@@PBD@Z	; WinMessage

; 205  : 	
; 206  : 	_global->fatal();

	mov	ecx, DWORD PTR ?_global@@3PAVXGlobal@@A	; _global
	add	esp, 8
	call	?fatal@XGlobal@@QAEXXZ			; XGlobal::fatal
	pop	esi

; 207  : }

	add	esp, 20					; 00000014H
	ret	8
?assert@WinMsgDef@@UAEXPBDK@Z ENDP			; WinMsgDef::assert
; Function compile flags: /Ogty
_level$ = 8
_message$ = 12
?message@WinMsgDef@@UAEXKPBD@Z PROC NEAR		; WinMsgDef::message
; _this$ = ecx

; 211  : 	WinMessage(hwnd,message);

	mov	eax, DWORD PTR _message$[esp-4]
	mov	ecx, DWORD PTR [ecx+4]
	push	eax
	push	ecx
	call	?WinMessage@@YAXPAUHWND__@@PBD@Z	; WinMessage

; 212  : 	if (level<=ERROR_SEVERE)

	mov	eax, DWORD PTR _level$[esp+4]
	add	esp, 8
	cmp	eax, 1
	ja	SHORT $L56948

; 213  : 		_global->fatal();

	mov	ecx, DWORD PTR ?_global@@3PAVXGlobal@@A	; _global
	call	?fatal@XGlobal@@QAEXXZ			; XGlobal::fatal
$L56948:

; 214  : }

	ret	8
?message@WinMsgDef@@UAEXKPBD@Z ENDP			; WinMsgDef::message
_TEXT	ENDS
PUBLIC	__TI1K
PUBLIC	__CTA1K
PUBLIC	??_R0K@8					; unsigned long `RTTI Type Descriptor'
PUBLIC	__CT??_R0K@84
EXTRN	??_7type_info@@6B@:BYTE				; type_info::`vftable'
EXTRN	__CxxThrowException@8:NEAR
;	COMDAT __TI1K
xdata$x	SEGMENT
__TI1K	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:__CTA1K
xdata$x	ENDS
;	COMDAT __CTA1K
xdata$x	SEGMENT
__CTA1K	DD	01H
	DD	FLAT:__CT??_R0K@84
xdata$x	ENDS
;	COMDAT __CT??_R0K@84
xdata$x	SEGMENT
__CT??_R0K@84 DD 01H
	DD	FLAT:??_R0K@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	04H
	DD	00H
xdata$x	ENDS
;	COMDAT ??_R0K@8
_DATA	SEGMENT
??_R0K@8 DD	FLAT:??_7type_info@@6B@			; unsigned long `RTTI Type Descriptor'
	DD	00H
	DB	'.K', 00H
; Function compile flags: /Ogty
_DATA	ENDS
_TEXT	SEGMENT
_level$ = 8
_message$ = 12
$T57546 = 12
?throw_msg@WinMsgDef@@UAEXKPBD@Z PROC NEAR		; WinMsgDef::throw_msg
; _this$ = ecx

; 218  : 	WinMessage(hwnd,message);

	mov	eax, DWORD PTR _message$[esp-4]
	mov	ecx, DWORD PTR [ecx+4]
	push	eax
	push	ecx
	call	?WinMessage@@YAXPAUHWND__@@PBD@Z	; WinMessage

; 219  : 	throw level;

	mov	edx, DWORD PTR _level$[esp+4]
	add	esp, 8
	lea	eax, DWORD PTR $T57546[esp-4]
	mov	DWORD PTR $T57546[esp-4], edx
	push	OFFSET FLAT:__TI1K
	push	eax
	call	__CxxThrowException@8
$L57548:
?throw_msg@WinMsgDef@@UAEXKPBD@Z ENDP			; WinMsgDef::throw_msg
_TEXT	ENDS
EXTRN	__imp__MessageBoxExA@20:NEAR
_DATA	SEGMENT
	ORG $+1
$SG56967 DB	'Error', 00H
; Function compile flags: /Ogty
_DATA	ENDS
_TEXT	SEGMENT
_hwnd$ = 8
_string$ = 12
?WinMessage@@YAXPAUHWND__@@PBD@Z PROC NEAR		; WinMessage

; 224  : 	MessageBoxEx(hwnd,string,"Error",
; 225  : 				MB_OK|MB_ICONERROR|MB_TASKMODAL,
; 226  : 				MAKELANGID(LANG_ENGLISH,SUBLANG_DEFAULT));

	mov	eax, DWORD PTR _string$[esp-4]
	mov	ecx, DWORD PTR _hwnd$[esp-4]
	push	1033					; 00000409H
	push	8208					; 00002010H
	push	OFFSET FLAT:$SG56967
	push	eax
	push	ecx
	call	DWORD PTR __imp__MessageBoxExA@20

; 227  : }

	ret	0
?WinMessage@@YAXPAUHWND__@@PBD@Z ENDP			; WinMessage
_TEXT	ENDS
PUBLIC	??0?$XChain@VCSysObj@@@@QAE@XZ			; XChain<CSysObj>::XChain<CSysObj>
; Function compile flags: /Ogty
; File C:\duke4\xcore\xclass.h
;	COMDAT ??0?$XChain@VCSysObj@@@@QAE@XZ
_TEXT	SEGMENT
??0?$XChain@VCSysObj@@@@QAE@XZ PROC NEAR		; XChain<CSysObj>::XChain<CSysObj>, COMDAT
; _this$ = ecx

; 830  : 	XChain(void) : head(null),tail(null) {}

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$XChain@VCSysObj@@@@QAE@XZ ENDP			; XChain<CSysObj>::XChain<CSysObj>
_TEXT	ENDS
PUBLIC	??0?$XChain@VCSysObj@@@@QAE@K@Z			; XChain<CSysObj>::XChain<CSysObj>
; Function compile flags: /Ogty
;	COMDAT ??0?$XChain@VCSysObj@@@@QAE@K@Z
_TEXT	SEGMENT
_owned$ = 8
??0?$XChain@VCSysObj@@@@QAE@K@Z PROC NEAR		; XChain<CSysObj>::XChain<CSysObj>, COMDAT
; _this$ = ecx

; 831  : 	XChain(U32 owned) : head(null),tail(null),xchain_state(owned) {}

	mov	eax, ecx
	mov	ecx, DWORD PTR _owned$[esp-4]
	shl	ecx, 31					; 0000001fH
	and	ecx, -2147483648			; 80000000H
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], ecx
	ret	4
??0?$XChain@VCSysObj@@@@QAE@K@Z ENDP			; XChain<CSysObj>::XChain<CSysObj>
_TEXT	ENDS
PUBLIC	?get_next@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z ; XChain<CSysObj>::get_next
; Function compile flags: /Ogty
;	COMDAT ?get_next@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z
_TEXT	SEGMENT
_ptr$ = 8
?get_next@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z PROC NEAR ; XChain<CSysObj>::get_next, COMDAT
; _this$ = ecx

; 840  : 	TYPE *get_next(TYPE *ptr){return ptr->next;}

	mov	eax, DWORD PTR _ptr$[esp-4]
	mov	eax, DWORD PTR [eax+4]
	ret	4
?get_next@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z ENDP ; XChain<CSysObj>::get_next
_TEXT	ENDS
PUBLIC	?get_prev@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z ; XChain<CSysObj>::get_prev
; Function compile flags: /Ogty
;	COMDAT ?get_prev@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z
_TEXT	SEGMENT
_ptr$ = 8
?get_prev@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z PROC NEAR ; XChain<CSysObj>::get_prev, COMDAT
; _this$ = ecx

; 841  : 	TYPE *get_prev(TYPE *ptr){return ptr->prev;}

	mov	eax, DWORD PTR _ptr$[esp-4]
	mov	eax, DWORD PTR [eax+8]
	ret	4
?get_prev@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z ENDP ; XChain<CSysObj>::get_prev
_TEXT	ENDS
PUBLIC	?get_head@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ ; XChain<CSysObj>::get_head
; Function compile flags: /Ogty
;	COMDAT ?get_head@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ
_TEXT	SEGMENT
?get_head@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ PROC NEAR ; XChain<CSysObj>::get_head, COMDAT
; _this$ = ecx

; 847  : 	inline TYPE *get_head(void){return head;}

	mov	eax, DWORD PTR [ecx]
	ret	0
?get_head@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ ENDP	; XChain<CSysObj>::get_head
_TEXT	ENDS
PUBLIC	?get_tail@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ ; XChain<CSysObj>::get_tail
; Function compile flags: /Ogty
;	COMDAT ?get_tail@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ
_TEXT	SEGMENT
?get_tail@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ PROC NEAR ; XChain<CSysObj>::get_tail, COMDAT
; _this$ = ecx

; 848  : 	inline TYPE *get_tail(void){return tail;}

	mov	eax, DWORD PTR [ecx+4]
	ret	0
?get_tail@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ ENDP	; XChain<CSysObj>::get_tail
_TEXT	ENDS
PUBLIC	??1?$XChain@VCSysObj@@@@QAE@XZ			; XChain<CSysObj>::~XChain<CSysObj>
EXTRN	?unreg_global_object@XGlobal@@QAEXPAVCSysObj@@@Z:NEAR ; XGlobal::unreg_global_object
; Function compile flags: /Ogty
;	COMDAT ??1?$XChain@VCSysObj@@@@QAE@XZ
_TEXT	SEGMENT
??1?$XChain@VCSysObj@@@@QAE@XZ PROC NEAR		; XChain<CSysObj>::~XChain<CSysObj>, COMDAT
; _this$ = ecx

; 853  : {

	push	esi
	mov	esi, ecx

; 854  : 	if (xchain_state.owned)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	jns	SHORT $L57592

; 855  : 	{
; 856  : 		while(head)

	cmp	DWORD PTR [esi], 0
	je	SHORT $L57592
	push	ebx
	push	edi
$L57053:

; 857  : 		{
; 858  : 			TYPE *tmp=(TYPE *)head->next;

	mov	eax, DWORD PTR [esi]

; 859  : 			delete head;

	mov	edi, eax
	mov	ebx, DWORD PTR [eax+4]
	test	edi, edi
	je	SHORT $L57573
	mov	DWORD PTR [edi], OFFSET FLAT:??_7CSysObj@@6B@ ; CSysObj::`vftable'
	mov	ecx, DWORD PTR ?_global@@3PAVXGlobal@@A	; _global
	push	edi
	call	?unreg_global_object@XGlobal@@QAEXPAVCSysObj@@@Z ; XGlobal::unreg_global_object
	mov	ecx, edi
	call	@xfree@4
$L57573:
	test	ebx, ebx

; 860  : 			head=tmp;

	mov	DWORD PTR [esi], ebx
	jne	SHORT $L57053
	pop	edi
	pop	ebx
$L57592:

; 861  : 		}
; 862  : 	}
; 863  : 	head=null;

	mov	DWORD PTR [esi], 0

; 864  : 	tail=null;

	mov	DWORD PTR [esi+4], 0
	pop	esi

; 865  : }

	ret	0
??1?$XChain@VCSysObj@@@@QAE@XZ ENDP			; XChain<CSysObj>::~XChain<CSysObj>
_TEXT	ENDS
PUBLIC	?lose_list@?$XChain@VCSysObj@@@@QAEXXZ		; XChain<CSysObj>::lose_list
; Function compile flags: /Ogty
;	COMDAT ?lose_list@?$XChain@VCSysObj@@@@QAEXXZ
_TEXT	SEGMENT
?lose_list@?$XChain@VCSysObj@@@@QAEXXZ PROC NEAR	; XChain<CSysObj>::lose_list, COMDAT
; _this$ = ecx

; 870  : 	head=null;tail=null;xchain_state.count=0;

	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [ecx], 0
	and	eax, -2147483648			; 80000000H
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], eax

; 871  : }

	ret	0
?lose_list@?$XChain@VCSysObj@@@@QAEXXZ ENDP		; XChain<CSysObj>::lose_list
_TEXT	ENDS
PUBLIC	?free_list@?$XChain@VCSysObj@@@@QAEXXZ		; XChain<CSysObj>::free_list
; Function compile flags: /Ogty
;	COMDAT ?free_list@?$XChain@VCSysObj@@@@QAEXXZ
_TEXT	SEGMENT
?free_list@?$XChain@VCSysObj@@@@QAEXXZ PROC NEAR	; XChain<CSysObj>::free_list, COMDAT
; _this$ = ecx

; 875  : {

	push	esi
	mov	esi, ecx

; 876  : 	if (xchain_state.owned)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	jns	SHORT $L57618

; 877  : 	{
; 878  : 		while(head)

	cmp	DWORD PTR [esi], 0
	je	SHORT $L57618
	push	ebx
	push	edi
$L57069:

; 879  : 		{
; 880  : 			TYPE *tmp=(TYPE *)head->next;

	mov	eax, DWORD PTR [esi]

; 881  : 			delete head;

	mov	edi, eax
	mov	ebx, DWORD PTR [eax+4]
	test	edi, edi
	je	SHORT $L57599
	mov	DWORD PTR [edi], OFFSET FLAT:??_7CSysObj@@6B@ ; CSysObj::`vftable'
	mov	ecx, DWORD PTR ?_global@@3PAVXGlobal@@A	; _global
	push	edi
	call	?unreg_global_object@XGlobal@@QAEXPAVCSysObj@@@Z ; XGlobal::unreg_global_object
	mov	ecx, edi
	call	@xfree@4
$L57599:
	test	ebx, ebx

; 882  : 			head=tmp;

	mov	DWORD PTR [esi], ebx
	jne	SHORT $L57069
	pop	edi
	pop	ebx
$L57618:

; 883  : 		}
; 884  : 	}
; 885  : 	head=null;tail=null;

	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+4], 0
	pop	esi

; 886  : }

	ret	0
?free_list@?$XChain@VCSysObj@@@@QAEXXZ ENDP		; XChain<CSysObj>::free_list
_TEXT	ENDS
PUBLIC	?add_head@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z ; XChain<CSysObj>::add_head
; Function compile flags: /Ogty
;	COMDAT ?add_head@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z
_TEXT	SEGMENT
_ptr$ = 8
?add_head@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z PROC NEAR ; XChain<CSysObj>::add_head, COMDAT
; _this$ = ecx

; 891  : 	ptr->next=head;

	mov	eax, DWORD PTR _ptr$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx

; 892  : 	ptr->prev=null;

	mov	DWORD PTR [eax+8], 0

; 893  : 	if (head)

	mov	edx, DWORD PTR [ecx]
	test	edx, edx
	je	SHORT $L57079

; 894  : 		head->prev=ptr;

	mov	DWORD PTR [edx+8], eax

; 897  : 	
; 898  : 	head=ptr;

	mov	DWORD PTR [ecx], eax

; 899  : 
; 900  : 	return head;
; 901  : }

	ret	4
$L57079:

; 895  : 	else
; 896  : 		tail=ptr;

	mov	DWORD PTR [ecx+4], eax

; 897  : 	
; 898  : 	head=ptr;

	mov	DWORD PTR [ecx], eax

; 899  : 
; 900  : 	return head;
; 901  : }

	ret	4
?add_head@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z ENDP ; XChain<CSysObj>::add_head
_TEXT	ENDS
PUBLIC	?add_tail@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z ; XChain<CSysObj>::add_tail
; Function compile flags: /Ogty
;	COMDAT ?add_tail@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z
_TEXT	SEGMENT
_ptr$ = 8
?add_tail@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z PROC NEAR ; XChain<CSysObj>::add_tail, COMDAT
; _this$ = ecx

; 906  : 	ptr->prev=tail;

	mov	eax, DWORD PTR _ptr$[esp-4]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+8], edx

; 907  : 	ptr->next=null;

	mov	DWORD PTR [eax+4], 0

; 908  : 	if (tail)

	mov	edx, DWORD PTR [ecx+4]
	test	edx, edx
	je	SHORT $L57085

; 909  : 		tail->next=ptr;

	mov	DWORD PTR [edx+4], eax

; 912  : 	
; 913  : 	tail=ptr;

	mov	DWORD PTR [ecx+4], eax

; 914  : 
; 915  : 	return tail;
; 916  : }

	ret	4
$L57085:

; 910  : 	else
; 911  : 		head=ptr;

	mov	DWORD PTR [ecx], eax

; 912  : 	
; 913  : 	tail=ptr;

	mov	DWORD PTR [ecx+4], eax

; 914  : 
; 915  : 	return tail;
; 916  : }

	ret	4
?add_tail@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z ENDP ; XChain<CSysObj>::add_tail
_TEXT	ENDS
PUBLIC	?remove_head@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ ; XChain<CSysObj>::remove_head
; Function compile flags: /Ogty
;	COMDAT ?remove_head@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ
_TEXT	SEGMENT
?remove_head@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ PROC NEAR ; XChain<CSysObj>::remove_head, COMDAT
; _this$ = ecx

; 937  : 	if (!head)

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	jne	SHORT $L57091

; 947  : 
; 948  : 	return ret;
; 949  : }

	ret	0
$L57091:

; 938  : 		return null;
; 939  : 
; 940  : 	TYPE *ret=head;
; 941  : 
; 942  : 	head=head->next;

	mov	edx, DWORD PTR [eax+4]

; 943  : 	if (!head)

	test	edx, edx
	mov	DWORD PTR [ecx], edx
	jne	SHORT $L57093

; 944  : 		tail=null;

	mov	DWORD PTR [ecx+4], edx

; 947  : 
; 948  : 	return ret;
; 949  : }

	ret	0
$L57093:

; 945  : 	else
; 946  : 		head->prev=null;

	mov	DWORD PTR [edx+8], 0

; 947  : 
; 948  : 	return ret;
; 949  : }

	ret	0
?remove_head@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ ENDP ; XChain<CSysObj>::remove_head
_TEXT	ENDS
PUBLIC	?remove_tail@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ ; XChain<CSysObj>::remove_tail
; Function compile flags: /Ogty
;	COMDAT ?remove_tail@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ
_TEXT	SEGMENT
?remove_tail@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ PROC NEAR ; XChain<CSysObj>::remove_tail, COMDAT
; _this$ = ecx

; 954  : 	if (!tail)

	mov	eax, DWORD PTR [ecx+4]
	test	eax, eax
	jne	SHORT $L57099

; 964  : 
; 965  : 	return ret;
; 966  : }

	ret	0
$L57099:

; 955  : 		return null;
; 956  : 
; 957  : 	TYPE *ret=tail;
; 958  : 
; 959  : 	tail=tail->prev;

	mov	edx, DWORD PTR [eax+8]

; 960  : 	if (!tail)

	test	edx, edx
	mov	DWORD PTR [ecx+4], edx
	jne	SHORT $L57101

; 961  : 		head=null;

	mov	DWORD PTR [ecx], edx

; 964  : 
; 965  : 	return ret;
; 966  : }

	ret	0
$L57101:

; 962  : 	else
; 963  : 		tail->next=null;

	mov	DWORD PTR [edx+4], 0

; 964  : 
; 965  : 	return ret;
; 966  : }

	ret	0
?remove_tail@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ ENDP ; XChain<CSysObj>::remove_tail
_TEXT	ENDS
PUBLIC	?remove@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z ; XChain<CSysObj>::remove
; Function compile flags: /Ogty
;	COMDAT ?remove@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z
_TEXT	SEGMENT
_ptr$ = 8
?remove@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z PROC NEAR ; XChain<CSysObj>::remove, COMDAT
; _this$ = ecx

; 921  : 	if (ptr->prev)

	mov	eax, DWORD PTR _ptr$[esp-4]
	mov	edx, DWORD PTR [eax+8]
	test	edx, edx
	je	SHORT $L57107
	push	esi

; 922  : 		ptr->prev->next=ptr->next;

	mov	esi, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], esi
	pop	esi

; 923  : 	else

	jmp	SHORT $L57108
$L57107:

; 924  : 		head=ptr->next;

	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx], edx
$L57108:

; 925  : 
; 926  : 	if (ptr->next)

	mov	edx, DWORD PTR [eax+4]
	test	edx, edx
	je	SHORT $L57109

; 927  : 		ptr->next->prev=ptr->prev;

	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], ecx

; 930  : 
; 931  : 	return ptr;
; 932  : }

	ret	4
$L57109:

; 928  : 	else
; 929  : 		tail=ptr->prev;

	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+4], edx

; 930  : 
; 931  : 	return ptr;
; 932  : }

	ret	4
?remove@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z ENDP ; XChain<CSysObj>::remove
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??1CSysObj@@QAE@XZ
_TEXT	SEGMENT
??1CSysObj@@QAE@XZ PROC NEAR				; CSysObj::~CSysObj, COMDAT
; _this$ = ecx

; 1470 : inline CSysObj::~CSysObj(void){_global->unreg_global_object(this);}

	mov	DWORD PTR [ecx], OFFSET FLAT:??_7CSysObj@@6B@ ; CSysObj::`vftable'
	push	ecx
	mov	ecx, DWORD PTR ?_global@@3PAVXGlobal@@A	; _global
	call	?unreg_global_object@XGlobal@@QAEXPAVCSysObj@@@Z ; XGlobal::unreg_global_object
	ret	0
??1CSysObj@@QAE@XZ ENDP					; CSysObj::~CSysObj
_TEXT	ENDS
PUBLIC	??_7XBufferReadInt@@6B@				; XBufferReadInt::`vftable'
PUBLIC	??_GXBufferReadInt@@UAEPAXI@Z			; XBufferReadInt::`scalar deleting destructor'
PUBLIC	??_EXBufferReadInt@@UAEPAXI@Z			; XBufferReadInt::`vector deleting destructor'
EXTRN	?read_direct@XBufferReadInt@@MAEKPAXKAAK@Z:NEAR	; XBufferReadInt::read_direct
;	COMDAT ??_7XBufferReadInt@@6B@
; File C:\duke4\xcore\xcore.h
CONST	SEGMENT
??_7XBufferReadInt@@6B@ DD FLAT:?read_direct@XBufferReadInt@@MAEKPAXKAAK@Z ; XBufferReadInt::`vftable'
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:??_EXBufferReadInt@@UAEPAXI@Z
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ??_GXBufferReadInt@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_GXBufferReadInt@@UAEPAXI@Z PROC NEAR			; XBufferReadInt::`scalar deleting destructor', COMDAT
; _this$ = ecx
	mov	al, BYTE PTR ___flags$[esp-4]
	push	esi
	mov	esi, ecx
	test	al, 1
	mov	DWORD PTR [esi], OFFSET FLAT:??_7XBufferReadInt@@6B@ ; XBufferReadInt::`vftable'
	je	SHORT $L57641
	call	@xfree@4
$L57641:
	mov	eax, esi
	pop	esi
	ret	4
??_GXBufferReadInt@@UAEPAXI@Z ENDP			; XBufferReadInt::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??1XBufferReadInt@@UAE@XZ			; XBufferReadInt::~XBufferReadInt
EXTRN	??_M@YGXPAXIHP6EX0@Z@Z:NEAR			; `eh vector destructor iterator'
; Function compile flags: /Ogty
;	COMDAT ??_EXBufferReadInt@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_EXBufferReadInt@@UAEPAXI@Z PROC NEAR			; XBufferReadInt::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebx
	mov	bl, BYTE PTR ___flags$[esp]
	push	esi
	mov	esi, ecx
	test	bl, 2
	je	SHORT $L56059
	mov	eax, DWORD PTR [esi-4]
	push	edi
	lea	edi, DWORD PTR [esi-4]
	push	OFFSET FLAT:??1XBufferReadInt@@UAE@XZ	; XBufferReadInt::~XBufferReadInt
	push	eax
	push	8
	push	esi
	call	??_M@YGXPAXIHP6EX0@Z@Z			; `eh vector destructor iterator'
	test	bl, 1
	je	SHORT $L57646
	mov	ecx, edi
	call	@xfree@4
$L57646:
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	ret	4
$L56059:
	test	bl, 1
	mov	DWORD PTR [esi], OFFSET FLAT:??_7XBufferReadInt@@6B@ ; XBufferReadInt::`vftable'
	je	SHORT $L57652
	mov	ecx, esi
	call	@xfree@4
$L57652:
	mov	eax, esi
	pop	esi
	pop	ebx
	ret	4
??_EXBufferReadInt@@UAEPAXI@Z ENDP			; XBufferReadInt::`vector deleting destructor'
; Function compile flags: /Ogty
; File C:\duke4\xcore\xstream.h
_TEXT	ENDS
;	COMDAT ??1XBufferReadInt@@UAE@XZ
_TEXT	SEGMENT
??1XBufferReadInt@@UAE@XZ PROC NEAR			; XBufferReadInt::~XBufferReadInt, COMDAT
; _this$ = ecx

; 37   : 	virtual ~XBufferReadInt(void){}

	mov	DWORD PTR [ecx], OFFSET FLAT:??_7XBufferReadInt@@6B@ ; XBufferReadInt::`vftable'
	ret	0
??1XBufferReadInt@@UAE@XZ ENDP				; XBufferReadInt::~XBufferReadInt
_TEXT	ENDS
PUBLIC	??_7XBufferWriteInt@@6B@			; XBufferWriteInt::`vftable'
PUBLIC	??_GXBufferWriteInt@@UAEPAXI@Z			; XBufferWriteInt::`scalar deleting destructor'
PUBLIC	??_EXBufferWriteInt@@UAEPAXI@Z			; XBufferWriteInt::`vector deleting destructor'
EXTRN	?write_direct@XBufferWriteInt@@MAEKPBXKAAK@Z:NEAR ; XBufferWriteInt::write_direct
;	COMDAT ??_7XBufferWriteInt@@6B@
; File C:\duke4\xcore\xcore.h
CONST	SEGMENT
??_7XBufferWriteInt@@6B@ DD FLAT:?write_direct@XBufferWriteInt@@MAEKPBXKAAK@Z ; XBufferWriteInt::`vftable'
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:??_EXBufferWriteInt@@UAEPAXI@Z
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ??_GXBufferWriteInt@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_GXBufferWriteInt@@UAEPAXI@Z PROC NEAR		; XBufferWriteInt::`scalar deleting destructor', COMDAT
; _this$ = ecx
	mov	al, BYTE PTR ___flags$[esp-4]
	push	esi
	mov	esi, ecx
	test	al, 1
	mov	DWORD PTR [esi], OFFSET FLAT:??_7XBufferWriteInt@@6B@ ; XBufferWriteInt::`vftable'
	je	SHORT $L57663
	call	@xfree@4
$L57663:
	mov	eax, esi
	pop	esi
	ret	4
??_GXBufferWriteInt@@UAEPAXI@Z ENDP			; XBufferWriteInt::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??1XBufferWriteInt@@UAE@XZ			; XBufferWriteInt::~XBufferWriteInt
; Function compile flags: /Ogty
;	COMDAT ??_EXBufferWriteInt@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_EXBufferWriteInt@@UAEPAXI@Z PROC NEAR		; XBufferWriteInt::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebx
	mov	bl, BYTE PTR ___flags$[esp]
	push	esi
	mov	esi, ecx
	test	bl, 2
	je	SHORT $L56111
	mov	eax, DWORD PTR [esi-4]
	push	edi
	lea	edi, DWORD PTR [esi-4]
	push	OFFSET FLAT:??1XBufferWriteInt@@UAE@XZ	; XBufferWriteInt::~XBufferWriteInt
	push	eax
	push	8
	push	esi
	call	??_M@YGXPAXIHP6EX0@Z@Z			; `eh vector destructor iterator'
	test	bl, 1
	je	SHORT $L57668
	mov	ecx, edi
	call	@xfree@4
$L57668:
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	ret	4
$L56111:
	test	bl, 1
	mov	DWORD PTR [esi], OFFSET FLAT:??_7XBufferWriteInt@@6B@ ; XBufferWriteInt::`vftable'
	je	SHORT $L57674
	mov	ecx, esi
	call	@xfree@4
$L57674:
	mov	eax, esi
	pop	esi
	pop	ebx
	ret	4
??_EXBufferWriteInt@@UAEPAXI@Z ENDP			; XBufferWriteInt::`vector deleting destructor'
; Function compile flags: /Ogty
; File C:\duke4\xcore\xstream.h
_TEXT	ENDS
;	COMDAT ??1XBufferWriteInt@@UAE@XZ
_TEXT	SEGMENT
??1XBufferWriteInt@@UAE@XZ PROC NEAR			; XBufferWriteInt::~XBufferWriteInt, COMDAT
; _this$ = ecx

; 56   : 	virtual ~XBufferWriteInt(void){}

	mov	DWORD PTR [ecx], OFFSET FLAT:??_7XBufferWriteInt@@6B@ ; XBufferWriteInt::`vftable'
	ret	0
??1XBufferWriteInt@@UAE@XZ ENDP				; XBufferWriteInt::~XBufferWriteInt
_TEXT	ENDS
PUBLIC	??1XStreamRdDirect@@UAE@XZ			; XStreamRdDirect::~XStreamRdDirect
PUBLIC	??_GXStreamRdDirect@@UAEPAXI@Z			; XStreamRdDirect::`scalar deleting destructor'
; Function compile flags: /Ogty
;	COMDAT ??_GXStreamRdDirect@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_GXStreamRdDirect@@UAEPAXI@Z PROC NEAR		; XStreamRdDirect::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1XStreamRdDirect@@UAE@XZ		; XStreamRdDirect::~XStreamRdDirect
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $L57682
	mov	ecx, esi
	call	@xfree@4
$L57682:
	mov	eax, esi
	pop	esi
	ret	4
??_GXStreamRdDirect@@UAEPAXI@Z ENDP			; XStreamRdDirect::`scalar deleting destructor'
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??1XStreamRdDirect@@UAE@XZ
_TEXT	SEGMENT
??1XStreamRdDirect@@UAE@XZ PROC NEAR			; XStreamRdDirect::~XStreamRdDirect, COMDAT
; _this$ = ecx

; 71   : 	~XStreamRdDirect(void){}

	mov	DWORD PTR [ecx], OFFSET FLAT:??_7XBufferReadInt@@6B@ ; XBufferReadInt::`vftable'
	ret	0
??1XStreamRdDirect@@UAE@XZ ENDP				; XStreamRdDirect::~XStreamRdDirect
_TEXT	ENDS
PUBLIC	??_EXStreamRdDirect@@UAEPAXI@Z			; XStreamRdDirect::`vector deleting destructor'
; Function compile flags: /Ogty
;	COMDAT ??_EXStreamRdDirect@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_EXStreamRdDirect@@UAEPAXI@Z PROC NEAR		; XStreamRdDirect::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebx
	mov	bl, BYTE PTR ___flags$[esp]
	push	esi
	mov	esi, ecx
	test	bl, 2
	je	SHORT $L56163
	mov	eax, DWORD PTR [esi-4]
	push	edi
	lea	edi, DWORD PTR [esi-4]
	push	OFFSET FLAT:??1XStreamRdDirect@@UAE@XZ	; XStreamRdDirect::~XStreamRdDirect
	push	eax
	push	8
	push	esi
	call	??_M@YGXPAXIHP6EX0@Z@Z			; `eh vector destructor iterator'
	test	bl, 1
	je	SHORT $L57693
	mov	ecx, edi
	call	@xfree@4
$L57693:
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	ret	4
$L56163:
	mov	ecx, esi
	call	??1XStreamRdDirect@@UAE@XZ		; XStreamRdDirect::~XStreamRdDirect
	test	bl, 1
	je	SHORT $L57695
	mov	ecx, esi
	call	@xfree@4
$L57695:
	mov	eax, esi
	pop	esi
	pop	ebx
	ret	4
??_EXStreamRdDirect@@UAEPAXI@Z ENDP			; XStreamRdDirect::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??1XStreamWrDirect@@UAE@XZ			; XStreamWrDirect::~XStreamWrDirect
PUBLIC	??_GXStreamWrDirect@@UAEPAXI@Z			; XStreamWrDirect::`scalar deleting destructor'
; Function compile flags: /Ogty
;	COMDAT ??_GXStreamWrDirect@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_GXStreamWrDirect@@UAEPAXI@Z PROC NEAR		; XStreamWrDirect::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1XStreamWrDirect@@UAE@XZ		; XStreamWrDirect::~XStreamWrDirect
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $L57702
	mov	ecx, esi
	call	@xfree@4
$L57702:
	mov	eax, esi
	pop	esi
	ret	4
??_GXStreamWrDirect@@UAEPAXI@Z ENDP			; XStreamWrDirect::`scalar deleting destructor'
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??1XStreamWrDirect@@UAE@XZ
_TEXT	SEGMENT
??1XStreamWrDirect@@UAE@XZ PROC NEAR			; XStreamWrDirect::~XStreamWrDirect, COMDAT
; _this$ = ecx

; 88   : 	~XStreamWrDirect(void){}

	mov	DWORD PTR [ecx], OFFSET FLAT:??_7XBufferWriteInt@@6B@ ; XBufferWriteInt::`vftable'
	ret	0
??1XStreamWrDirect@@UAE@XZ ENDP				; XStreamWrDirect::~XStreamWrDirect
_TEXT	ENDS
PUBLIC	??_EXStreamWrDirect@@UAEPAXI@Z			; XStreamWrDirect::`vector deleting destructor'
; Function compile flags: /Ogty
;	COMDAT ??_EXStreamWrDirect@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_EXStreamWrDirect@@UAEPAXI@Z PROC NEAR		; XStreamWrDirect::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebx
	mov	bl, BYTE PTR ___flags$[esp]
	push	esi
	mov	esi, ecx
	test	bl, 2
	je	SHORT $L56219
	mov	eax, DWORD PTR [esi-4]
	push	edi
	lea	edi, DWORD PTR [esi-4]
	push	OFFSET FLAT:??1XStreamWrDirect@@UAE@XZ	; XStreamWrDirect::~XStreamWrDirect
	push	eax
	push	8
	push	esi
	call	??_M@YGXPAXIHP6EX0@Z@Z			; `eh vector destructor iterator'
	test	bl, 1
	je	SHORT $L57713
	mov	ecx, edi
	call	@xfree@4
$L57713:
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	ret	4
$L56219:
	mov	ecx, esi
	call	??1XStreamWrDirect@@UAE@XZ		; XStreamWrDirect::~XStreamWrDirect
	test	bl, 1
	je	SHORT $L57715
	mov	ecx, esi
	call	@xfree@4
$L57715:
	mov	eax, esi
	pop	esi
	pop	ebx
	ret	4
??_EXStreamWrDirect@@UAEPAXI@Z ENDP			; XStreamWrDirect::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??1XMemRdBuffer@@UAE@XZ				; XMemRdBuffer::~XMemRdBuffer
PUBLIC	??_GXMemRdBuffer@@UAEPAXI@Z			; XMemRdBuffer::`scalar deleting destructor'
; Function compile flags: /Ogty
;	COMDAT ??_GXMemRdBuffer@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_GXMemRdBuffer@@UAEPAXI@Z PROC NEAR			; XMemRdBuffer::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1XMemRdBuffer@@UAE@XZ			; XMemRdBuffer::~XMemRdBuffer
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $L57722
	mov	ecx, esi
	call	@xfree@4
$L57722:
	mov	eax, esi
	pop	esi
	ret	4
??_GXMemRdBuffer@@UAEPAXI@Z ENDP			; XMemRdBuffer::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_7XMemRdBuffer@@6B@				; XMemRdBuffer::`vftable'
PUBLIC	??_EXMemRdBuffer@@UAEPAXI@Z			; XMemRdBuffer::`vector deleting destructor'
EXTRN	?read@XMemRdBuffer@@UAEKPAXKAAK1@Z:NEAR		; XMemRdBuffer::read
EXTRN	?seek@XMemRdBuffer@@UAEKJ@Z:NEAR		; XMemRdBuffer::seek
;	COMDAT ??_7XMemRdBuffer@@6B@
CONST	SEGMENT
??_7XMemRdBuffer@@6B@ DD FLAT:?read_direct@XBufferReadInt@@MAEKPAXKAAK@Z ; XMemRdBuffer::`vftable'
	DD	FLAT:?read@XMemRdBuffer@@UAEKPAXKAAK1@Z
	DD	FLAT:?seek@XMemRdBuffer@@UAEKJ@Z
	DD	FLAT:??_EXMemRdBuffer@@UAEPAXI@Z
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ??1XMemRdBuffer@@UAE@XZ
_TEXT	SEGMENT
??1XMemRdBuffer@@UAE@XZ PROC NEAR			; XMemRdBuffer::~XMemRdBuffer, COMDAT
; _this$ = ecx

; 109  : 	~XMemRdBuffer(void){}

	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET FLAT:??_7XMemRdBuffer@@6B@ ; XMemRdBuffer::`vftable'
	mov	ecx, DWORD PTR [esi+8]
	call	@xfree@4
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi], OFFSET FLAT:??_7XBufferReadInt@@6B@ ; XBufferReadInt::`vftable'
	pop	esi
	ret	0
??1XMemRdBuffer@@UAE@XZ ENDP				; XMemRdBuffer::~XMemRdBuffer
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??_EXMemRdBuffer@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_EXMemRdBuffer@@UAEPAXI@Z PROC NEAR			; XMemRdBuffer::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebx
	mov	bl, BYTE PTR ___flags$[esp]
	push	esi
	mov	esi, ecx
	test	bl, 2
	je	SHORT $L56272
	mov	eax, DWORD PTR [esi-4]
	push	edi
	lea	edi, DWORD PTR [esi-4]
	push	OFFSET FLAT:??1XMemRdBuffer@@UAE@XZ	; XMemRdBuffer::~XMemRdBuffer
	push	eax
	push	24					; 00000018H
	push	esi
	call	??_M@YGXPAXIHP6EX0@Z@Z			; `eh vector destructor iterator'
	test	bl, 1
	je	SHORT $L57738
	mov	ecx, edi
	call	@xfree@4
$L57738:
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	ret	4
$L56272:
	mov	ecx, esi
	call	??1XMemRdBuffer@@UAE@XZ			; XMemRdBuffer::~XMemRdBuffer
	test	bl, 1
	je	SHORT $L57740
	mov	ecx, esi
	call	@xfree@4
$L57740:
	mov	eax, esi
	pop	esi
	pop	ebx
	ret	4
??_EXMemRdBuffer@@UAEPAXI@Z ENDP			; XMemRdBuffer::`vector deleting destructor'
_TEXT	ENDS
END
