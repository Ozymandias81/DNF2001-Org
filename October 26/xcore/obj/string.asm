; Listing generated by Microsoft (R) Optimizing Compiler Version 12.00.8943.0 

	TITLE	C:\duke4\xcore\string.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0BF@MBIJ@Cannot?5init?5CPrintfT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
drectve	SEGMENT DWORD USE32 PUBLIC ''
drectve	ENDS
;	COMDAT ??0?$XChain@VXStatistic@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?get_head@?$XList@VXStatistic@@@@QAEPAVXStatistic@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$XChain@VCSysObj@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$XChain@VCSysObj@@@@QAE@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?get_next@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?get_prev@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?get_head@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?get_tail@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$XChain@VXStatistic@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?free_list@?$XChain@VXStatistic@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$XList@VXStatistic@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$XList@VXStatistic@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?free_list@?$XList@VXStatistic@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?add_head@?$XList@VXStatistic@@@@QAEPAU_XPos@@PAVXStatistic@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?remove_head@?$XList@VXStatistic@@@@QAEPAVXStatistic@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$XChain@VCSysObj@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lose_list@?$XChain@VCSysObj@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?free_list@?$XChain@VCSysObj@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?add_head@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?add_tail@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?remove_head@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?remove_tail@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?remove@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$XList@PAX@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$XRcBase@VCStrObj@@@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$XRcBase@VCStrObj@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$XRcBase@VCStrObj@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DelRef@?$XRcBase@VCStrObj@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$XRcBase@VCStrObj@@@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$XRcPtr@VCPathObj@@@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$XRcPtr@VCPathObj@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$XRcPtr@VCPathObj@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddRef@?$XRcPtr@VCPathObj@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DelRef@?$XRcPtr@VCPathObj@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$XRcPtr@VCPathObj@@@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$XList@VXFindLevel@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$XList@VXFindLevel@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCSysObj@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCStrObj@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCPathObj@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GXFindLevel@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?new_node@?$XList@VXStatistic@@@@IAEPAUXNode@1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?free_nodes@?$XList@VXStatistic@@@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?free_nodes@?$XList@PAX@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?free_nodes@?$XList@VXFindLevel@@@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddRef@?$XRcBase@VCStrObj@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GXStreamWrDirect@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1XStreamWrDirect@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7XStreamWrDirect@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??1XBufferWriteInt@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7XBufferWriteInt@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??3XStreamWrDirect@@SAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_EXStreamWrDirect@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?flush@XStreamWrDirect@@UAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?seek@XStreamWrDirect@@UAEKJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GXStreamRdDirect@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1XStreamRdDirect@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7XStreamRdDirect@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??1XBufferReadInt@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7XBufferReadInt@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??3XStreamRdDirect@@SAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_EXStreamRdDirect@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?seek@XStreamRdDirect@@UAEKJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?base_init@XFile@@EAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4autochar@@QAEAAV0@PAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GXBufferWriteInt@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_EXBufferWriteInt@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GXBufferReadInt@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_EXBufferReadInt@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pos_wr@CBaseStream@@UAEXKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pos_rd@CBaseStream@@UAEXKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?put@CBaseStream@@UAEKD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ioctl_write@CBaseStream@@UAEKKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ioctl_read@CBaseStream@@UAEKKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?seek_int@CBaseStream@@MAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GXMemRdBuffer@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1XMemRdBuffer@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7XMemRdBuffer@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??1autochar@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3XMemRdBuffer@@SAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_EXMemRdBuffer@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1XFindLevel@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CStrObj@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CSysObj@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CSysObj@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??0XListState@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3XStatistic@@SAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0XChainState@@QAE@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0XChainState@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?realloc@StrGrow@@IAEXKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?init@MemGrow@@QAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?set_cur@TmpPrintf@@QAEPADPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?set_cur@CPrintf@@QAEPADPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?get_cur@TmpPrintf@@QAEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6CPrintf@@QAEAAV0@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?get_cur@CPrintf@@QAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6CPrintf@@QAEAAV0@D@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CPrintf@@QAE@PADKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CPathObj@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3@YAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?get_str@TmpPrintf@@QAEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?get_str@CPrintf@@QAEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?get_len@TmpPrintf@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?get_len@CPrintf@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6TmpPrintf@@QAEAAV0@D@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?get_last@TmpPrintf@@QAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?get_last@CPrintf@@QAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6TmpPrintf@@QAEAAV0@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?str@CPrintf@@QAEKPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1TmpPrintf@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0TmpPrintf@@QAE@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1XFile@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7XFile@@6BCBaseStream@@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7XFile@@6BCSysObj@@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??1CBaseStream@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CBaseStream@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?is_open@CBaseStream@@IAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3CStrObj@@SAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2CStrObj@@SAPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0XRef@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
FLAT	GROUP _DATA, CONST, _BSS, drectve
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

drectve	SEGMENT
$SG56785 DB	'-INCLUDE:___@@_PchSym_@00@UwfpvEUcxlivUlyqUhgwxlivOlyq@', 00H
drectve	ENDS
PUBLIC	@fitoa@8
; Function compile flags: /Ogty
; File C:\duke4\xcore\string.cpp
_TEXT	SEGMENT
_stack$ = -12
@fitoa@8 PROC NEAR
; _val$ = ecx
; _str$ = edx

; 8    : {

	sub	esp, 12					; 0000000cH
	mov	eax, ecx

; 9    : 	U8 stack[12];
; 10   : 	U8 *cur=stack;
; 11   : 	char *base=str;
; 12   : 
; 13   : 	if (val&0x80000000)

	test	eax, eax
	push	esi
	mov	esi, edx
	push	edi
	lea	ecx, DWORD PTR _stack$[esp+20]
	mov	edi, esi
	jns	SHORT $L58063

; 14   : 	{
; 15   : 		val=-val;

	neg	eax

; 16   : 		*str++='-';

	mov	BYTE PTR [esi], 45			; 0000002dH
	inc	esi
$L58063:
	push	ebx
$L57145:

; 17   : 	}
; 18   : 	do
; 19   : 	{
; 20   : 		U32 digit;
; 21   : 
; 22   : 		digit=(val%10) + '0';

	cdq
	mov	ebx, 10					; 0000000aH
	idiv	ebx
	add	edx, 48					; 00000030H

; 23   : 		val/=10;
; 24   : 		*cur++=(U8)digit;

	mov	BYTE PTR [ecx], dl
	inc	ecx

; 25   : 	}while(val);

	test	eax, eax
	jne	SHORT $L57145
	pop	ebx
$L57150:

; 26   : 	/* reverse out */
; 27   : 	do
; 28   : 	{
; 29   : 		*str++=(char)(*(--cur));

	mov	al, BYTE PTR [ecx-1]
	dec	ecx
	mov	BYTE PTR [esi], al

; 30   : 	}while(stack!=cur);

	lea	edx, DWORD PTR _stack$[esp+20]
	inc	esi
	cmp	ecx, edx
	jne	SHORT $L57150

; 31   : 	/* end string */
; 32   : 	str[0]=0;
; 33   : 
; 34   : 	/* return number of characters */
; 35   : 	return ((U32)(str - base));

	mov	eax, esi
	mov	BYTE PTR [esi], 0
	sub	eax, edi
	pop	edi
	pop	esi

; 36   : }

	add	esp, 12					; 0000000cH
	ret	0
@fitoa@8 ENDP
_TEXT	ENDS
PUBLIC	@futoa@8
; Function compile flags: /Ogty
_TEXT	SEGMENT
_stack$ = -12
@futoa@8 PROC NEAR
; _val$ = ecx
; _str$ = edx

; 39   : {

	sub	esp, 12					; 0000000cH
	mov	eax, ecx

; 40   : 	U8 stack[12];
; 41   : 	U8 *cur=stack;

	lea	ecx, DWORD PTR _stack$[esp+12]
	push	esi
	mov	esi, edx
	push	edi

; 42   : 	char *base=str;

	mov	edi, esi
	push	ebx
$L57162:

; 43   : 
; 44   : 	do
; 45   : 	{
; 46   : 		U32 digit;
; 47   : 
; 48   : 		digit=(val%10) + '0';

	xor	edx, edx
	mov	ebx, 10					; 0000000aH
	div	ebx
	add	edx, 48					; 00000030H

; 49   : 		val/=10;
; 50   : 		*cur++=(U8)digit;

	mov	BYTE PTR [ecx], dl
	inc	ecx

; 51   : 	}while(val);

	test	eax, eax
	jne	SHORT $L57162
	pop	ebx
$L57167:

; 52   : 	/* reverse out */
; 53   : 	do
; 54   : 	{
; 55   : 		*str++=(char)(*(--cur));

	mov	al, BYTE PTR [ecx-1]
	dec	ecx
	mov	BYTE PTR [esi], al

; 56   : 	}while(stack!=cur);

	lea	edx, DWORD PTR _stack$[esp+20]
	inc	esi
	cmp	ecx, edx
	jne	SHORT $L57167

; 57   : 	/* end string */
; 58   : 	str[0]=0;
; 59   : 
; 60   : 	/* return number of characters */
; 61   : 	return ((U32)(str - base));

	mov	eax, esi
	mov	BYTE PTR [esi], 0
	sub	eax, edi
	pop	edi
	pop	esi

; 62   : }

	add	esp, 12					; 0000000cH
	ret	0
@futoa@8 ENDP
_TEXT	ENDS
PUBLIC	@fscan_f@12
; Function compile flags: /Ogty
_TEXT	SEGMENT
_flags$ = 8
@fscan_f@12 PROC NEAR
; _text$ = ecx
; _flag_list$ = edx

; 65   : {

	push	ebx
	push	esi
	push	edi

; 66   :    U8 *src=(U8 *)(*text);

	mov	edi, DWORD PTR [ecx]

; 67   :    U32 key;
; 68   : 
; 69   :    while(key=*src++)

	xor	ecx, ecx
	mov	esi, edx
	movsx	eax, BYTE PTR [edi]
	mov	cl, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $L58074
	mov	dl, BYTE PTR _flags$[esp+8]
$L57181:

; 70   :    {
; 71   :       if (flag_list[key] & flags)

	mov	bl, BYTE PTR [ecx+esi]
	inc	eax
	test	bl, dl
	jne	SHORT $L58073
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $L57181
$L58074:

; 67   :    U32 key;
; 68   : 
; 69   :    while(key=*src++)

	inc	eax

; 74   :          return ((CC8P)src);
; 75   :       }
; 76   :    }
; 77   :    *((U8 **)text)=src;

	mov	DWORD PTR [edi], eax
	pop	edi
	pop	esi

; 78   :    return null;

	xor	eax, eax
	pop	ebx

; 79   : }

	ret	4
$L58073:

; 72   :       {
; 73   :          *((U8 **)text)=(--src);

	dec	eax
	mov	DWORD PTR [edi], eax
	pop	edi
	pop	esi
	pop	ebx

; 79   : }

	ret	4
@fscan_f@12 ENDP
_TEXT	ENDS
PUBLIC	@fscan_nf@12
; Function compile flags: /Ogty
_TEXT	SEGMENT
_flags$ = 8
@fscan_nf@12 PROC NEAR
; _text$ = ecx
; _flag_list$ = edx

; 82   : {

	push	ebx
	push	esi
	push	edi

; 83   :    U8 *src=(U8 *)(*text);

	mov	edi, DWORD PTR [ecx]

; 84   :    U32 key;
; 85   : 
; 86   :    while(key=*src++)

	xor	ecx, ecx
	mov	esi, edx
	movsx	eax, BYTE PTR [edi]
	mov	cl, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $L58078
	mov	dl, BYTE PTR _flags$[esp+8]
$L57196:

; 87   :    {
; 88   :       if (!(flag_list[key] & flags))

	mov	bl, BYTE PTR [ecx+esi]
	inc	eax
	test	bl, dl
	je	SHORT $L58077
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $L57196
$L58078:

; 84   :    U32 key;
; 85   : 
; 86   :    while(key=*src++)

	inc	eax

; 91   :          return ((CC8P)src);
; 92   :       }
; 93   :    }
; 94   :    *((U8 **)text)=src;

	mov	DWORD PTR [edi], eax
	pop	edi
	pop	esi

; 95   :    return null;

	xor	eax, eax
	pop	ebx

; 96   : }

	ret	4
$L58077:

; 89   :       {
; 90   :          *((U8 **)text)=(--src);

	dec	eax
	mov	DWORD PTR [edi], eax
	pop	edi
	pop	esi
	pop	ebx

; 96   : }

	ret	4
@fscan_nf@12 ENDP
_TEXT	ENDS
PUBLIC	??0CStr@@QAE@PBDK@Z				; CStr::CStr
EXTRN	@xmalloc@4:NEAR
; Function compile flags: /Ogty
_TEXT	SEGMENT
_Str$ = 8
_Size$ = 12
??0CStr@@QAE@PBDK@Z PROC NEAR				; CStr::CStr
; _this$ = ecx

; 99   : {

	mov	eax, DWORD PTR _Size$[esp-4]
	push	ebx
	mov	ebx, ecx
	push	esi
	push	edi

; 100  : 	str=(char *)xmalloc(size+1);

	lea	ecx, DWORD PTR [eax+1]
	mov	DWORD PTR [ebx], eax
	call	@xmalloc@4

; 101  : 	memcpy(str,Str,size);

	mov	ecx, DWORD PTR [ebx]
	mov	esi, DWORD PTR _Str$[esp+8]
	mov	DWORD PTR [ebx+4], eax
	mov	edi, eax
	mov	eax, ecx
	shr	ecx, 2
	rep movsd
	mov	ecx, eax

; 102  : 	str[size]=0;
; 103  : }

	mov	eax, ebx
	and	ecx, 3
	rep movsb
	mov	ecx, DWORD PTR [ebx+4]
	mov	edx, DWORD PTR [ebx]
	pop	edi
	pop	esi
	mov	BYTE PTR [ecx+edx], 0
	pop	ebx
	ret	8
??0CStr@@QAE@PBDK@Z ENDP				; CStr::CStr
_TEXT	ENDS
PUBLIC	??0CStr@@QAE@PBD@Z				; CStr::CStr
; Function compile flags: /Ogty
_TEXT	SEGMENT
_Str$ = 8
??0CStr@@QAE@PBD@Z PROC NEAR				; CStr::CStr
; _this$ = ecx

; 106  : {

	push	ebx
	push	esi

; 107  : 	size=strlen(Str);

	mov	esi, DWORD PTR _Str$[esp+4]
	push	edi
	mov	ebx, ecx
	mov	edi, esi
	or	ecx, -1
	xor	eax, eax
	repne scasb
	not	ecx
	dec	ecx
	mov	DWORD PTR [ebx], ecx

; 108  : 	str=(char *)xmalloc(size+1);

	inc	ecx
	call	@xmalloc@4

; 109  : 	memcpy(str,Str,size+1);

	mov	ecx, DWORD PTR [ebx]
	mov	DWORD PTR [ebx+4], eax
	inc	ecx
	mov	edi, eax
	mov	eax, ecx
	shr	ecx, 2
	rep movsd
	mov	ecx, eax

; 110  : }

	mov	eax, ebx
	and	ecx, 3
	rep movsb
	pop	edi
	pop	esi
	pop	ebx
	ret	4
??0CStr@@QAE@PBD@Z ENDP					; CStr::CStr
_TEXT	ENDS
PUBLIC	??0CStrLow@@QAE@PBDK@Z				; CStrLow::CStrLow
PUBLIC	@fstrncpy_tolower@12
; Function compile flags: /Ogty
_TEXT	SEGMENT
_Str$ = 8
_Size$ = 12
??0CStrLow@@QAE@PBDK@Z PROC NEAR			; CStrLow::CStrLow
; _this$ = ecx

; 113  : {

	mov	eax, DWORD PTR _Size$[esp-4]
	push	esi
	mov	esi, ecx

; 114  : 	str=(char *)xmalloc(size+1);

	lea	ecx, DWORD PTR [eax+1]
	mov	DWORD PTR [esi], eax
	call	@xmalloc@4

; 115  : 	fstrncpy_tolower(str,Str,size+1);

	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR _Str$[esp]
	inc	ecx
	mov	DWORD PTR [esi+4], eax
	push	ecx
	mov	ecx, eax
	call	@fstrncpy_tolower@12

; 116  : }

	mov	eax, esi
	pop	esi
	ret	8
??0CStrLow@@QAE@PBDK@Z ENDP				; CStrLow::CStrLow
_TEXT	ENDS
PUBLIC	??0CStrLow@@QAE@PBD@Z				; CStrLow::CStrLow
; Function compile flags: /Ogty
_TEXT	SEGMENT
_Str$ = 8
??0CStrLow@@QAE@PBD@Z PROC NEAR				; CStrLow::CStrLow
; _this$ = ecx

; 119  : {

	push	ebx

; 120  : 	size=strlen(Str);

	mov	ebx, DWORD PTR _Str$[esp]
	push	esi
	push	edi
	mov	esi, ecx
	mov	edi, ebx
	or	ecx, -1
	xor	eax, eax
	repne scasb
	not	ecx
	dec	ecx
	mov	DWORD PTR [esi], ecx

; 121  : 	str=(char *)xmalloc(size+1);

	inc	ecx
	call	@xmalloc@4

; 122  : 	fstrncpy_tolower(str,Str,size+1);

	mov	ecx, DWORD PTR [esi]
	mov	edx, ebx
	inc	ecx
	mov	DWORD PTR [esi+4], eax
	push	ecx
	mov	ecx, eax
	call	@fstrncpy_tolower@12

; 123  : }

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx
	ret	4
??0CStrLow@@QAE@PBD@Z ENDP				; CStrLow::CStrLow
_TEXT	ENDS
PUBLIC	??0CStrCat@@QAE@PBD0@Z				; CStrCat::CStrCat
; Function compile flags: /Ogty
_TEXT	SEGMENT
_str1$ = 8
_str2$ = 12
_len2$ = 8
??0CStrCat@@QAE@PBD0@Z PROC NEAR			; CStrCat::CStrCat
; _this$ = ecx

; 126  : {

	push	ebx
	push	ebp
	push	esi

; 127  : 	U32 len1=strlen(str1);

	mov	esi, DWORD PTR _str1$[esp+8]
	push	edi
	mov	ebx, ecx
	mov	edi, esi
	or	ecx, -1
	xor	eax, eax
	repne scasb

; 128  : 	U32 len2=strlen(str2);

	mov	edi, DWORD PTR _str2$[esp+12]
	not	ecx
	dec	ecx
	mov	ebp, ecx
	or	ecx, -1
	repne scasb
	not	ecx
	dec	ecx
	mov	DWORD PTR _len2$[esp+12], ecx

; 129  : 
; 130  : 	size=len1+len2;

	lea	eax, DWORD PTR [ecx+ebp]
	mov	DWORD PTR [ebx], eax

; 131  : 
; 132  : 	str=(char *)xmalloc(size+1);

	lea	ecx, DWORD PTR [eax+1]
	call	@xmalloc@4

; 133  : 	memcpy(str,str1,len1);

	mov	ecx, ebp
	mov	DWORD PTR [ebx+4], eax
	mov	edi, eax
	mov	eax, ecx
	shr	ecx, 2
	rep movsd
	mov	ecx, eax

; 134  : 	memcpy(str+len1,str2,len2+1);
; 135  : }

	mov	eax, ebx
	and	ecx, 3
	rep movsb
	mov	ecx, DWORD PTR _len2$[esp+12]
	mov	edi, DWORD PTR [ebx+4]
	mov	esi, DWORD PTR _str2$[esp+12]
	inc	ecx
	mov	edx, ecx
	add	edi, ebp
	shr	ecx, 2
	rep movsd
	mov	ecx, edx
	and	ecx, 3
	rep movsb
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	8
??0CStrCat@@QAE@PBD0@Z ENDP				; CStrCat::CStrCat
_TEXT	ENDS
PUBLIC	@fstreq@8
; Function compile flags: /Ogty
_TEXT	SEGMENT
@fstreq@8 PROC NEAR
; _str1$ = ecx
; _str2$ = edx

; 138  : {

	push	ebx
	push	esi
	mov	eax, ecx

; 139  : 	if (strcmp(str1,str2)==0)

	mov	esi, edx
$L58085:
	mov	dl, BYTE PTR [eax]
	mov	bl, BYTE PTR [esi]
	mov	cl, dl
	cmp	dl, bl
	jne	SHORT $L58086
	test	cl, cl
	je	SHORT $L58087
	mov	dl, BYTE PTR [eax+1]
	mov	bl, BYTE PTR [esi+1]
	mov	cl, dl
	cmp	dl, bl
	jne	SHORT $L58086
	add	eax, 2
	add	esi, 2
	test	cl, cl
	jne	SHORT $L58085
$L58087:
	xor	eax, eax
	xor	ecx, ecx
	test	eax, eax
	sete	cl
	pop	esi
	mov	eax, ecx
	pop	ebx

; 140  : 		return TRUE;
; 141  : 	return FALSE;
; 142  : }

	ret	0
$L58086:

; 139  : 	if (strcmp(str1,str2)==0)

	sbb	eax, eax
	pop	esi
	sbb	eax, -1
	xor	ecx, ecx
	test	eax, eax
	sete	cl
	mov	eax, ecx
	pop	ebx

; 140  : 		return TRUE;
; 141  : 	return FALSE;
; 142  : }

	ret	0
@fstreq@8 ENDP
_TEXT	ENDS
PUBLIC	@fstrexp_eq@8
; Function compile flags: /Ogty
_TEXT	SEGMENT
@fstrexp_eq@8 PROC NEAR
; _exp$ = ecx
; _str$ = edx

; 145  : {

	push	esi
$L57242:

; 146  : 	D_ASSERT(exp);D_ASSERT(str);
; 147  : 
; 148  : 	while(1)
; 149  : 	{
; 150  : 		U32 key1,key2;
; 151  : 
; 152  : 		key1=*exp++;
; 153  : 		key2=*str++;

	movsx	esi, BYTE PTR [edx]
	movsx	eax, BYTE PTR [ecx]
	inc	ecx
	inc	edx

; 154  : 
; 155  : 		if ((!key2)||(!key1))

	test	esi, esi
	je	SHORT $L57247
	test	eax, eax
	je	SHORT $L57249

; 162  : 		}
; 163  : 
; 164  : 		/* if in wildcard */
; 165  : 		if (key1=='*')

	cmp	eax, 42					; 0000002aH
	jne	SHORT $L58093
$L57252:

; 166  : 		{
; 167  : 			/* advance key1 to non-wildcard */
; 168  : 			while(1)
; 169  : 			{
; 170  : 				key1=*exp++;

	movsx	eax, BYTE PTR [ecx]
	inc	ecx

; 171  : 				if (!key1)

	test	eax, eax
	je	SHORT $L58092

; 172  : 					return TRUE;
; 173  : 				if (key1!='*')

	cmp	eax, 42					; 0000002aH
	je	SHORT $L57252
$L58093:

; 174  : 					break;
; 175  : 			}
; 176  : 		}
; 177  : 		if (key1!=key2)

	cmp	eax, esi
	je	SHORT $L57242
$L57249:

; 161  : 			return FALSE;

	xor	eax, eax
	pop	esi

; 178  : 			return FALSE;
; 179  : 	}
; 180  : 	return TRUE;
; 181  : }

	ret	0
$L57247:

; 156  : 		{
; 157  : 			if ((!key1) && (!key2))

	test	eax, eax
	jne	SHORT $L57248

; 158  : 				return TRUE;

	mov	eax, 1
	pop	esi

; 178  : 			return FALSE;
; 179  : 	}
; 180  : 	return TRUE;
; 181  : }

	ret	0
$L57248:

; 159  : 			if (key1=='*')

	cmp	eax, 42					; 0000002aH
	jne	SHORT $L57249
$L58092:

; 160  : 				return TRUE;

	mov	eax, 1
	pop	esi

; 178  : 			return FALSE;
; 179  : 	}
; 180  : 	return TRUE;
; 181  : }

	ret	0
@fstrexp_eq@8 ENDP
_TEXT	ENDS
PUBLIC	@fstrneq@12
; Function compile flags: /Ogty
_TEXT	SEGMENT
_size$ = 8
@fstrneq@12 PROC NEAR
; _str1$ = ecx
; _str2$ = edx

; 184  : {

	push	esi
	push	edi

; 185  : 	while(size--)

	mov	edi, DWORD PTR _size$[esp+4]
	test	edi, edi
	je	SHORT $L58102
$L57263:

; 186  : 	{
; 187  : 		U32 key1=*str1++;

	movsx	eax, BYTE PTR [ecx]

; 188  : 		U32 key2=*str2++;

	movsx	esi, BYTE PTR [edx]
	dec	edi
	inc	ecx
	inc	edx

; 189  : 		if (key1!=key2)

	cmp	eax, esi
	jne	SHORT $L58100

; 191  : 		if (!key1)

	test	eax, eax
	je	SHORT $L58102

; 185  : 	while(size--)

	test	edi, edi
	jne	SHORT $L57263
$L58102:
	pop	edi

; 192  : 			return TRUE;
; 193  : 	}
; 194  : 	return TRUE;

	mov	eax, 1
	pop	esi

; 195  : }

	ret	4
$L58100:
	pop	edi

; 190  : 			return FALSE;

	xor	eax, eax
	pop	esi

; 195  : }

	ret	4
@fstrneq@12 ENDP
_TEXT	ENDS
PUBLIC	@fstrchr@8
; Function compile flags: /Ogty
_TEXT	SEGMENT
@fstrchr@8 PROC NEAR
; _str$ = ecx
; _key$ = dl

; 200  : 	U32 val;
; 201  : 
; 202  : 	while(val=*str++)

	movsx	eax, BYTE PTR [ecx]
	test	eax, eax
	je	SHORT $L58106
	movsx	edx, dl
$L57275:
	inc	ecx

; 203  : 	{
; 204  : 		if (val==(U32)key)

	cmp	eax, edx
	je	SHORT $L58105
	movsx	eax, BYTE PTR [ecx]
	test	eax, eax
	jne	SHORT $L57275
$L58106:

; 206  : 	}
; 207  : 	return null;

	xor	eax, eax

; 208  : }

	ret	0
$L58105:

; 205  : 			return (char *)str-1;

	lea	eax, DWORD PTR [ecx-1]

; 208  : }

	ret	0
@fstrchr@8 ENDP
_TEXT	ENDS
PUBLIC	??2@YAPAXI@Z					; operator new
; Function compile flags: /Ogty
; File C:\duke4\xcore\xcore.h
;	COMDAT ??2@YAPAXI@Z
_TEXT	SEGMENT
_size$ = 8
??2@YAPAXI@Z PROC NEAR					; operator new, COMDAT

; 129  : __inline void *operator new(size_t size){return xmalloc(size);}

	mov	ecx, DWORD PTR _size$[esp-4]
	jmp	@xmalloc@4
??2@YAPAXI@Z ENDP					; operator new
_TEXT	ENDS
PUBLIC	@fstrcpy@8
; Function compile flags: /Ogty
; File C:\duke4\xcore\string.cpp
_TEXT	SEGMENT
@fstrcpy@8 PROC NEAR
; _dst$ = ecx
; _src$ = edx

; 211  : {

	push	ebx

; 212  : 	U8 key;
; 213  : 	
; 214  : 	while(key=*src++)

	mov	bl, BYTE PTR [edx]
	test	bl, bl
	mov	eax, ecx
	je	SHORT $L58114
$L57286:
	inc	edx

; 215  : 		*dst++=key;

	mov	BYTE PTR [eax], bl
	inc	eax
	mov	bl, BYTE PTR [edx]
	test	bl, bl
	jne	SHORT $L57286
$L58114:

; 216  : 	
; 217  : 	dst[0]=0;

	mov	BYTE PTR [eax], 0
	pop	ebx

; 218  : 	return dst;
; 219  : }

	ret	0
@fstrcpy@8 ENDP
_TEXT	ENDS
PUBLIC	??3@YAXPAX@Z					; operator delete
EXTRN	@xfree@4:NEAR
; Function compile flags: /Ogty
; File C:\duke4\xcore\xcore.h
;	COMDAT ??3@YAXPAX@Z
_TEXT	SEGMENT
_ptr$ = 8
??3@YAXPAX@Z PROC NEAR					; operator delete, COMDAT

; 130  : __inline void operator delete(void *ptr){xfree(ptr);}

	mov	ecx, DWORD PTR _ptr$[esp-4]
	jmp	@xfree@4
??3@YAXPAX@Z ENDP					; operator delete
_TEXT	ENDS
PUBLIC	@fstrncpy@12
; Function compile flags: /Ogty
; File C:\duke4\xcore\string.cpp
_TEXT	SEGMENT
_size$ = 8
@fstrncpy@12 PROC NEAR
; _dst$ = ecx
; _src$ = edx

; 223  : {

	push	esi
	push	edi

; 224  : 	U32 i;
; 225  : 
; 226  : 	if (size==0)

	mov	edi, DWORD PTR _size$[esp+4]
	test	edi, edi
	jne	SHORT $L57294
	pop	edi

; 227  : 		return 0;

	xor	eax, eax
	pop	esi

; 237  : }

	ret	4
$L57294:

; 228  : 
; 229  : 	for(i=0;i<size;i++)

	xor	esi, esi
	test	edi, edi
	jbe	SHORT $L57297
$L57295:

; 230  : 	{
; 231  : 		*dst++=*src++;

	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx], al

; 232  : 		if (src[-1]==0)

	mov	al, BYTE PTR [edx]
	inc	ecx
	inc	edx
	test	al, al
	je	SHORT $L58119
	inc	esi
	cmp	esi, edi
	jb	SHORT $L57295
$L57297:

; 234  : 	}
; 235  : 	dst[-1]=0;
; 236  : 	return (i-1);

	lea	eax, DWORD PTR [esi-1]
	pop	edi
	mov	BYTE PTR [ecx-1], 0
	pop	esi

; 237  : }

	ret	4
$L58119:

; 233  : 			return i;

	mov	eax, esi
	pop	edi
	pop	esi

; 237  : }

	ret	4
@fstrncpy@12 ENDP
_TEXT	ENDS
PUBLIC	@fstrcpy_tolower@8
EXTRN	?_app_char_flags@@3QBEB:BYTE			; _app_char_flags
; Function compile flags: /Ogty
_TEXT	SEGMENT
_key$ = -4
@fstrcpy_tolower@8 PROC NEAR
; _dst$ = ecx
; _src$ = edx

; 240  : {

	push	ecx
	push	ebx
	push	esi
	mov	esi, edx
	mov	eax, ecx

; 241  : 	U8 key;
; 242  : 	
; 243  : 	while(key=*src++)

	mov	bl, BYTE PTR [esi]
	test	bl, bl
	mov	BYTE PTR _key$[esp+12], bl
	je	SHORT $L58125
$L57305:

; 244  : 		*dst++=fsetlower(key);

	mov	ecx, DWORD PTR _key$[esp+12]
	inc	esi
	and	ecx, 255				; 000000ffH
	mov	dl, BYTE PTR ?_app_char_flags@@3QBEB[ecx]
	and	dl, 32					; 00000020H
	add	dl, bl
	mov	BYTE PTR [eax], dl
	mov	bl, BYTE PTR [esi]
	inc	eax
	mov	BYTE PTR _key$[esp+12], bl
	test	bl, bl
	jne	SHORT $L57305
$L58125:
	pop	esi

; 245  : 	
; 246  : 	dst[0]=0;

	mov	BYTE PTR [eax], 0
	pop	ebx

; 247  : 	return dst;
; 248  : }

	pop	ecx
	ret	0
@fstrcpy_tolower@8 ENDP
; Function compile flags: /Ogty
_size$ = 8
@fstrncpy_tolower@12 PROC NEAR
; _dst$ = ecx
; _src$ = edx

; 252  : {

	push	ebx
	push	esi
	push	edi

; 253  : 	U32 i;
; 254  : 
; 255  : 	if (size==0)

	mov	edi, DWORD PTR _size$[esp+8]
	test	edi, edi
	jne	SHORT $L57314
	pop	edi
	pop	esi

; 256  : 		return 0;

	xor	eax, eax
	pop	ebx

; 267  : }

	ret	4
$L57314:

; 257  : 
; 258  : 	for(i=0;i<size;i++)

	xor	esi, esi
	test	edi, edi
	jbe	SHORT $L57317
$L57315:

; 259  : 	{
; 260  : 		U8 key=fsetlower(*src);src++;

	mov	al, BYTE PTR [edx]
	mov	ebx, eax
	and	ebx, 255				; 000000ffH
	mov	bl, BYTE PTR ?_app_char_flags@@3QBEB[ebx]
	and	bl, 32					; 00000020H
	add	bl, al
	inc	edx

; 261  : 		*dst++=key;

	mov	BYTE PTR [ecx], bl
	inc	ecx

; 262  : 		if (key==0)

	test	bl, bl
	je	SHORT $L58128
	inc	esi
	cmp	esi, edi
	jb	SHORT $L57315
$L57317:

; 264  : 	}
; 265  : 	dst[-1]=0;
; 266  : 	return (i-1);

	lea	eax, DWORD PTR [esi-1]
	pop	edi
	pop	esi
	mov	BYTE PTR [ecx-1], 0
	pop	ebx

; 267  : }

	ret	4
$L58128:

; 263  : 			return i;

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx

; 267  : }

	ret	4
@fstrncpy_tolower@12 ENDP
_TEXT	ENDS
PUBLIC	@fstrnrchr@12
; Function compile flags: /Ogty
_TEXT	SEGMENT
_size$ = 8
@fstrnrchr@12 PROC NEAR
; _text$ = ecx
; _key$ = edx

; 271  :    U8 *src=(U8 *)text;
; 272  : 
; 273  :    while(((I32)(size--))>0)

	mov	eax, DWORD PTR _size$[esp-4]
	push	esi
	test	eax, eax
	mov	esi, edx
	jle	SHORT $L58133
$L57329:

; 274  :    {
; 275  :       if (((U32)(*src--))==key)

	xor	edx, edx
	dec	eax
	mov	dl, BYTE PTR [ecx]
	dec	ecx
	cmp	edx, esi
	je	SHORT $L58132

; 271  :    U8 *src=(U8 *)text;
; 272  : 
; 273  :    while(((I32)(size--))>0)

	test	eax, eax
	jg	SHORT $L57329
$L58133:

; 277  :    }
; 278  :    return null;

	xor	eax, eax
	pop	esi

; 279  : }

	ret	4
$L58132:

; 276  :          return ((CC8P)(src + 1));

	lea	eax, DWORD PTR [ecx+1]
	pop	esi

; 279  : }

	ret	4
@fstrnrchr@12 ENDP
_TEXT	ENDS
PUBLIC	@fstrprchr@12
; Function compile flags: /Ogty
_TEXT	SEGMENT
_end$ = 8
@fstrprchr@12 PROC NEAR
; _text$ = ecx
; _key$ = edx

; 282  : {

	push	esi
	mov	esi, edx

; 283  :    U8 *src=(U8 *)text;
; 284  :    I32 size=text - end;

	mov	edx, DWORD PTR _end$[esp]
	mov	eax, ecx
	sub	eax, edx

; 285  :    
; 286  :    D_ASSERT(size>0);
; 287  : 
; 288  :    while((size--)>0)

	test	eax, eax
	jle	SHORT $L58137
$L57344:

; 289  :    {
; 290  :       if (((U32)(*src--))==key)

	xor	edx, edx
	mov	dl, BYTE PTR [ecx]
	dec	ecx
	dec	eax
	cmp	edx, esi
	je	SHORT $L58136

; 285  :    
; 286  :    D_ASSERT(size>0);
; 287  : 
; 288  :    while((size--)>0)

	test	eax, eax
	jg	SHORT $L57344
$L58137:

; 292  :    }
; 293  :    return null;

	xor	eax, eax
	pop	esi

; 294  : }

	ret	4
$L58136:

; 291  :          return ((CC8P)(src + 1));

	lea	eax, DWORD PTR [ecx+1]
	pop	esi

; 294  : }

	ret	4
@fstrprchr@12 ENDP
_TEXT	ENDS
PUBLIC	@hex32@8
; Function compile flags: /Ogty
_TEXT	SEGMENT
_stack$ = -12
@hex32@8 PROC NEAR
; _val$ = ecx
; _ptr$ = edx

; 297  : {

	sub	esp, 12					; 0000000cH
	mov	eax, edx

; 298  :    char stack[12];
; 299  :    char *cur,*base=ptr;
; 300  : 
; 301  :    cur=stack;
; 302  :    while(val)

	test	ecx, ecx
	push	esi
	lea	esi, DWORD PTR _stack$[esp+16]
	je	SHORT $L57364
	push	ebx
$L57357:

; 303  :    {
; 304  :       U32 nibble;
; 305  : 
; 306  :       nibble=(val&0xF);

	mov	ebx, ecx
	and	ebx, 15					; 0000000fH

; 307  :       if (nibble<0xA)

	cmp	ebx, 10					; 0000000aH
	jae	SHORT $L57360

; 308  :          *cur++=(char)(nibble+48);

	add	bl, 48					; 00000030H

; 309  :       else

	jmp	SHORT $L58143
$L57360:

; 310  :          *cur++=(char)(nibble+55);

	add	bl, 55					; 00000037H
$L58143:
	mov	BYTE PTR [esi], bl
	inc	esi

; 311  :       val>>=4;

	shr	ecx, 4
	jne	SHORT $L57357
	pop	ebx
$L57364:

; 312  :    }
; 313  :    do
; 314  :    {
; 315  :       *ptr++=(char)(*(--cur));

	mov	cl, BYTE PTR [esi-1]
	dec	esi
	mov	BYTE PTR [eax], cl

; 316  :    }while(stack!=cur);

	lea	ecx, DWORD PTR _stack$[esp+16]
	inc	eax
	cmp	esi, ecx
	jne	SHORT $L57364

; 317  :    ptr[0]=0;

	mov	BYTE PTR [eax], 0

; 318  :    return ptr - base;

	sub	eax, edx
	pop	esi

; 319  : }

	add	esp, 12					; 0000000cH
	ret	0
@hex32@8 ENDP
_TEXT	ENDS
PUBLIC	_hex64
; Function compile flags: /Ogty
_TEXT	SEGMENT
_val$ = 8
_ptr$ = 16
_stack$ = -20
_hex64	PROC NEAR

; 322  : {

	sub	esp, 20					; 00000014H

; 323  :    char stack[20];
; 324  :    char *cur,*base=ptr;

	mov	eax, DWORD PTR _ptr$[esp+16]

; 325  : 
; 326  :    cur=stack;

	lea	edx, DWORD PTR _stack$[esp+20]
	push	ebp
	push	esi

; 327  :    while(val)

	mov	esi, DWORD PTR _val$[esp+24]
	push	edi
	mov	edi, DWORD PTR _val$[esp+32]
	mov	ecx, esi
	or	ecx, edi
	mov	ebp, eax
	je	SHORT $L57384
$L57376:

; 328  :    {
; 329  :       U32 nibble;
; 330  : 
; 331  :       nibble=(U32)(val&0xF);

	mov	ecx, esi
	and	ecx, 15					; 0000000fH

; 332  :       if (nibble<0xA)

	cmp	ecx, 10					; 0000000aH
	jae	SHORT $L57380

; 333  :          *cur++=(char)(nibble+48);

	add	cl, 48					; 00000030H

; 334  :       else

	jmp	SHORT $L58149
$L57380:

; 335  :          *cur++=(char)(nibble+55);

	add	cl, 55					; 00000037H
$L58149:

; 336  :       val>>=4;

	shrd	esi, edi, 4
	mov	BYTE PTR [edx], cl
	mov	ecx, esi
	shr	edi, 4
	inc	edx
	or	ecx, edi
	jne	SHORT $L57376
$L57384:

; 337  :    }
; 338  :    do
; 339  :    {
; 340  :       *ptr++=(char)(*(--cur));

	mov	cl, BYTE PTR [edx-1]
	dec	edx
	mov	BYTE PTR [eax], cl

; 341  :    }while(stack!=cur);

	lea	ecx, DWORD PTR _stack$[esp+32]
	inc	eax
	cmp	edx, ecx
	jne	SHORT $L57384

; 342  :    ptr[0]=0;

	mov	BYTE PTR [eax], 0
	pop	edi

; 343  :    return ptr - base;

	sub	eax, ebp
	pop	esi
	pop	ebp

; 344  : }

	add	esp, 20					; 00000014H
	ret	0
_hex64	ENDP
_TEXT	ENDS
PUBLIC	??0CStrObj@@QAE@PBD@Z				; CStrObj::CStrObj
; Function compile flags: /Ogty
_TEXT	SEGMENT
_Str$ = 8
??0CStrObj@@QAE@PBD@Z PROC NEAR				; CStrObj::CStrObj
; _this$ = ecx

; 347  : {

	push	ebx
	push	esi

; 348  : 	size=strlen(Str);

	mov	esi, DWORD PTR _Str$[esp+4]
	mov	ebx, ecx
	push	edi
	mov	edi, esi
	or	ecx, -1
	xor	eax, eax
	mov	DWORD PTR [ebx], 0
	repne scasb
	not	ecx
	dec	ecx
	mov	DWORD PTR [ebx+8], ecx

; 349  : 	str=(char *)xmalloc(size+1);

	inc	ecx
	call	@xmalloc@4

; 350  : 	memcpy(str,Str,size+1);

	mov	ecx, DWORD PTR [ebx+8]
	mov	DWORD PTR [ebx+4], eax
	inc	ecx
	mov	edi, eax
	mov	eax, ecx
	shr	ecx, 2
	rep movsd
	mov	ecx, eax

; 351  : }

	mov	eax, ebx
	and	ecx, 3
	rep movsb
	pop	edi
	pop	esi
	pop	ebx
	ret	4
??0CStrObj@@QAE@PBD@Z ENDP				; CStrObj::CStrObj
_TEXT	ENDS
PUBLIC	??0CStrRef@@QAE@PBD@Z				; CStrRef::CStrRef
; Function compile flags: /Ogty
_TEXT	SEGMENT
_str$ = 8
??0CStrRef@@QAE@PBD@Z PROC NEAR				; CStrRef::CStrRef
; _this$ = ecx

; 354  : {

	push	esi
	mov	esi, ecx

; 355  : 	node=new CStrObj(str);

	mov	ecx, 12					; 0000000cH
	mov	DWORD PTR [esi], 0
	call	@xmalloc@4
	test	eax, eax
	je	SHORT $L58157
	mov	ecx, DWORD PTR _str$[esp]
	push	ecx
	mov	ecx, eax
	call	??0CStrObj@@QAE@PBD@Z			; CStrObj::CStrObj
	mov	DWORD PTR [esi], eax

; 356  : 	node->rcount=1;

	mov	DWORD PTR [eax], 1

; 357  : }

	mov	eax, esi
	pop	esi
	ret	4
$L58157:

; 355  : 	node=new CStrObj(str);

	xor	eax, eax
	mov	DWORD PTR [esi], eax

; 356  : 	node->rcount=1;

	mov	DWORD PTR [eax], 1

; 357  : }

	mov	eax, esi
	pop	esi
	ret	4
??0CStrRef@@QAE@PBD@Z ENDP				; CStrRef::CStrRef
_TEXT	ENDS
PUBLIC	??4CStrRef@@QAEAAV0@PBD@Z			; CStrRef::operator=
; Function compile flags: /Ogty
_TEXT	SEGMENT
_ptr$ = 8
??4CStrRef@@QAEAAV0@PBD@Z PROC NEAR			; CStrRef::operator=
; _this$ = ecx

; 360  : {

	push	esi
	push	edi
	mov	edi, ecx

; 361  : 	DelRef();

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $L58195
	mov	ecx, DWORD PTR [eax]
	dec	ecx
	mov	DWORD PTR [eax], ecx
	mov	esi, DWORD PTR [edi]
	cmp	DWORD PTR [esi], 0
	jne	SHORT $L58195
	test	esi, esi
	je	SHORT $L58195
	mov	ecx, DWORD PTR [esi+4]
	call	@xfree@4
	mov	ecx, esi
	mov	DWORD PTR [esi+4], 0
	call	@xfree@4
$L58195:

; 362  : 	node=null;
; 363  : 	if (!ptr)

	mov	esi, DWORD PTR _ptr$[esp+4]
	mov	DWORD PTR [edi], 0
	test	esi, esi

; 364  : 		return *this;

	je	SHORT $L58210

; 365  : 	node=new CStrObj(ptr);

	mov	ecx, 12					; 0000000cH
	call	@xmalloc@4
	test	eax, eax
	je	SHORT $L58170
	push	esi
	mov	ecx, eax
	call	??0CStrObj@@QAE@PBD@Z			; CStrObj::CStrObj
	mov	DWORD PTR [edi], eax

; 366  : 	node->rcount=1;

	mov	DWORD PTR [eax], 1

; 367  : 	return *this;

	mov	eax, edi
	pop	edi
	pop	esi

; 368  : }

	ret	4
$L58170:

; 365  : 	node=new CStrObj(ptr);

	xor	eax, eax
	mov	DWORD PTR [edi], eax

; 366  : 	node->rcount=1;

	mov	DWORD PTR [eax], 1
$L58210:

; 367  : 	return *this;

	mov	eax, edi
	pop	edi
	pop	esi

; 368  : }

	ret	4
??4CStrRef@@QAEAAV0@PBD@Z ENDP				; CStrRef::operator=
_TEXT	ENDS
PUBLIC	??1autochar@@QAE@XZ				; autochar::~autochar
PUBLIC	?seek_int@CBaseStream@@MAEJXZ			; CBaseStream::seek_int
PUBLIC	??1CBaseStream@@QAE@XZ				; CBaseStream::~CBaseStream
PUBLIC	?ioctl_read@CBaseStream@@UAEKKK@Z		; CBaseStream::ioctl_read
PUBLIC	?ioctl_write@CBaseStream@@UAEKKK@Z		; CBaseStream::ioctl_write
PUBLIC	?put@CBaseStream@@UAEKD@Z			; CBaseStream::put
PUBLIC	?pos_rd@CBaseStream@@UAEXKK@Z			; CBaseStream::pos_rd
PUBLIC	?pos_wr@CBaseStream@@UAEXKK@Z			; CBaseStream::pos_wr
PUBLIC	??_7CBaseStream@@6B@				; CBaseStream::`vftable'
PUBLIC	?base_init@XFile@@EAEXXZ			; XFile::base_init
PUBLIC	??1XFile@@QAE@XZ				; XFile::~XFile
PUBLIC	??_7XFile@@6BCBaseStream@@@			; XFile::`vftable'
PUBLIC	??_7XFile@@6BCSysObj@@@				; XFile::`vftable'
PUBLIC	??1CSysObj@@QAE@XZ				; CSysObj::~CSysObj
PUBLIC	??_7CSysObj@@6B@				; CSysObj::`vftable'
PUBLIC	?file_exist@CPathObj@@QAEKXZ			; CPathObj::file_exist
EXTRN	__purecall:NEAR
EXTRN	?_global@@3PAVXGlobal@@A:DWORD			; _global
EXTRN	?unreg_global_object@XGlobal@@QAEXPAVCSysObj@@@Z:NEAR ; XGlobal::unreg_global_object
EXTRN	__except_list:DWORD
EXTRN	?base_init@CBaseStream@@MAEXXZ:NEAR		; CBaseStream::base_init
EXTRN	___CxxFrameHandler:NEAR
EXTRN	?write@CBaseStream@@UAEKPBXKAAK@Z:NEAR		; CBaseStream::write
EXTRN	?write@CBaseStream@@UAEKPBXK@Z:NEAR		; CBaseStream::write
EXTRN	?read@CBaseStream@@UAEKPAXKAAK@Z:NEAR		; CBaseStream::read
EXTRN	?read@CBaseStream@@UAEKPAXK@Z:NEAR		; CBaseStream::read
EXTRN	?flush@CBaseStream@@UAEKXZ:NEAR			; CBaseStream::flush
EXTRN	??6CBaseStream@@UAEAAV0@PBD@Z:NEAR		; CBaseStream::operator<<
EXTRN	??6CBaseStream@@UAEAAV0@K@Z:NEAR		; CBaseStream::operator<<
EXTRN	??6CBaseStream@@UAEAAV0@D@Z:NEAR		; CBaseStream::operator<<
EXTRN	?std_close@XFile@@AAEKXZ:NEAR			; XFile::std_close
EXTRN	?destroy@XFile@@EAEKXZ:NEAR			; XFile::destroy
EXTRN	??0XFile@@QAE@XZ:NEAR				; XFile::XFile
EXTRN	?open@XFile@@QAEKPBD0@Z:NEAR			; XFile::open
EXTRN	?close@XFile@@UAEKXZ:NEAR			; XFile::close
EXTRN	?pos_rd@XFile@@UAEXKK@Z:NEAR			; XFile::pos_rd
EXTRN	?pos_wr@XFile@@UAEXKK@Z:NEAR			; XFile::pos_wr
xdata$x	SEGMENT
$T58339	DD	0ffffffffH
	DD	FLAT:$L58214
	DD	0ffffffffH
	DD	FLAT:$L58218
	DD	01H
	DD	FLAT:$L58221
	DD	02H
	DD	FLAT:$L58222
	DD	0ffffffffH
	DD	FLAT:$L58277
	DD	04H
	DD	FLAT:$L58280
	DD	05H
	DD	FLAT:$L58281
$T58336	DD	019930520H
	DD	07H
	DD	FLAT:$T58339
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
_DATA	SEGMENT
$SG57418 DB	'r', 00H
_DATA	ENDS
;	COMDAT ??_7XFile@@6BCSysObj@@@
; File C:\duke4\xcore\xstream.h
CONST	SEGMENT
??_7XFile@@6BCSysObj@@@ DD FLAT:?destroy@XFile@@EAEKXZ	; XFile::`vftable'
CONST	ENDS
;	COMDAT ??_7XFile@@6BCBaseStream@@@
CONST	SEGMENT
??_7XFile@@6BCBaseStream@@@ DD FLAT:?base_init@XFile@@EAEXXZ ; XFile::`vftable'
	DD	FLAT:?seek_int@CBaseStream@@MAEJXZ
	DD	FLAT:?close@XFile@@UAEKXZ
	DD	FLAT:?ioctl_read@CBaseStream@@UAEKKK@Z
	DD	FLAT:?ioctl_write@CBaseStream@@UAEKKK@Z
	DD	FLAT:?write@CBaseStream@@UAEKPBXK@Z
	DD	FLAT:?write@CBaseStream@@UAEKPBXKAAK@Z
	DD	FLAT:?read@CBaseStream@@UAEKPAXK@Z
	DD	FLAT:?read@CBaseStream@@UAEKPAXKAAK@Z
	DD	FLAT:?flush@CBaseStream@@UAEKXZ
	DD	FLAT:?put@CBaseStream@@UAEKD@Z
	DD	FLAT:??6CBaseStream@@UAEAAV0@D@Z
	DD	FLAT:??6CBaseStream@@UAEAAV0@K@Z
	DD	FLAT:??6CBaseStream@@UAEAAV0@PBD@Z
	DD	FLAT:?pos_rd@XFile@@UAEXKK@Z
	DD	FLAT:?pos_wr@XFile@@UAEXKK@Z
CONST	ENDS
;	COMDAT ??_7CSysObj@@6B@
CONST	SEGMENT
??_7CSysObj@@6B@ DD FLAT:__purecall			; CSysObj::`vftable'
CONST	ENDS
;	COMDAT ??_7CBaseStream@@6B@
CONST	SEGMENT
??_7CBaseStream@@6B@ DD FLAT:?base_init@CBaseStream@@MAEXXZ ; CBaseStream::`vftable'
	DD	FLAT:?seek_int@CBaseStream@@MAEJXZ
	DD	FLAT:__purecall
	DD	FLAT:?ioctl_read@CBaseStream@@UAEKKK@Z
	DD	FLAT:?ioctl_write@CBaseStream@@UAEKKK@Z
	DD	FLAT:?write@CBaseStream@@UAEKPBXK@Z
	DD	FLAT:?write@CBaseStream@@UAEKPBXKAAK@Z
	DD	FLAT:?read@CBaseStream@@UAEKPAXK@Z
	DD	FLAT:?read@CBaseStream@@UAEKPAXKAAK@Z
	DD	FLAT:?flush@CBaseStream@@UAEKXZ
	DD	FLAT:?put@CBaseStream@@UAEKD@Z
	DD	FLAT:??6CBaseStream@@UAEAAV0@D@Z
	DD	FLAT:??6CBaseStream@@UAEAAV0@K@Z
	DD	FLAT:??6CBaseStream@@UAEAAV0@PBD@Z
	DD	FLAT:?pos_rd@CBaseStream@@UAEXKK@Z
	DD	FLAT:?pos_wr@CBaseStream@@UAEXKK@Z
; Function compile flags: /Ogty
; File C:\duke4\xcore\string.cpp
CONST	ENDS
_TEXT	SEGMENT
$T58233 = -64
$T58292 = -88
__$EHRec$ = -12
_file$ = -56
?file_exist@CPathObj@@QAEKXZ PROC NEAR			; CPathObj::file_exist
; _this$ = ecx

; 371  : {

	push	-1
	push	$L58337
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 44					; 0000002cH
	push	esi
	mov	esi, ecx

; 372  : 	XFile file;

	lea	ecx, DWORD PTR _file$[esp+60]
	call	??0XFile@@QAE@XZ			; XFile::XFile

; 373  : 
; 374  : 	/* default to using relative or short path */
; 375  : 	CC8 *path=file_path;

	mov	eax, DWORD PTR [esi+8]

; 376  : 	/* but use absolute path if available */
; 377  : 	if (abs_path)

	mov	esi, DWORD PTR [esi+24]
	test	esi, esi
	mov	DWORD PTR __$EHRec$[esp+68], 0
	je	SHORT $L57416

; 378  : 		path=abs_path;

	mov	eax, esi
$L57416:

; 379  : 
; 380  : 	if (file.open(path,"r"))

	push	OFFSET FLAT:$SG57418
	push	eax
	lea	ecx, DWORD PTR _file$[esp+68]
	call	?open@XFile@@QAEKPBD0@Z			; XFile::open
	test	eax, eax
	pop	esi

; 381  : 		return TRUE;

	mov	DWORD PTR _file$[esp+84], OFFSET FLAT:??_7XFile@@6BCSysObj@@@ ; XFile::`vftable'
	mov	DWORD PTR _file$[esp+56], OFFSET FLAT:??_7XFile@@6BCBaseStream@@@ ; XFile::`vftable'
	je	$L57417
	mov	eax, DWORD PTR _file$[esp+60]
	mov	DWORD PTR __$EHRec$[esp+64], 3
	test	ah, 1
	je	SHORT $L58273
	lea	ecx, DWORD PTR _file$[esp+56]
	call	?std_close@XFile@@AAEKXZ		; XFile::std_close
$L58273:
	mov	ecx, DWORD PTR _file$[esp+96]
	call	@xfree@4
	mov	ecx, DWORD PTR ?_global@@3PAVXGlobal@@A	; _global
	lea	eax, DWORD PTR _file$[esp+84]
	push	eax
	mov	DWORD PTR _file$[esp+100], 0
	mov	BYTE PTR __$EHRec$[esp+68], 1
	mov	DWORD PTR _file$[esp+88], OFFSET FLAT:??_7CSysObj@@6B@ ; CSysObj::`vftable'
	call	?unreg_global_object@XGlobal@@QAEXPAVCSysObj@@@Z ; XGlobal::unreg_global_object
	mov	ecx, DWORD PTR _file$[esp+76]
	mov	DWORD PTR __$EHRec$[esp+64], -1
	test	ecx, ecx
	mov	DWORD PTR _file$[esp+56], OFFSET FLAT:??_7CBaseStream@@6B@ ; CBaseStream::`vftable'
	je	SHORT $L58265
	mov	edx, DWORD PTR [ecx]
	push	1
	call	DWORD PTR [edx+12]
$L58265:
	mov	ecx, DWORD PTR _file$[esp+80]
	test	ecx, ecx
	je	SHORT $L58269
	mov	eax, DWORD PTR [ecx]
	push	1
	call	DWORD PTR [eax+16]
$L58269:
	mov	eax, 1

; 383  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+56]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 56					; 00000038H
	ret	0
$L57417:

; 382  : 	return FALSE;

	mov	eax, DWORD PTR _file$[esp+60]
	mov	DWORD PTR __$EHRec$[esp+64], 6
	test	ah, 1
	je	SHORT $L58332
	lea	ecx, DWORD PTR _file$[esp+56]
	call	?std_close@XFile@@AAEKXZ		; XFile::std_close
$L58332:
	mov	ecx, DWORD PTR _file$[esp+96]
	call	@xfree@4
	lea	ecx, DWORD PTR _file$[esp+84]
	mov	DWORD PTR _file$[esp+96], 0
	push	ecx
	mov	ecx, DWORD PTR ?_global@@3PAVXGlobal@@A	; _global
	mov	BYTE PTR __$EHRec$[esp+68], 4
	mov	DWORD PTR _file$[esp+88], OFFSET FLAT:??_7CSysObj@@6B@ ; CSysObj::`vftable'
	call	?unreg_global_object@XGlobal@@QAEXPAVCSysObj@@@Z ; XGlobal::unreg_global_object
	mov	ecx, DWORD PTR _file$[esp+76]
	mov	DWORD PTR __$EHRec$[esp+64], -1
	test	ecx, ecx
	mov	DWORD PTR _file$[esp+56], OFFSET FLAT:??_7CBaseStream@@6B@ ; CBaseStream::`vftable'
	je	SHORT $L58324
	mov	edx, DWORD PTR [ecx]
	push	1
	call	DWORD PTR [edx+12]
$L58324:
	mov	ecx, DWORD PTR _file$[esp+80]
	test	ecx, ecx
	je	SHORT $L58328
	mov	eax, DWORD PTR [ecx]
	push	1
	call	DWORD PTR [eax+16]
$L58328:

; 383  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+56]
	xor	eax, eax
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 56					; 00000038H
	ret	0
_TEXT	ENDS
text$x	SEGMENT
$L58214:
	lea	ecx, DWORD PTR _file$[ebp]
	jmp	??1XFile@@QAE@XZ			; XFile::~XFile
$L58218:
	lea	ecx, DWORD PTR _file$[ebp]
	jmp	??1CBaseStream@@QAE@XZ			; CBaseStream::~CBaseStream
$L58221:
	lea	eax, DWORD PTR _file$[ebp]
	test	eax, eax
	je	$L58219
	lea	ecx, DWORD PTR _file$[ebp+28]
	mov	DWORD PTR $T58233[ebp], ecx
	jmp	$L58220
$L58219:
	mov	DWORD PTR $T58233[ebp], 0
$L58220:
	mov	ecx, DWORD PTR $T58233[ebp]
	jmp	??1CSysObj@@QAE@XZ			; CSysObj::~CSysObj
$L58222:
	lea	ecx, DWORD PTR _file$[ebp+40]
	jmp	??1autochar@@QAE@XZ			; autochar::~autochar
$L58277:
	lea	ecx, DWORD PTR _file$[ebp]
	jmp	??1CBaseStream@@QAE@XZ			; CBaseStream::~CBaseStream
$L58280:
	lea	eax, DWORD PTR _file$[ebp]
	test	eax, eax
	je	$L58278
	lea	ecx, DWORD PTR _file$[ebp+28]
	mov	DWORD PTR $T58292[ebp], ecx
	jmp	$L58279
$L58278:
	mov	DWORD PTR $T58292[ebp], 0
$L58279:
	mov	ecx, DWORD PTR $T58292[ebp]
	jmp	??1CSysObj@@QAE@XZ			; CSysObj::~CSysObj
$L58281:
	lea	ecx, DWORD PTR _file$[ebp+40]
	jmp	??1autochar@@QAE@XZ			; autochar::~autochar
$L58337:
	mov	eax, OFFSET FLAT:$T58336
	jmp	___CxxFrameHandler
text$x	ENDS
?file_exist@CPathObj@@QAEKXZ ENDP			; CPathObj::file_exist
; Function compile flags: /Ogty
; File C:\duke4\xcore\xclass.h
;	COMDAT ??1autochar@@QAE@XZ
_TEXT	SEGMENT
??1autochar@@QAE@XZ PROC NEAR				; autochar::~autochar, COMDAT
; _this$ = ecx

; 69   : 	inline ~autochar(void){xfree(ptr);ptr=null;}

	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR [esi]
	call	@xfree@4
	mov	DWORD PTR [esi], 0
	pop	esi
	ret	0
??1autochar@@QAE@XZ ENDP				; autochar::~autochar
_TEXT	ENDS
PUBLIC	?set_extension@CPathObj@@IAEXXZ			; CPathObj::set_extension
; Function compile flags: /Ogty
; File C:\duke4\xcore\string.cpp
_TEXT	SEGMENT
?set_extension@CPathObj@@IAEXXZ PROC NEAR		; CPathObj::set_extension
; _this$ = ecx

; 386  : {

	push	esi
	mov	esi, ecx

; 387  : 	D_ASSERT(file_path);
; 388  : 	CC8 *dot=fstrprchr(file_path+file_path_len-1,'.',file_path);

	xor	ecx, ecx
	mov	edx, 46					; 0000002eH
	mov	eax, DWORD PTR [esi+8]
	mov	cx, WORD PTR [esi+6]
	push	eax
	lea	ecx, DWORD PTR [ecx+eax-1]
	call	@fstrprchr@12

; 389  : 	if (dot)

	test	eax, eax
	je	SHORT $L57426

; 390  : 		dot++;

	inc	eax
$L57426:

; 391  : 	ext=dot;

	mov	DWORD PTR [esi+16], eax

; 392  : 	flags|=SETUP_EXT;

	mov	eax, DWORD PTR [esi+36]
	or	al, 1
	mov	DWORD PTR [esi+36], eax
	pop	esi

; 393  : }

	ret	0
?set_extension@CPathObj@@IAEXXZ ENDP			; CPathObj::set_extension
_TEXT	ENDS
PUBLIC	?set_name@CPathObj@@IAEXXZ			; CPathObj::set_name
; Function compile flags: /Ogty
_TEXT	SEGMENT
?set_name@CPathObj@@IAEXXZ PROC NEAR			; CPathObj::set_name
; _this$ = ecx

; 396  : {

	push	esi
	mov	esi, ecx

; 397  : 	D_ASSERT(file_path);
; 398  : 	CC8 *slash=fstrprchr(file_path+file_path_len-1,OS_SLASH,file_path);

	xor	ecx, ecx
	mov	edx, 92					; 0000005cH
	mov	eax, DWORD PTR [esi+8]
	mov	cx, WORD PTR [esi+6]
	push	eax
	lea	ecx, DWORD PTR [ecx+eax-1]
	call	@fstrprchr@12

; 399  : 	if (slash)

	test	eax, eax
	je	SHORT $L57432

; 400  : 		slash++;

	inc	eax
$L57432:

; 401  : 	file_name=slash;

	mov	DWORD PTR [esi+12], eax

; 402  : 	flags|=SETUP_NAME;

	mov	eax, DWORD PTR [esi+36]
	or	al, 4
	mov	DWORD PTR [esi+36], eax
	pop	esi

; 403  : }

	ret	0
?set_name@CPathObj@@IAEXXZ ENDP				; CPathObj::set_name
_TEXT	ENDS
PUBLIC	?get_extension@CPathObj@@QAEPBDXZ		; CPathObj::get_extension
; Function compile flags: /Ogty
_TEXT	SEGMENT
?get_extension@CPathObj@@QAEPBDXZ PROC NEAR		; CPathObj::get_extension
; _this$ = ecx

; 406  : {

	push	esi
	mov	esi, ecx

; 407  : 	/* if we haven't setup the extension member yet */
; 408  : 	if (!(flags & SETUP_EXT))

	test	BYTE PTR [esi+36], 1
	jne	SHORT $L58346

; 409  : 		set_extension();

	call	?set_extension@CPathObj@@IAEXXZ		; CPathObj::set_extension
$L58346:

; 410  : 	return ext;

	mov	eax, DWORD PTR [esi+16]
	pop	esi

; 411  : }

	ret	0
?get_extension@CPathObj@@QAEPBDXZ ENDP			; CPathObj::get_extension
_TEXT	ENDS
PUBLIC	?get_filename@CPathObj@@QAEPBDXZ		; CPathObj::get_filename
; Function compile flags: /Ogty
_TEXT	SEGMENT
?get_filename@CPathObj@@QAEPBDXZ PROC NEAR		; CPathObj::get_filename
; _this$ = ecx

; 414  : {

	push	esi
	mov	esi, ecx

; 415  : 	if (!(flags & SETUP_NAME))

	test	BYTE PTR [esi+36], 4
	jne	SHORT $L58348

; 416  : 		set_name();

	call	?set_name@CPathObj@@IAEXXZ		; CPathObj::set_name
$L58348:

; 417  : 	return file_name;

	mov	eax, DWORD PTR [esi+12]
	pop	esi

; 418  : }

	ret	0
?get_filename@CPathObj@@QAEPBDXZ ENDP			; CPathObj::get_filename
_TEXT	ENDS
PUBLIC	?init_name_path@CPathObj@@QAEXPBD0@Z		; CPathObj::init_name_path
PUBLIC	??1TmpPrintf@@QAE@XZ				; TmpPrintf::~TmpPrintf
EXTRN	?fstrcpy_lim@CPrintf@@IAEKPBD@Z:NEAR		; CPrintf::fstrcpy_lim
EXTRN	?chr@CPrintf@@QAEKD@Z:NEAR			; CPrintf::chr
EXTRN	?get_printf@@YAPAVCPrintfT@@K@Z:NEAR		; get_printf
EXTRN	?release_printf@@YAXPAVCPrintfT@@@Z:NEAR	; release_printf
xdata$x	SEGMENT
$T58425	DD	0ffffffffH
	DD	FLAT:$L58350
$T58423	DD	019930520H
	DD	01H
	DD	FLAT:$T58425
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
_TEXT	SEGMENT
__$EHRec$ = -12
_name$ = 8
_path$ = 12
_tmp$ = -16
?init_name_path@CPathObj@@QAEXPBD0@Z PROC NEAR		; CPathObj::init_name_path
; _this$ = ecx

; 421  : {

	push	-1
	push	$L58424
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	push	ebx
	push	ebp
	push	esi
	push	edi

; 422  : 	TmpPrintf tmp(XMAX_PATH);

	push	260					; 00000104H
	mov	edi, ecx
	call	?get_printf@@YAPAVCPrintfT@@K@Z		; get_printf
	mov	esi, eax
	add	esp, 4
	mov	DWORD PTR _tmp$[esp+32], esi

; 423  : 
; 424  : 	if (*path)

	mov	eax, DWORD PTR _path$[esp+28]
	mov	DWORD PTR __$EHRec$[esp+40], 0
	cmp	BYTE PTR [eax], 0
	je	SHORT $L57449

; 425  : 	{
; 426  : 		tmp << path;

	push	eax
	mov	ecx, esi
	call	?fstrcpy_lim@CPrintf@@IAEKPBD@Z		; CPrintf::fstrcpy_lim

; 427  : 		char last=*(tmp.get_last());

	mov	eax, DWORD PTR [esi+4]
	mov	al, BYTE PTR [eax-1]

; 428  : 		if (!((last=='\\') || (last=='/')))

	cmp	al, 92					; 0000005cH
	je	SHORT $L58372
	cmp	al, 47					; 0000002fH
	je	SHORT $L58372

; 429  : 			tmp << OS_SLASH;

	push	92					; 0000005cH
	mov	ecx, esi
	call	?chr@CPrintf@@QAEKD@Z			; CPrintf::chr
$L58372:

; 430  : 		flags|=HAS_REL_PATH;

	mov	eax, DWORD PTR [edi+36]
	or	al, 2
	mov	DWORD PTR [edi+36], eax
$L57449:

; 431  : 	}
; 432  : 	U32 name_offset=tmp.get_len();
; 433  : 	
; 434  : 	tmp << name;

	mov	ecx, DWORD PTR _name$[esp+28]
	mov	ebx, DWORD PTR [esi+4]
	mov	ebp, DWORD PTR [esi]
	push	ecx
	mov	ecx, esi
	sub	ebx, ebp
	call	?fstrcpy_lim@CPrintf@@IAEKPBD@Z		; CPrintf::fstrcpy_lim

; 435  : 
; 436  : 	U32 len=tmp.get_len();
; 437  : 
; 438  : 	/* pad for some growth/manipulation */
; 439  : 	len+=16;

	mov	ebp, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	sub	ebp, ecx
	add	ebp, 16					; 00000010H

; 440  : 
; 441  : 	file_path=(char *)xmalloc(len);

	mov	ecx, ebp
	call	@xmalloc@4
	mov	DWORD PTR [edi+8], eax

; 442  : 	file_path_size=(U16)len;

	mov	WORD PTR [edi+4], bp

; 443  : 
; 444  : 	fstrcpy(file_path,tmp.get_str());

	mov	edx, DWORD PTR [esi]
	mov	ecx, eax
	call	@fstrcpy@8

; 445  : 	ext=null;
; 446  : 	file_name=file_path+name_offset;

	mov	edx, DWORD PTR [edi+8]
	mov	DWORD PTR [edi+16], 0
	add	edx, ebx

; 447  : 	file_path_len=(U16)tmp.get_len();
; 448  : 
; 449  : 	flags|=SETUP_NAME;
; 450  : }

	push	esi
	mov	DWORD PTR [edi+12], edx
	mov	ax, WORD PTR [esi+4]
	mov	edx, DWORD PTR [edi+36]
	sub	ax, WORD PTR [esi]
	or	edx, 4
	mov	DWORD PTR __$EHRec$[esp+44], -1
	mov	WORD PTR [edi+6], ax
	mov	DWORD PTR [edi+36], edx
	call	?release_printf@@YAXPAVCPrintfT@@@Z	; release_printf
	mov	ecx, DWORD PTR __$EHRec$[esp+36]
	add	esp, 4
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 16					; 00000010H
	ret	8
_TEXT	ENDS
text$x	SEGMENT
$L58350:
	lea	ecx, DWORD PTR _tmp$[ebp]
	jmp	??1TmpPrintf@@QAE@XZ			; TmpPrintf::~TmpPrintf
$L58424:
	mov	eax, OFFSET FLAT:$T58423
	jmp	___CxxFrameHandler
text$x	ENDS
?init_name_path@CPathObj@@QAEXPBD0@Z ENDP		; CPathObj::init_name_path
PUBLIC	?init_abs_path@CPathObj@@QAEXPBD@Z		; CPathObj::init_abs_path
EXTRN	@fstrlen@4:NEAR
; Function compile flags: /Ogty
_TEXT	SEGMENT
_abs_name$ = 8
?init_abs_path@CPathObj@@QAEXPBD@Z PROC NEAR		; CPathObj::init_abs_path
; _this$ = ecx

; 453  : {

	push	esi
	push	edi

; 454  : 	U32 len=fstrlen(abs_name);

	mov	edi, DWORD PTR _abs_name$[esp+4]
	mov	esi, ecx
	mov	ecx, edi
	call	@fstrlen@4

; 455  : 	
; 456  : 	/* pad for some growth */
; 457  : 	file_path_len=(U16)len;
; 458  : 	file_path_size=file_path_len+16;

	lea	ecx, DWORD PTR [eax+16]
	mov	WORD PTR [esi+6], ax
	mov	WORD PTR [esi+4], cx

; 459  : 
; 460  : 	file_path=(char *)xmalloc(file_path_size);

	and	ecx, 65535				; 0000ffffH
	call	@xmalloc@4

; 461  : 	fstrcpy(file_path,abs_name);

	mov	edx, edi
	mov	ecx, eax
	mov	DWORD PTR [esi+8], eax
	call	@fstrcpy@8

; 462  : 	file_name=null;
; 463  : 	
; 464  : 	
; 465  : 	flags|=HAS_REL_PATH;

	mov	eax, DWORD PTR [esi+36]
	mov	DWORD PTR [esi+12], 0
	or	al, 2
	pop	edi
	mov	DWORD PTR [esi+36], eax
	pop	esi

; 466  : }

	ret	4
?init_abs_path@CPathObj@@QAEXPBD@Z ENDP			; CPathObj::init_abs_path
_TEXT	ENDS
PUBLIC	?init_name@CPathObj@@QAEXPBD@Z			; CPathObj::init_name
; Function compile flags: /Ogty
_TEXT	SEGMENT
_name$ = 8
?init_name@CPathObj@@QAEXPBD@Z PROC NEAR		; CPathObj::init_name
; _this$ = ecx

; 469  : {

	push	esi
	push	edi

; 470  : 	U32 len=fstrlen(name);

	mov	edi, DWORD PTR _name$[esp+4]
	mov	esi, ecx
	mov	ecx, edi
	call	@fstrlen@4

; 471  : 
; 472  : 	/* pad for some growth */
; 473  : 	file_path_len=(U16)len;
; 474  : 	file_path_size=file_path_len+16;

	lea	ecx, DWORD PTR [eax+16]
	mov	WORD PTR [esi+6], ax
	mov	WORD PTR [esi+4], cx

; 475  : 
; 476  : 	file_path=(char *)xmalloc(file_path_size);

	and	ecx, 65535				; 0000ffffH
	call	@xmalloc@4

; 477  : 	fstrcpy(file_path,name);

	mov	edx, edi
	mov	ecx, eax
	mov	DWORD PTR [esi+8], eax
	call	@fstrcpy@8

; 478  : 	file_name=null;

	mov	DWORD PTR [esi+12], 0
	pop	edi
	pop	esi

; 479  : }

	ret	4
?init_name@CPathObj@@QAEXPBD@Z ENDP			; CPathObj::init_name
_TEXT	ENDS
PUBLIC	??1CPathObj@@QAE@XZ				; CPathObj::~CPathObj
PUBLIC	?init@CPathRef@@QAEPBDPBD0@Z			; CPathRef::init
; Function compile flags: /Ogty
_TEXT	SEGMENT
_Filename$ = 8
_Pathname$ = 12
?init@CPathRef@@QAEPBDPBD0@Z PROC NEAR			; CPathRef::init
; _this$ = ecx

; 482  : {

	push	esi
	mov	esi, ecx
	push	edi

; 483  : 	DelRef();

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $L58451
	mov	ecx, DWORD PTR [eax]
	dec	ecx
	mov	DWORD PTR [eax], ecx
	mov	edi, DWORD PTR [esi]
	cmp	DWORD PTR [edi], 0
	jne	SHORT $L58451
	test	edi, edi
	je	SHORT $L58451
	mov	ecx, edi
	call	??1CPathObj@@QAE@XZ			; CPathObj::~CPathObj
	mov	ecx, edi
	call	@xfree@4
$L58451:

; 484  : 
; 485  : 	node=new CPathObj;

	mov	ecx, 40					; 00000028H
	call	@xmalloc@4
	test	eax, eax
	je	SHORT $L58431
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+8], 0
	mov	DWORD PTR [eax+24], 0
	mov	DWORD PTR [eax+32], 0
	jmp	SHORT $L58432
$L58431:
	xor	eax, eax
$L58432:

; 486  : 	node->init_name_path(Filename,Pathname);

	mov	ecx, DWORD PTR _Pathname$[esp+4]
	mov	edx, DWORD PTR _Filename$[esp+4]
	push	ecx
	push	edx
	mov	ecx, eax
	mov	DWORD PTR [esi], eax
	call	?init_name_path@CPathObj@@QAEXPBD0@Z	; CPathObj::init_name_path

; 487  : 
; 488  : 	AddRef();

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $L58476
	mov	ecx, DWORD PTR [eax]
	pop	edi
	inc	ecx
	mov	DWORD PTR [eax], ecx

; 489  : 	
; 490  : 	return node->file_path;

	mov	eax, DWORD PTR [esi]
	pop	esi
	mov	eax, DWORD PTR [eax+8]

; 491  : }

	ret	8
$L58476:

; 489  : 	
; 490  : 	return node->file_path;

	mov	ecx, DWORD PTR [esi]
	pop	edi
	pop	esi
	mov	eax, DWORD PTR [ecx+8]

; 491  : }

	ret	8
?init@CPathRef@@QAEPBDPBD0@Z ENDP			; CPathRef::init
_TEXT	ENDS
PUBLIC	??0CPathRef@@QAE@PBD@Z				; CPathRef::CPathRef
; Function compile flags: /Ogty
_TEXT	SEGMENT
_str$ = 8
??0CPathRef@@QAE@PBD@Z PROC NEAR			; CPathRef::CPathRef
; _this$ = ecx

; 494  : {

	push	esi
	mov	esi, ecx

; 495  : 	node=new CPathObj;

	mov	ecx, 40					; 00000028H
	mov	DWORD PTR [esi], 0
	call	@xmalloc@4
	test	eax, eax
	je	SHORT $L58480
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+8], 0
	mov	DWORD PTR [eax+24], 0
	mov	DWORD PTR [eax+32], 0
	jmp	SHORT $L58481
$L58480:
	xor	eax, eax
$L58481:

; 496  : 	node->init_name(str);

	mov	ecx, DWORD PTR _str$[esp]
	mov	DWORD PTR [esi], eax
	push	ecx
	mov	ecx, eax
	call	?init_name@CPathObj@@QAEXPBD@Z		; CPathObj::init_name

; 497  : 
; 498  : 	AddRef();

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $L58502
	inc	DWORD PTR [eax]
$L58502:

; 499  : }

	mov	eax, esi
	pop	esi
	ret	4
??0CPathRef@@QAE@PBD@Z ENDP				; CPathRef::CPathRef
_TEXT	ENDS
PUBLIC	?set_absolute@CPathRef@@QAEXPBD@Z		; CPathRef::set_absolute
; Function compile flags: /Ogty
_TEXT	SEGMENT
_abs_name$ = 8
?set_absolute@CPathRef@@QAEXPBD@Z PROC NEAR		; CPathRef::set_absolute
; _this$ = ecx

; 502  : {

	push	esi
	mov	esi, ecx
	push	edi

; 503  : 	DelRef();

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $L58526
	mov	ecx, DWORD PTR [eax]
	dec	ecx
	mov	DWORD PTR [eax], ecx
	mov	edi, DWORD PTR [esi]
	cmp	DWORD PTR [edi], 0
	jne	SHORT $L58526
	test	edi, edi
	je	SHORT $L58526
	mov	ecx, edi
	call	??1CPathObj@@QAE@XZ			; CPathObj::~CPathObj
	mov	ecx, edi
	call	@xfree@4
$L58526:

; 504  : 
; 505  : 	node=new CPathObj;

	mov	ecx, 40					; 00000028H
	call	@xmalloc@4
	test	eax, eax
	je	SHORT $L58506
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+8], 0
	mov	DWORD PTR [eax+24], 0
	mov	DWORD PTR [eax+32], 0
	jmp	SHORT $L58507
$L58506:
	xor	eax, eax
$L58507:

; 506  : 	node->init_abs_path(abs_name);

	mov	ecx, DWORD PTR _abs_name$[esp+4]
	mov	DWORD PTR [esi], eax
	push	ecx
	mov	ecx, eax
	call	?init_abs_path@CPathObj@@QAEXPBD@Z	; CPathObj::init_abs_path

; 507  : 	
; 508  : 	AddRef();

	mov	esi, DWORD PTR [esi]
	test	esi, esi
	je	SHORT $L58549
	inc	DWORD PTR [esi]
$L58549:
	pop	edi
	pop	esi

; 509  : }

	ret	4
?set_absolute@CPathRef@@QAEXPBD@Z ENDP			; CPathRef::set_absolute
_TEXT	ENDS
PUBLIC	?is_ext@CPathObj@@QAEKPBD@Z			; CPathObj::is_ext
; Function compile flags: /Ogty
_TEXT	SEGMENT
_Ext$ = 8
?is_ext@CPathObj@@QAEKPBD@Z PROC NEAR			; CPathObj::is_ext
; _this$ = ecx

; 513  : 	if (!ext)

	mov	ecx, DWORD PTR [ecx+16]
	test	ecx, ecx
	jne	SHORT $L57500

; 514  : 		return FALSE;

	xor	eax, eax

; 516  : }

	ret	4
$L57500:

; 515  : 	return fstreq(ext,Ext);

	mov	edx, DWORD PTR _Ext$[esp-4]
	call	@fstreq@8

; 516  : }

	ret	4
?is_ext@CPathObj@@QAEKPBD@Z ENDP			; CPathObj::is_ext
_TEXT	ENDS
PUBLIC	?is_room@CPathObj@@IAEKK@Z			; CPathObj::is_room
; Function compile flags: /Ogty
_TEXT	SEGMENT
_more$ = 8
?is_room@CPathObj@@IAEKK@Z PROC NEAR			; CPathObj::is_room
; _this$ = ecx

; 520  : 	if ((file_path_size - file_path_len) > (I32)more) 

	xor	eax, eax
	xor	edx, edx
	mov	ax, WORD PTR [ecx+6]
	mov	dx, WORD PTR [ecx+4]
	mov	ecx, DWORD PTR _more$[esp-4]
	sub	edx, eax
	xor	eax, eax
	cmp	edx, ecx
	setg	al

; 521  : 		return TRUE;
; 522  : 
; 523  : 	return FALSE;
; 524  : }

	ret	4
?is_room@CPathObj@@IAEKK@Z ENDP				; CPathObj::is_room
_TEXT	ENDS
PUBLIC	?set_extension@CPathObj@@IAEXPBD@Z		; CPathObj::set_extension
; Function compile flags: /Ogty
_TEXT	SEGMENT
_Ext$ = 8
_obj$ = -20
?set_extension@CPathObj@@IAEXPBD@Z PROC NEAR		; CPathObj::set_extension
; _this$ = ecx

; 527  : {

	sub	esp, 20					; 00000014H
	push	esi
	mov	esi, ecx

; 528  : 	if (ext)

	mov	ecx, DWORD PTR [esi+16]
	test	ecx, ecx
	je	SHORT $L57511

; 529  : 	{
; 530  : 		fstrcpy((char *)ext,Ext);

	mov	edx, DWORD PTR _Ext$[esp+20]
	call	@fstrcpy@8
	pop	esi

; 540  : }

	add	esp, 20					; 00000014H
	ret	4
$L57511:

; 531  : 		return;
; 532  : 	}
; 533  : 	
; 534  : 	CPrintf obj(file_path,file_path_size,file_path_len);

	mov	ecx, DWORD PTR [esi+8]
	xor	eax, eax
	mov	ax, WORD PTR [esi+6]
	mov	DWORD PTR _obj$[esp+24], ecx
	add	ecx, eax
	mov	DWORD PTR _obj$[esp+32], eax
	xor	eax, eax
	mov	DWORD PTR _obj$[esp+28], ecx
	mov	ax, WORD PTR [esi+4]

; 535  : 
; 536  : 	obj << '.';

	push	46					; 0000002eH
	lea	ecx, DWORD PTR _obj$[esp+28]
	mov	DWORD PTR _obj$[esp+40], eax
	mov	DWORD PTR _obj$[esp+44], 0
	call	?chr@CPrintf@@QAEKD@Z			; CPrintf::chr

; 537  : 	ext=obj.get_cur();

	mov	ecx, DWORD PTR _obj$[esp+28]

; 538  : 	obj << Ext;

	mov	edx, DWORD PTR _Ext$[esp+20]
	mov	DWORD PTR [esi+16], ecx
	push	edx
	lea	ecx, DWORD PTR _obj$[esp+28]
	call	?fstrcpy_lim@CPrintf@@IAEKPBD@Z		; CPrintf::fstrcpy_lim

; 539  : 	flags|=SETUP_EXT;

	mov	eax, DWORD PTR [esi+36]
	or	al, 1
	mov	DWORD PTR [esi+36], eax
	pop	esi

; 540  : }

	add	esp, 20					; 00000014H
	ret	4
?set_extension@CPathObj@@IAEXPBD@Z ENDP			; CPathObj::set_extension
_TEXT	ENDS
PUBLIC	?init_new_ext@CPathObj@@QAEKPAV1@PBD@Z		; CPathObj::init_new_ext
PUBLIC	?set_extension@CPathRef@@QAEXPBD@Z		; CPathRef::set_extension
; Function compile flags: /Ogty
_TEXT	SEGMENT
_ext$ = 8
?set_extension@CPathRef@@QAEXPBD@Z PROC NEAR		; CPathRef::set_extension
; _this$ = ecx

; 543  : {

	push	ebx

; 544  : 	D_ASSERT(ext);
; 545  : 	D_ASSERT(node);
; 546  : 
; 547  : 	/* if extension isn't really changing */
; 548  : 	if (node->is_ext(ext))

	mov	ebx, DWORD PTR _ext$[esp]
	push	esi
	mov	esi, ecx
	push	edi
	push	ebx
	mov	edi, DWORD PTR [esi]
	mov	ecx, edi
	call	?is_ext@CPathObj@@QAEKPBD@Z		; CPathObj::is_ext
	test	eax, eax
	jne	$L58616

; 549  : 		return;
; 550  : 
; 551  : 	/* if we are the only reference */
; 552  : 	if (node->rcount==1)

	cmp	DWORD PTR [edi], 1
	jne	SHORT $L57520

; 553  : 	{
; 554  : 		if (node->is_room(fstrlen(ext)+1))

	mov	ecx, ebx
	call	@fstrlen@4
	inc	eax
	mov	ecx, edi
	push	eax
	call	?is_room@CPathObj@@IAEKK@Z		; CPathObj::is_room
	test	eax, eax
	je	SHORT $L57520

; 555  : 		{
; 556  : 			node->set_extension(ext);

	push	ebx
	mov	ecx, edi
	call	?set_extension@CPathObj@@IAEXPBD@Z	; CPathObj::set_extension
	pop	edi
	pop	esi
	pop	ebx

; 567  : }

	ret	4
$L57520:

; 557  : 			return;
; 558  : 		}
; 559  : 	}
; 560  : 	
; 561  : 	/* ok we need a new node */
; 562  : 	CPathObj *tmp=new CPathObj;

	mov	ecx, 40					; 00000028H
	call	@xmalloc@4
	test	eax, eax
	je	SHORT $L58573
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+8], 0
	mov	DWORD PTR [eax+24], 0
	mov	DWORD PTR [eax+32], 0
	mov	edi, eax
	jmp	SHORT $L58574
$L58573:
	xor	edi, edi
$L58574:

; 563  : 	tmp->init_new_ext(node,ext);

	mov	eax, DWORD PTR [esi]
	push	ebx
	push	eax
	mov	ecx, edi
	call	?init_new_ext@CPathObj@@QAEKPAV1@PBD@Z	; CPathObj::init_new_ext

; 564  : 	DelRef();

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $L58604
	mov	ecx, DWORD PTR [eax]
	dec	ecx
	mov	DWORD PTR [eax], ecx
	mov	ebx, DWORD PTR [esi]
	cmp	DWORD PTR [ebx], 0
	jne	SHORT $L58604
	test	ebx, ebx
	je	SHORT $L58604
	mov	ecx, ebx
	call	??1CPathObj@@QAE@XZ			; CPathObj::~CPathObj
	mov	ecx, ebx
	call	@xfree@4
$L58604:

; 565  : 	node=tmp;
; 566  : 	AddRef();

	test	edi, edi
	mov	DWORD PTR [esi], edi
	je	SHORT $L58616
	inc	DWORD PTR [edi]
$L58616:
	pop	edi
	pop	esi
	pop	ebx

; 567  : }

	ret	4
?set_extension@CPathRef@@QAEXPBD@Z ENDP			; CPathRef::set_extension
_TEXT	ENDS
xdata$x	SEGMENT
$T58690	DD	0ffffffffH
	DD	FLAT:$L58620
$T58688	DD	019930520H
	DD	01H
	DD	FLAT:$T58690
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
_TEXT	SEGMENT
_obj$ = 8
_tmp$ = -16
__$EHRec$ = -12
?init_new_ext@CPathObj@@QAEKPAV1@PBD@Z PROC NEAR	; CPathObj::init_new_ext
; _this$ = ecx

; 570  : {

	push	-1
	push	$L58689
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	push	esi
	push	edi

; 571  : 	TmpPrintf tmp(XMAX_PATH);

	push	260					; 00000104H
	mov	edi, ecx
	call	?get_printf@@YAPAVCPrintfT@@K@Z		; get_printf
	mov	esi, eax
	add	esp, 4
	mov	DWORD PTR _tmp$[esp+24], esi

; 572  : 
; 573  : 	tmp << obj->file_path;

	mov	eax, DWORD PTR _obj$[esp+20]
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+32], 0
	mov	eax, DWORD PTR [eax+8]
	push	eax
	call	?fstrcpy_lim@CPrintf@@IAEKPBD@Z		; CPrintf::fstrcpy_lim

; 574  : 	
; 575  : 	CC8 *start=tmp.get_str();

	mov	eax, DWORD PTR [esi]

; 576  : 	CC8 *end=tmp.get_cur();

	mov	ecx, DWORD PTR [esi+4]

; 577  : 
; 578  : 	U32 tmp_size=end - start;
; 579  : 	ext=fstrprchr(end-1,'.',start);

	push	eax
	dec	ecx
	mov	edx, 46					; 0000002eH
	call	@fstrprchr@12

; 580  : 	if (ext)

	test	eax, eax
	mov	DWORD PTR [edi+16], eax
	je	SHORT $L57535

; 581  : 		tmp.set_cur(ext);

	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [esi]
	sub	ecx, eax
	mov	DWORD PTR [esi+4], eax
	lea	ecx, DWORD PTR [ecx+edx-1]
	mov	DWORD PTR [esi+8], ecx

; 582  : 	else

	jmp	SHORT $L57536
$L57535:

; 583  : 		ext=tmp.get_cur();

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [edi+16], eax
$L57536:

; 584  : 
; 585  : 	if (*ext!='.')

	mov	edx, DWORD PTR [edi+16]
	cmp	BYTE PTR [edx], 46			; 0000002eH
	je	SHORT $L58672

; 586  : 		tmp << '.';

	push	46					; 0000002eH
	mov	ecx, esi
	call	?chr@CPrintf@@QAEKD@Z			; CPrintf::chr
$L58672:

; 587  : 
; 588  : 	tmp << ext;

	mov	edi, DWORD PTR [edi+16]
	mov	ecx, esi
	push	edi
	call	?fstrcpy_lim@CPrintf@@IAEKPBD@Z		; CPrintf::fstrcpy_lim

; 589  : 	
; 590  : 	return TRUE;

	push	esi
	mov	DWORD PTR __$EHRec$[esp+36], -1
	call	?release_printf@@YAXPAVCPrintfT@@@Z	; release_printf

; 591  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	add	esp, 4
	mov	eax, 1
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	add	esp, 16					; 00000010H
	ret	8
_TEXT	ENDS
text$x	SEGMENT
$L58620:
	lea	ecx, DWORD PTR _tmp$[ebp]
	jmp	??1TmpPrintf@@QAE@XZ			; TmpPrintf::~TmpPrintf
$L58689:
	mov	eax, OFFSET FLAT:$T58688
	jmp	___CxxFrameHandler
text$x	ENDS
?init_new_ext@CPathObj@@QAEKPAV1@PBD@Z ENDP		; CPathObj::init_new_ext
; Function compile flags: /Ogty
_TEXT	SEGMENT
??1CPathObj@@QAE@XZ PROC NEAR				; CPathObj::~CPathObj
; _this$ = ecx

; 594  : {

	push	esi
	mov	esi, ecx

; 595  : 	if (file_path)

	mov	ecx, DWORD PTR [esi+8]
	test	ecx, ecx
	je	SHORT $L57543

; 596  : 		xfree(file_path);

	call	@xfree@4
$L57543:

; 597  : 	if (abs_path)

	mov	ecx, DWORD PTR [esi+24]
	test	ecx, ecx
	je	SHORT $L57544

; 598  : 		xfree((void *)abs_path);

	call	@xfree@4
$L57544:

; 599  : 	if (just_path)

	mov	ecx, DWORD PTR [esi+32]
	pop	esi
	test	ecx, ecx
	je	SHORT $L57546

; 600  : 		xfree((void *)just_path);

	jmp	@xfree@4
$L57546:

; 601  : }

	ret	0
??1CPathObj@@QAE@XZ ENDP				; CPathObj::~CPathObj
_TEXT	ENDS
PUBLIC	?copy@StrGrow@@QAEXPBD@Z			; StrGrow::copy
EXTRN	?realloc@MemGrow@@QAEXK@Z:NEAR			; MemGrow::realloc
; Function compile flags: /Ogty
_TEXT	SEGMENT
_str$ = 8
?copy@StrGrow@@QAEXPBD@Z PROC NEAR			; StrGrow::copy
; _this$ = ecx

; 604  : {

	push	ebx
	push	esi
	mov	esi, ecx
	push	edi

; 605  : 	if (!base)
; 606  : 	{
; 607  : 		U32 len=fstrlen(str);

	mov	edi, DWORD PTR _str$[esp+8]
	cmp	DWORD PTR [esi], 0
	jne	SHORT $keep_copying$57554
	mov	ecx, edi
	call	@fstrlen@4

; 608  : 		init(inc_size+len);

	mov	ecx, DWORD PTR [esi+16]
	add	ecx, eax
	mov	DWORD PTR [esi+4], ecx
	call	@xmalloc@4

; 609  : 		cur=::fstrcpy(base,str);

	mov	edx, edi
	mov	ecx, eax
	mov	DWORD PTR [esi], eax
	call	@fstrcpy@8

; 610  : 		end=base+size;

	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR [esi+8], eax
	add	edx, DWORD PTR [esi]
	mov	DWORD PTR [esi+12], edx
$L58706:
	pop	edi
	pop	esi
	pop	ebx

; 625  : }

	ret	4
$keep_copying$57554:
	mov	eax, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [esi+8]
	sub	eax, edx
	test	eax, eax
	jle	SHORT $L58707
$L57557:

; 611  : 		return;
; 612  : 	}
; 613  : 
; 614  : keep_copying:
; 615  : 	I32 size_left=end - cur;
; 616  : 	while(size_left-- > 0)
; 617  : 	{
; 618  : 		if (!(*cur=*str++))

	mov	ecx, DWORD PTR [esi+8]
	mov	dl, BYTE PTR [edi]
	dec	eax
	inc	edi
	mov	BYTE PTR [ecx], dl
	mov	ecx, DWORD PTR [esi+8]
	cmp	BYTE PTR [ecx], 0
	je	SHORT $L58706

; 619  : 			return;
; 620  : 		cur++;

	inc	ecx
	test	eax, eax
	mov	DWORD PTR [esi+8], ecx
	jg	SHORT $L57557
$L58707:

; 621  : 	}
; 622  : 
; 623  : 	realloc(inc_size);

	mov	ebx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR [esi]
	sub	ebx, eax
	mov	eax, DWORD PTR [esi+16]
	push	eax
	mov	ecx, esi
	call	?realloc@MemGrow@@QAEXK@Z		; MemGrow::realloc
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [esi+4]
	add	edx, eax
	lea	ecx, DWORD PTR [eax+ebx]
	mov	DWORD PTR [esi+12], edx
	mov	DWORD PTR [esi+8], ecx

; 624  : 	goto keep_copying;

	jmp	SHORT $keep_copying$57554
?copy@StrGrow@@QAEXPBD@Z ENDP				; StrGrow::copy
_TEXT	ENDS
PUBLIC	?copy@StrGrow@@QAEKPBDK@Z			; StrGrow::copy
; Function compile flags: /Ogty
_TEXT	SEGMENT
_str$ = 8
_size$ = 12
?copy@StrGrow@@QAEKPBDK@Z PROC NEAR			; StrGrow::copy
; _this$ = ecx

; 628  : {

	push	ebx
	push	esi
	push	edi

; 629  : 	if (size==0)

	mov	edi, DWORD PTR _size$[esp+8]

; 630  : 		return 0;

	xor	eax, eax
	test	edi, edi
	je	SHORT $L57564

; 631  : 
; 632  : 	I32 size_left=end - cur;
; 633  : 
; 634  : 	if ((size_left-size) < 0)
; 635  : 		realloc(inc_size,size);
; 636  : 
; 637  : 	U32 i;
; 638  : 
; 639  : 	for(i=0;i<size;i++)

	jbe	SHORT $L57571
	mov	esi, DWORD PTR _str$[esp+8]
$L57569:

; 640  : 	{
; 641  : 		U8 key;
; 642  : 
; 643  : 		*cur=key=str[i];

	mov	dl, BYTE PTR [eax+esi]
	mov	ebx, DWORD PTR [ecx+8]

; 644  : 		if (key==0)

	test	dl, dl
	mov	BYTE PTR [ebx], dl
	je	SHORT $L57564

; 645  : 			return i;
; 646  : 		cur++;

	mov	edx, DWORD PTR [ecx+8]
	inc	edx
	inc	eax
	cmp	eax, edi
	mov	DWORD PTR [ecx+8], edx
	jb	SHORT $L57569
$L57571:

; 647  : 	}
; 648  : 	*(--cur)=0;

	mov	edx, DWORD PTR [ecx+8]
	dec	edx

; 649  : 	return (i-1);

	dec	eax
	mov	DWORD PTR [ecx+8], edx
	mov	ecx, edx
	mov	BYTE PTR [ecx], 0
$L57564:
	pop	edi
	pop	esi
	pop	ebx

; 650  : }

	ret	8
?copy@StrGrow@@QAEKPBDK@Z ENDP				; StrGrow::copy
_TEXT	ENDS
PUBLIC	?path_append@StrGrow@@QAEXPBD@Z			; StrGrow::path_append
; Function compile flags: /Ogty
_TEXT	SEGMENT
_more$ = 8
?path_append@StrGrow@@QAEXPBD@Z PROC NEAR		; StrGrow::path_append
; _this$ = ecx

; 653  : {

	push	ebx
	push	esi
	mov	esi, ecx
	push	edi

; 654  : 	if (!base)

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $L57578

; 655  : 	{
; 656  : 		copy(more);

	mov	eax, DWORD PTR _more$[esp+8]
	push	eax
	call	?copy@StrGrow@@QAEXPBD@Z		; StrGrow::copy
$L58737:
	pop	edi
	pop	esi
	pop	ebx

; 686  : }

	ret	4
$L57578:
	mov	ecx, DWORD PTR [esi+12]
	mov	edi, DWORD PTR [esi+8]
	sub	ecx, edi
	mov	edi, DWORD PTR _more$[esp+8]
	cmp	ecx, 1
	jae	SHORT $L58723
	mov	ecx, edi
	call	@fstrlen@4
	mov	edx, DWORD PTR [esi+16]
	mov	ebx, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [edx+eax+1]
	sub	ebx, ecx
	push	eax
	mov	ecx, esi
	call	?realloc@MemGrow@@QAEXK@Z		; MemGrow::realloc
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [esi+4]
	add	edx, eax
	lea	ecx, DWORD PTR [eax+ebx]
	mov	DWORD PTR [esi+12], edx
	mov	DWORD PTR [esi+8], ecx
$L58723:
	mov	ecx, DWORD PTR [esi+8]
	cmp	ecx, eax
	je	SHORT $keep_copying$57584
	mov	al, BYTE PTR [ecx-1]
	cmp	al, 92					; 0000005cH
	je	SHORT $keep_copying$57584

; 657  : 		return;
; 658  : 	}
; 659  : 
; 660  : 	U32 size_left=end - cur;
; 661  : 
; 662  : 	if (size_left<1)
; 663  : 	{
; 664  : 		U32 len=fstrlen(more);
; 665  : 		realloc(inc_size+len+1);
; 666  : 	}
; 667  : 
; 668  : 	if (cur!=base)
; 669  : 	{
; 670  : 		/* if slash is missing put it in */
; 671  : 		if ((cur[-1]!=OS_SLASH) && (cur[-1]!=OS_SLASH_OTHER))

	cmp	al, 47					; 0000002fH
	je	SHORT $keep_copying$57584

; 672  : 			*cur++=OS_SLASH;

	mov	BYTE PTR [ecx], 92			; 0000005cH
	mov	eax, DWORD PTR [esi+8]
	inc	eax
	mov	DWORD PTR [esi+8], eax
$keep_copying$57584:

; 673  : 	}
; 674  : 
; 675  : keep_copying:
; 676  : 	size_left=end - cur;

	mov	ecx, DWORD PTR [esi+12]
	mov	eax, DWORD PTR [esi+8]
	sub	ecx, eax

; 677  : 	while(size_left--)

	je	SHORT $L58738
$L57586:

; 678  : 	{
; 679  : 		if (!(*cur=*more++))

	mov	eax, DWORD PTR [esi+8]
	mov	dl, BYTE PTR [edi]
	dec	ecx
	inc	edi
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR [esi+8]
	cmp	BYTE PTR [eax], 0
	je	SHORT $L58737

; 680  : 			return;
; 681  : 		cur++;

	inc	eax
	test	ecx, ecx
	mov	DWORD PTR [esi+8], eax
	jne	SHORT $L57586
$L58738:

; 682  : 	}
; 683  : 
; 684  : 	realloc(inc_size);

	mov	ebx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR [esi]
	sub	ebx, eax
	mov	eax, DWORD PTR [esi+16]
	push	eax
	mov	ecx, esi
	call	?realloc@MemGrow@@QAEXK@Z		; MemGrow::realloc
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [esi+4]
	add	edx, eax
	lea	ecx, DWORD PTR [eax+ebx]
	mov	DWORD PTR [esi+12], edx
	mov	DWORD PTR [esi+8], ecx

; 685  : 	goto keep_copying;

	jmp	SHORT $keep_copying$57584
?path_append@StrGrow@@QAEXPBD@Z ENDP			; StrGrow::path_append
_TEXT	ENDS
PUBLIC	?printf@StrGrow@@QAAKPBDZZ			; StrGrow::printf
EXTRN	__imp___vsnprintf:NEAR
; Function compile flags: /Ogty
_TEXT	SEGMENT
_str$ = 12
_this$ = 8
?printf@StrGrow@@QAAKPBDZZ PROC NEAR			; StrGrow::printf

; 690  : {

	push	ebx
	mov	ebx, DWORD PTR __imp___vsnprintf
	push	esi
	mov	esi, DWORD PTR _this$[esp+4]
	push	edi
$L57600:

; 691  : 	va_list  args;
; 692  : 	I32      num;
; 693  : 
; 694  : 	va_start(args,str);
; 695  : 
; 696  : 	while(1)
; 697  : 	{
; 698  : 		/* minus 1 for safety*/
; 699  : 		I32 size_left=end - cur - 1;

	mov	ecx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR [esi+12]
	sub	eax, ecx
	dec	eax

; 700  : 		if (size_left > 1)

	cmp	eax, 1
	jle	SHORT $L57604

; 701  : 		{
; 702  : 			num=_vsnprintf(cur,size_left-1,str,args);

	lea	edx, DWORD PTR _str$[esp+12]
	dec	eax
	push	edx
	mov	edx, DWORD PTR _str$[esp+12]
	push	edx
	push	eax
	push	ecx
	call	ebx
	add	esp, 16					; 00000010H

; 703  : 			if (num!=-1)

	cmp	eax, -1
	jne	SHORT $L58755
$L57604:

; 704  : 				break;
; 705  : 		}
; 706  : 		realloc(inc_size);

	mov	edi, DWORD PTR [esi+8]
	mov	eax, DWORD PTR [esi]
	sub	edi, eax
	mov	eax, DWORD PTR [esi+16]
	push	eax
	mov	ecx, esi
	call	?realloc@MemGrow@@QAEXK@Z		; MemGrow::realloc
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [esi+4]
	add	edx, eax
	lea	ecx, DWORD PTR [eax+edi]
	mov	DWORD PTR [esi+12], edx
	mov	DWORD PTR [esi+8], ecx
	jmp	SHORT $L57600
$L58755:

; 707  : 	}
; 708  : 	cur+=num;

	mov	ecx, DWORD PTR [esi+8]
	pop	edi
	add	ecx, eax
	mov	DWORD PTR [esi+8], ecx
	pop	esi
	pop	ebx

; 709  : 
; 710  : 	va_end(args);
; 711  : 
; 712  : 	return num;
; 713  : }

	ret	0
?printf@StrGrow@@QAAKPBDZZ ENDP				; StrGrow::printf
_TEXT	ENDS
PUBLIC	?num@StrGrow@@QAEKK@Z				; StrGrow::num
; Function compile flags: /Ogty
_TEXT	SEGMENT
_val$ = 8
?num@StrGrow@@QAEKK@Z PROC NEAR				; StrGrow::num
; _this$ = ecx

; 716  : {

	push	esi
	mov	esi, ecx

; 717  : 	I32 size_left=end - cur;

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [esi+12]
	sub	ecx, eax

; 718  : 	if (size_left < 13)

	cmp	ecx, 13					; 0000000dH
	jge	SHORT $L58758

; 719  : 		realloc(inc_size,13);

	mov	edx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+16]
	sub	eax, edx
	push	edi
	cmp	ecx, 13					; 0000000dH
	mov	edi, eax
	jae	SHORT $L58760
	mov	ecx, 13					; 0000000dH
$L58760:
	push	ecx
	mov	ecx, esi
	call	?realloc@MemGrow@@QAEXK@Z		; MemGrow::realloc
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+4]
	add	ecx, eax
	lea	edx, DWORD PTR [eax+edi]
	mov	DWORD PTR [esi+12], ecx
	mov	DWORD PTR [esi+8], edx
	pop	edi
$L58758:

; 720  : 
; 721  : 	U32 ret=futoa(val,cur);

	mov	edx, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR _val$[esp]
	call	@futoa@8

; 722  : 	cur+=ret;

	mov	ecx, DWORD PTR [esi+8]
	add	ecx, eax
	mov	DWORD PTR [esi+8], ecx
	pop	esi

; 723  : 	return ret;
; 724  : }

	ret	4
?num@StrGrow@@QAEKK@Z ENDP				; StrGrow::num
_TEXT	ENDS
PUBLIC	?num@StrGrow@@QAEKJ@Z				; StrGrow::num
; Function compile flags: /Ogty
_TEXT	SEGMENT
_val$ = 8
?num@StrGrow@@QAEKJ@Z PROC NEAR				; StrGrow::num
; _this$ = ecx

; 727  : {

	push	esi
	mov	esi, ecx

; 728  : 	I32 size_left=end - cur;

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [esi+12]
	sub	ecx, eax

; 729  : 	if (size_left < 13)

	cmp	ecx, 13					; 0000000dH
	jge	SHORT $L58765

; 730  : 		realloc(inc_size,13);

	mov	edx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+16]
	sub	eax, edx
	push	edi
	cmp	ecx, 13					; 0000000dH
	mov	edi, eax
	jae	SHORT $L58767
	mov	ecx, 13					; 0000000dH
$L58767:
	push	ecx
	mov	ecx, esi
	call	?realloc@MemGrow@@QAEXK@Z		; MemGrow::realloc
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+4]
	add	ecx, eax
	lea	edx, DWORD PTR [eax+edi]
	mov	DWORD PTR [esi+12], ecx
	mov	DWORD PTR [esi+8], edx
	pop	edi
$L58765:

; 731  : 	
; 732  : 	U32 ret=fitoa(val,cur);

	mov	edx, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR _val$[esp]
	call	@fitoa@8

; 733  : 	cur+=ret;

	mov	ecx, DWORD PTR [esi+8]
	add	ecx, eax
	mov	DWORD PTR [esi+8], ecx
	pop	esi

; 734  : 	return ret;
; 735  : }

	ret	4
?num@StrGrow@@QAEKJ@Z ENDP				; StrGrow::num
_TEXT	ENDS
PUBLIC	?chr@StrGrow@@QAEKD@Z				; StrGrow::chr
; Function compile flags: /Ogty
_TEXT	SEGMENT
_key$ = 8
?chr@StrGrow@@QAEKD@Z PROC NEAR				; StrGrow::chr
; _this$ = ecx

; 738  : {

	push	esi
	mov	esi, ecx

; 739  : 	I32 size_left=end - cur;

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [esi+12]
	sub	ecx, eax

; 740  : 	if (size_left < 1)

	cmp	ecx, 1
	jge	SHORT $L58772

; 741  : 		realloc(inc_size,1);

	mov	edx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+16]
	sub	eax, edx
	push	edi
	cmp	ecx, 1
	mov	edi, eax
	jae	SHORT $L58774
	mov	ecx, 1
$L58774:
	push	ecx
	mov	ecx, esi
	call	?realloc@MemGrow@@QAEXK@Z		; MemGrow::realloc
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+4]
	add	ecx, eax
	lea	edx, DWORD PTR [eax+edi]
	mov	DWORD PTR [esi+12], ecx
	mov	DWORD PTR [esi+8], edx
	pop	edi
$L58772:

; 742  : 
; 743  : 	*cur++=key;

	mov	edx, DWORD PTR [esi+8]
	mov	al, BYTE PTR _key$[esp]
	mov	BYTE PTR [edx], al
	mov	eax, DWORD PTR [esi+8]
	inc	eax
	mov	DWORD PTR [esi+8], eax
	mov	esi, eax

; 744  : 	*cur=0;
; 745  : 	return 1;

	mov	eax, 1
	mov	BYTE PTR [esi], 0
	pop	esi

; 746  : }

	ret	4
?chr@StrGrow@@QAEKD@Z ENDP				; StrGrow::chr
_TEXT	ENDS
PUBLIC	@fset_extension@8
EXTRN	@xxx_throw@4:NEAR
_DATA	SEGMENT
	ORG $+2
$SG57643 DB	'fset_extension: invalid path to set extension', 00H
; Function compile flags: /Ogty
_DATA	ENDS
_TEXT	SEGMENT
@fset_extension@8 PROC NEAR
; _path$ = ecx
; _the_ext$ = edx

; 749  : {

	push	ebx
	push	esi
	push	edi
	mov	ebx, edx
	mov	esi, ecx

; 750  : 	U32 size=fstrlen(path);

	call	@fstrlen@4
	mov	edi, eax

; 751  : 	char *ext;
; 752  : 
; 753  : 	for (U32 i=size-1;i>0;i--)

	lea	edx, DWORD PTR [edi-1]
	mov	ecx, edx
	test	ecx, ecx
	jbe	SHORT $L57642
$L57633:

; 754  : 	{
; 755  : 		char key=path[i];

	mov	al, BYTE PTR [ecx+esi]

; 756  : 
; 757  : 		if (key=='.')

	cmp	al, 46					; 0000002eH
	je	SHORT $L58779

; 760  : 			goto found;
; 761  : 		}
; 762  : 		/* if we get to a slash before the '.' */
; 763  : 		if ((key=='\\') || (key=='/'))

	cmp	al, 92					; 0000005cH
	je	SHORT $L58780
	cmp	al, 47					; 0000002fH
	je	SHORT $L58780

; 751  : 	char *ext;
; 752  : 
; 753  : 	for (U32 i=size-1;i>0;i--)

	dec	ecx
	jne	SHORT $L57633

; 767  : 			break;
; 768  : 		}
; 769  : 	}
; 770  : 	ext=path+size;

	lea	ecx, DWORD PTR [edi+esi]
	pop	edi

; 771  : 	*ext++='.';
; 772  : found:
; 773  : 	return fstrcpy(ext,the_ext);

	mov	edx, ebx
	pop	esi
	mov	BYTE PTR [ecx], 46			; 0000002eH
	inc	ecx
	pop	ebx
	jmp	@fstrcpy@8
$L58779:

; 758  : 		{
; 759  : 			ext=path+i+1;

	lea	ecx, DWORD PTR [ecx+esi+1]
	pop	edi

; 771  : 	*ext++='.';
; 772  : found:
; 773  : 	return fstrcpy(ext,the_ext);

	mov	edx, ebx
	pop	esi
	pop	ebx
	jmp	@fstrcpy@8
$L58780:

; 764  : 		{
; 765  : 			if (i==(size-1))

	cmp	ecx, edx
	jne	SHORT $L57642

; 766  : 				xxx_throw("fset_extension: invalid path to set extension");

	mov	ecx, OFFSET FLAT:$SG57643
	call	@xxx_throw@4
$L57642:

; 767  : 			break;
; 768  : 		}
; 769  : 	}
; 770  : 	ext=path+size;

	lea	ecx, DWORD PTR [edi+esi]
	pop	edi

; 771  : 	*ext++='.';
; 772  : found:
; 773  : 	return fstrcpy(ext,the_ext);

	mov	edx, ebx
	pop	esi
	mov	BYTE PTR [ecx], 46			; 0000002eH
	inc	ecx
$found$57638:
	pop	ebx
	jmp	@fstrcpy@8
@fset_extension@8 ENDP
; Function compile flags: /Ogty
; File C:\duke4\xcore\xclass.h
_TEXT	ENDS
;	COMDAT ??1CSysObj@@QAE@XZ
_TEXT	SEGMENT
??1CSysObj@@QAE@XZ PROC NEAR				; CSysObj::~CSysObj, COMDAT
; _this$ = ecx

; 1470 : inline CSysObj::~CSysObj(void){_global->unreg_global_object(this);}

	mov	DWORD PTR [ecx], OFFSET FLAT:??_7CSysObj@@6B@ ; CSysObj::`vftable'
	push	ecx
	mov	ecx, DWORD PTR ?_global@@3PAVXGlobal@@A	; _global
	call	?unreg_global_object@XGlobal@@QAEXPAVCSysObj@@@Z ; XGlobal::unreg_global_object
	ret	0
??1CSysObj@@QAE@XZ ENDP					; CSysObj::~CSysObj
_TEXT	ENDS
PUBLIC	@fget_extension@4
; Function compile flags: /Ogty
; File C:\duke4\xcore\string.cpp
_TEXT	SEGMENT
@fget_extension@4 PROC NEAR
; _path$ = ecx

; 777  : {

	push	esi
	mov	esi, ecx

; 778  : 	U32 size=fstrlen(path);

	call	@fstrlen@4

; 779  : 
; 780  : 	for (U32 i=size-1;i>0;i--)

	lea	edx, DWORD PTR [eax-1]
	test	edx, edx
	jbe	SHORT $L57651
$L57649:

; 781  : 	{
; 782  : 		char key=path[i];

	mov	cl, BYTE PTR [edx+esi]

; 783  : 
; 784  : 		if (key=='.')

	cmp	cl, 46					; 0000002eH
	je	SHORT $L58787

; 789  : 		}
; 790  : 		/* if we get to a slash before the '.' */
; 791  : 		if ((key=='\\') || (key=='/'))

	cmp	cl, 92					; 0000005cH
	je	SHORT $L57651
	cmp	cl, 47					; 0000002fH
	je	SHORT $L57651

; 779  : 
; 780  : 	for (U32 i=size-1;i>0;i--)

	dec	edx
	jne	SHORT $L57649
$L57651:

; 792  : 			return null;
; 793  : 	}
; 794  : 	return null;

	xor	eax, eax
	pop	esi

; 795  : }

	ret	0
$L58787:

; 785  : 		{
; 786  : 			if (i==size)

	cmp	edx, eax

; 787  : 				return null;

	je	SHORT $L57651

; 788  : 			return path+i+1;

	lea	eax, DWORD PTR [edx+esi+1]
	pop	esi

; 795  : }

	ret	0
@fget_extension@4 ENDP
_TEXT	ENDS
PUBLIC	@fget_filename@4
; Function compile flags: /Ogty
_TEXT	SEGMENT
@fget_filename@4 PROC NEAR
; _path$ = ecx

; 798  : {

	push	esi
	mov	esi, ecx

; 799  : 	U32 size=fstrlen(path);

	call	@fstrlen@4

; 800  : 
; 801  : 	for (U32 i=size;i>0;i--)

	test	eax, eax
	mov	edx, eax
	jbe	SHORT $L57664
$L57662:

; 802  : 	{
; 803  : 		char key=path[i];

	mov	cl, BYTE PTR [edx+esi]

; 804  : 
; 805  : 		if ((key=='\\') || (key=='/'))

	cmp	cl, 92					; 0000005cH
	je	SHORT $L58792
	cmp	cl, 47					; 0000002fH
	je	SHORT $L58792

; 800  : 
; 801  : 	for (U32 i=size;i>0;i--)

	dec	edx
	jne	SHORT $L57662
$L57664:

; 810  : 		}
; 811  : 	}
; 812  : 	return path;

	mov	eax, esi
	pop	esi

; 813  : }

	ret	0
$L58792:

; 806  : 		{
; 807  : 			if (i==size)

	cmp	edx, eax
	jne	SHORT $L57668

; 808  : 				return null;

	xor	eax, eax
	pop	esi

; 813  : }

	ret	0
$L57668:

; 809  : 			return path+i+1;

	lea	eax, DWORD PTR [edx+esi+1]
	pop	esi

; 813  : }

	ret	0
@fget_filename@4 ENDP
_TEXT	ENDS
PUBLIC	@fpath_append@8
; Function compile flags: /Ogty
_TEXT	SEGMENT
@fpath_append@8 PROC NEAR
; _path$ = ecx
; _more$ = edx

; 816  : {

	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	ebx, edx
	mov	esi, ecx

; 817  : 	U32 len1,len2;
; 818  : 
; 819  : 	len1=fstrlen(path);

	call	@fstrlen@4

; 820  : 	len2=fstrlen(more);

	mov	ecx, ebx
	mov	edi, eax
	call	@fstrlen@4

; 821  : 
; 822  : 	char *str=(char *)xmalloc(len1+len2+2);

	lea	ecx, DWORD PTR [eax+edi+2]
	call	@xmalloc@4
	mov	ebp, eax

; 823  : 
; 824  : 	char *cur=fstrcpy(str,path);

	mov	edx, esi
	mov	ecx, ebp
	call	@fstrcpy@8

; 825  : 	if ((path[len1-1]=='\\')||(path[len1-1]=='/'))

	mov	cl, BYTE PTR [edi+esi-1]
	cmp	cl, 92					; 0000005cH
	je	SHORT $L57679
	cmp	cl, 47					; 0000002fH
	je	SHORT $L57679

; 827  : 	else
; 828  : 	{
; 829  : 		*cur++=OS_SLASH;

	lea	ecx, DWORD PTR [eax+1]
	mov	edx, ebx
	mov	BYTE PTR [eax], 92			; 0000005cH
	call	@fstrcpy@8

; 830  : 		cur=fstrcpy(cur,more);
; 831  : 	}
; 832  : 	return str;

	mov	eax, ebp
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 833  : }

	ret	0
$L57679:

; 826  : 		fstrcpy(cur,more);

	mov	ecx, eax
	mov	edx, ebx
	call	@fstrcpy@8

; 830  : 		cur=fstrcpy(cur,more);
; 831  : 	}
; 832  : 	return str;

	mov	eax, ebp
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 833  : }

	ret	0
@fpath_append@8 ENDP
_TEXT	ENDS
PUBLIC	??0?$XChain@VCSysObj@@@@QAE@XZ			; XChain<CSysObj>::XChain<CSysObj>
; Function compile flags: /Ogty
; File C:\duke4\xcore\xclass.h
;	COMDAT ??0?$XChain@VCSysObj@@@@QAE@XZ
_TEXT	SEGMENT
??0?$XChain@VCSysObj@@@@QAE@XZ PROC NEAR		; XChain<CSysObj>::XChain<CSysObj>, COMDAT
; _this$ = ecx

; 830  : 	XChain(void) : head(null),tail(null) {}

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$XChain@VCSysObj@@@@QAE@XZ ENDP			; XChain<CSysObj>::XChain<CSysObj>
_TEXT	ENDS
PUBLIC	??0?$XChain@VCSysObj@@@@QAE@K@Z			; XChain<CSysObj>::XChain<CSysObj>
; Function compile flags: /Ogty
;	COMDAT ??0?$XChain@VCSysObj@@@@QAE@K@Z
_TEXT	SEGMENT
_owned$ = 8
??0?$XChain@VCSysObj@@@@QAE@K@Z PROC NEAR		; XChain<CSysObj>::XChain<CSysObj>, COMDAT
; _this$ = ecx

; 831  : 	XChain(U32 owned) : head(null),tail(null),xchain_state(owned) {}

	mov	eax, ecx
	mov	ecx, DWORD PTR _owned$[esp-4]
	shl	ecx, 31					; 0000001fH
	and	ecx, -2147483648			; 80000000H
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], ecx
	ret	4
??0?$XChain@VCSysObj@@@@QAE@K@Z ENDP			; XChain<CSysObj>::XChain<CSysObj>
_TEXT	ENDS
PUBLIC	?get_next@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z ; XChain<CSysObj>::get_next
; Function compile flags: /Ogty
;	COMDAT ?get_next@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z
_TEXT	SEGMENT
_ptr$ = 8
?get_next@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z PROC NEAR ; XChain<CSysObj>::get_next, COMDAT
; _this$ = ecx

; 840  : 	TYPE *get_next(TYPE *ptr){return ptr->next;}

	mov	eax, DWORD PTR _ptr$[esp-4]
	mov	eax, DWORD PTR [eax+4]
	ret	4
?get_next@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z ENDP ; XChain<CSysObj>::get_next
_TEXT	ENDS
PUBLIC	?get_prev@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z ; XChain<CSysObj>::get_prev
; Function compile flags: /Ogty
;	COMDAT ?get_prev@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z
_TEXT	SEGMENT
_ptr$ = 8
?get_prev@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z PROC NEAR ; XChain<CSysObj>::get_prev, COMDAT
; _this$ = ecx

; 841  : 	TYPE *get_prev(TYPE *ptr){return ptr->prev;}

	mov	eax, DWORD PTR _ptr$[esp-4]
	mov	eax, DWORD PTR [eax+8]
	ret	4
?get_prev@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z ENDP ; XChain<CSysObj>::get_prev
_TEXT	ENDS
PUBLIC	?get_head@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ ; XChain<CSysObj>::get_head
; Function compile flags: /Ogty
;	COMDAT ?get_head@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ
_TEXT	SEGMENT
?get_head@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ PROC NEAR ; XChain<CSysObj>::get_head, COMDAT
; _this$ = ecx

; 847  : 	inline TYPE *get_head(void){return head;}

	mov	eax, DWORD PTR [ecx]
	ret	0
?get_head@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ ENDP	; XChain<CSysObj>::get_head
_TEXT	ENDS
PUBLIC	?get_tail@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ ; XChain<CSysObj>::get_tail
; Function compile flags: /Ogty
;	COMDAT ?get_tail@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ
_TEXT	SEGMENT
?get_tail@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ PROC NEAR ; XChain<CSysObj>::get_tail, COMDAT
; _this$ = ecx

; 848  : 	inline TYPE *get_tail(void){return tail;}

	mov	eax, DWORD PTR [ecx+4]
	ret	0
?get_tail@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ ENDP	; XChain<CSysObj>::get_tail
_TEXT	ENDS
PUBLIC	??1?$XChain@VCSysObj@@@@QAE@XZ			; XChain<CSysObj>::~XChain<CSysObj>
; Function compile flags: /Ogty
;	COMDAT ??1?$XChain@VCSysObj@@@@QAE@XZ
_TEXT	SEGMENT
??1?$XChain@VCSysObj@@@@QAE@XZ PROC NEAR		; XChain<CSysObj>::~XChain<CSysObj>, COMDAT
; _this$ = ecx

; 853  : {

	push	esi
	mov	esi, ecx

; 854  : 	if (xchain_state.owned)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	jns	SHORT $L58838

; 855  : 	{
; 856  : 		while(head)

	cmp	DWORD PTR [esi], 0
	je	SHORT $L58838
	push	ebx
	push	edi
$L57766:

; 857  : 		{
; 858  : 			TYPE *tmp=(TYPE *)head->next;

	mov	eax, DWORD PTR [esi]

; 859  : 			delete head;

	mov	edi, eax
	mov	ebx, DWORD PTR [eax+4]
	test	edi, edi
	je	SHORT $L58819
	mov	DWORD PTR [edi], OFFSET FLAT:??_7CSysObj@@6B@ ; CSysObj::`vftable'
	mov	ecx, DWORD PTR ?_global@@3PAVXGlobal@@A	; _global
	push	edi
	call	?unreg_global_object@XGlobal@@QAEXPAVCSysObj@@@Z ; XGlobal::unreg_global_object
	mov	ecx, edi
	call	@xfree@4
$L58819:
	test	ebx, ebx

; 860  : 			head=tmp;

	mov	DWORD PTR [esi], ebx
	jne	SHORT $L57766
	pop	edi
	pop	ebx
$L58838:

; 861  : 		}
; 862  : 	}
; 863  : 	head=null;

	mov	DWORD PTR [esi], 0

; 864  : 	tail=null;

	mov	DWORD PTR [esi+4], 0
	pop	esi

; 865  : }

	ret	0
??1?$XChain@VCSysObj@@@@QAE@XZ ENDP			; XChain<CSysObj>::~XChain<CSysObj>
_TEXT	ENDS
PUBLIC	?lose_list@?$XChain@VCSysObj@@@@QAEXXZ		; XChain<CSysObj>::lose_list
; Function compile flags: /Ogty
;	COMDAT ?lose_list@?$XChain@VCSysObj@@@@QAEXXZ
_TEXT	SEGMENT
?lose_list@?$XChain@VCSysObj@@@@QAEXXZ PROC NEAR	; XChain<CSysObj>::lose_list, COMDAT
; _this$ = ecx

; 870  : 	head=null;tail=null;xchain_state.count=0;

	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [ecx], 0
	and	eax, -2147483648			; 80000000H
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], eax

; 871  : }

	ret	0
?lose_list@?$XChain@VCSysObj@@@@QAEXXZ ENDP		; XChain<CSysObj>::lose_list
_TEXT	ENDS
PUBLIC	?free_list@?$XChain@VCSysObj@@@@QAEXXZ		; XChain<CSysObj>::free_list
; Function compile flags: /Ogty
;	COMDAT ?free_list@?$XChain@VCSysObj@@@@QAEXXZ
_TEXT	SEGMENT
?free_list@?$XChain@VCSysObj@@@@QAEXXZ PROC NEAR	; XChain<CSysObj>::free_list, COMDAT
; _this$ = ecx

; 875  : {

	push	esi
	mov	esi, ecx

; 876  : 	if (xchain_state.owned)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	jns	SHORT $L58864

; 877  : 	{
; 878  : 		while(head)

	cmp	DWORD PTR [esi], 0
	je	SHORT $L58864
	push	ebx
	push	edi
$L57782:

; 879  : 		{
; 880  : 			TYPE *tmp=(TYPE *)head->next;

	mov	eax, DWORD PTR [esi]

; 881  : 			delete head;

	mov	edi, eax
	mov	ebx, DWORD PTR [eax+4]
	test	edi, edi
	je	SHORT $L58845
	mov	DWORD PTR [edi], OFFSET FLAT:??_7CSysObj@@6B@ ; CSysObj::`vftable'
	mov	ecx, DWORD PTR ?_global@@3PAVXGlobal@@A	; _global
	push	edi
	call	?unreg_global_object@XGlobal@@QAEXPAVCSysObj@@@Z ; XGlobal::unreg_global_object
	mov	ecx, edi
	call	@xfree@4
$L58845:
	test	ebx, ebx

; 882  : 			head=tmp;

	mov	DWORD PTR [esi], ebx
	jne	SHORT $L57782
	pop	edi
	pop	ebx
$L58864:

; 883  : 		}
; 884  : 	}
; 885  : 	head=null;tail=null;

	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+4], 0
	pop	esi

; 886  : }

	ret	0
?free_list@?$XChain@VCSysObj@@@@QAEXXZ ENDP		; XChain<CSysObj>::free_list
_TEXT	ENDS
PUBLIC	?add_head@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z ; XChain<CSysObj>::add_head
; Function compile flags: /Ogty
;	COMDAT ?add_head@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z
_TEXT	SEGMENT
_ptr$ = 8
?add_head@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z PROC NEAR ; XChain<CSysObj>::add_head, COMDAT
; _this$ = ecx

; 891  : 	ptr->next=head;

	mov	eax, DWORD PTR _ptr$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx

; 892  : 	ptr->prev=null;

	mov	DWORD PTR [eax+8], 0

; 893  : 	if (head)

	mov	edx, DWORD PTR [ecx]
	test	edx, edx
	je	SHORT $L57792

; 894  : 		head->prev=ptr;

	mov	DWORD PTR [edx+8], eax

; 897  : 	
; 898  : 	head=ptr;

	mov	DWORD PTR [ecx], eax

; 899  : 
; 900  : 	return head;
; 901  : }

	ret	4
$L57792:

; 895  : 	else
; 896  : 		tail=ptr;

	mov	DWORD PTR [ecx+4], eax

; 897  : 	
; 898  : 	head=ptr;

	mov	DWORD PTR [ecx], eax

; 899  : 
; 900  : 	return head;
; 901  : }

	ret	4
?add_head@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z ENDP ; XChain<CSysObj>::add_head
_TEXT	ENDS
PUBLIC	?add_tail@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z ; XChain<CSysObj>::add_tail
; Function compile flags: /Ogty
;	COMDAT ?add_tail@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z
_TEXT	SEGMENT
_ptr$ = 8
?add_tail@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z PROC NEAR ; XChain<CSysObj>::add_tail, COMDAT
; _this$ = ecx

; 906  : 	ptr->prev=tail;

	mov	eax, DWORD PTR _ptr$[esp-4]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+8], edx

; 907  : 	ptr->next=null;

	mov	DWORD PTR [eax+4], 0

; 908  : 	if (tail)

	mov	edx, DWORD PTR [ecx+4]
	test	edx, edx
	je	SHORT $L57798

; 909  : 		tail->next=ptr;

	mov	DWORD PTR [edx+4], eax

; 912  : 	
; 913  : 	tail=ptr;

	mov	DWORD PTR [ecx+4], eax

; 914  : 
; 915  : 	return tail;
; 916  : }

	ret	4
$L57798:

; 910  : 	else
; 911  : 		head=ptr;

	mov	DWORD PTR [ecx], eax

; 912  : 	
; 913  : 	tail=ptr;

	mov	DWORD PTR [ecx+4], eax

; 914  : 
; 915  : 	return tail;
; 916  : }

	ret	4
?add_tail@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z ENDP ; XChain<CSysObj>::add_tail
; Function compile flags: /Ogty
; File C:\duke4\xcore\xstring.h
_TEXT	ENDS
;	COMDAT ??1TmpPrintf@@QAE@XZ
_TEXT	SEGMENT
??1TmpPrintf@@QAE@XZ PROC NEAR				; TmpPrintf::~TmpPrintf, COMDAT
; _this$ = ecx

; 290  : 	__inline ~TmpPrintf(void){release_printf(ptr);}

	mov	eax, DWORD PTR [ecx]
	push	eax
	call	?release_printf@@YAXPAVCPrintfT@@@Z	; release_printf
	pop	ecx
	ret	0
??1TmpPrintf@@QAE@XZ ENDP				; TmpPrintf::~TmpPrintf
_TEXT	ENDS
PUBLIC	?remove_head@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ ; XChain<CSysObj>::remove_head
; Function compile flags: /Ogty
; File C:\duke4\xcore\xclass.h
;	COMDAT ?remove_head@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ
_TEXT	SEGMENT
?remove_head@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ PROC NEAR ; XChain<CSysObj>::remove_head, COMDAT
; _this$ = ecx

; 937  : 	if (!head)

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	jne	SHORT $L57804

; 947  : 
; 948  : 	return ret;
; 949  : }

	ret	0
$L57804:

; 938  : 		return null;
; 939  : 
; 940  : 	TYPE *ret=head;
; 941  : 
; 942  : 	head=head->next;

	mov	edx, DWORD PTR [eax+4]

; 943  : 	if (!head)

	test	edx, edx
	mov	DWORD PTR [ecx], edx
	jne	SHORT $L57806

; 944  : 		tail=null;

	mov	DWORD PTR [ecx+4], edx

; 947  : 
; 948  : 	return ret;
; 949  : }

	ret	0
$L57806:

; 945  : 	else
; 946  : 		head->prev=null;

	mov	DWORD PTR [edx+8], 0

; 947  : 
; 948  : 	return ret;
; 949  : }

	ret	0
?remove_head@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ ENDP ; XChain<CSysObj>::remove_head
_TEXT	ENDS
PUBLIC	?remove_tail@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ ; XChain<CSysObj>::remove_tail
; Function compile flags: /Ogty
;	COMDAT ?remove_tail@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ
_TEXT	SEGMENT
?remove_tail@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ PROC NEAR ; XChain<CSysObj>::remove_tail, COMDAT
; _this$ = ecx

; 954  : 	if (!tail)

	mov	eax, DWORD PTR [ecx+4]
	test	eax, eax
	jne	SHORT $L57812

; 964  : 
; 965  : 	return ret;
; 966  : }

	ret	0
$L57812:

; 955  : 		return null;
; 956  : 
; 957  : 	TYPE *ret=tail;
; 958  : 
; 959  : 	tail=tail->prev;

	mov	edx, DWORD PTR [eax+8]

; 960  : 	if (!tail)

	test	edx, edx
	mov	DWORD PTR [ecx+4], edx
	jne	SHORT $L57814

; 961  : 		head=null;

	mov	DWORD PTR [ecx], edx

; 964  : 
; 965  : 	return ret;
; 966  : }

	ret	0
$L57814:

; 962  : 	else
; 963  : 		tail->next=null;

	mov	DWORD PTR [edx+4], 0

; 964  : 
; 965  : 	return ret;
; 966  : }

	ret	0
?remove_tail@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ ENDP ; XChain<CSysObj>::remove_tail
_TEXT	ENDS
PUBLIC	?remove@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z ; XChain<CSysObj>::remove
; Function compile flags: /Ogty
;	COMDAT ?remove@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z
_TEXT	SEGMENT
_ptr$ = 8
?remove@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z PROC NEAR ; XChain<CSysObj>::remove, COMDAT
; _this$ = ecx

; 921  : 	if (ptr->prev)

	mov	eax, DWORD PTR _ptr$[esp-4]
	mov	edx, DWORD PTR [eax+8]
	test	edx, edx
	je	SHORT $L57820
	push	esi

; 922  : 		ptr->prev->next=ptr->next;

	mov	esi, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], esi
	pop	esi

; 923  : 	else

	jmp	SHORT $L57821
$L57820:

; 924  : 		head=ptr->next;

	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx], edx
$L57821:

; 925  : 
; 926  : 	if (ptr->next)

	mov	edx, DWORD PTR [eax+4]
	test	edx, edx
	je	SHORT $L57822

; 927  : 		ptr->next->prev=ptr->prev;

	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], ecx

; 930  : 
; 931  : 	return ptr;
; 932  : }

	ret	4
$L57822:

; 928  : 	else
; 929  : 		tail=ptr->prev;

	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+4], edx

; 930  : 
; 931  : 	return ptr;
; 932  : }

	ret	4
?remove@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z ENDP ; XChain<CSysObj>::remove
_TEXT	ENDS
PUBLIC	??_7XBufferReadInt@@6B@				; XBufferReadInt::`vftable'
PUBLIC	??_GXBufferReadInt@@UAEPAXI@Z			; XBufferReadInt::`scalar deleting destructor'
PUBLIC	??_EXBufferReadInt@@UAEPAXI@Z			; XBufferReadInt::`vector deleting destructor'
EXTRN	?read_direct@XBufferReadInt@@MAEKPAXKAAK@Z:NEAR	; XBufferReadInt::read_direct
;	COMDAT ??_7XBufferReadInt@@6B@
; File C:\duke4\xcore\xcore.h
CONST	SEGMENT
??_7XBufferReadInt@@6B@ DD FLAT:?read_direct@XBufferReadInt@@MAEKPAXKAAK@Z ; XBufferReadInt::`vftable'
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:??_EXBufferReadInt@@UAEPAXI@Z
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ??_GXBufferReadInt@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_GXBufferReadInt@@UAEPAXI@Z PROC NEAR			; XBufferReadInt::`scalar deleting destructor', COMDAT
; _this$ = ecx
	mov	al, BYTE PTR ___flags$[esp-4]
	push	esi
	mov	esi, ecx
	test	al, 1
	mov	DWORD PTR [esi], OFFSET FLAT:??_7XBufferReadInt@@6B@ ; XBufferReadInt::`vftable'
	je	SHORT $L58887
	call	@xfree@4
$L58887:
	mov	eax, esi
	pop	esi
	ret	4
??_GXBufferReadInt@@UAEPAXI@Z ENDP			; XBufferReadInt::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??1XBufferReadInt@@UAE@XZ			; XBufferReadInt::~XBufferReadInt
EXTRN	??_M@YGXPAXIHP6EX0@Z@Z:NEAR			; `eh vector destructor iterator'
; Function compile flags: /Ogty
;	COMDAT ??_EXBufferReadInt@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_EXBufferReadInt@@UAEPAXI@Z PROC NEAR			; XBufferReadInt::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebx
	mov	bl, BYTE PTR ___flags$[esp]
	push	esi
	mov	esi, ecx
	test	bl, 2
	je	SHORT $L56059
	mov	eax, DWORD PTR [esi-4]
	push	edi
	lea	edi, DWORD PTR [esi-4]
	push	OFFSET FLAT:??1XBufferReadInt@@UAE@XZ	; XBufferReadInt::~XBufferReadInt
	push	eax
	push	8
	push	esi
	call	??_M@YGXPAXIHP6EX0@Z@Z			; `eh vector destructor iterator'
	test	bl, 1
	je	SHORT $L58892
	mov	ecx, edi
	call	@xfree@4
$L58892:
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	ret	4
$L56059:
	test	bl, 1
	mov	DWORD PTR [esi], OFFSET FLAT:??_7XBufferReadInt@@6B@ ; XBufferReadInt::`vftable'
	je	SHORT $L58897
	mov	ecx, esi
	call	@xfree@4
$L58897:
	mov	eax, esi
	pop	esi
	pop	ebx
	ret	4
??_EXBufferReadInt@@UAEPAXI@Z ENDP			; XBufferReadInt::`vector deleting destructor'
; Function compile flags: /Ogty
; File C:\duke4\xcore\xstream.h
_TEXT	ENDS
;	COMDAT ??1XBufferReadInt@@UAE@XZ
_TEXT	SEGMENT
??1XBufferReadInt@@UAE@XZ PROC NEAR			; XBufferReadInt::~XBufferReadInt, COMDAT
; _this$ = ecx

; 37   : 	virtual ~XBufferReadInt(void){}

	mov	DWORD PTR [ecx], OFFSET FLAT:??_7XBufferReadInt@@6B@ ; XBufferReadInt::`vftable'
	ret	0
??1XBufferReadInt@@UAE@XZ ENDP				; XBufferReadInt::~XBufferReadInt
_TEXT	ENDS
PUBLIC	??_7XBufferWriteInt@@6B@			; XBufferWriteInt::`vftable'
PUBLIC	??_GXBufferWriteInt@@UAEPAXI@Z			; XBufferWriteInt::`scalar deleting destructor'
PUBLIC	??_EXBufferWriteInt@@UAEPAXI@Z			; XBufferWriteInt::`vector deleting destructor'
EXTRN	?write_direct@XBufferWriteInt@@MAEKPBXKAAK@Z:NEAR ; XBufferWriteInt::write_direct
;	COMDAT ??_7XBufferWriteInt@@6B@
; File C:\duke4\xcore\xcore.h
CONST	SEGMENT
??_7XBufferWriteInt@@6B@ DD FLAT:?write_direct@XBufferWriteInt@@MAEKPBXKAAK@Z ; XBufferWriteInt::`vftable'
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:??_EXBufferWriteInt@@UAEPAXI@Z
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ??_GXBufferWriteInt@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_GXBufferWriteInt@@UAEPAXI@Z PROC NEAR		; XBufferWriteInt::`scalar deleting destructor', COMDAT
; _this$ = ecx
	mov	al, BYTE PTR ___flags$[esp-4]
	push	esi
	mov	esi, ecx
	test	al, 1
	mov	DWORD PTR [esi], OFFSET FLAT:??_7XBufferWriteInt@@6B@ ; XBufferWriteInt::`vftable'
	je	SHORT $L58909
	call	@xfree@4
$L58909:
	mov	eax, esi
	pop	esi
	ret	4
??_GXBufferWriteInt@@UAEPAXI@Z ENDP			; XBufferWriteInt::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??1XBufferWriteInt@@UAE@XZ			; XBufferWriteInt::~XBufferWriteInt
; Function compile flags: /Ogty
;	COMDAT ??_EXBufferWriteInt@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_EXBufferWriteInt@@UAEPAXI@Z PROC NEAR		; XBufferWriteInt::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebx
	mov	bl, BYTE PTR ___flags$[esp]
	push	esi
	mov	esi, ecx
	test	bl, 2
	je	SHORT $L56111
	mov	eax, DWORD PTR [esi-4]
	push	edi
	lea	edi, DWORD PTR [esi-4]
	push	OFFSET FLAT:??1XBufferWriteInt@@UAE@XZ	; XBufferWriteInt::~XBufferWriteInt
	push	eax
	push	8
	push	esi
	call	??_M@YGXPAXIHP6EX0@Z@Z			; `eh vector destructor iterator'
	test	bl, 1
	je	SHORT $L58913
	mov	ecx, edi
	call	@xfree@4
$L58913:
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	ret	4
$L56111:
	test	bl, 1
	mov	DWORD PTR [esi], OFFSET FLAT:??_7XBufferWriteInt@@6B@ ; XBufferWriteInt::`vftable'
	je	SHORT $L58919
	mov	ecx, esi
	call	@xfree@4
$L58919:
	mov	eax, esi
	pop	esi
	pop	ebx
	ret	4
??_EXBufferWriteInt@@UAEPAXI@Z ENDP			; XBufferWriteInt::`vector deleting destructor'
; Function compile flags: /Ogty
; File C:\duke4\xcore\xstream.h
_TEXT	ENDS
;	COMDAT ??1XBufferWriteInt@@UAE@XZ
_TEXT	SEGMENT
??1XBufferWriteInt@@UAE@XZ PROC NEAR			; XBufferWriteInt::~XBufferWriteInt, COMDAT
; _this$ = ecx

; 56   : 	virtual ~XBufferWriteInt(void){}

	mov	DWORD PTR [ecx], OFFSET FLAT:??_7XBufferWriteInt@@6B@ ; XBufferWriteInt::`vftable'
	ret	0
??1XBufferWriteInt@@UAE@XZ ENDP				; XBufferWriteInt::~XBufferWriteInt
_TEXT	ENDS
PUBLIC	??1XStreamRdDirect@@UAE@XZ			; XStreamRdDirect::~XStreamRdDirect
PUBLIC	??_GXStreamRdDirect@@UAEPAXI@Z			; XStreamRdDirect::`scalar deleting destructor'
; Function compile flags: /Ogty
;	COMDAT ??_GXStreamRdDirect@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_GXStreamRdDirect@@UAEPAXI@Z PROC NEAR		; XStreamRdDirect::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1XStreamRdDirect@@UAE@XZ		; XStreamRdDirect::~XStreamRdDirect
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $L58928
	mov	ecx, esi
	call	@xfree@4
$L58928:
	mov	eax, esi
	pop	esi
	ret	4
??_GXStreamRdDirect@@UAEPAXI@Z ENDP			; XStreamRdDirect::`scalar deleting destructor'
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??1XStreamRdDirect@@UAE@XZ
_TEXT	SEGMENT
??1XStreamRdDirect@@UAE@XZ PROC NEAR			; XStreamRdDirect::~XStreamRdDirect, COMDAT
; _this$ = ecx

; 71   : 	~XStreamRdDirect(void){}

	mov	DWORD PTR [ecx], OFFSET FLAT:??_7XBufferReadInt@@6B@ ; XBufferReadInt::`vftable'
	ret	0
??1XStreamRdDirect@@UAE@XZ ENDP				; XStreamRdDirect::~XStreamRdDirect
_TEXT	ENDS
PUBLIC	??_EXStreamRdDirect@@UAEPAXI@Z			; XStreamRdDirect::`vector deleting destructor'
; Function compile flags: /Ogty
;	COMDAT ??_EXStreamRdDirect@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_EXStreamRdDirect@@UAEPAXI@Z PROC NEAR		; XStreamRdDirect::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebx
	mov	bl, BYTE PTR ___flags$[esp]
	push	esi
	mov	esi, ecx
	test	bl, 2
	je	SHORT $L56163
	mov	eax, DWORD PTR [esi-4]
	push	edi
	lea	edi, DWORD PTR [esi-4]
	push	OFFSET FLAT:??1XStreamRdDirect@@UAE@XZ	; XStreamRdDirect::~XStreamRdDirect
	push	eax
	push	8
	push	esi
	call	??_M@YGXPAXIHP6EX0@Z@Z			; `eh vector destructor iterator'
	test	bl, 1
	je	SHORT $L58939
	mov	ecx, edi
	call	@xfree@4
$L58939:
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	ret	4
$L56163:
	mov	ecx, esi
	call	??1XStreamRdDirect@@UAE@XZ		; XStreamRdDirect::~XStreamRdDirect
	test	bl, 1
	je	SHORT $L58942
	mov	ecx, esi
	call	@xfree@4
$L58942:
	mov	eax, esi
	pop	esi
	pop	ebx
	ret	4
??_EXStreamRdDirect@@UAEPAXI@Z ENDP			; XStreamRdDirect::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??1XStreamWrDirect@@UAE@XZ			; XStreamWrDirect::~XStreamWrDirect
PUBLIC	??_GXStreamWrDirect@@UAEPAXI@Z			; XStreamWrDirect::`scalar deleting destructor'
; Function compile flags: /Ogty
;	COMDAT ??_GXStreamWrDirect@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_GXStreamWrDirect@@UAEPAXI@Z PROC NEAR		; XStreamWrDirect::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1XStreamWrDirect@@UAE@XZ		; XStreamWrDirect::~XStreamWrDirect
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $L58948
	mov	ecx, esi
	call	@xfree@4
$L58948:
	mov	eax, esi
	pop	esi
	ret	4
??_GXStreamWrDirect@@UAEPAXI@Z ENDP			; XStreamWrDirect::`scalar deleting destructor'
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??1XStreamWrDirect@@UAE@XZ
_TEXT	SEGMENT
??1XStreamWrDirect@@UAE@XZ PROC NEAR			; XStreamWrDirect::~XStreamWrDirect, COMDAT
; _this$ = ecx

; 88   : 	~XStreamWrDirect(void){}

	mov	DWORD PTR [ecx], OFFSET FLAT:??_7XBufferWriteInt@@6B@ ; XBufferWriteInt::`vftable'
	ret	0
??1XStreamWrDirect@@UAE@XZ ENDP				; XStreamWrDirect::~XStreamWrDirect
_TEXT	ENDS
PUBLIC	??_EXStreamWrDirect@@UAEPAXI@Z			; XStreamWrDirect::`vector deleting destructor'
; Function compile flags: /Ogty
;	COMDAT ??_EXStreamWrDirect@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_EXStreamWrDirect@@UAEPAXI@Z PROC NEAR		; XStreamWrDirect::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebx
	mov	bl, BYTE PTR ___flags$[esp]
	push	esi
	mov	esi, ecx
	test	bl, 2
	je	SHORT $L56219
	mov	eax, DWORD PTR [esi-4]
	push	edi
	lea	edi, DWORD PTR [esi-4]
	push	OFFSET FLAT:??1XStreamWrDirect@@UAE@XZ	; XStreamWrDirect::~XStreamWrDirect
	push	eax
	push	8
	push	esi
	call	??_M@YGXPAXIHP6EX0@Z@Z			; `eh vector destructor iterator'
	test	bl, 1
	je	SHORT $L58959
	mov	ecx, edi
	call	@xfree@4
$L58959:
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	ret	4
$L56219:
	mov	ecx, esi
	call	??1XStreamWrDirect@@UAE@XZ		; XStreamWrDirect::~XStreamWrDirect
	test	bl, 1
	je	SHORT $L58962
	mov	ecx, esi
	call	@xfree@4
$L58962:
	mov	eax, esi
	pop	esi
	pop	ebx
	ret	4
??_EXStreamWrDirect@@UAEPAXI@Z ENDP			; XStreamWrDirect::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??1XMemRdBuffer@@UAE@XZ				; XMemRdBuffer::~XMemRdBuffer
PUBLIC	??_GXMemRdBuffer@@UAEPAXI@Z			; XMemRdBuffer::`scalar deleting destructor'
; Function compile flags: /Ogty
;	COMDAT ??_GXMemRdBuffer@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_GXMemRdBuffer@@UAEPAXI@Z PROC NEAR			; XMemRdBuffer::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1XMemRdBuffer@@UAE@XZ			; XMemRdBuffer::~XMemRdBuffer
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $L58968
	mov	ecx, esi
	call	@xfree@4
$L58968:
	mov	eax, esi
	pop	esi
	ret	4
??_GXMemRdBuffer@@UAEPAXI@Z ENDP			; XMemRdBuffer::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_7XMemRdBuffer@@6B@				; XMemRdBuffer::`vftable'
PUBLIC	??_EXMemRdBuffer@@UAEPAXI@Z			; XMemRdBuffer::`vector deleting destructor'
EXTRN	?read@XMemRdBuffer@@UAEKPAXKAAK1@Z:NEAR		; XMemRdBuffer::read
EXTRN	?seek@XMemRdBuffer@@UAEKJ@Z:NEAR		; XMemRdBuffer::seek
;	COMDAT ??_7XMemRdBuffer@@6B@
CONST	SEGMENT
??_7XMemRdBuffer@@6B@ DD FLAT:?read_direct@XBufferReadInt@@MAEKPAXKAAK@Z ; XMemRdBuffer::`vftable'
	DD	FLAT:?read@XMemRdBuffer@@UAEKPAXKAAK1@Z
	DD	FLAT:?seek@XMemRdBuffer@@UAEKJ@Z
	DD	FLAT:??_EXMemRdBuffer@@UAEPAXI@Z
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ??1XMemRdBuffer@@UAE@XZ
_TEXT	SEGMENT
??1XMemRdBuffer@@UAE@XZ PROC NEAR			; XMemRdBuffer::~XMemRdBuffer, COMDAT
; _this$ = ecx

; 109  : 	~XMemRdBuffer(void){}

	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET FLAT:??_7XMemRdBuffer@@6B@ ; XMemRdBuffer::`vftable'
	mov	ecx, DWORD PTR [esi+8]
	call	@xfree@4
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi], OFFSET FLAT:??_7XBufferReadInt@@6B@ ; XBufferReadInt::`vftable'
	pop	esi
	ret	0
??1XMemRdBuffer@@UAE@XZ ENDP				; XMemRdBuffer::~XMemRdBuffer
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??_EXMemRdBuffer@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_EXMemRdBuffer@@UAEPAXI@Z PROC NEAR			; XMemRdBuffer::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebx
	mov	bl, BYTE PTR ___flags$[esp]
	push	esi
	mov	esi, ecx
	test	bl, 2
	je	SHORT $L56272
	mov	eax, DWORD PTR [esi-4]
	push	edi
	lea	edi, DWORD PTR [esi-4]
	push	OFFSET FLAT:??1XMemRdBuffer@@UAE@XZ	; XMemRdBuffer::~XMemRdBuffer
	push	eax
	push	24					; 00000018H
	push	esi
	call	??_M@YGXPAXIHP6EX0@Z@Z			; `eh vector destructor iterator'
	test	bl, 1
	je	SHORT $L58984
	mov	ecx, edi
	call	@xfree@4
$L58984:
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	ret	4
$L56272:
	mov	ecx, esi
	call	??1XMemRdBuffer@@UAE@XZ			; XMemRdBuffer::~XMemRdBuffer
	test	bl, 1
	je	SHORT $L58987
	mov	ecx, esi
	call	@xfree@4
$L58987:
	mov	eax, esi
	pop	esi
	pop	ebx
	ret	4
??_EXMemRdBuffer@@UAEPAXI@Z ENDP			; XMemRdBuffer::`vector deleting destructor'
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?seek_int@CBaseStream@@MAEJXZ
_TEXT	SEGMENT
?seek_int@CBaseStream@@MAEJXZ PROC NEAR			; CBaseStream::seek_int, COMDAT
; _this$ = ecx

; 163  : 	virtual I32 seek_int(void){return TRUE;}

	mov	eax, 1
	ret	0
?seek_int@CBaseStream@@MAEJXZ ENDP			; CBaseStream::seek_int
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??1CBaseStream@@QAE@XZ
_TEXT	SEGMENT
??1CBaseStream@@QAE@XZ PROC NEAR			; CBaseStream::~CBaseStream, COMDAT
; _this$ = ecx

; 167  : 	{

	push	esi
	mov	esi, ecx

; 168  : 		delete rd_int;

	mov	ecx, DWORD PTR [esi+20]
	mov	DWORD PTR [esi], OFFSET FLAT:??_7CBaseStream@@6B@ ; CBaseStream::`vftable'
	test	ecx, ecx
	je	SHORT $L58994
	mov	eax, DWORD PTR [ecx]
	push	1
	call	DWORD PTR [eax+12]
$L58994:

; 169  : 		delete wr_int;

	mov	ecx, DWORD PTR [esi+24]
	pop	esi
	test	ecx, ecx
	je	SHORT $L58998
	mov	edx, DWORD PTR [ecx]
	push	1
	call	DWORD PTR [edx+16]
$L58998:

; 170  : 	}

	ret	0
??1CBaseStream@@QAE@XZ ENDP				; CBaseStream::~CBaseStream
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?ioctl_read@CBaseStream@@UAEKKK@Z
_TEXT	SEGMENT
?ioctl_read@CBaseStream@@UAEKKK@Z PROC NEAR		; CBaseStream::ioctl_read, COMDAT
; _this$ = ecx

; 173  : 	virtual U32 ioctl_read(U32 type,U32 size){return TRUE;}

	mov	eax, 1
	ret	8
?ioctl_read@CBaseStream@@UAEKKK@Z ENDP			; CBaseStream::ioctl_read
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?ioctl_write@CBaseStream@@UAEKKK@Z
_TEXT	SEGMENT
?ioctl_write@CBaseStream@@UAEKKK@Z PROC NEAR		; CBaseStream::ioctl_write, COMDAT
; _this$ = ecx

; 174  : 	virtual U32 ioctl_write(U32 type,U32 size){return TRUE;}

	mov	eax, 1
	ret	8
?ioctl_write@CBaseStream@@UAEKKK@Z ENDP			; CBaseStream::ioctl_write
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?put@CBaseStream@@UAEKD@Z
_TEXT	SEGMENT
_val$ = 8
?put@CBaseStream@@UAEKD@Z PROC NEAR			; CBaseStream::put, COMDAT
; _this$ = ecx

; 181  : 	virtual U32 put(char val){return write(&val,1);}

	mov	eax, DWORD PTR [ecx]
	lea	edx, DWORD PTR _val$[esp-4]
	push	1
	push	edx
	call	DWORD PTR [eax+20]
	ret	4
?put@CBaseStream@@UAEKD@Z ENDP				; CBaseStream::put
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?pos_rd@CBaseStream@@UAEXKK@Z
_TEXT	SEGMENT
?pos_rd@CBaseStream@@UAEXKK@Z PROC NEAR			; CBaseStream::pos_rd, COMDAT
; _this$ = ecx

; 187  : 	virtual void pos_rd(U32 adj,U32 at_adj){}

	ret	8
?pos_rd@CBaseStream@@UAEXKK@Z ENDP			; CBaseStream::pos_rd
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?pos_wr@CBaseStream@@UAEXKK@Z
_TEXT	SEGMENT
?pos_wr@CBaseStream@@UAEXKK@Z PROC NEAR			; CBaseStream::pos_wr, COMDAT
; _this$ = ecx

; 188  : 	virtual void pos_wr(U32 adj,U32 at_adj){}

	ret	8
?pos_wr@CBaseStream@@UAEXKK@Z ENDP			; CBaseStream::pos_wr
; Function compile flags: /Ogty
; File C:\duke4\xcore\filex.h
_TEXT	ENDS
;	COMDAT ?base_init@XFile@@EAEXXZ
_TEXT	SEGMENT
?base_init@XFile@@EAEXXZ PROC NEAR			; XFile::base_init, COMDAT
; _this$ = ecx

; 12   : 	void base_init(void){CBaseStream::base_init();name=null;}

	push	esi
	mov	esi, ecx
	call	?base_init@CBaseStream@@MAEXXZ		; CBaseStream::base_init
	mov	DWORD PTR [esi+40], 0
	pop	esi
	ret	0
?base_init@XFile@@EAEXXZ ENDP				; XFile::base_init
_TEXT	ENDS
;	COMDAT xdata$x
; File C:\duke4\xcore\xstream.h
xdata$x	SEGMENT
$T59058	DD	0ffffffffH
	DD	FLAT:$L59020
	DD	00H
	DD	FLAT:$L59023
	DD	01H
	DD	FLAT:$L59024
$T59056	DD	019930520H
	DD	03H
	DD	FLAT:$T59058
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File C:\duke4\xcore\filex.h
xdata$x	ENDS
;	COMDAT ??1XFile@@QAE@XZ
_TEXT	SEGMENT
$T59035 = -8
__$EHRec$ = -12
_this$ = -16
??1XFile@@QAE@XZ PROC NEAR				; XFile::~XFile, COMDAT
; _this$ = ecx

; 26   : 	{

	push	-1
	push	$L59057
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	push	esi
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+24], esi
	lea	edi, DWORD PTR [esi+28]
	mov	DWORD PTR [esi], OFFSET FLAT:??_7XFile@@6BCBaseStream@@@ ; XFile::`vftable'
	mov	DWORD PTR [edi], OFFSET FLAT:??_7XFile@@6BCSysObj@@@ ; XFile::`vftable'

; 27   : 		if (is_open())

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR __$EHRec$[esp+32], 2
	test	ah, 1
	je	SHORT $L56516

; 28   : 			std_close();

	call	?std_close@XFile@@AAEKXZ		; XFile::std_close
$L56516:

; 29   : 	}

	mov	ecx, DWORD PTR [esi+40]
	call	@xfree@4
	mov	DWORD PTR [esi+40], 0
	mov	DWORD PTR [edi], OFFSET FLAT:??_7CSysObj@@6B@ ; CSysObj::`vftable'
	mov	ecx, DWORD PTR ?_global@@3PAVXGlobal@@A	; _global
	push	edi
	mov	BYTE PTR __$EHRec$[esp+36], 0
	call	?unreg_global_object@XGlobal@@QAEXPAVCSysObj@@@Z ; XGlobal::unreg_global_object
	mov	ecx, DWORD PTR [esi+20]
	mov	DWORD PTR __$EHRec$[esp+32], -1
	test	ecx, ecx
	mov	DWORD PTR [esi], OFFSET FLAT:??_7CBaseStream@@6B@ ; CBaseStream::`vftable'
	je	SHORT $L59048
	mov	eax, DWORD PTR [ecx]
	push	1
	call	DWORD PTR [eax+12]
$L59048:
	mov	ecx, DWORD PTR [esi+24]
	pop	edi
	test	ecx, ecx
	pop	esi
	je	SHORT $L59052
	mov	edx, DWORD PTR [ecx]
	push	1
	call	DWORD PTR [edx+16]
$L59052:
	mov	ecx, DWORD PTR __$EHRec$[esp+16]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L59020:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CBaseStream@@QAE@XZ			; CBaseStream::~CBaseStream
$L59023:
	cmp	DWORD PTR _this$[ebp], 0
	je	$L59021
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 28					; 0000001cH
	mov	DWORD PTR $T59035[ebp], eax
	jmp	$L59022
$L59021:
	mov	DWORD PTR $T59035[ebp], 0
$L59022:
	mov	ecx, DWORD PTR $T59035[ebp]
	jmp	??1CSysObj@@QAE@XZ			; CSysObj::~CSysObj
$L59024:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	jmp	??1autochar@@QAE@XZ			; autochar::~autochar
$L59057:
	mov	eax, OFFSET FLAT:$T59056
	jmp	___CxxFrameHandler
text$x	ENDS
??1XFile@@QAE@XZ ENDP					; XFile::~XFile
END
