; Listing generated by Microsoft (R) Optimizing Compiler Version 12.00.8943.0 

	TITLE	C:\duke4\xcore\global.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT PARA USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0BF@MBIJ@Cannot?5init?5CPrintfT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
drectve	SEGMENT DWORD USE32 PUBLIC ''
drectve	ENDS
;	COMDAT ??_C@_0CF@MJGC@XGlobal?3?3printf?3?5Out?5of?5error?5me@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CRT$XCA	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCA	ENDS
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
CRT$XCL	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCL	ENDS
CRT$XCC	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCC	ENDS
CRT$XCZ	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCZ	ENDS
;	COMDAT ?printf@XGlobal@@QAAXKPBDZZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$XChain@VXStatistic@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?get_head@?$XList@VXStatistic@@@@QAEPAVXStatistic@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$XChain@VCSysObj@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$XChain@VCSysObj@@@@QAE@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?get_next@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?get_prev@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?get_head@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?get_tail@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$XChain@VXStatistic@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?free_list@?$XChain@VXStatistic@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$XList@VXStatistic@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$XList@VXStatistic@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?free_list@?$XList@VXStatistic@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?add_head@?$XList@VXStatistic@@@@QAEPAU_XPos@@PAVXStatistic@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?remove_head@?$XList@VXStatistic@@@@QAEPAVXStatistic@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$XChain@VCSysObj@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lose_list@?$XChain@VCSysObj@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?free_list@?$XChain@VCSysObj@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?add_head@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?add_tail@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?remove_head@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?remove_tail@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?remove@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$XList@PAX@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$XList@PAX@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?free_list@?$XList@PAX@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?add_head@?$XList@PAX@@QAEPAU_XPos@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?remove_head@?$XList@PAX@@QAEPAPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$XRcBase@VCStrObj@@@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$XRcBase@VCStrObj@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$XRcBase@VCStrObj@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$XRcBase@VCStrObj@@@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$XRcPtr@VCPathObj@@@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$XRcPtr@VCPathObj@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$XRcPtr@VCPathObj@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$XRcPtr@VCPathObj@@@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$XList@VXFindLevel@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$XList@VXFindLevel@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCSysObj@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GXFindLevel@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?new_node@?$XList@VXStatistic@@@@IAEPAUXNode@1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?free_nodes@?$XList@VXStatistic@@@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?new_node@?$XList@PAX@@IAEPAUXNode@1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?free_nodes@?$XList@PAX@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?free_nodes@?$XList@VXFindLevel@@@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddRef@?$XRcBase@VCStrObj@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DelRef@?$XRcBase@VCStrObj@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddRef@?$XRcPtr@VCPathObj@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DelRef@?$XRcPtr@VCPathObj@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCStrObj@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCPathObj@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GXStreamWrDirect@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1XStreamWrDirect@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7XStreamWrDirect@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??1XBufferWriteInt@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7XBufferWriteInt@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??3XStreamWrDirect@@SAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_EXStreamWrDirect@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?flush@XStreamWrDirect@@UAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?seek@XStreamWrDirect@@UAEKJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GXStreamRdDirect@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1XStreamRdDirect@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7XStreamRdDirect@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??1XBufferReadInt@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7XBufferReadInt@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??3XStreamRdDirect@@SAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_EXStreamRdDirect@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?seek@XStreamRdDirect@@UAEKJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?base_init@XFile@@EAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4autochar@@QAEAAV0@PAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GXBufferWriteInt@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_EXBufferWriteInt@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GXBufferReadInt@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_EXBufferReadInt@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pos_wr@CBaseStream@@UAEXKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pos_rd@CBaseStream@@UAEXKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?put@CBaseStream@@UAEKD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ioctl_write@CBaseStream@@UAEKKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ioctl_read@CBaseStream@@UAEKKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?seek_int@CBaseStream@@MAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GXMemRdBuffer@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1XMemRdBuffer@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7XMemRdBuffer@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??1autochar@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3XMemRdBuffer@@SAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_EXMemRdBuffer@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3CStrObj@@SAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CStrObj@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1XFindLevel@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CSysObj@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CSysObj@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??3@YAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0XListState@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3XStatistic@@SAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0XChainState@@QAE@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0XChainState@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?close@XStatManager@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7XGlobal@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??1XStatManager@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0XStatManager@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7XCoreDll@@6BXGlobal@@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7XCoreDll@@6BXDll@@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??0XDll@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7XDll@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
FLAT	GROUP _DATA, CONST, _BSS, drectve, CRT$XCA, CRT$XCU, CRT$XCL, CRT$XCC, CRT$XCZ
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?_global@@3PAVXGlobal@@A			; _global
PUBLIC	?xcore_dll@@3VXCoreDll@@A			; xcore_dll
PUBLIC	?_xcore_dll@@3PAVXDll@@A			; _xcore_dll
PUBLIC	__gmalloc
PUBLIC	__mem_lock
PUBLIC	?_xapp@@3PAVXApp@@A				; _xapp
PUBLIC	__err_printf_string
_BSS	SEGMENT
?_global@@3PAVXGlobal@@A DD 01H DUP (?)			; _global
?xcore_dll@@3VXCoreDll@@A DB 02074H DUP (?)		; xcore_dll
?_xcore_dll@@3PAVXDll@@A DD 01H DUP (?)			; _xcore_dll
__gmalloc DD	01H DUP (?)
__mem_lock DD	01H DUP (?)
?_xapp@@3PAVXApp@@A DD 01H DUP (?)			; _xapp
__err_printf_string DB 01000H DUP (?)
_BSS	ENDS
CRT$XCL	SEGMENT
_$S5	DD	FLAT:_$E4
CRT$XCL	ENDS
drectve	SEGMENT
$SG56785 DB	'-INCLUDE:___@@_PchSym_@00@UwfpvEUcxlivUlyqUhgwxlivOlyq@', 00H
; Function compile flags: /Ogty
drectve	ENDS
_TEXT	SEGMENT
_$E4	PROC NEAR
	call	_$E1
	jmp	_$E3
_$E4	ENDP
_TEXT	ENDS
PUBLIC	??0XCoreDll@@QAE@XZ				; XCoreDll::XCoreDll
; Function compile flags: /Ogty
; File C:\duke4\xcore\global.cpp
_TEXT	SEGMENT
_$E1	PROC NEAR

; 24   : XCoreDll xcore_dll;

	mov	ecx, OFFSET FLAT:?xcore_dll@@3VXCoreDll@@A
	jmp	??0XCoreDll@@QAE@XZ			; XCoreDll::XCoreDll
_$E1	ENDP
_TEXT	ENDS
EXTRN	_atexit:NEAR
; Function compile flags: /Ogty
_TEXT	SEGMENT
_$E3	PROC NEAR
	push	OFFSET FLAT:_$E2
	call	_atexit
	pop	ecx
	ret	0
_$E3	ENDP
_TEXT	ENDS
PUBLIC	??1XCoreDll@@QAE@XZ				; XCoreDll::~XCoreDll
; Function compile flags: /Ogty
_TEXT	SEGMENT
_$E2	PROC NEAR
	mov	ecx, OFFSET FLAT:?xcore_dll@@3VXCoreDll@@A
	jmp	??1XCoreDll@@QAE@XZ			; XCoreDll::~XCoreDll
_$E2	ENDP
_TEXT	ENDS
PUBLIC	?detach_process@XCoreDll@@UAEKPAX@Z		; XCoreDll::detach_process
PUBLIC	??_7XCoreDll@@6BXDll@@@				; XCoreDll::`vftable'
PUBLIC	??_7XCoreDll@@6BXGlobal@@@			; XCoreDll::`vftable'
PUBLIC	??0XGlobal@@QAE@XZ				; XGlobal::XGlobal
PUBLIC	?close@XGlobal@@UAEXXZ				; XGlobal::close
PUBLIC	??_7XDll@@6B@					; XDll::`vftable'
EXTRN	?attach_process@XDll@@UAEKPAX@Z:NEAR		; XDll::attach_process
EXTRN	?detach_process@XDll@@UAEKPAX@Z:NEAR		; XDll::detach_process
;	COMDAT ??_7XDll@@6B@
; File C:\duke4\xcore\xclass.h
CONST	SEGMENT
??_7XDll@@6B@ DD FLAT:?attach_process@XDll@@UAEKPAX@Z	; XDll::`vftable'
	DD	FLAT:?detach_process@XDll@@UAEKPAX@Z
CONST	ENDS
;	COMDAT ??_7XCoreDll@@6BXDll@@@
CONST	SEGMENT
??_7XCoreDll@@6BXDll@@@ DD FLAT:?attach_process@XDll@@UAEKPAX@Z ; XCoreDll::`vftable'
	DD	FLAT:?detach_process@XCoreDll@@UAEKPAX@Z
CONST	ENDS
;	COMDAT ??_7XCoreDll@@6BXGlobal@@@
CONST	SEGMENT
??_7XCoreDll@@6BXGlobal@@@ DD FLAT:?close@XGlobal@@UAEXXZ ; XCoreDll::`vftable'
; Function compile flags: /Ogty
; File C:\duke4\xcore\global.cpp
CONST	ENDS
_TEXT	SEGMENT
??0XCoreDll@@QAE@XZ PROC NEAR				; XCoreDll::XCoreDll
; _this$ = ecx

; 34   : {

	push	esi
	mov	esi, ecx
	push	edi
	lea	edi, DWORD PTR [esi+4]
	mov	DWORD PTR [esi], OFFSET FLAT:??_7XDll@@6B@ ; XDll::`vftable'
	mov	ecx, edi
	call	??0XGlobal@@QAE@XZ			; XGlobal::XGlobal
	mov	DWORD PTR [esi], OFFSET FLAT:??_7XCoreDll@@6BXDll@@@ ; XCoreDll::`vftable'
	mov	DWORD PTR [edi], OFFSET FLAT:??_7XCoreDll@@6BXGlobal@@@ ; XCoreDll::`vftable'

; 35   : 	_xcore_dll=this;

	mov	DWORD PTR ?_xcore_dll@@3PAVXDll@@A, esi	; _xcore_dll

; 36   : }

	mov	eax, esi
	pop	edi
	pop	esi
	ret	0
??0XCoreDll@@QAE@XZ ENDP				; XCoreDll::XCoreDll
_TEXT	ENDS
PUBLIC	??1XGlobal@@QAE@XZ				; XGlobal::~XGlobal
; Function compile flags: /Ogty
_TEXT	SEGMENT
??1XCoreDll@@QAE@XZ PROC NEAR				; XCoreDll::~XCoreDll
; _this$ = ecx

; 39   : {

	mov	DWORD PTR [ecx], OFFSET FLAT:??_7XCoreDll@@6BXDll@@@ ; XCoreDll::`vftable'
	add	ecx, 4
	mov	DWORD PTR [ecx], OFFSET FLAT:??_7XCoreDll@@6BXGlobal@@@ ; XCoreDll::`vftable'

; 40   : 	_xcore_dll=null;

	mov	DWORD PTR ?_xcore_dll@@3PAVXDll@@A, 0	; _xcore_dll

; 41   : }

	jmp	??1XGlobal@@QAE@XZ			; XGlobal::~XGlobal
??1XCoreDll@@QAE@XZ ENDP				; XCoreDll::~XCoreDll
; Function compile flags: /Ogty
?detach_process@XCoreDll@@UAEKPAX@Z PROC NEAR		; XCoreDll::detach_process
; _this$ = ecx

; 45   : 	_global->close();

	mov	ecx, DWORD PTR ?_global@@3PAVXGlobal@@A	; _global
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax]

; 46   : 	return TRUE;

	mov	eax, 1

; 47   : }

	ret	4
?detach_process@XCoreDll@@UAEKPAX@Z ENDP		; XCoreDll::detach_process
_TEXT	ENDS
PUBLIC	?attach_thread@XCoreDll@@QAEKPAX@Z		; XCoreDll::attach_thread
PUBLIC	?attach_thread@XGlobal@@QAEXPAX@Z		; XGlobal::attach_thread
; Function compile flags: /Ogty
_TEXT	SEGMENT
_hmod$ = 8
?attach_thread@XCoreDll@@QAEKPAX@Z PROC NEAR		; XCoreDll::attach_thread
; _this$ = ecx

; 51   : 	_global->attach_thread(hmod);

	mov	eax, DWORD PTR _hmod$[esp-4]
	mov	ecx, DWORD PTR ?_global@@3PAVXGlobal@@A	; _global
	push	eax
	call	?attach_thread@XGlobal@@QAEXPAX@Z	; XGlobal::attach_thread

; 52   : 	return TRUE;

	mov	eax, 1

; 53   : }

	ret	4
?attach_thread@XCoreDll@@QAEKPAX@Z ENDP			; XCoreDll::attach_thread
_TEXT	ENDS
PUBLIC	?detach_thread@XCoreDll@@QAEKPAX@Z		; XCoreDll::detach_thread
PUBLIC	?detach_thread@XGlobal@@QAEXPAX@Z		; XGlobal::detach_thread
; Function compile flags: /Ogty
_TEXT	SEGMENT
_hmod$ = 8
?detach_thread@XCoreDll@@QAEKPAX@Z PROC NEAR		; XCoreDll::detach_thread
; _this$ = ecx

; 57   : 	_global->detach_thread(hmod);

	mov	eax, DWORD PTR _hmod$[esp-4]
	mov	ecx, DWORD PTR ?_global@@3PAVXGlobal@@A	; _global
	push	eax
	call	?detach_thread@XGlobal@@QAEXPAX@Z	; XGlobal::detach_thread

; 58   : 	return TRUE;

	mov	eax, 1

; 59   : }

	ret	4
?detach_thread@XCoreDll@@QAEKPAX@Z ENDP			; XCoreDll::detach_thread
_TEXT	ENDS
PUBLIC	??1?$XChain@VCSysObj@@@@QAE@XZ			; XChain<CSysObj>::~XChain<CSysObj>
PUBLIC	??0ErrMem@@QAE@XZ				; ErrMem::ErrMem
PUBLIC	??1ErrMem@@QAE@XZ				; ErrMem::~ErrMem
PUBLIC	??1?$XList@PAX@@QAE@XZ				; XList<void *>::~XList<void *>
PUBLIC	??_7XGlobal@@6B@				; XGlobal::`vftable'
PUBLIC	??1XStatManager@@QAE@XZ				; XStatManager::~XStatManager
EXTRN	?_win_error@@3VWinMsgDef@@A:QWORD		; _win_error
EXTRN	?_mem_init@@YAXXZ:NEAR				; _mem_init
EXTRN	__except_list:DWORD
EXTRN	___CxxFrameHandler:NEAR
xdata$x	SEGMENT
$T57874	DD	0ffffffffH
	DD	FLAT:$L57799
	DD	00H
	DD	FLAT:$L57800
	DD	01H
	DD	FLAT:$L57801
	DD	02H
	DD	FLAT:$L57802
	DD	03H
	DD	FLAT:$L57803
$T57871	DD	019930520H
	DD	05H
	DD	FLAT:$T57874
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_7XGlobal@@6B@
; File C:\duke4\xcore\xclass.h
CONST	SEGMENT
??_7XGlobal@@6B@ DD FLAT:?close@XGlobal@@UAEXXZ		; XGlobal::`vftable'
; Function compile flags: /Ogty
; File C:\duke4\xcore\global.cpp
CONST	ENDS
_TEXT	SEGMENT
_this$ = -16
__$EHRec$ = -12
??0XGlobal@@QAE@XZ PROC NEAR				; XGlobal::XGlobal
; _this$ = ecx

; 66   : {

	push	-1
	push	$L57872
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi
	lea	ecx, DWORD PTR [esi+4]
	call	??0ErrMem@@QAE@XZ			; ErrMem::ErrMem
	xor	eax, eax
	mov	DWORD PTR [esi+8212], eax
	mov	DWORD PTR [esi+8216], eax
	mov	DWORD PTR __$EHRec$[esp+28], eax
	mov	DWORD PTR [esi+8220], eax
	mov	DWORD PTR [esi+8224], eax
	mov	DWORD PTR [esi+8228], eax
	mov	DWORD PTR [esi+8232], eax
	mov	DWORD PTR [esi+8236], eax
	mov	DWORD PTR [esi+8240], eax
	mov	DWORD PTR [esi+8244], eax
	mov	DWORD PTR [esi+8248], eax
	mov	ecx, DWORD PTR [esi+8252]
	and	ecx, -16777211				; ff000005H
	or	ecx, 16777221				; 01000005H
	mov	DWORD PTR [esi+8252], ecx
	mov	DWORD PTR [esi+8256], eax
	mov	DWORD PTR [esi+8260], eax
	mov	DWORD PTR [esi+8264], eax
	mov	DWORD PTR [esi+8268], eax
	mov	DWORD PTR [esi+8272], eax
	mov	DWORD PTR [esi+8276], eax
	mov	DWORD PTR [esi+8280], eax
	mov	DWORD PTR [esi+8284], eax
	mov	DWORD PTR [esi+8288], eax
	mov	DWORD PTR [esi+8292], eax
	mov	edx, DWORD PTR [esi+8296]
	and	edx, -16777211				; ff000005H
	or	edx, 16777221				; 01000005H
	mov	DWORD PTR [esi+8296], edx
	mov	DWORD PTR [esi+8300], eax
	mov	DWORD PTR [esi], OFFSET FLAT:??_7XGlobal@@6B@ ; XGlobal::`vftable'
	mov	BYTE PTR __$EHRec$[esp+28], 4

; 67   : 	_global=this;

	mov	DWORD PTR ?_global@@3PAVXGlobal@@A, esi	; _global

; 68   : 	_mem_init();

	call	?_mem_init@@YAXXZ			; _mem_init

; 69   : 	error=&_win_error;
; 70   : 	fallback=&_win_error;
; 71   : }

	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	eax, OFFSET FLAT:?_win_error@@3VWinMsgDef@@A ; _win_error
	mov	DWORD PTR [esi+8204], eax
	mov	DWORD PTR [esi+8208], eax
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
text$x	SEGMENT
$L57799:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	??1ErrMem@@QAE@XZ			; ErrMem::~ErrMem
$L57800:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8212				; 00002014H
	jmp	??1?$XChain@VCSysObj@@@@QAE@XZ		; XChain<CSysObj>::~XChain<CSysObj>
$L57801:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8224				; 00002020H
	jmp	??1?$XChain@VCSysObj@@@@QAE@XZ		; XChain<CSysObj>::~XChain<CSysObj>
$L57802:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8236				; 0000202cH
	jmp	??1?$XList@PAX@@QAE@XZ			; XList<void *>::~XList<void *>
$L57803:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8264				; 00002048H
	jmp	??1XStatManager@@QAE@XZ			; XStatManager::~XStatManager
$L57872:
	mov	eax, OFFSET FLAT:$T57871
	jmp	___CxxFrameHandler
text$x	ENDS
??0XGlobal@@QAE@XZ ENDP					; XGlobal::XGlobal
PUBLIC	?unreg_global_object@XGlobal@@QAEXPAVCSysObj@@@Z ; XGlobal::unreg_global_object
PUBLIC	??_7CSysObj@@6B@				; CSysObj::`vftable'
EXTRN	__purecall:NEAR
EXTRN	@xlist_free_nodes@4:NEAR
EXTRN	@xfree@4:NEAR
xdata$x	SEGMENT
$T58047	DD	0ffffffffH
	DD	FLAT:$L57877
	DD	00H
	DD	FLAT:$L57878
	DD	01H
	DD	FLAT:$L57879
	DD	02H
	DD	FLAT:$L57880
	DD	03H
	DD	FLAT:$L57881
$T58035	DD	019930520H
	DD	05H
	DD	FLAT:$T58047
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_7CSysObj@@6B@
; File C:\duke4\xcore\xcore.h
CONST	SEGMENT
??_7CSysObj@@6B@ DD FLAT:__purecall			; CSysObj::`vftable'
; Function compile flags: /Ogty
; File C:\duke4\xcore\global.cpp
CONST	ENDS
_TEXT	SEGMENT
__$EHRec$ = -12
_this$ = -16
??1XGlobal@@QAE@XZ PROC NEAR				; XGlobal::~XGlobal
; _this$ = ecx

; 74   : {

	push	-1
	push	$L58046
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+32], esi
	mov	DWORD PTR [esi], OFFSET FLAT:??_7XGlobal@@6B@ ; XGlobal::`vftable'

; 75   : 	/* if we failed to call close */
; 76   : 	if (_global)

	mov	eax, DWORD PTR ?_global@@3PAVXGlobal@@A	; _global
	xor	ebx, ebx
	cmp	eax, ebx
	mov	DWORD PTR __$EHRec$[esp+40], 4
	je	SHORT $L57213

; 77   : 		close();

	call	?close@XGlobal@@UAEXXZ			; XGlobal::close
$L57213:

; 78   : }

	mov	al, BYTE PTR [esi+8299]
	lea	edi, DWORD PTR [esi+8280]
	test	al, 1
	je	SHORT $L57930
	cmp	DWORD PTR [edi], ebx
	je	SHORT $L57930
$L57929:
	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [eax+8]
	call	@xfree@4
	mov	ecx, DWORD PTR [edi]
	mov	eax, DWORD PTR [ecx]
	cmp	eax, ebx
	mov	DWORD PTR [edi], eax
	jne	SHORT $L57929
$L57930:
	mov	ecx, edi
	call	@xlist_free_nodes@4
	mov	eax, DWORD PTR [esi+8276]
	mov	ebp, -2147483648			; 80000000H
	test	eax, ebp
	je	SHORT $L57919
	cmp	DWORD PTR [esi+8268], ebx
	je	SHORT $L57919
$L57939:
	mov	edx, DWORD PTR [esi+8268]
	mov	ecx, edx
	mov	edi, DWORD PTR [edx+40]
	call	@xfree@4
	cmp	edi, ebx
	mov	DWORD PTR [esi+8268], edi
	jne	SHORT $L57939
$L57919:
	lea	edi, DWORD PTR [esi+8236]
	mov	DWORD PTR [esi+8268], ebx
	mov	DWORD PTR [esi+8272], ebx
	test	BYTE PTR [edi+19], 1
	je	SHORT $L57958
	cmp	DWORD PTR [edi], ebx
	je	SHORT $L57958
$L57957:
	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [eax+8]
	call	@xfree@4
	mov	ecx, DWORD PTR [edi]
	mov	eax, DWORD PTR [ecx]
	cmp	eax, ebx
	mov	DWORD PTR [edi], eax
	jne	SHORT $L57957
$L57958:
	mov	ecx, edi
	call	@xlist_free_nodes@4
	mov	eax, DWORD PTR [esi+8232]
	mov	BYTE PTR __$EHRec$[esp+40], 1
	test	eax, ebp
	je	SHORT $L57994
	cmp	DWORD PTR [esi+8224], ebx
	je	SHORT $L57994
$L57993:
	mov	edx, DWORD PTR [esi+8224]
	mov	edi, edx
	mov	ebp, DWORD PTR [edx+4]
	cmp	edi, ebx
	je	SHORT $L57982
	mov	DWORD PTR [edi], OFFSET FLAT:??_7CSysObj@@6B@ ; CSysObj::`vftable'
	mov	ecx, DWORD PTR ?_global@@3PAVXGlobal@@A	; _global
	push	edi
	call	?unreg_global_object@XGlobal@@QAEXPAVCSysObj@@@Z ; XGlobal::unreg_global_object
	mov	ecx, edi
	call	@xfree@4
$L57982:
	cmp	ebp, ebx
	mov	DWORD PTR [esi+8224], ebp
	jne	SHORT $L57993
	mov	ebp, -2147483648			; 80000000H
$L57994:
	mov	DWORD PTR [esi+8224], ebx
	mov	DWORD PTR [esi+8228], ebx
	mov	eax, DWORD PTR [esi+8220]
	mov	BYTE PTR __$EHRec$[esp+40], bl
	test	eax, ebp
	je	SHORT $L58031
	cmp	DWORD PTR [esi+8212], ebx
	je	SHORT $L58031
$L58030:
	mov	eax, DWORD PTR [esi+8212]
	mov	edi, eax
	mov	ebp, DWORD PTR [eax+4]
	cmp	edi, ebx
	je	SHORT $L58019
	mov	DWORD PTR [edi], OFFSET FLAT:??_7CSysObj@@6B@ ; CSysObj::`vftable'
	mov	ecx, DWORD PTR ?_global@@3PAVXGlobal@@A	; _global
	push	edi
	call	?unreg_global_object@XGlobal@@QAEXPAVCSysObj@@@Z ; XGlobal::unreg_global_object
	mov	ecx, edi
	call	@xfree@4
$L58019:
	cmp	ebp, ebx
	mov	DWORD PTR [esi+8212], ebp
	jne	SHORT $L58030
$L58031:
	lea	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [esi+8212], ebx
	mov	DWORD PTR [esi+8216], ebx
	mov	DWORD PTR __$EHRec$[esp+40], -1
	call	??1ErrMem@@QAE@XZ			; ErrMem::~ErrMem
	mov	ecx, DWORD PTR __$EHRec$[esp+32]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
text$x	SEGMENT
$L57877:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	??1ErrMem@@QAE@XZ			; ErrMem::~ErrMem
$L57878:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8212				; 00002014H
	jmp	??1?$XChain@VCSysObj@@@@QAE@XZ		; XChain<CSysObj>::~XChain<CSysObj>
$L57879:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8224				; 00002020H
	jmp	??1?$XChain@VCSysObj@@@@QAE@XZ		; XChain<CSysObj>::~XChain<CSysObj>
$L57880:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8236				; 0000202cH
	jmp	??1?$XList@PAX@@QAE@XZ			; XList<void *>::~XList<void *>
$L57881:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8264				; 00002048H
	jmp	??1XStatManager@@QAE@XZ			; XStatManager::~XStatManager
$L58046:
	mov	eax, OFFSET FLAT:$T58035
	jmp	___CxxFrameHandler
text$x	ENDS
??1XGlobal@@QAE@XZ ENDP					; XGlobal::~XGlobal
PUBLIC	?_handle_unclean@XGlobal@@IAEXXZ		; XGlobal::_handle_unclean
PUBLIC	?_free_raw@XGlobal@@IAEXXZ			; XGlobal::_free_raw
EXTRN	?_mem_close@@YAXXZ:NEAR				; _mem_close
EXTRN	?_flush_printf_mem@@YAXXZ:NEAR			; _flush_printf_mem
; Function compile flags: /Ogty
_TEXT	SEGMENT
?close@XGlobal@@UAEXXZ PROC NEAR			; XGlobal::close
; _this$ = ecx

; 81   : {

	push	ebx
	push	esi
	mov	esi, ecx

; 82   : 	_flush_printf_mem();

	call	?_flush_printf_mem@@YAXXZ		; _flush_printf_mem

; 83   : 
; 84   : 	/* free raw globally allocated memory */
; 85   : 	_free_raw();

	mov	ecx, esi
	call	?_free_raw@XGlobal@@IAEXXZ		; XGlobal::_free_raw

; 86   : 
; 87   : #ifdef DEBUG
; 88   : 	if (_test_leak())
; 89   : 		xxx_bitch("Memory Leak");
; 90   : #endif
; 91   : 	
; 92   : 	/* clean up badly handled stuff */
; 93   : 	_handle_unclean();

	mov	ecx, esi
	call	?_handle_unclean@XGlobal@@IAEXXZ	; XGlobal::_handle_unclean

; 94   : 
; 95   : 	_global=null;

	xor	ebx, ebx
	mov	DWORD PTR ?_global@@3PAVXGlobal@@A, ebx	; _global

; 96   : 	stats.close();

	mov	eax, DWORD PTR [esi+8276]
	test	eax, eax
	jns	SHORT $L58092
	cmp	DWORD PTR [esi+8268], ebx
	je	SHORT $L58092
	push	edi
$L58091:
	mov	eax, DWORD PTR [esi+8268]
	mov	ecx, eax
	mov	edi, DWORD PTR [eax+40]
	call	@xfree@4
	cmp	edi, ebx
	mov	DWORD PTR [esi+8268], edi
	jne	SHORT $L58091
	pop	edi
$L58092:
	mov	DWORD PTR [esi+8268], ebx
	mov	DWORD PTR [esi+8272], ebx
	mov	al, BYTE PTR [esi+8299]
	add	esi, 8280				; 00002058H
	test	al, 1
	je	SHORT $L58103
	cmp	DWORD PTR [esi], ebx
	je	SHORT $L58103
$L58102:
	mov	ecx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ecx+8]
	call	@xfree@4
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx]
	cmp	eax, ebx
	mov	DWORD PTR [esi], eax
	jne	SHORT $L58102
$L58103:
	mov	ecx, esi
	mov	DWORD PTR [esi], ebx
	mov	DWORD PTR [esi+4], ebx
	call	@xlist_free_nodes@4
	pop	esi
	pop	ebx

; 97   : 	_mem_close();

	jmp	?_mem_close@@YAXXZ			; _mem_close
?close@XGlobal@@UAEXXZ ENDP				; XGlobal::close
; Function compile flags: /Ogty
?_free_raw@XGlobal@@IAEXXZ PROC NEAR			; XGlobal::_free_raw
; _this$ = ecx

; 101  : {

	push	ebx
	push	esi
	lea	esi, DWORD PTR [ecx+8236]

; 102  : 	void **tmp_handle;
; 103  : 	
; 104  : 	while(tmp_handle=raw_handles.remove_head())

	xor	ebx, ebx
	push	edi
$L57224:
	mov	eax, DWORD PTR [esi]
	cmp	eax, ebx
	je	SHORT $L58143
	mov	ecx, DWORD PTR [eax]
	mov	edi, DWORD PTR [eax+8]
	cmp	ecx, ebx
	mov	DWORD PTR [esi], ecx
	je	SHORT $L58118
	mov	DWORD PTR [ecx+4], ebx
	jmp	SHORT $L58119
$L58118:
	mov	DWORD PTR [esi], ebx
	mov	DWORD PTR [esi+4], ebx
$L58119:
	mov	ecx, DWORD PTR [esi+8]
	cmp	edi, ebx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [esi+8], eax
	je	SHORT $L58143

; 105  : 	{
; 106  : 		xfree(*tmp_handle);

	mov	ecx, DWORD PTR [edi]
	call	@xfree@4

; 107  : 		*tmp_handle=null;

	mov	DWORD PTR [edi], ebx

; 108  : 	}

	jmp	SHORT $L57224
$L58143:

; 109  : 	/* need to free list too since this gets called when we are dumping memory */
; 110  : 	raw_handles.free_list();

	mov	al, BYTE PTR [esi+19]
	pop	edi
	test	al, 1
	je	SHORT $L58138
	cmp	DWORD PTR [esi], ebx
	je	SHORT $L58138
$L58137:
	mov	edx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [edx+8]
	call	@xfree@4
	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax]
	cmp	eax, ebx
	mov	DWORD PTR [esi], eax
	jne	SHORT $L58137
$L58138:
	mov	DWORD PTR [esi], ebx
	mov	DWORD PTR [esi+4], ebx
	mov	ecx, esi
	pop	esi
	pop	ebx
	jmp	@xlist_free_nodes@4
?_free_raw@XGlobal@@IAEXXZ ENDP				; XGlobal::_free_raw
_TEXT	ENDS
PUBLIC	?reg_global_handle_rawptr@XGlobal@@QAEXPAPAX@Z	; XGlobal::reg_global_handle_rawptr
EXTRN	@xlist_new_node@8:NEAR
; Function compile flags: /Ogty
_TEXT	SEGMENT
_ptr$ = 8
?reg_global_handle_rawptr@XGlobal@@QAEXPAPAX@Z PROC NEAR ; XGlobal::reg_global_handle_rawptr
; _this$ = ecx

; 115  : 	raw_handles.add_head(ptr);

	mov	eax, DWORD PTR [ecx+8244]
	push	esi
	lea	esi, DWORD PTR [ecx+8236]
	test	eax, eax
	jne	SHORT $L58154
	mov	edx, 12					; 0000000cH
	mov	ecx, esi
	call	@xlist_new_node@8
	mov	DWORD PTR [esi+8], eax
$L58154:
	mov	eax, DWORD PTR [esi+8]
	mov	edx, DWORD PTR _ptr$[esp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [esi+8], ecx
	mov	DWORD PTR [eax+8], edx
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	jne	SHORT $L58156
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi], eax
	pop	esi

; 116  : }

	ret	4

; 115  : 	raw_handles.add_head(ptr);

$L58156:
	mov	DWORD PTR [ecx+4], eax
	mov	DWORD PTR [esi], eax
	pop	esi

; 116  : }

	ret	4
?reg_global_handle_rawptr@XGlobal@@QAEXPAPAX@Z ENDP	; XGlobal::reg_global_handle_rawptr
_TEXT	ENDS
PUBLIC	?reg_global_object@XGlobal@@QAEXPAVCSysObj@@@Z	; XGlobal::reg_global_object
; Function compile flags: /Ogty
_TEXT	SEGMENT
_obj$ = 8
?reg_global_object@XGlobal@@QAEXPAVCSysObj@@@Z PROC NEAR ; XGlobal::reg_global_object
; _this$ = ecx

; 120  : 	sys_objects.add_head(obj);

	mov	eax, DWORD PTR _obj$[esp-4]
	mov	edx, DWORD PTR [ecx+8212]
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax+8], 0
	mov	edx, DWORD PTR [ecx+8212]
	test	edx, edx
	je	SHORT $L58164
	mov	DWORD PTR [edx+8], eax
	mov	DWORD PTR [ecx+8212], eax

; 121  : }

	ret	4

; 120  : 	sys_objects.add_head(obj);

$L58164:
	mov	DWORD PTR [ecx+8216], eax
	mov	DWORD PTR [ecx+8212], eax

; 121  : }

	ret	4
?reg_global_object@XGlobal@@QAEXPAVCSysObj@@@Z ENDP	; XGlobal::reg_global_object
; Function compile flags: /Ogty
_ptr$ = 8
?unreg_global_object@XGlobal@@QAEXPAVCSysObj@@@Z PROC NEAR ; XGlobal::unreg_global_object
; _this$ = ecx

; 125  : 	CSysObj *obj;
; 126  : 
; 127  : 	obj=sys_objects.get_head();

	mov	eax, DWORD PTR [ecx+8212]

; 128  : 	while(obj)

	test	eax, eax
	je	SHORT $L58178
	mov	edx, DWORD PTR _ptr$[esp-4]
$L57240:

; 129  : 	{
; 130  : 		if (obj==ptr)

	cmp	eax, edx
	je	SHORT $L58184

; 133  : 			return;
; 134  : 		}
; 135  : 		obj=sys_objects.get_next(obj);

	mov	eax, DWORD PTR [eax+4]
	test	eax, eax
	jne	SHORT $L57240

; 136  : 	}
; 137  : }

	ret	4
$L58184:

; 131  : 		{
; 132  : 			sys_objects.remove(obj);

	mov	edx, DWORD PTR [eax+8]
	test	edx, edx
	je	SHORT $L58175
	push	esi
	mov	esi, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], esi
	pop	esi
	jmp	SHORT $L58176
$L58175:
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+8212], edx
$L58176:
	mov	edx, DWORD PTR [eax+4]
	test	edx, edx
	je	SHORT $L58177
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax

; 136  : 	}
; 137  : }

	ret	4

; 131  : 		{
; 132  : 			sys_objects.remove(obj);

$L58177:
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8216], edx
$L58178:

; 136  : 	}
; 137  : }

	ret	4
?unreg_global_object@XGlobal@@QAEXPAVCSysObj@@@Z ENDP	; XGlobal::unreg_global_object
; Function compile flags: /Ogty
?_handle_unclean@XGlobal@@IAEXXZ PROC NEAR		; XGlobal::_handle_unclean
; _this$ = ecx

; 140  : {

	push	esi
	push	edi
	mov	esi, ecx

; 141  : 	/* run through list of registered system objects */
; 142  : 	/* and destroy them */
; 143  : 	CSysObj *obj;
; 144  : 	
; 145  : 	/* kernel objects come first */
; 146  : 
; 147  : 	/* NOTE: destroy must not free up memory or destruct them */
; 148  : 	/* it simply frees up system resources if it can */
; 149  : 	while(obj=sys_objects.remove_head())

	xor	edi, edi
$L57249:
	mov	ecx, DWORD PTR [esi+8212]
	cmp	ecx, edi
	je	SHORT $L57252
	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, edi
	mov	DWORD PTR [esi+8212], eax
	jne	SHORT $L58191
	mov	DWORD PTR [esi+8216], edi
	jmp	SHORT $L58192
$L58191:
	mov	DWORD PTR [eax+8], edi
$L58192:
	cmp	ecx, edi
	je	SHORT $L57252

; 150  : 		obj->destroy();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax]
	jmp	SHORT $L57249
$L57252:

; 151  : 
; 152  : 	/* now file objects, since they are riskier */
; 153  : 
; 154  : 	/* NOTE: destroy must not free up memory or destruct objects */
; 155  : 	/* it simply frees up system resources if it can */
; 156  : 	while(obj=file_objects.remove_head())

	mov	ecx, DWORD PTR [esi+8224]
	cmp	ecx, edi
	je	SHORT $L58206
	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, edi
	mov	DWORD PTR [esi+8224], eax
	jne	SHORT $L58199
	mov	DWORD PTR [esi+8228], edi
	jmp	SHORT $L58200
$L58199:
	mov	DWORD PTR [eax+8], edi
$L58200:
	cmp	ecx, edi
	je	SHORT $L58206

; 157  : 		obj->destroy();

	mov	edx, DWORD PTR [ecx]
	call	DWORD PTR [edx]
	jmp	SHORT $L57252
$L58206:
	pop	edi
	pop	esi

; 158  : }

	ret	0
?_handle_unclean@XGlobal@@IAEXXZ ENDP			; XGlobal::_handle_unclean
_TEXT	ENDS
PUBLIC	?_fatal_exit@XGlobal@@QAEXXZ			; XGlobal::_fatal_exit
EXTRN	__imp__exit:NEAR
; Function compile flags: /Ogty
_TEXT	SEGMENT
?_fatal_exit@XGlobal@@QAEXXZ PROC NEAR			; XGlobal::_fatal_exit
; _this$ = ecx

; 171  : 	/* try and clean up */
; 172  : 	_handle_unclean();

	call	?_handle_unclean@XGlobal@@IAEXXZ	; XGlobal::_handle_unclean

; 173  : 	/* might make sense to call _exit instead */
; 174  : 	exit(1);

	push	1
	call	DWORD PTR __imp__exit
$L58208:
?_fatal_exit@XGlobal@@QAEXXZ ENDP			; XGlobal::_fatal_exit
_TEXT	ENDS
EXTRN	__imp__TlsAlloc@0:NEAR
EXTRN	__imp__TlsSetValue@8:NEAR
; Function compile flags: /Ogty
_TEXT	SEGMENT
??0ErrMem@@QAE@XZ PROC NEAR				; ErrMem::ErrMem
; _this$ = ecx

; 178  : {

	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], 1

; 179  : 	tls_index=TlsAlloc();

	call	DWORD PTR __imp__TlsAlloc@0

; 180  : 	/* main thread gets default memory */
; 181  : 	TlsSetValue(tls_index,&rotate);

	push	esi
	push	eax
	mov	DWORD PTR [esi+8196], eax
	call	DWORD PTR __imp__TlsSetValue@8

; 182  : }

	mov	eax, esi
	pop	esi
	ret	0
??0ErrMem@@QAE@XZ ENDP					; ErrMem::ErrMem
_TEXT	ENDS
EXTRN	__imp__TlsFree@4:NEAR
; Function compile flags: /Ogty
_TEXT	SEGMENT
??1ErrMem@@QAE@XZ PROC NEAR				; ErrMem::~ErrMem
; _this$ = ecx

; 186  : 	/* release tls */
; 187  : 	TlsFree(tls_index);

	mov	eax, DWORD PTR [ecx+8196]
	push	eax
	call	DWORD PTR __imp__TlsFree@4

; 188  : }

	ret	0
??1ErrMem@@QAE@XZ ENDP					; ErrMem::~ErrMem
_TEXT	ENDS
PUBLIC	?get@ErrMem@@QAEPADK@Z				; ErrMem::get
EXTRN	@_bsf@4:NEAR
EXTRN	__imp__TlsGetValue@4:NEAR
; Function compile flags: /Ogty
_TEXT	SEGMENT
_size$ = 8
?get@ErrMem@@QAEPADK@Z PROC NEAR			; ErrMem::get
; _this$ = ecx

; 192  : 	ErrMem *emem=(ErrMem *)TlsGetValue(tls_index);

	mov	eax, DWORD PTR [ecx+8196]
	push	esi
	push	edi
	push	eax
	call	DWORD PTR __imp__TlsGetValue@4
	mov	edi, eax

; 193  : 
; 194  : 	if (!emem)

	test	edi, edi
	jne	SHORT $L57272
	pop	edi
	pop	esi

; 215  : }

	ret	4
$L57272:

; 195  : 		return null;
; 196  : 
; 197  : 	size=ALIGN_POW2(size,ERR_MEM_CHUNK);

	mov	ecx, DWORD PTR _size$[esp+4]
	lea	esi, DWORD PTR [ecx+255]

; 213  : 	_rotl(rotate,bits);
; 214  : 	return ptr;

	shr	esi, 8
	cmp	esi, 32					; 00000020H
	jbe	SHORT $L57281
	pop	edi
	xor	eax, eax
	pop	esi

; 215  : }

	ret	4
$L57281:

; 198  : 	U32 bits=size/ERR_MEM_CHUNK;
; 199  : 
; 200  : 	if (bits>32)
; 201  : 		return null;
; 202  : 
; 203  : 	U32 loc=_bsf(emem->rotate) - 1;

	mov	ecx, DWORD PTR [edi]
	call	@_bsf@4
	dec	eax

; 204  : 
; 205  : 	/* wrap memory, start at beginning */
; 206  : 	if ((loc+bits)>32)

	lea	edx, DWORD PTR [eax+esi]
	cmp	edx, 32					; 00000020H
	jbe	SHORT $L57283

; 207  : 	{
; 208  : 		emem->rotate=1<<bits;

	mov	eax, 1
	mov	ecx, esi
	shl	eax, cl
	mov	DWORD PTR [edi], eax

; 209  : 		return emem->def_mem;

	lea	eax, DWORD PTR [edi+4]
	pop	edi
	pop	esi

; 215  : }

	ret	4
$L57283:

; 210  : 	}
; 211  : 	
; 212  : 	char *ptr=emem->def_mem+(loc*ERR_MEM_CHUNK);

	shl	eax, 8

; 213  : 	_rotl(rotate,bits);
; 214  : 	return ptr;

	lea	eax, DWORD PTR [eax+edi+4]
	pop	edi
	pop	esi

; 215  : }

	ret	4
?get@ErrMem@@QAEPADK@Z ENDP				; ErrMem::get
_TEXT	ENDS
PUBLIC	??3@YAXPAX@Z					; operator delete
; Function compile flags: /Ogty
; File C:\duke4\xcore\xcore.h
;	COMDAT ??3@YAXPAX@Z
_TEXT	SEGMENT
_ptr$ = 8
??3@YAXPAX@Z PROC NEAR					; operator delete, COMDAT

; 130  : __inline void operator delete(void *ptr){xfree(ptr);}

	mov	ecx, DWORD PTR _ptr$[esp-4]
	jmp	@xfree@4
??3@YAXPAX@Z ENDP					; operator delete
_TEXT	ENDS
PUBLIC	?get_more@ErrMem@@QAEPADPADK@Z			; ErrMem::get_more
; Function compile flags: /Ogty
; File C:\duke4\xcore\global.cpp
_TEXT	SEGMENT
_mem$ = 8
_inc_size$ = 12
?get_more@ErrMem@@QAEPADPADK@Z PROC NEAR		; ErrMem::get_more
; _this$ = ecx

; 219  : 	ErrMem *emem=(ErrMem *)TlsGetValue(tls_index);

	mov	eax, DWORD PTR [ecx+8196]
	push	esi
	push	edi
	push	eax
	call	DWORD PTR __imp__TlsGetValue@4
	mov	edi, eax

; 220  : 	
; 221  : 	if (!emem)

	test	edi, edi
	jne	SHORT $L57292
	pop	edi
	pop	esi

; 247  : }

	ret	8
$L57292:

; 222  : 		return null;
; 223  : 
; 224  : 	inc_size=ALIGN_POW2(inc_size,ERR_MEM_CHUNK);

	mov	ecx, DWORD PTR _inc_size$[esp+4]
	push	ebx
	lea	esi, DWORD PTR [ecx+255]

; 225  : 	U32 bits=inc_size/ERR_MEM_CHUNK;
; 226  : 
; 227  : 	U32 off=(U32)(mem - emem->def_mem);
; 228  : 	
; 229  : 	off/=ERR_MEM_CHUNK;
; 230  : 	U32 end=(_bsf(emem->rotate) - 1);

	mov	ecx, DWORD PTR [edi]

; 243  : 	}
; 244  : 
; 245  : 	_rotl(emem->rotate,bits);
; 246  : 	return mem;

	shr	esi, 8
	call	@_bsf@4
	mov	edx, DWORD PTR _mem$[esp+8]
	dec	eax
	mov	ebx, edx
	mov	ecx, eax
	sub	ebx, edi
	sub	ebx, 4
	shr	ebx, 8
	sub	ecx, ebx
	pop	ebx
	add	ecx, esi
	cmp	ecx, 32					; 00000020H
	jbe	SHORT $L57305
	pop	edi
	xor	eax, eax
	pop	esi

; 247  : }

	ret	8
$L57305:

; 231  : 
; 232  : 	U32 total_bits=end - off + bits;
; 233  : 
; 234  : 	/* if asking for too much */
; 235  : 	if (total_bits>32)
; 236  : 		return null;
; 237  : 
; 238  : 	/* wrap memory, start at beginning */
; 239  : 	if ((end + bits) > 32)

	add	eax, esi
	cmp	eax, 32					; 00000020H
	jbe	SHORT $L57306

; 240  : 	{
; 241  : 		emem->rotate=_rotl(1,total_bits);

	mov	edx, 1

; 242  : 		return emem->def_mem;

	lea	eax, DWORD PTR [edi+4]
	rol	edx, cl
	mov	DWORD PTR [edi], edx
	pop	edi
	pop	esi

; 247  : }

	ret	8
$L57306:
	pop	edi

; 243  : 	}
; 244  : 
; 245  : 	_rotl(emem->rotate,bits);
; 246  : 	return mem;

	mov	eax, edx
	pop	esi

; 247  : }

	ret	8
?get_more@ErrMem@@QAEPADPADK@Z ENDP			; ErrMem::get_more
_TEXT	ENDS
PUBLIC	?add_thread@ErrMem@@QAEXXZ			; ErrMem::add_thread
EXTRN	@xmalloc@4:NEAR
; Function compile flags: /Ogty
_TEXT	SEGMENT
?add_thread@ErrMem@@QAEXXZ PROC NEAR			; ErrMem::add_thread
; _this$ = ecx

; 250  : {

	push	esi
	mov	esi, ecx

; 251  : 	ErrMem *emem=(ErrMem *)xmalloc(sizeof(ErrMem));

	mov	ecx, 8200				; 00002008H
	call	@xmalloc@4

; 252  : 	TlsSetValue(tls_index,emem);

	push	eax
	mov	eax, DWORD PTR [esi+8196]
	push	eax
	call	DWORD PTR __imp__TlsSetValue@8
	pop	esi

; 253  : }

	ret	0
?add_thread@ErrMem@@QAEXXZ ENDP				; ErrMem::add_thread
_TEXT	ENDS
PUBLIC	?remove_thread@ErrMem@@QAEXXZ			; ErrMem::remove_thread
; Function compile flags: /Ogty
_TEXT	SEGMENT
?remove_thread@ErrMem@@QAEXXZ PROC NEAR			; ErrMem::remove_thread
; _this$ = ecx

; 256  : {

	push	esi
	mov	esi, ecx

; 257  : 	ErrMem *emem=(ErrMem *)TlsGetValue(tls_index);

	mov	eax, DWORD PTR [esi+8196]
	push	eax
	call	DWORD PTR __imp__TlsGetValue@4

; 258  : 	
; 259  : 	if (emem)

	test	eax, eax
	je	SHORT $L57321

; 260  : 	{
; 261  : 		/* for my sanity */
; 262  : 		if (emem!=this)

	cmp	eax, esi
	je	SHORT $L57321

; 263  : 			xfree(emem);

	mov	ecx, eax
	call	@xfree@4
$L57321:

; 264  : 	}
; 265  : 
; 266  : 	TlsSetValue(tls_index,null);

	mov	ecx, DWORD PTR [esi+8196]
	push	0
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	pop	esi

; 267  : }

	ret	0
?remove_thread@ErrMem@@QAEXXZ ENDP			; ErrMem::remove_thread
_TEXT	ENDS
PUBLIC	?message@XGlobal@@QAEXKPBD@Z			; XGlobal::message
; Function compile flags: /Ogty
_TEXT	SEGMENT
_level$ = 8
_str$ = 12
?message@XGlobal@@QAEXKPBD@Z PROC NEAR			; XGlobal::message
; _this$ = ecx

; 271  : 	error->message(level,str);

	mov	ecx, DWORD PTR [ecx+8204]
	mov	eax, DWORD PTR [ecx]
	jmp	DWORD PTR [eax]
?message@XGlobal@@QAEXKPBD@Z ENDP			; XGlobal::message
; Function compile flags: /Ogty
?attach_thread@XGlobal@@QAEXPAX@Z PROC NEAR		; XGlobal::attach_thread
; _this$ = ecx

; 276  : 	err_mem.add_thread();

	add	ecx, 4
	call	?add_thread@ErrMem@@QAEXXZ		; ErrMem::add_thread

; 277  : }

	ret	4
?attach_thread@XGlobal@@QAEXPAX@Z ENDP			; XGlobal::attach_thread
; Function compile flags: /Ogty
?detach_thread@XGlobal@@QAEXPAX@Z PROC NEAR		; XGlobal::detach_thread
; _this$ = ecx

; 281  : 	err_mem.remove_thread();

	add	ecx, 4
	call	?remove_thread@ErrMem@@QAEXXZ		; ErrMem::remove_thread

; 282  : }

	ret	4
?detach_thread@XGlobal@@QAEXPAX@Z ENDP			; XGlobal::detach_thread
_TEXT	ENDS
PUBLIC	?printf@XGlobal@@QAAXKPBDZZ			; XGlobal::printf
PUBLIC	??_C@_0CF@MJGC@XGlobal?3?3printf?3?5Out?5of?5error?5me@ ; `string'
EXTRN	__imp___vsnprintf:NEAR
EXTRN	@xxx_fatal@4:NEAR
;	COMDAT ??_C@_0CF@MJGC@XGlobal?3?3printf?3?5Out?5of?5error?5me@
_DATA	SEGMENT
??_C@_0CF@MJGC@XGlobal?3?3printf?3?5Out?5of?5error?5me@ DB 'XGlobal::prin'
	DB	'tf: Out of error memory', 00H		; `string'
; Function compile flags: /Ogty
_DATA	ENDS
;	COMDAT ?printf@XGlobal@@QAAXKPBDZZ
_TEXT	SEGMENT
_level$ = 12
_str$ = 16
_this$ = 8
?printf@XGlobal@@QAAXKPBDZZ PROC NEAR			; XGlobal::printf, COMDAT

; 286  : 	char *mem;
; 287  : 	U32 size=512;
; 288  : 	
; 289  : 	mem=err_mem.get(size);

	mov	eax, DWORD PTR _this$[esp-4]
	push	ebx
	push	ebp
	push	esi
	lea	ebx, DWORD PTR [eax+4]
	push	edi
	push	512					; 00000200H
	mov	ecx, ebx
	call	?get@ErrMem@@QAEPADK@Z			; ErrMem::get
	mov	ebp, DWORD PTR __imp___vsnprintf
	mov	esi, eax
	mov	edi, 511				; 000001ffH
$L57349:

; 297  : 	{
; 298  : 		num=_vsnprintf(mem,size-1,str,args);

	mov	edx, DWORD PTR _str$[esp+12]
	lea	ecx, DWORD PTR _str$[esp+16]
	push	ecx
	push	edx
	push	edi
	push	esi
	call	ebp
	add	esp, 16					; 00000010H

; 299  : 		if (num!=-1)

	cmp	eax, -1
	jne	SHORT $L57350

; 300  : 			break;
; 301  : 		/* try and get a little more mem */
; 302  : 		if (!err_mem.get_more(mem,512))

	push	512					; 00000200H
	push	esi
	mov	ecx, ebx
	call	?get_more@ErrMem@@QAEPADPADK@Z		; ErrMem::get_more
	test	eax, eax
	je	SHORT $L58223

; 307  : 			return;
; 308  : 		}
; 309  : 		size+=512;

	add	edi, 512				; 00000200H

; 290  : 
; 291  : 	va_list  args;
; 292  : 	I32      num;
; 293  : 
; 294  : 	va_start(args,str);
; 295  : 
; 296  : 	while(1)

	jmp	SHORT $L57349
$L58223:

; 303  : 		{
; 304  : 			/* send it out even if incomplete, so we can get a clue */
; 305  : 			error->message(level,str);

	mov	eax, DWORD PTR _this$[esp+12]
	mov	ecx, DWORD PTR [eax+8204]
	mov	eax, DWORD PTR _str$[esp+12]
	push	eax
	mov	eax, DWORD PTR _level$[esp+16]
	mov	edx, DWORD PTR [ecx]
	push	eax
	call	DWORD PTR [edx]
	pop	edi
	pop	esi
	pop	ebp

; 306  : 			xxx_fatal("XGlobal::printf: Out of error memory");

	mov	ecx, OFFSET FLAT:??_C@_0CF@MJGC@XGlobal?3?3printf?3?5Out?5of?5error?5me@ ; `string'
	pop	ebx
	jmp	@xxx_fatal@4
$L57350:

; 310  : 	}
; 311  : 
; 312  : 	va_end(args);
; 313  : 
; 314  : 	/* send out as message */
; 315  : 	error->message(level,str);

	mov	ecx, DWORD PTR _this$[esp+12]
	mov	eax, DWORD PTR _str$[esp+12]
	push	eax
	mov	eax, DWORD PTR _level$[esp+16]
	mov	ecx, DWORD PTR [ecx+8204]
	push	eax
	mov	edx, DWORD PTR [ecx]
	call	DWORD PTR [edx]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 316  : }

	ret	0
?printf@XGlobal@@QAAXKPBDZZ ENDP			; XGlobal::printf
_TEXT	ENDS
PUBLIC	?throw_msg@XGlobal@@QAEXKPBD@Z			; XGlobal::throw_msg
; Function compile flags: /Ogty
_TEXT	SEGMENT
_level$ = 8
_str$ = 12
?throw_msg@XGlobal@@QAEXKPBD@Z PROC NEAR		; XGlobal::throw_msg
; _this$ = ecx

; 320  : 	if (sys_flags & SYS_IN_THROW)

	mov	eax, DWORD PTR [ecx+8260]
	test	al, 2
	je	SHORT $L57360

; 321  : 		fallback->throw_msg(level,str);

	mov	ecx, DWORD PTR [ecx+8208]
	mov	eax, DWORD PTR [ecx]
	jmp	DWORD PTR [eax+4]
$L57360:

; 322  : 	else
; 323  : 	{
; 324  : 		sys_flags|=SYS_IN_THROW;

	or	al, 2
	mov	DWORD PTR [ecx+8260], eax

; 325  : 		error->throw_msg(level,str);

	mov	ecx, DWORD PTR [ecx+8204]
	mov	eax, DWORD PTR [ecx]
	jmp	DWORD PTR [eax+4]
?throw_msg@XGlobal@@QAEXKPBD@Z ENDP			; XGlobal::throw_msg
_TEXT	ENDS
PUBLIC	?caught@XGlobal@@QAEXXZ				; XGlobal::caught
; Function compile flags: /Ogty
_TEXT	SEGMENT
?caught@XGlobal@@QAEXXZ PROC NEAR			; XGlobal::caught
; _this$ = ecx

; 332  : 	D_ASSERT(sys_flags & SYS_IN_THROW);
; 333  : 
; 334  : 	sys_flags &=~ SYS_IN_THROW;

	mov	eax, DWORD PTR [ecx+8260]
	and	al, -3					; fffffffdH
	mov	DWORD PTR [ecx+8260], eax

; 335  : }

	ret	0
?caught@XGlobal@@QAEXXZ ENDP				; XGlobal::caught
_TEXT	ENDS
PUBLIC	?fatal@XGlobal@@QAEXXZ				; XGlobal::fatal
; Function compile flags: /Ogty
_TEXT	SEGMENT
?fatal@XGlobal@@QAEXXZ PROC NEAR			; XGlobal::fatal
; _this$ = ecx

; 339  : 	/* use an alternate error mechanism */
; 340  : 	/* if already in fatal error */
; 341  : 	if (sys_flags & SYS_IN_FATAL)

	mov	eax, DWORD PTR [ecx+8260]
	test	al, 4

; 342  : 		_fatal_exit();
; 343  : 	else

	jne	SHORT $L58230

; 344  : 	{
; 345  : 		sys_flags|=SYS_IN_FATAL;

	or	al, 4
	mov	DWORD PTR [ecx+8260], eax
$L58230:

; 346  : 		_fatal_exit();

	jmp	?_fatal_exit@XGlobal@@QAEXXZ		; XGlobal::_fatal_exit
?fatal@XGlobal@@QAEXXZ ENDP				; XGlobal::fatal
_TEXT	ENDS
PUBLIC	?set_error@XGlobal@@QAEXPAVCError@@@Z		; XGlobal::set_error
; Function compile flags: /Ogty
_TEXT	SEGMENT
_Error$ = 8
?set_error@XGlobal@@QAEXPAVCError@@@Z PROC NEAR		; XGlobal::set_error
; _this$ = ecx

; 352  : 	D_ASSERT(Error);
; 353  : 	error=Error;

	mov	eax, DWORD PTR _Error$[esp-4]
	mov	DWORD PTR [ecx+8204], eax

; 354  : }

	ret	4
?set_error@XGlobal@@QAEXPAVCError@@@Z ENDP		; XGlobal::set_error
_TEXT	ENDS
PUBLIC	??0?$XChain@VCSysObj@@@@QAE@XZ			; XChain<CSysObj>::XChain<CSysObj>
; Function compile flags: /Ogty
; File C:\duke4\xcore\xclass.h
;	COMDAT ??0?$XChain@VCSysObj@@@@QAE@XZ
_TEXT	SEGMENT
??0?$XChain@VCSysObj@@@@QAE@XZ PROC NEAR		; XChain<CSysObj>::XChain<CSysObj>, COMDAT
; _this$ = ecx

; 830  : 	XChain(void) : head(null),tail(null) {}

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$XChain@VCSysObj@@@@QAE@XZ ENDP			; XChain<CSysObj>::XChain<CSysObj>
_TEXT	ENDS
PUBLIC	??0?$XChain@VCSysObj@@@@QAE@K@Z			; XChain<CSysObj>::XChain<CSysObj>
; Function compile flags: /Ogty
;	COMDAT ??0?$XChain@VCSysObj@@@@QAE@K@Z
_TEXT	SEGMENT
_owned$ = 8
??0?$XChain@VCSysObj@@@@QAE@K@Z PROC NEAR		; XChain<CSysObj>::XChain<CSysObj>, COMDAT
; _this$ = ecx

; 831  : 	XChain(U32 owned) : head(null),tail(null),xchain_state(owned) {}

	mov	eax, ecx
	mov	ecx, DWORD PTR _owned$[esp-4]
	shl	ecx, 31					; 0000001fH
	and	ecx, -2147483648			; 80000000H
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], ecx
	ret	4
??0?$XChain@VCSysObj@@@@QAE@K@Z ENDP			; XChain<CSysObj>::XChain<CSysObj>
_TEXT	ENDS
PUBLIC	?get_next@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z ; XChain<CSysObj>::get_next
; Function compile flags: /Ogty
;	COMDAT ?get_next@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z
_TEXT	SEGMENT
_ptr$ = 8
?get_next@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z PROC NEAR ; XChain<CSysObj>::get_next, COMDAT
; _this$ = ecx

; 840  : 	TYPE *get_next(TYPE *ptr){return ptr->next;}

	mov	eax, DWORD PTR _ptr$[esp-4]
	mov	eax, DWORD PTR [eax+4]
	ret	4
?get_next@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z ENDP ; XChain<CSysObj>::get_next
_TEXT	ENDS
PUBLIC	?get_prev@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z ; XChain<CSysObj>::get_prev
; Function compile flags: /Ogty
;	COMDAT ?get_prev@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z
_TEXT	SEGMENT
_ptr$ = 8
?get_prev@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z PROC NEAR ; XChain<CSysObj>::get_prev, COMDAT
; _this$ = ecx

; 841  : 	TYPE *get_prev(TYPE *ptr){return ptr->prev;}

	mov	eax, DWORD PTR _ptr$[esp-4]
	mov	eax, DWORD PTR [eax+8]
	ret	4
?get_prev@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z ENDP ; XChain<CSysObj>::get_prev
_TEXT	ENDS
PUBLIC	?get_head@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ ; XChain<CSysObj>::get_head
; Function compile flags: /Ogty
;	COMDAT ?get_head@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ
_TEXT	SEGMENT
?get_head@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ PROC NEAR ; XChain<CSysObj>::get_head, COMDAT
; _this$ = ecx

; 847  : 	inline TYPE *get_head(void){return head;}

	mov	eax, DWORD PTR [ecx]
	ret	0
?get_head@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ ENDP	; XChain<CSysObj>::get_head
_TEXT	ENDS
PUBLIC	?get_tail@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ ; XChain<CSysObj>::get_tail
; Function compile flags: /Ogty
;	COMDAT ?get_tail@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ
_TEXT	SEGMENT
?get_tail@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ PROC NEAR ; XChain<CSysObj>::get_tail, COMDAT
; _this$ = ecx

; 848  : 	inline TYPE *get_tail(void){return tail;}

	mov	eax, DWORD PTR [ecx+4]
	ret	0
?get_tail@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ ENDP	; XChain<CSysObj>::get_tail
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??1XStatManager@@QAE@XZ
_TEXT	SEGMENT
??1XStatManager@@QAE@XZ PROC NEAR			; XStatManager::~XStatManager, COMDAT
; _this$ = ecx
	push	ebx
	push	esi
	mov	esi, ecx
	push	edi
	xor	ebx, ebx
	mov	al, BYTE PTR [esi+35]
	lea	edi, DWORD PTR [esi+16]
	test	al, 1
	je	SHORT $L58272
	cmp	DWORD PTR [edi], ebx
	je	SHORT $L58272
$L58271:
	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [eax+8]
	call	@xfree@4
	mov	ecx, DWORD PTR [edi]
	mov	eax, DWORD PTR [ecx]
	cmp	eax, ebx
	mov	DWORD PTR [edi], eax
	jne	SHORT $L58271
$L58272:
	mov	ecx, edi
	call	@xlist_free_nodes@4
	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	jns	SHORT $L58294
	cmp	DWORD PTR [esi+4], ebx
	je	SHORT $L58294
$L58285:
	mov	edx, DWORD PTR [esi+4]
	mov	ecx, edx
	mov	edi, DWORD PTR [edx+40]
	call	@xfree@4
	cmp	edi, ebx
	mov	DWORD PTR [esi+4], edi
	jne	SHORT $L58285
$L58294:
	mov	DWORD PTR [esi+4], ebx
	mov	DWORD PTR [esi+8], ebx
	pop	edi
	pop	esi
	pop	ebx
	ret	0
??1XStatManager@@QAE@XZ ENDP				; XStatManager::~XStatManager
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??1?$XChain@VCSysObj@@@@QAE@XZ
_TEXT	SEGMENT
??1?$XChain@VCSysObj@@@@QAE@XZ PROC NEAR		; XChain<CSysObj>::~XChain<CSysObj>, COMDAT
; _this$ = ecx

; 853  : {

	push	esi
	mov	esi, ecx

; 854  : 	if (xchain_state.owned)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	jns	SHORT $L58318

; 855  : 	{
; 856  : 		while(head)

	cmp	DWORD PTR [esi], 0
	je	SHORT $L58318
	push	ebx
	push	edi
$L57461:

; 857  : 		{
; 858  : 			TYPE *tmp=(TYPE *)head->next;

	mov	eax, DWORD PTR [esi]

; 859  : 			delete head;

	mov	edi, eax
	mov	ebx, DWORD PTR [eax+4]
	test	edi, edi
	je	SHORT $L58299
	mov	DWORD PTR [edi], OFFSET FLAT:??_7CSysObj@@6B@ ; CSysObj::`vftable'
	mov	ecx, DWORD PTR ?_global@@3PAVXGlobal@@A	; _global
	push	edi
	call	?unreg_global_object@XGlobal@@QAEXPAVCSysObj@@@Z ; XGlobal::unreg_global_object
	mov	ecx, edi
	call	@xfree@4
$L58299:
	test	ebx, ebx

; 860  : 			head=tmp;

	mov	DWORD PTR [esi], ebx
	jne	SHORT $L57461
	pop	edi
	pop	ebx
$L58318:

; 861  : 		}
; 862  : 	}
; 863  : 	head=null;

	mov	DWORD PTR [esi], 0

; 864  : 	tail=null;

	mov	DWORD PTR [esi+4], 0
	pop	esi

; 865  : }

	ret	0
??1?$XChain@VCSysObj@@@@QAE@XZ ENDP			; XChain<CSysObj>::~XChain<CSysObj>
_TEXT	ENDS
PUBLIC	?lose_list@?$XChain@VCSysObj@@@@QAEXXZ		; XChain<CSysObj>::lose_list
; Function compile flags: /Ogty
;	COMDAT ?lose_list@?$XChain@VCSysObj@@@@QAEXXZ
_TEXT	SEGMENT
?lose_list@?$XChain@VCSysObj@@@@QAEXXZ PROC NEAR	; XChain<CSysObj>::lose_list, COMDAT
; _this$ = ecx

; 870  : 	head=null;tail=null;xchain_state.count=0;

	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [ecx], 0
	and	eax, -2147483648			; 80000000H
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], eax

; 871  : }

	ret	0
?lose_list@?$XChain@VCSysObj@@@@QAEXXZ ENDP		; XChain<CSysObj>::lose_list
_TEXT	ENDS
PUBLIC	?free_list@?$XChain@VCSysObj@@@@QAEXXZ		; XChain<CSysObj>::free_list
; Function compile flags: /Ogty
;	COMDAT ?free_list@?$XChain@VCSysObj@@@@QAEXXZ
_TEXT	SEGMENT
?free_list@?$XChain@VCSysObj@@@@QAEXXZ PROC NEAR	; XChain<CSysObj>::free_list, COMDAT
; _this$ = ecx

; 875  : {

	push	esi
	mov	esi, ecx

; 876  : 	if (xchain_state.owned)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	jns	SHORT $L58344

; 877  : 	{
; 878  : 		while(head)

	cmp	DWORD PTR [esi], 0
	je	SHORT $L58344
	push	ebx
	push	edi
$L57477:

; 879  : 		{
; 880  : 			TYPE *tmp=(TYPE *)head->next;

	mov	eax, DWORD PTR [esi]

; 881  : 			delete head;

	mov	edi, eax
	mov	ebx, DWORD PTR [eax+4]
	test	edi, edi
	je	SHORT $L58325
	mov	DWORD PTR [edi], OFFSET FLAT:??_7CSysObj@@6B@ ; CSysObj::`vftable'
	mov	ecx, DWORD PTR ?_global@@3PAVXGlobal@@A	; _global
	push	edi
	call	?unreg_global_object@XGlobal@@QAEXPAVCSysObj@@@Z ; XGlobal::unreg_global_object
	mov	ecx, edi
	call	@xfree@4
$L58325:
	test	ebx, ebx

; 882  : 			head=tmp;

	mov	DWORD PTR [esi], ebx
	jne	SHORT $L57477
	pop	edi
	pop	ebx
$L58344:

; 883  : 		}
; 884  : 	}
; 885  : 	head=null;tail=null;

	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+4], 0
	pop	esi

; 886  : }

	ret	0
?free_list@?$XChain@VCSysObj@@@@QAEXXZ ENDP		; XChain<CSysObj>::free_list
_TEXT	ENDS
PUBLIC	?add_head@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z ; XChain<CSysObj>::add_head
; Function compile flags: /Ogty
;	COMDAT ?add_head@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z
_TEXT	SEGMENT
_ptr$ = 8
?add_head@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z PROC NEAR ; XChain<CSysObj>::add_head, COMDAT
; _this$ = ecx

; 891  : 	ptr->next=head;

	mov	eax, DWORD PTR _ptr$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx

; 892  : 	ptr->prev=null;

	mov	DWORD PTR [eax+8], 0

; 893  : 	if (head)

	mov	edx, DWORD PTR [ecx]
	test	edx, edx
	je	SHORT $L57487

; 894  : 		head->prev=ptr;

	mov	DWORD PTR [edx+8], eax

; 897  : 	
; 898  : 	head=ptr;

	mov	DWORD PTR [ecx], eax

; 899  : 
; 900  : 	return head;
; 901  : }

	ret	4
$L57487:

; 895  : 	else
; 896  : 		tail=ptr;

	mov	DWORD PTR [ecx+4], eax

; 897  : 	
; 898  : 	head=ptr;

	mov	DWORD PTR [ecx], eax

; 899  : 
; 900  : 	return head;
; 901  : }

	ret	4
?add_head@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z ENDP ; XChain<CSysObj>::add_head
_TEXT	ENDS
PUBLIC	?add_tail@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z ; XChain<CSysObj>::add_tail
; Function compile flags: /Ogty
;	COMDAT ?add_tail@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z
_TEXT	SEGMENT
_ptr$ = 8
?add_tail@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z PROC NEAR ; XChain<CSysObj>::add_tail, COMDAT
; _this$ = ecx

; 906  : 	ptr->prev=tail;

	mov	eax, DWORD PTR _ptr$[esp-4]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+8], edx

; 907  : 	ptr->next=null;

	mov	DWORD PTR [eax+4], 0

; 908  : 	if (tail)

	mov	edx, DWORD PTR [ecx+4]
	test	edx, edx
	je	SHORT $L57493

; 909  : 		tail->next=ptr;

	mov	DWORD PTR [edx+4], eax

; 912  : 	
; 913  : 	tail=ptr;

	mov	DWORD PTR [ecx+4], eax

; 914  : 
; 915  : 	return tail;
; 916  : }

	ret	4
$L57493:

; 910  : 	else
; 911  : 		head=ptr;

	mov	DWORD PTR [ecx], eax

; 912  : 	
; 913  : 	tail=ptr;

	mov	DWORD PTR [ecx+4], eax

; 914  : 
; 915  : 	return tail;
; 916  : }

	ret	4
?add_tail@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z ENDP ; XChain<CSysObj>::add_tail
_TEXT	ENDS
PUBLIC	?remove_head@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ ; XChain<CSysObj>::remove_head
; Function compile flags: /Ogty
;	COMDAT ?remove_head@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ
_TEXT	SEGMENT
?remove_head@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ PROC NEAR ; XChain<CSysObj>::remove_head, COMDAT
; _this$ = ecx

; 937  : 	if (!head)

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	jne	SHORT $L57499

; 947  : 
; 948  : 	return ret;
; 949  : }

	ret	0
$L57499:

; 938  : 		return null;
; 939  : 
; 940  : 	TYPE *ret=head;
; 941  : 
; 942  : 	head=head->next;

	mov	edx, DWORD PTR [eax+4]

; 943  : 	if (!head)

	test	edx, edx
	mov	DWORD PTR [ecx], edx
	jne	SHORT $L57501

; 944  : 		tail=null;

	mov	DWORD PTR [ecx+4], edx

; 947  : 
; 948  : 	return ret;
; 949  : }

	ret	0
$L57501:

; 945  : 	else
; 946  : 		head->prev=null;

	mov	DWORD PTR [edx+8], 0

; 947  : 
; 948  : 	return ret;
; 949  : }

	ret	0
?remove_head@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ ENDP ; XChain<CSysObj>::remove_head
_TEXT	ENDS
PUBLIC	?remove_tail@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ ; XChain<CSysObj>::remove_tail
; Function compile flags: /Ogty
;	COMDAT ?remove_tail@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ
_TEXT	SEGMENT
?remove_tail@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ PROC NEAR ; XChain<CSysObj>::remove_tail, COMDAT
; _this$ = ecx

; 954  : 	if (!tail)

	mov	eax, DWORD PTR [ecx+4]
	test	eax, eax
	jne	SHORT $L57507

; 964  : 
; 965  : 	return ret;
; 966  : }

	ret	0
$L57507:

; 955  : 		return null;
; 956  : 
; 957  : 	TYPE *ret=tail;
; 958  : 
; 959  : 	tail=tail->prev;

	mov	edx, DWORD PTR [eax+8]

; 960  : 	if (!tail)

	test	edx, edx
	mov	DWORD PTR [ecx+4], edx
	jne	SHORT $L57509

; 961  : 		head=null;

	mov	DWORD PTR [ecx], edx

; 964  : 
; 965  : 	return ret;
; 966  : }

	ret	0
$L57509:

; 962  : 	else
; 963  : 		tail->next=null;

	mov	DWORD PTR [edx+4], 0

; 964  : 
; 965  : 	return ret;
; 966  : }

	ret	0
?remove_tail@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ ENDP ; XChain<CSysObj>::remove_tail
_TEXT	ENDS
PUBLIC	?remove@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z ; XChain<CSysObj>::remove
; Function compile flags: /Ogty
;	COMDAT ?remove@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z
_TEXT	SEGMENT
_ptr$ = 8
?remove@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z PROC NEAR ; XChain<CSysObj>::remove, COMDAT
; _this$ = ecx

; 921  : 	if (ptr->prev)

	mov	eax, DWORD PTR _ptr$[esp-4]
	mov	edx, DWORD PTR [eax+8]
	test	edx, edx
	je	SHORT $L57515
	push	esi

; 922  : 		ptr->prev->next=ptr->next;

	mov	esi, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], esi
	pop	esi

; 923  : 	else

	jmp	SHORT $L57516
$L57515:

; 924  : 		head=ptr->next;

	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx], edx
$L57516:

; 925  : 
; 926  : 	if (ptr->next)

	mov	edx, DWORD PTR [eax+4]
	test	edx, edx
	je	SHORT $L57517

; 927  : 		ptr->next->prev=ptr->prev;

	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], ecx

; 930  : 
; 931  : 	return ptr;
; 932  : }

	ret	4
$L57517:

; 928  : 	else
; 929  : 		tail=ptr->prev;

	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+4], edx

; 930  : 
; 931  : 	return ptr;
; 932  : }

	ret	4
?remove@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z ENDP ; XChain<CSysObj>::remove
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??1?$XList@PAX@@QAE@XZ
_TEXT	SEGMENT
??1?$XList@PAX@@QAE@XZ PROC NEAR			; XList<void *>::~XList<void *>, COMDAT
; _this$ = ecx

; 413  : {

	push	esi
	mov	esi, ecx

; 414  : 	if (xlist_state.owned)

	test	BYTE PTR [esi+19], 1
	je	SHORT $L57530

; 415  : 	{
; 416  : 		while(head)

	cmp	DWORD PTR [esi], 0
	je	SHORT $L57530
$L57529:

; 417  : 		{
; 418  : 			delete head->data;

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+8]
	call	@xfree@4

; 419  : 			head=head->next;

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	mov	DWORD PTR [esi], eax
	jne	SHORT $L57529
$L57530:

; 420  : 		}
; 421  : 	}
; 422  : 	free_nodes();

	mov	ecx, esi
	pop	esi
	jmp	@xlist_free_nodes@4
??1?$XList@PAX@@QAE@XZ ENDP				; XList<void *>::~XList<void *>
_TEXT	ENDS
PUBLIC	??_7XBufferReadInt@@6B@				; XBufferReadInt::`vftable'
PUBLIC	??_GXBufferReadInt@@UAEPAXI@Z			; XBufferReadInt::`scalar deleting destructor'
PUBLIC	??_EXBufferReadInt@@UAEPAXI@Z			; XBufferReadInt::`vector deleting destructor'
EXTRN	?read_direct@XBufferReadInt@@MAEKPAXKAAK@Z:NEAR	; XBufferReadInt::read_direct
;	COMDAT ??_7XBufferReadInt@@6B@
; File C:\duke4\xcore\xcore.h
CONST	SEGMENT
??_7XBufferReadInt@@6B@ DD FLAT:?read_direct@XBufferReadInt@@MAEKPAXKAAK@Z ; XBufferReadInt::`vftable'
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:??_EXBufferReadInt@@UAEPAXI@Z
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ??_GXBufferReadInt@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_GXBufferReadInt@@UAEPAXI@Z PROC NEAR			; XBufferReadInt::`scalar deleting destructor', COMDAT
; _this$ = ecx
	mov	al, BYTE PTR ___flags$[esp-4]
	push	esi
	mov	esi, ecx
	test	al, 1
	mov	DWORD PTR [esi], OFFSET FLAT:??_7XBufferReadInt@@6B@ ; XBufferReadInt::`vftable'
	je	SHORT $L58377
	call	@xfree@4
$L58377:
	mov	eax, esi
	pop	esi
	ret	4
??_GXBufferReadInt@@UAEPAXI@Z ENDP			; XBufferReadInt::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??1XBufferReadInt@@UAE@XZ			; XBufferReadInt::~XBufferReadInt
EXTRN	??_M@YGXPAXIHP6EX0@Z@Z:NEAR			; `eh vector destructor iterator'
; Function compile flags: /Ogty
;	COMDAT ??_EXBufferReadInt@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_EXBufferReadInt@@UAEPAXI@Z PROC NEAR			; XBufferReadInt::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebx
	mov	bl, BYTE PTR ___flags$[esp]
	push	esi
	mov	esi, ecx
	test	bl, 2
	je	SHORT $L56059
	mov	eax, DWORD PTR [esi-4]
	push	edi
	lea	edi, DWORD PTR [esi-4]
	push	OFFSET FLAT:??1XBufferReadInt@@UAE@XZ	; XBufferReadInt::~XBufferReadInt
	push	eax
	push	8
	push	esi
	call	??_M@YGXPAXIHP6EX0@Z@Z			; `eh vector destructor iterator'
	test	bl, 1
	je	SHORT $L58382
	mov	ecx, edi
	call	@xfree@4
$L58382:
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	ret	4
$L56059:
	test	bl, 1
	mov	DWORD PTR [esi], OFFSET FLAT:??_7XBufferReadInt@@6B@ ; XBufferReadInt::`vftable'
	je	SHORT $L58388
	mov	ecx, esi
	call	@xfree@4
$L58388:
	mov	eax, esi
	pop	esi
	pop	ebx
	ret	4
??_EXBufferReadInt@@UAEPAXI@Z ENDP			; XBufferReadInt::`vector deleting destructor'
; Function compile flags: /Ogty
; File C:\duke4\xcore\xstream.h
_TEXT	ENDS
;	COMDAT ??1XBufferReadInt@@UAE@XZ
_TEXT	SEGMENT
??1XBufferReadInt@@UAE@XZ PROC NEAR			; XBufferReadInt::~XBufferReadInt, COMDAT
; _this$ = ecx

; 37   : 	virtual ~XBufferReadInt(void){}

	mov	DWORD PTR [ecx], OFFSET FLAT:??_7XBufferReadInt@@6B@ ; XBufferReadInt::`vftable'
	ret	0
??1XBufferReadInt@@UAE@XZ ENDP				; XBufferReadInt::~XBufferReadInt
_TEXT	ENDS
PUBLIC	??_7XBufferWriteInt@@6B@			; XBufferWriteInt::`vftable'
PUBLIC	??_GXBufferWriteInt@@UAEPAXI@Z			; XBufferWriteInt::`scalar deleting destructor'
PUBLIC	??_EXBufferWriteInt@@UAEPAXI@Z			; XBufferWriteInt::`vector deleting destructor'
EXTRN	?write_direct@XBufferWriteInt@@MAEKPBXKAAK@Z:NEAR ; XBufferWriteInt::write_direct
;	COMDAT ??_7XBufferWriteInt@@6B@
; File C:\duke4\xcore\xcore.h
CONST	SEGMENT
??_7XBufferWriteInt@@6B@ DD FLAT:?write_direct@XBufferWriteInt@@MAEKPBXKAAK@Z ; XBufferWriteInt::`vftable'
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:??_EXBufferWriteInt@@UAEPAXI@Z
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ??_GXBufferWriteInt@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_GXBufferWriteInt@@UAEPAXI@Z PROC NEAR		; XBufferWriteInt::`scalar deleting destructor', COMDAT
; _this$ = ecx
	mov	al, BYTE PTR ___flags$[esp-4]
	push	esi
	mov	esi, ecx
	test	al, 1
	mov	DWORD PTR [esi], OFFSET FLAT:??_7XBufferWriteInt@@6B@ ; XBufferWriteInt::`vftable'
	je	SHORT $L58399
	call	@xfree@4
$L58399:
	mov	eax, esi
	pop	esi
	ret	4
??_GXBufferWriteInt@@UAEPAXI@Z ENDP			; XBufferWriteInt::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??1XBufferWriteInt@@UAE@XZ			; XBufferWriteInt::~XBufferWriteInt
; Function compile flags: /Ogty
;	COMDAT ??_EXBufferWriteInt@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_EXBufferWriteInt@@UAEPAXI@Z PROC NEAR		; XBufferWriteInt::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebx
	mov	bl, BYTE PTR ___flags$[esp]
	push	esi
	mov	esi, ecx
	test	bl, 2
	je	SHORT $L56111
	mov	eax, DWORD PTR [esi-4]
	push	edi
	lea	edi, DWORD PTR [esi-4]
	push	OFFSET FLAT:??1XBufferWriteInt@@UAE@XZ	; XBufferWriteInt::~XBufferWriteInt
	push	eax
	push	8
	push	esi
	call	??_M@YGXPAXIHP6EX0@Z@Z			; `eh vector destructor iterator'
	test	bl, 1
	je	SHORT $L58404
	mov	ecx, edi
	call	@xfree@4
$L58404:
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	ret	4
$L56111:
	test	bl, 1
	mov	DWORD PTR [esi], OFFSET FLAT:??_7XBufferWriteInt@@6B@ ; XBufferWriteInt::`vftable'
	je	SHORT $L58410
	mov	ecx, esi
	call	@xfree@4
$L58410:
	mov	eax, esi
	pop	esi
	pop	ebx
	ret	4
??_EXBufferWriteInt@@UAEPAXI@Z ENDP			; XBufferWriteInt::`vector deleting destructor'
; Function compile flags: /Ogty
; File C:\duke4\xcore\xstream.h
_TEXT	ENDS
;	COMDAT ??1XBufferWriteInt@@UAE@XZ
_TEXT	SEGMENT
??1XBufferWriteInt@@UAE@XZ PROC NEAR			; XBufferWriteInt::~XBufferWriteInt, COMDAT
; _this$ = ecx

; 56   : 	virtual ~XBufferWriteInt(void){}

	mov	DWORD PTR [ecx], OFFSET FLAT:??_7XBufferWriteInt@@6B@ ; XBufferWriteInt::`vftable'
	ret	0
??1XBufferWriteInt@@UAE@XZ ENDP				; XBufferWriteInt::~XBufferWriteInt
_TEXT	ENDS
PUBLIC	??1XStreamRdDirect@@UAE@XZ			; XStreamRdDirect::~XStreamRdDirect
PUBLIC	??_GXStreamRdDirect@@UAEPAXI@Z			; XStreamRdDirect::`scalar deleting destructor'
; Function compile flags: /Ogty
;	COMDAT ??_GXStreamRdDirect@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_GXStreamRdDirect@@UAEPAXI@Z PROC NEAR		; XStreamRdDirect::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1XStreamRdDirect@@UAE@XZ		; XStreamRdDirect::~XStreamRdDirect
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $L58418
	mov	ecx, esi
	call	@xfree@4
$L58418:
	mov	eax, esi
	pop	esi
	ret	4
??_GXStreamRdDirect@@UAEPAXI@Z ENDP			; XStreamRdDirect::`scalar deleting destructor'
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??1XStreamRdDirect@@UAE@XZ
_TEXT	SEGMENT
??1XStreamRdDirect@@UAE@XZ PROC NEAR			; XStreamRdDirect::~XStreamRdDirect, COMDAT
; _this$ = ecx

; 71   : 	~XStreamRdDirect(void){}

	mov	DWORD PTR [ecx], OFFSET FLAT:??_7XBufferReadInt@@6B@ ; XBufferReadInt::`vftable'
	ret	0
??1XStreamRdDirect@@UAE@XZ ENDP				; XStreamRdDirect::~XStreamRdDirect
_TEXT	ENDS
PUBLIC	??_EXStreamRdDirect@@UAEPAXI@Z			; XStreamRdDirect::`vector deleting destructor'
; Function compile flags: /Ogty
;	COMDAT ??_EXStreamRdDirect@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_EXStreamRdDirect@@UAEPAXI@Z PROC NEAR		; XStreamRdDirect::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebx
	mov	bl, BYTE PTR ___flags$[esp]
	push	esi
	mov	esi, ecx
	test	bl, 2
	je	SHORT $L56163
	mov	eax, DWORD PTR [esi-4]
	push	edi
	lea	edi, DWORD PTR [esi-4]
	push	OFFSET FLAT:??1XStreamRdDirect@@UAE@XZ	; XStreamRdDirect::~XStreamRdDirect
	push	eax
	push	8
	push	esi
	call	??_M@YGXPAXIHP6EX0@Z@Z			; `eh vector destructor iterator'
	test	bl, 1
	je	SHORT $L58429
	mov	ecx, edi
	call	@xfree@4
$L58429:
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	ret	4
$L56163:
	mov	ecx, esi
	call	??1XStreamRdDirect@@UAE@XZ		; XStreamRdDirect::~XStreamRdDirect
	test	bl, 1
	je	SHORT $L58431
	mov	ecx, esi
	call	@xfree@4
$L58431:
	mov	eax, esi
	pop	esi
	pop	ebx
	ret	4
??_EXStreamRdDirect@@UAEPAXI@Z ENDP			; XStreamRdDirect::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??1XStreamWrDirect@@UAE@XZ			; XStreamWrDirect::~XStreamWrDirect
PUBLIC	??_GXStreamWrDirect@@UAEPAXI@Z			; XStreamWrDirect::`scalar deleting destructor'
; Function compile flags: /Ogty
;	COMDAT ??_GXStreamWrDirect@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_GXStreamWrDirect@@UAEPAXI@Z PROC NEAR		; XStreamWrDirect::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1XStreamWrDirect@@UAE@XZ		; XStreamWrDirect::~XStreamWrDirect
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $L58438
	mov	ecx, esi
	call	@xfree@4
$L58438:
	mov	eax, esi
	pop	esi
	ret	4
??_GXStreamWrDirect@@UAEPAXI@Z ENDP			; XStreamWrDirect::`scalar deleting destructor'
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??1XStreamWrDirect@@UAE@XZ
_TEXT	SEGMENT
??1XStreamWrDirect@@UAE@XZ PROC NEAR			; XStreamWrDirect::~XStreamWrDirect, COMDAT
; _this$ = ecx

; 88   : 	~XStreamWrDirect(void){}

	mov	DWORD PTR [ecx], OFFSET FLAT:??_7XBufferWriteInt@@6B@ ; XBufferWriteInt::`vftable'
	ret	0
??1XStreamWrDirect@@UAE@XZ ENDP				; XStreamWrDirect::~XStreamWrDirect
_TEXT	ENDS
PUBLIC	??_EXStreamWrDirect@@UAEPAXI@Z			; XStreamWrDirect::`vector deleting destructor'
; Function compile flags: /Ogty
;	COMDAT ??_EXStreamWrDirect@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_EXStreamWrDirect@@UAEPAXI@Z PROC NEAR		; XStreamWrDirect::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebx
	mov	bl, BYTE PTR ___flags$[esp]
	push	esi
	mov	esi, ecx
	test	bl, 2
	je	SHORT $L56219
	mov	eax, DWORD PTR [esi-4]
	push	edi
	lea	edi, DWORD PTR [esi-4]
	push	OFFSET FLAT:??1XStreamWrDirect@@UAE@XZ	; XStreamWrDirect::~XStreamWrDirect
	push	eax
	push	8
	push	esi
	call	??_M@YGXPAXIHP6EX0@Z@Z			; `eh vector destructor iterator'
	test	bl, 1
	je	SHORT $L58449
	mov	ecx, edi
	call	@xfree@4
$L58449:
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	ret	4
$L56219:
	mov	ecx, esi
	call	??1XStreamWrDirect@@UAE@XZ		; XStreamWrDirect::~XStreamWrDirect
	test	bl, 1
	je	SHORT $L58451
	mov	ecx, esi
	call	@xfree@4
$L58451:
	mov	eax, esi
	pop	esi
	pop	ebx
	ret	4
??_EXStreamWrDirect@@UAEPAXI@Z ENDP			; XStreamWrDirect::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??1XMemRdBuffer@@UAE@XZ				; XMemRdBuffer::~XMemRdBuffer
PUBLIC	??_GXMemRdBuffer@@UAEPAXI@Z			; XMemRdBuffer::`scalar deleting destructor'
; Function compile flags: /Ogty
;	COMDAT ??_GXMemRdBuffer@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_GXMemRdBuffer@@UAEPAXI@Z PROC NEAR			; XMemRdBuffer::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1XMemRdBuffer@@UAE@XZ			; XMemRdBuffer::~XMemRdBuffer
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $L58458
	mov	ecx, esi
	call	@xfree@4
$L58458:
	mov	eax, esi
	pop	esi
	ret	4
??_GXMemRdBuffer@@UAEPAXI@Z ENDP			; XMemRdBuffer::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_7XMemRdBuffer@@6B@				; XMemRdBuffer::`vftable'
PUBLIC	??_EXMemRdBuffer@@UAEPAXI@Z			; XMemRdBuffer::`vector deleting destructor'
EXTRN	?read@XMemRdBuffer@@UAEKPAXKAAK1@Z:NEAR		; XMemRdBuffer::read
EXTRN	?seek@XMemRdBuffer@@UAEKJ@Z:NEAR		; XMemRdBuffer::seek
;	COMDAT ??_7XMemRdBuffer@@6B@
CONST	SEGMENT
??_7XMemRdBuffer@@6B@ DD FLAT:?read_direct@XBufferReadInt@@MAEKPAXKAAK@Z ; XMemRdBuffer::`vftable'
	DD	FLAT:?read@XMemRdBuffer@@UAEKPAXKAAK1@Z
	DD	FLAT:?seek@XMemRdBuffer@@UAEKJ@Z
	DD	FLAT:??_EXMemRdBuffer@@UAEPAXI@Z
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ??1XMemRdBuffer@@UAE@XZ
_TEXT	SEGMENT
??1XMemRdBuffer@@UAE@XZ PROC NEAR			; XMemRdBuffer::~XMemRdBuffer, COMDAT
; _this$ = ecx

; 109  : 	~XMemRdBuffer(void){}

	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET FLAT:??_7XMemRdBuffer@@6B@ ; XMemRdBuffer::`vftable'
	mov	ecx, DWORD PTR [esi+8]
	call	@xfree@4
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi], OFFSET FLAT:??_7XBufferReadInt@@6B@ ; XBufferReadInt::`vftable'
	pop	esi
	ret	0
??1XMemRdBuffer@@UAE@XZ ENDP				; XMemRdBuffer::~XMemRdBuffer
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??_EXMemRdBuffer@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_EXMemRdBuffer@@UAEPAXI@Z PROC NEAR			; XMemRdBuffer::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebx
	mov	bl, BYTE PTR ___flags$[esp]
	push	esi
	mov	esi, ecx
	test	bl, 2
	je	SHORT $L56272
	mov	eax, DWORD PTR [esi-4]
	push	edi
	lea	edi, DWORD PTR [esi-4]
	push	OFFSET FLAT:??1XMemRdBuffer@@UAE@XZ	; XMemRdBuffer::~XMemRdBuffer
	push	eax
	push	24					; 00000018H
	push	esi
	call	??_M@YGXPAXIHP6EX0@Z@Z			; `eh vector destructor iterator'
	test	bl, 1
	je	SHORT $L58474
	mov	ecx, edi
	call	@xfree@4
$L58474:
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	ret	4
$L56272:
	mov	ecx, esi
	call	??1XMemRdBuffer@@UAE@XZ			; XMemRdBuffer::~XMemRdBuffer
	test	bl, 1
	je	SHORT $L58476
	mov	ecx, esi
	call	@xfree@4
$L58476:
	mov	eax, esi
	pop	esi
	pop	ebx
	ret	4
??_EXMemRdBuffer@@UAEPAXI@Z ENDP			; XMemRdBuffer::`vector deleting destructor'
_TEXT	ENDS
END
