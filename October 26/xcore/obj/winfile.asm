; Listing generated by Microsoft (R) Optimizing Compiler Version 12.00.8943.0 

	TITLE	C:\duke4\xcore\winfile.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0BF@MBIJ@Cannot?5init?5CPrintfT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
drectve	SEGMENT DWORD USE32 PUBLIC ''
drectve	ENDS
;	COMDAT ??0?$XChain@VXStatistic@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?get_head@?$XList@VXStatistic@@@@QAEPAVXStatistic@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$XChain@VCSysObj@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$XChain@VCSysObj@@@@QAE@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?get_next@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?get_prev@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?get_head@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?get_tail@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$XChain@VXStatistic@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?free_list@?$XChain@VXStatistic@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$XList@VXStatistic@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$XList@VXStatistic@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?free_list@?$XList@VXStatistic@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?add_head@?$XList@VXStatistic@@@@QAEPAU_XPos@@PAVXStatistic@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?remove_head@?$XList@VXStatistic@@@@QAEPAVXStatistic@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$XChain@VCSysObj@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lose_list@?$XChain@VCSysObj@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?free_list@?$XChain@VCSysObj@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?add_head@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?add_tail@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?remove_head@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?remove_tail@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?remove@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$XList@PAX@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$XRcBase@VCStrObj@@@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$XRcBase@VCStrObj@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$XRcBase@VCStrObj@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$XRcBase@VCStrObj@@@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$XRcPtr@VCPathObj@@@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$XRcPtr@VCPathObj@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$XRcPtr@VCPathObj@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$XRcPtr@VCPathObj@@@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$XList@VXFindLevel@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$XList@VXFindLevel@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCSysObj@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GXFindLevel@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?new_node@?$XList@VXStatistic@@@@IAEPAUXNode@1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?free_nodes@?$XList@VXStatistic@@@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?free_nodes@?$XList@PAX@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?free_nodes@?$XList@VXFindLevel@@@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddRef@?$XRcBase@VCStrObj@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DelRef@?$XRcBase@VCStrObj@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddRef@?$XRcPtr@VCPathObj@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DelRef@?$XRcPtr@VCPathObj@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCStrObj@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCPathObj@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GXStreamWrDirect@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1XStreamWrDirect@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7XStreamWrDirect@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??1XBufferWriteInt@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7XBufferWriteInt@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_EXStreamWrDirect@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?flush@XStreamWrDirect@@UAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?seek@XStreamWrDirect@@UAEKJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GXStreamRdDirect@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1XStreamRdDirect@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7XStreamRdDirect@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??3XStreamRdDirect@@SAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_EXStreamRdDirect@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?seek@XStreamRdDirect@@UAEKJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?base_init@XFile@@EAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4autochar@@QAEAAV0@PAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GXBufferWriteInt@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_EXBufferWriteInt@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GXBufferReadInt@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_EXBufferReadInt@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pos_wr@CBaseStream@@UAEXKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pos_rd@CBaseStream@@UAEXKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?put@CBaseStream@@UAEKD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ioctl_write@CBaseStream@@UAEKKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ioctl_read@CBaseStream@@UAEKKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?seek_int@CBaseStream@@MAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GXMemRdBuffer@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1XMemRdBuffer@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_EXMemRdBuffer@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3CStrObj@@SAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CStrObj@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1XFindLevel@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CSysObj@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CSysObj@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??3@YAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0XListState@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3XStatistic@@SAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0XChainState@@QAE@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0XChainState@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0XStreamWrDirect@@QAE@PAVCBaseStream@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0XBufferWriteInt@@QAE@PAVCBaseStream@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3XStreamWrDirect@@SAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2XStreamWrDirect@@SAPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3XMemRdBuffer@@SAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2XMemRdBuffer@@SAPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Bautochar@@QAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?get_handle@CBaseStream@@QAEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7XMemRdBuffer@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??1autochar@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0autochar@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1XBufferReadInt@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7XBufferReadInt@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??0XBufferReadInt@@QAE@PAVCBaseStream@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
FLAT	GROUP _DATA, CONST, _BSS, drectve
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

drectve	SEGMENT
$SG56785 DB	'-INCLUDE:___@@_PchSym_@00@UwfpvEUcxlivUlyqUhgwxlivOlyq@', 00H
drectve	ENDS
PUBLIC	?read_direct@XBufferReadInt@@MAEKPAXKAAK@Z	; XBufferReadInt::read_direct
PUBLIC	??0XMemRdBuffer@@QAE@PAVCBaseStream@@K@Z	; XMemRdBuffer::XMemRdBuffer
PUBLIC	??_7XMemRdBuffer@@6B@				; XMemRdBuffer::`vftable'
PUBLIC	??_EXMemRdBuffer@@UAEPAXI@Z			; XMemRdBuffer::`vector deleting destructor'
EXTRN	?read@XMemRdBuffer@@UAEKPAXKAAK1@Z:NEAR		; XMemRdBuffer::read
EXTRN	?seek@XMemRdBuffer@@UAEKJ@Z:NEAR		; XMemRdBuffer::seek
;	COMDAT ??_7XMemRdBuffer@@6B@
; File C:\duke4\xcore\xclass.h
CONST	SEGMENT
??_7XMemRdBuffer@@6B@ DD FLAT:?read_direct@XBufferReadInt@@MAEKPAXKAAK@Z ; XMemRdBuffer::`vftable'
	DD	FLAT:?read@XMemRdBuffer@@UAEKPAXKAAK1@Z
	DD	FLAT:?seek@XMemRdBuffer@@UAEKJ@Z
	DD	FLAT:??_EXMemRdBuffer@@UAEPAXI@Z
; Function compile flags: /Ogty
; File C:\duke4\xcore\winfile.cpp
CONST	ENDS
_TEXT	SEGMENT
_Stream$ = 8
_size$ = 12
??0XMemRdBuffer@@QAE@PAVCBaseStream@@K@Z PROC NEAR	; XMemRdBuffer::XMemRdBuffer
; _this$ = ecx

; 6    : {

	mov	edx, DWORD PTR _size$[esp-4]
	mov	eax, ecx
	mov	ecx, DWORD PTR _Stream$[esp-4]
	mov	DWORD PTR [eax+4], ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], edx
	mov	DWORD PTR [eax+16], ecx
	mov	DWORD PTR [eax], OFFSET FLAT:??_7XMemRdBuffer@@6B@ ; XMemRdBuffer::`vftable'

; 7    : }

	ret	8
??0XMemRdBuffer@@QAE@PAVCBaseStream@@K@Z ENDP		; XMemRdBuffer::XMemRdBuffer
_TEXT	ENDS
EXTRN	__imp__ReadFile@20:NEAR
; Function compile flags: /Ogty
_TEXT	SEGMENT
_mem$ = 8
_size$ = 12
_num_read$ = 16
?read_direct@XBufferReadInt@@MAEKPAXKAAK@Z PROC NEAR	; XBufferReadInt::read_direct
; _this$ = ecx

; 11   : 	if (!ReadFile(stream->get_handle(),mem,size,&num_read,null))

	mov	edx, DWORD PTR _mem$[esp-4]
	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR _size$[esp]
	push	edi
	mov	edi, DWORD PTR _num_read$[esp+4]
	mov	eax, DWORD PTR [esi+4]
	push	0
	push	edi
	push	ecx
	mov	eax, DWORD PTR [eax+16]
	push	edx
	push	eax
	call	DWORD PTR __imp__ReadFile@20
	test	eax, eax
	jne	SHORT $L56798
	pop	edi
	pop	esi

; 17   : }

	ret	12					; 0000000cH
$L56798:

; 12   : 		return 0;
; 13   : 
; 14   : 	stream->pos_rd(num_read,num_read);

	mov	ecx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [edi]
	push	eax
	push	eax
	mov	edx, DWORD PTR [ecx]
	call	DWORD PTR [edx+56]
	pop	edi

; 15   : 
; 16   : 	return TRUE;

	mov	eax, 1
	pop	esi

; 17   : }

	ret	12					; 0000000cH
?read_direct@XBufferReadInt@@MAEKPAXKAAK@Z ENDP		; XBufferReadInt::read_direct
_TEXT	ENDS
PUBLIC	?write_direct@XBufferWriteInt@@MAEKPBXKAAK@Z	; XBufferWriteInt::write_direct
EXTRN	__imp__WriteFile@20:NEAR
; Function compile flags: /Ogty
_TEXT	SEGMENT
_mem$ = 8
_size$ = 12
_num_written$ = 16
?write_direct@XBufferWriteInt@@MAEKPBXKAAK@Z PROC NEAR	; XBufferWriteInt::write_direct
; _this$ = ecx

; 20   : {

	push	esi
	mov	esi, ecx

; 21   : 	if (!size)

	mov	ecx, DWORD PTR _size$[esp]
	push	edi
	test	ecx, ecx
	jne	SHORT $L56805
	pop	edi

; 22   : 		return 0;

	xor	eax, eax
	pop	esi

; 30   : }

	ret	12					; 0000000cH
$L56805:

; 23   : 	
; 24   : 	if (!WriteFile(stream->get_handle(),mem,size,&num_written,null))

	mov	edi, DWORD PTR _num_written$[esp+4]
	mov	eax, DWORD PTR [esi+4]
	push	0
	push	edi
	mov	eax, DWORD PTR [eax+16]
	push	ecx
	mov	ecx, DWORD PTR _mem$[esp+16]
	push	ecx
	push	eax
	call	DWORD PTR __imp__WriteFile@20
	test	eax, eax
	jne	SHORT $L56806
	pop	edi
	pop	esi

; 30   : }

	ret	12					; 0000000cH
$L56806:

; 25   : 		return 0;
; 26   : 
; 27   : 	stream->pos_wr(num_written,num_written);

	mov	ecx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [edi]
	push	eax
	push	eax
	mov	edx, DWORD PTR [ecx]
	call	DWORD PTR [edx+60]
	pop	edi

; 28   : 
; 29   : 	return TRUE;

	mov	eax, 1
	pop	esi

; 30   : }

	ret	12					; 0000000cH
?write_direct@XBufferWriteInt@@MAEKPBXKAAK@Z ENDP	; XBufferWriteInt::write_direct
_TEXT	ENDS
PUBLIC	?std_close@XFile@@AAEKXZ			; XFile::std_close
EXTRN	__imp__CloseHandle@4:NEAR
; Function compile flags: /Ogty
_TEXT	SEGMENT
?std_close@XFile@@AAEKXZ PROC NEAR			; XFile::std_close
; _this$ = ecx

; 33   : {

	push	esi
	mov	esi, ecx

; 34   : 	if (handle)

	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
	je	SHORT $L57271

; 35   : 		CloseHandle(handle);

	push	eax
	call	DWORD PTR __imp__CloseHandle@4
$L57271:

; 36   : 
; 37   : 	handle=null;

	mov	DWORD PTR [esi+16], 0

; 38   : 	return TRUE;

	mov	eax, 1
	pop	esi

; 39   : }

	ret	0
?std_close@XFile@@AAEKXZ ENDP				; XFile::std_close
_TEXT	ENDS
PUBLIC	?destroy@XFile@@EAEKXZ				; XFile::destroy
; Function compile flags: /Ogty
_TEXT	SEGMENT
?destroy@XFile@@EAEKXZ PROC NEAR			; XFile::destroy
; _this$ = ecx

; 42   : {

	push	esi
	mov	esi, ecx

; 43   : 	if (handle)

	mov	eax, DWORD PTR [esi-12]
	test	eax, eax
	je	SHORT $L57273

; 44   : 		CloseHandle(handle);

	push	eax
	call	DWORD PTR __imp__CloseHandle@4
$L57273:

; 45   : 	handle=null;

	mov	DWORD PTR [esi-12], 0

; 46   : 	return TRUE;

	mov	eax, 1
	pop	esi

; 47   : }

	ret	0
?destroy@XFile@@EAEKXZ ENDP				; XFile::destroy
_TEXT	ENDS
PUBLIC	?std_open@XFile@@AAEKXZ				; XFile::std_open
PUBLIC	?std_seek@XFile@@AAEKJK@Z			; XFile::std_seek
EXTRN	__imp__CreateFileA@28:NEAR
; Function compile flags: /Ogty
_TEXT	SEGMENT
_security$ = -12
?std_open@XFile@@AAEKXZ PROC NEAR			; XFile::std_open
; _this$ = ecx

; 50   : {

	sub	esp, 12					; 0000000cH

; 51   : 	SECURITY_ATTRIBUTES security;
; 52   : 	U32 access,share_mode,create;
; 53   : 
; 54   : 	access=0;

	xor	edx, edx
	push	esi
	mov	esi, ecx

; 55   : 	if (state.read)

	mov	eax, DWORD PTR [esi+4]
	test	al, 2
	je	SHORT $L56825

; 56   : 		access|=GENERIC_READ;

	mov	edx, -2147483648			; 80000000H
$L56825:

; 57   : 	if (state.write)

	test	al, 4
	je	SHORT $L56826

; 58   : 		access|=GENERIC_WRITE;

	or	edx, 1073741824				; 40000000H
$L56826:

; 59   : 	
; 60   : 	create=OPEN_EXISTING;
; 61   : 	if (state.create)

	test	al, 64					; 00000040H
	mov	ecx, 3
	je	SHORT $L56827

; 62   : 		create=OPEN_ALWAYS;

	mov	ecx, 4
$L56827:

; 63   : 	if (state.truncate)

	test	al, al
	jns	SHORT $L56828

; 64   : 		create=CREATE_ALWAYS;

	mov	ecx, 2
$L56828:

; 65   : 
; 66   : 	share_mode=FILE_SHARE_READ|FILE_SHARE_WRITE;
; 67   : 
; 68   : 	security.bInheritHandle=TRUE;
; 69   : 	security.lpSecurityDescriptor=null;
; 70   : 	security.nLength=sizeof(SECURITY_ATTRIBUTES);
; 71   : 
; 72   : 	handle=CreateFile(name,
; 73   : 					  access,share_mode,
; 74   : 					  &security,
; 75   : 					  create,FILE_ATTRIBUTE_NORMAL,
; 76   : 					  null);

	mov	eax, DWORD PTR [esi+40]
	push	0
	push	128					; 00000080H
	push	ecx
	lea	ecx, DWORD PTR _security$[esp+28]
	mov	DWORD PTR _security$[esp+36], 1
	push	ecx
	push	3
	push	edx
	push	eax
	mov	DWORD PTR _security$[esp+48], 0
	mov	DWORD PTR _security$[esp+44], 12	; 0000000cH
	call	DWORD PTR __imp__CreateFileA@28

; 77   : 	
; 78   : 	if (((I32)handle)<=0)

	test	eax, eax
	mov	DWORD PTR [esi+16], eax
	jg	SHORT $L56831

; 79   : 		return FALSE;

	xor	eax, eax
	pop	esi

; 92   : }

	add	esp, 12					; 0000000cH
	ret	0
$L56831:

; 80   : 
; 81   : 	if (state.append)

	test	BYTE PTR [esi+4], 8
	je	SHORT $L56833

; 82   : 	{
; 83   : 		if (!std_seek(0,FILE_SEEK_END))

	push	3
	push	0
	mov	ecx, esi
	call	?std_seek@XFile@@AAEKJK@Z		; XFile::std_seek
	test	eax, eax
	jne	SHORT $L56833

; 84   : 		{
; 85   : 			CloseHandle(handle);

	mov	edx, DWORD PTR [esi+16]
	push	edx
	call	DWORD PTR __imp__CloseHandle@4

; 86   : 			return FALSE;

	xor	eax, eax
	pop	esi

; 92   : }

	add	esp, 12					; 0000000cH
	ret	0
$L56833:

; 87   : 		}
; 88   : 	}
; 89   : 
; 90   : 	state.is_open=TRUE;

	mov	eax, DWORD PTR [esi+4]
	or	ah, 1
	mov	DWORD PTR [esi+4], eax

; 91   : 	return TRUE;

	mov	eax, 1
	pop	esi

; 92   : }

	add	esp, 12					; 0000000cH
	ret	0
?std_open@XFile@@AAEKXZ ENDP				; XFile::std_open
_TEXT	ENDS
EXTRN	__imp__SetFilePointer@16:NEAR
EXTRN	@xxx_fatal@4:NEAR
_DATA	SEGMENT
$SG56848 DB	'XFile::std_seek: invalid type of seek', 00H
; Function compile flags: /Ogty
_DATA	ENDS
_TEXT	SEGMENT
_offset$ = 8
_type$ = 12
?std_seek@XFile@@AAEKJK@Z PROC NEAR			; XFile::std_seek
; _this$ = ecx

; 95   : {

	push	esi

; 96   : 	I32 ret;
; 97   : 
; 98   : 	switch(type)
; 99   : 	{

	mov	esi, DWORD PTR _type$[esp]
	mov	eax, esi
	push	edi
	dec	eax
	mov	edi, ecx
	je	SHORT $L56844
	dec	eax
	je	SHORT $L56845
	dec	eax
	je	SHORT $L56846

; 109  : 		default:
; 110  : 			xxx_fatal("XFile::std_seek: invalid type of seek");

	mov	ecx, OFFSET FLAT:$SG56848
	call	@xxx_fatal@4

; 111  : 			break;

	jmp	SHORT $L56841
$L56846:

; 106  : 		case FILE_SEEK_END:
; 107  : 			type=FILE_END;

	mov	esi, 2

; 108  : 			break;

	jmp	SHORT $L56841
$L56845:

; 102  : 			break;
; 103  : 		case FILE_SEEK_CUR:
; 104  : 			type=FILE_CURRENT;

	mov	esi, 1

; 105  : 			break;

	jmp	SHORT $L56841
$L56844:

; 100  : 		case FILE_SEEK_SET:
; 101  : 			type=FILE_BEGIN;

	xor	esi, esi
$L56841:

; 112  : 	}
; 113  : 	
; 114  : 	ret=SetFilePointer(handle,offset,null,type);

	mov	eax, DWORD PTR _offset$[esp+4]
	mov	ecx, DWORD PTR [edi+16]
	push	esi
	push	0
	push	eax
	push	ecx
	call	DWORD PTR __imp__SetFilePointer@16

; 115  : 	if (ret<0)

	test	eax, eax
	jge	SHORT $L56849
	pop	edi

; 116  : 		return FALSE;

	xor	eax, eax
	pop	esi

; 121  : }

	ret	8
$L56849:

; 117  : 
; 118  : 	state.pos_at=ret;

	mov	DWORD PTR [edi+8], eax

; 119  : 	state.pos_should=ret;

	mov	DWORD PTR [edi+12], eax
	pop	edi

; 120  : 	return TRUE;

	mov	eax, 1
	pop	esi

; 121  : }

	ret	8
?std_seek@XFile@@AAEKJK@Z ENDP				; XFile::std_seek
_TEXT	ENDS
PUBLIC	?load_in_memory@XFile@@QAEKK@Z			; XFile::load_in_memory
EXTRN	__imp__GetFileSize@8:NEAR
EXTRN	?set_rd_interface@CBaseStream@@IAEXPAVXBufferReadInt@@@Z:NEAR ; CBaseStream::set_rd_interface
EXTRN	@xxx_throw@4:NEAR
EXTRN	@xmalloc@4:NEAR
_DATA	SEGMENT
	ORG $+2
$SG56859 DB	'XFile::load_in_memory: Unable to get file size', 00H
; Function compile flags: /Ogty
_DATA	ENDS
_TEXT	SEGMENT
_max_size$ = 8
_file_size_high$ = -4
?load_in_memory@XFile@@QAEKK@Z PROC NEAR		; XFile::load_in_memory
; _this$ = ecx

; 124  : {

	push	ecx
	push	esi
	push	edi
	mov	edi, ecx

; 125  : 	if (!state.is_open)

	mov	eax, DWORD PTR [edi+4]
	test	ah, 1
	jne	SHORT $L56854
	pop	edi

; 126  : 		return FALSE;

	xor	eax, eax
	pop	esi

; 147  : }

	pop	ecx
	ret	4
$L56854:

; 127  : 
; 128  : 	U32 file_size,file_size_high;
; 129  : 
; 130  : 	file_size=GetFileSize(handle,&file_size_high);

	mov	ecx, DWORD PTR [edi+16]
	lea	eax, DWORD PTR _file_size_high$[esp+12]
	push	eax
	push	ecx
	call	DWORD PTR __imp__GetFileSize@8
	mov	esi, eax

; 131  : 	if (((I32)file_size)==-1)

	cmp	esi, -1
	jne	SHORT $L56858

; 132  : 		xxx_throw("XFile::load_in_memory: Unable to get file size");

	mov	ecx, OFFSET FLAT:$SG56859
	call	@xxx_throw@4
$L56858:

; 133  : 
; 134  : 	/* don't handle LARGE file sizes for loading in memory */
; 135  : 	if (file_size_high)

	mov	eax, DWORD PTR _file_size_high$[esp+12]
	test	eax, eax
	je	SHORT $L56860
	pop	edi

; 136  : 		return FALSE;

	xor	eax, eax
	pop	esi

; 147  : }

	pop	ecx
	ret	4
$L56860:

; 137  : 
; 138  : 	/* if exceeds max size */
; 139  : 	if (file_size > ((U64)max_size))

	cmp	esi, DWORD PTR _max_size$[esp+8]
	jbe	SHORT $L56862
	pop	edi

; 140  : 		return FALSE;

	xor	eax, eax
	pop	esi

; 147  : }

	pop	ecx
	ret	4
$L56862:

; 141  : 
; 142  : 	U32 buf_size=(U32)file_size;
; 143  : 
; 144  : 	set_rd_interface(new XMemRdBuffer(this,buf_size));

	mov	ecx, 24					; 00000018H
	call	@xmalloc@4
	test	eax, eax
	je	SHORT $L57283
	push	esi
	push	edi
	mov	ecx, eax
	call	??0XMemRdBuffer@@QAE@PAVCBaseStream@@K@Z ; XMemRdBuffer::XMemRdBuffer
	push	eax
	mov	ecx, edi
	call	?set_rd_interface@CBaseStream@@IAEXPAVXBufferReadInt@@@Z ; CBaseStream::set_rd_interface
	pop	edi

; 145  : 
; 146  : 	return TRUE;

	mov	eax, 1
	pop	esi

; 147  : }

	pop	ecx
	ret	4
$L57283:

; 141  : 
; 142  : 	U32 buf_size=(U32)file_size;
; 143  : 
; 144  : 	set_rd_interface(new XMemRdBuffer(this,buf_size));

	xor	eax, eax
	mov	ecx, edi
	push	eax
	call	?set_rd_interface@CBaseStream@@IAEXPAVXBufferReadInt@@@Z ; CBaseStream::set_rd_interface
	pop	edi

; 145  : 
; 146  : 	return TRUE;

	mov	eax, 1
	pop	esi

; 147  : }

	pop	ecx
	ret	4
?load_in_memory@XFile@@QAEKK@Z ENDP			; XFile::load_in_memory
_TEXT	ENDS
PUBLIC	?seek@XStreamWrDirect@@UAEKJ@Z			; XStreamWrDirect::seek
PUBLIC	?flush@XStreamWrDirect@@UAEKXZ			; XStreamWrDirect::flush
PUBLIC	??_7XStreamWrDirect@@6B@			; XStreamWrDirect::`vftable'
PUBLIC	??_EXStreamWrDirect@@UAEPAXI@Z			; XStreamWrDirect::`vector deleting destructor'
PUBLIC	?open@CStdOut@@QAEKXZ				; CStdOut::open
EXTRN	?write@XStreamWrDirect@@UAEKPBXKAAK1@Z:NEAR	; XStreamWrDirect::write
EXTRN	__imp__GetStdHandle@4:NEAR
EXTRN	?set_wr_interface@CBaseStream@@IAEXPAVXBufferWriteInt@@@Z:NEAR ; CBaseStream::set_wr_interface
;	COMDAT ??_7XStreamWrDirect@@6B@
; File C:\duke4\xcore\xstream.h
CONST	SEGMENT
??_7XStreamWrDirect@@6B@ DD FLAT:?write_direct@XBufferWriteInt@@MAEKPBXKAAK@Z ; XStreamWrDirect::`vftable'
	DD	FLAT:?write@XStreamWrDirect@@UAEKPBXKAAK1@Z
	DD	FLAT:?seek@XStreamWrDirect@@UAEKJ@Z
	DD	FLAT:?flush@XStreamWrDirect@@UAEKXZ
	DD	FLAT:??_EXStreamWrDirect@@UAEPAXI@Z
; Function compile flags: /Ogty
; File C:\duke4\xcore\winfile.cpp
CONST	ENDS
_TEXT	SEGMENT
?open@CStdOut@@QAEKXZ PROC NEAR				; CStdOut::open
; _this$ = ecx

; 173  : {

	push	esi
	mov	esi, ecx

; 174  : 	base_init();

	mov	eax, DWORD PTR [esi]
	call	DWORD PTR [eax]

; 175  : 
; 176  : 	handle=GetStdHandle(STD_OUTPUT_HANDLE);

	push	-11					; fffffff5H
	call	DWORD PTR __imp__GetStdHandle@4

; 177  : 	if (!handle)

	test	eax, eax
	mov	DWORD PTR [esi+16], eax
	jne	SHORT $L56874
	pop	esi

; 185  : }

	ret	0
$L56874:

; 178  : 		return FALSE;
; 179  : 
; 180  : 	set_wr_interface(new XStreamWrDirect(this));

	mov	ecx, 8
	call	@xmalloc@4
	test	eax, eax
	je	SHORT $L57292
	mov	DWORD PTR [eax+4], esi
	mov	DWORD PTR [eax], OFFSET FLAT:??_7XStreamWrDirect@@6B@ ; XStreamWrDirect::`vftable'
	jmp	SHORT $L57293
$L57292:
	xor	eax, eax
$L57293:
	push	eax
	mov	ecx, esi
	call	?set_wr_interface@CBaseStream@@IAEXPAVXBufferWriteInt@@@Z ; CBaseStream::set_wr_interface

; 181  : 	
; 182  : 	state.is_open=TRUE;

	mov	eax, DWORD PTR [esi+4]
	or	ah, 1
	mov	DWORD PTR [esi+4], eax

; 183  : 
; 184  : 	return TRUE;

	mov	eax, 1
	pop	esi

; 185  : }

	ret	0
?open@CStdOut@@QAEKXZ ENDP				; CStdOut::open
_TEXT	ENDS
PUBLIC	@file_exist@4
EXTRN	__imp__GetFileAttributesA@4:NEAR
; Function compile flags: /Ogty
_TEXT	SEGMENT
@file_exist@4 PROC NEAR
; _path$ = ecx

; 195  : 	U32 attr=GetFileAttributes(path);

	push	ecx
	call	DWORD PTR __imp__GetFileAttributesA@4

; 196  : 	
; 197  : 	if (attr==-1)

	cmp	eax, -1
	jne	SHORT $L56884

; 198  : 		return FALSE;

	xor	eax, eax

; 201  : 		return FALSE;
; 202  : 
; 203  : 	return TRUE;
; 204  : }

	ret	0
$L56884:

; 199  : 
; 200  : 	if (attr&(FILE_ATTRIBUTE_DIRECTORY|FILE_ATTRIBUTE_DEVICE))

	and	al, 80					; 00000050H
	neg	al
	sbb	eax, eax
	inc	eax

; 201  : 		return FALSE;
; 202  : 
; 203  : 	return TRUE;
; 204  : }

	ret	0
@file_exist@4 ENDP
_TEXT	ENDS
PUBLIC	??0?$XChain@VCSysObj@@@@QAE@XZ			; XChain<CSysObj>::XChain<CSysObj>
; Function compile flags: /Ogty
; File C:\duke4\xcore\xclass.h
;	COMDAT ??0?$XChain@VCSysObj@@@@QAE@XZ
_TEXT	SEGMENT
??0?$XChain@VCSysObj@@@@QAE@XZ PROC NEAR		; XChain<CSysObj>::XChain<CSysObj>, COMDAT
; _this$ = ecx

; 830  : 	XChain(void) : head(null),tail(null) {}

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$XChain@VCSysObj@@@@QAE@XZ ENDP			; XChain<CSysObj>::XChain<CSysObj>
_TEXT	ENDS
PUBLIC	??3@YAXPAX@Z					; operator delete
EXTRN	@xfree@4:NEAR
; Function compile flags: /Ogty
; File C:\duke4\xcore\xcore.h
;	COMDAT ??3@YAXPAX@Z
_TEXT	SEGMENT
_ptr$ = 8
??3@YAXPAX@Z PROC NEAR					; operator delete, COMDAT

; 130  : __inline void operator delete(void *ptr){xfree(ptr);}

	mov	ecx, DWORD PTR _ptr$[esp-4]
	jmp	@xfree@4
??3@YAXPAX@Z ENDP					; operator delete
_TEXT	ENDS
PUBLIC	??0?$XChain@VCSysObj@@@@QAE@K@Z			; XChain<CSysObj>::XChain<CSysObj>
; Function compile flags: /Ogty
; File C:\duke4\xcore\xclass.h
;	COMDAT ??0?$XChain@VCSysObj@@@@QAE@K@Z
_TEXT	SEGMENT
_owned$ = 8
??0?$XChain@VCSysObj@@@@QAE@K@Z PROC NEAR		; XChain<CSysObj>::XChain<CSysObj>, COMDAT
; _this$ = ecx

; 831  : 	XChain(U32 owned) : head(null),tail(null),xchain_state(owned) {}

	mov	eax, ecx
	mov	ecx, DWORD PTR _owned$[esp-4]
	shl	ecx, 31					; 0000001fH
	and	ecx, -2147483648			; 80000000H
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], ecx
	ret	4
??0?$XChain@VCSysObj@@@@QAE@K@Z ENDP			; XChain<CSysObj>::XChain<CSysObj>
_TEXT	ENDS
PUBLIC	?get_next@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z ; XChain<CSysObj>::get_next
; Function compile flags: /Ogty
;	COMDAT ?get_next@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z
_TEXT	SEGMENT
_ptr$ = 8
?get_next@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z PROC NEAR ; XChain<CSysObj>::get_next, COMDAT
; _this$ = ecx

; 840  : 	TYPE *get_next(TYPE *ptr){return ptr->next;}

	mov	eax, DWORD PTR _ptr$[esp-4]
	mov	eax, DWORD PTR [eax+4]
	ret	4
?get_next@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z ENDP ; XChain<CSysObj>::get_next
_TEXT	ENDS
PUBLIC	?get_prev@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z ; XChain<CSysObj>::get_prev
; Function compile flags: /Ogty
;	COMDAT ?get_prev@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z
_TEXT	SEGMENT
_ptr$ = 8
?get_prev@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z PROC NEAR ; XChain<CSysObj>::get_prev, COMDAT
; _this$ = ecx

; 841  : 	TYPE *get_prev(TYPE *ptr){return ptr->prev;}

	mov	eax, DWORD PTR _ptr$[esp-4]
	mov	eax, DWORD PTR [eax+8]
	ret	4
?get_prev@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z ENDP ; XChain<CSysObj>::get_prev
_TEXT	ENDS
PUBLIC	?get_head@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ ; XChain<CSysObj>::get_head
; Function compile flags: /Ogty
;	COMDAT ?get_head@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ
_TEXT	SEGMENT
?get_head@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ PROC NEAR ; XChain<CSysObj>::get_head, COMDAT
; _this$ = ecx

; 847  : 	inline TYPE *get_head(void){return head;}

	mov	eax, DWORD PTR [ecx]
	ret	0
?get_head@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ ENDP	; XChain<CSysObj>::get_head
_TEXT	ENDS
PUBLIC	?get_tail@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ ; XChain<CSysObj>::get_tail
; Function compile flags: /Ogty
;	COMDAT ?get_tail@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ
_TEXT	SEGMENT
?get_tail@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ PROC NEAR ; XChain<CSysObj>::get_tail, COMDAT
; _this$ = ecx

; 848  : 	inline TYPE *get_tail(void){return tail;}

	mov	eax, DWORD PTR [ecx+4]
	ret	0
?get_tail@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ ENDP	; XChain<CSysObj>::get_tail
_TEXT	ENDS
PUBLIC	??1?$XChain@VCSysObj@@@@QAE@XZ			; XChain<CSysObj>::~XChain<CSysObj>
PUBLIC	??_7CSysObj@@6B@				; CSysObj::`vftable'
EXTRN	__purecall:NEAR
EXTRN	?_global@@3PAVXGlobal@@A:DWORD			; _global
EXTRN	?unreg_global_object@XGlobal@@QAEXPAVCSysObj@@@Z:NEAR ; XGlobal::unreg_global_object
;	COMDAT ??_7CSysObj@@6B@
; File C:\duke4\xcore\xcore.h
CONST	SEGMENT
??_7CSysObj@@6B@ DD FLAT:__purecall			; CSysObj::`vftable'
; Function compile flags: /Ogty
; File C:\duke4\xcore\xclass.h
CONST	ENDS
;	COMDAT ??1?$XChain@VCSysObj@@@@QAE@XZ
_TEXT	SEGMENT
??1?$XChain@VCSysObj@@@@QAE@XZ PROC NEAR		; XChain<CSysObj>::~XChain<CSysObj>, COMDAT
; _this$ = ecx

; 853  : {

	push	esi
	mov	esi, ecx

; 854  : 	if (xchain_state.owned)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	jns	SHORT $L57352

; 855  : 	{
; 856  : 		while(head)

	cmp	DWORD PTR [esi], 0
	je	SHORT $L57352
	push	ebx
	push	edi
$L56971:

; 857  : 		{
; 858  : 			TYPE *tmp=(TYPE *)head->next;

	mov	eax, DWORD PTR [esi]

; 859  : 			delete head;

	mov	edi, eax
	mov	ebx, DWORD PTR [eax+4]
	test	edi, edi
	je	SHORT $L57333
	mov	DWORD PTR [edi], OFFSET FLAT:??_7CSysObj@@6B@ ; CSysObj::`vftable'
	mov	ecx, DWORD PTR ?_global@@3PAVXGlobal@@A	; _global
	push	edi
	call	?unreg_global_object@XGlobal@@QAEXPAVCSysObj@@@Z ; XGlobal::unreg_global_object
	mov	ecx, edi
	call	@xfree@4
$L57333:
	test	ebx, ebx

; 860  : 			head=tmp;

	mov	DWORD PTR [esi], ebx
	jne	SHORT $L56971
	pop	edi
	pop	ebx
$L57352:

; 861  : 		}
; 862  : 	}
; 863  : 	head=null;

	mov	DWORD PTR [esi], 0

; 864  : 	tail=null;

	mov	DWORD PTR [esi+4], 0
	pop	esi

; 865  : }

	ret	0
??1?$XChain@VCSysObj@@@@QAE@XZ ENDP			; XChain<CSysObj>::~XChain<CSysObj>
_TEXT	ENDS
PUBLIC	?lose_list@?$XChain@VCSysObj@@@@QAEXXZ		; XChain<CSysObj>::lose_list
; Function compile flags: /Ogty
;	COMDAT ?lose_list@?$XChain@VCSysObj@@@@QAEXXZ
_TEXT	SEGMENT
?lose_list@?$XChain@VCSysObj@@@@QAEXXZ PROC NEAR	; XChain<CSysObj>::lose_list, COMDAT
; _this$ = ecx

; 870  : 	head=null;tail=null;xchain_state.count=0;

	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [ecx], 0
	and	eax, -2147483648			; 80000000H
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], eax

; 871  : }

	ret	0
?lose_list@?$XChain@VCSysObj@@@@QAEXXZ ENDP		; XChain<CSysObj>::lose_list
_TEXT	ENDS
PUBLIC	?free_list@?$XChain@VCSysObj@@@@QAEXXZ		; XChain<CSysObj>::free_list
; Function compile flags: /Ogty
;	COMDAT ?free_list@?$XChain@VCSysObj@@@@QAEXXZ
_TEXT	SEGMENT
?free_list@?$XChain@VCSysObj@@@@QAEXXZ PROC NEAR	; XChain<CSysObj>::free_list, COMDAT
; _this$ = ecx

; 875  : {

	push	esi
	mov	esi, ecx

; 876  : 	if (xchain_state.owned)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	jns	SHORT $L57378

; 877  : 	{
; 878  : 		while(head)

	cmp	DWORD PTR [esi], 0
	je	SHORT $L57378
	push	ebx
	push	edi
$L56987:

; 879  : 		{
; 880  : 			TYPE *tmp=(TYPE *)head->next;

	mov	eax, DWORD PTR [esi]

; 881  : 			delete head;

	mov	edi, eax
	mov	ebx, DWORD PTR [eax+4]
	test	edi, edi
	je	SHORT $L57359
	mov	DWORD PTR [edi], OFFSET FLAT:??_7CSysObj@@6B@ ; CSysObj::`vftable'
	mov	ecx, DWORD PTR ?_global@@3PAVXGlobal@@A	; _global
	push	edi
	call	?unreg_global_object@XGlobal@@QAEXPAVCSysObj@@@Z ; XGlobal::unreg_global_object
	mov	ecx, edi
	call	@xfree@4
$L57359:
	test	ebx, ebx

; 882  : 			head=tmp;

	mov	DWORD PTR [esi], ebx
	jne	SHORT $L56987
	pop	edi
	pop	ebx
$L57378:

; 883  : 		}
; 884  : 	}
; 885  : 	head=null;tail=null;

	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+4], 0
	pop	esi

; 886  : }

	ret	0
?free_list@?$XChain@VCSysObj@@@@QAEXXZ ENDP		; XChain<CSysObj>::free_list
_TEXT	ENDS
PUBLIC	?add_head@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z ; XChain<CSysObj>::add_head
; Function compile flags: /Ogty
;	COMDAT ?add_head@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z
_TEXT	SEGMENT
_ptr$ = 8
?add_head@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z PROC NEAR ; XChain<CSysObj>::add_head, COMDAT
; _this$ = ecx

; 891  : 	ptr->next=head;

	mov	eax, DWORD PTR _ptr$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx

; 892  : 	ptr->prev=null;

	mov	DWORD PTR [eax+8], 0

; 893  : 	if (head)

	mov	edx, DWORD PTR [ecx]
	test	edx, edx
	je	SHORT $L56997

; 894  : 		head->prev=ptr;

	mov	DWORD PTR [edx+8], eax

; 897  : 	
; 898  : 	head=ptr;

	mov	DWORD PTR [ecx], eax

; 899  : 
; 900  : 	return head;
; 901  : }

	ret	4
$L56997:

; 895  : 	else
; 896  : 		tail=ptr;

	mov	DWORD PTR [ecx+4], eax

; 897  : 	
; 898  : 	head=ptr;

	mov	DWORD PTR [ecx], eax

; 899  : 
; 900  : 	return head;
; 901  : }

	ret	4
?add_head@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z ENDP ; XChain<CSysObj>::add_head
_TEXT	ENDS
PUBLIC	?add_tail@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z ; XChain<CSysObj>::add_tail
; Function compile flags: /Ogty
;	COMDAT ?add_tail@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z
_TEXT	SEGMENT
_ptr$ = 8
?add_tail@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z PROC NEAR ; XChain<CSysObj>::add_tail, COMDAT
; _this$ = ecx

; 906  : 	ptr->prev=tail;

	mov	eax, DWORD PTR _ptr$[esp-4]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+8], edx

; 907  : 	ptr->next=null;

	mov	DWORD PTR [eax+4], 0

; 908  : 	if (tail)

	mov	edx, DWORD PTR [ecx+4]
	test	edx, edx
	je	SHORT $L57003

; 909  : 		tail->next=ptr;

	mov	DWORD PTR [edx+4], eax

; 912  : 	
; 913  : 	tail=ptr;

	mov	DWORD PTR [ecx+4], eax

; 914  : 
; 915  : 	return tail;
; 916  : }

	ret	4
$L57003:

; 910  : 	else
; 911  : 		head=ptr;

	mov	DWORD PTR [ecx], eax

; 912  : 	
; 913  : 	tail=ptr;

	mov	DWORD PTR [ecx+4], eax

; 914  : 
; 915  : 	return tail;
; 916  : }

	ret	4
?add_tail@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z ENDP ; XChain<CSysObj>::add_tail
_TEXT	ENDS
PUBLIC	?remove_head@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ ; XChain<CSysObj>::remove_head
; Function compile flags: /Ogty
;	COMDAT ?remove_head@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ
_TEXT	SEGMENT
?remove_head@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ PROC NEAR ; XChain<CSysObj>::remove_head, COMDAT
; _this$ = ecx

; 937  : 	if (!head)

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	jne	SHORT $L57009

; 947  : 
; 948  : 	return ret;
; 949  : }

	ret	0
$L57009:

; 938  : 		return null;
; 939  : 
; 940  : 	TYPE *ret=head;
; 941  : 
; 942  : 	head=head->next;

	mov	edx, DWORD PTR [eax+4]

; 943  : 	if (!head)

	test	edx, edx
	mov	DWORD PTR [ecx], edx
	jne	SHORT $L57011

; 944  : 		tail=null;

	mov	DWORD PTR [ecx+4], edx

; 947  : 
; 948  : 	return ret;
; 949  : }

	ret	0
$L57011:

; 945  : 	else
; 946  : 		head->prev=null;

	mov	DWORD PTR [edx+8], 0

; 947  : 
; 948  : 	return ret;
; 949  : }

	ret	0
?remove_head@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ ENDP ; XChain<CSysObj>::remove_head
_TEXT	ENDS
PUBLIC	?remove_tail@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ ; XChain<CSysObj>::remove_tail
; Function compile flags: /Ogty
;	COMDAT ?remove_tail@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ
_TEXT	SEGMENT
?remove_tail@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ PROC NEAR ; XChain<CSysObj>::remove_tail, COMDAT
; _this$ = ecx

; 954  : 	if (!tail)

	mov	eax, DWORD PTR [ecx+4]
	test	eax, eax
	jne	SHORT $L57017

; 964  : 
; 965  : 	return ret;
; 966  : }

	ret	0
$L57017:

; 955  : 		return null;
; 956  : 
; 957  : 	TYPE *ret=tail;
; 958  : 
; 959  : 	tail=tail->prev;

	mov	edx, DWORD PTR [eax+8]

; 960  : 	if (!tail)

	test	edx, edx
	mov	DWORD PTR [ecx+4], edx
	jne	SHORT $L57019

; 961  : 		head=null;

	mov	DWORD PTR [ecx], edx

; 964  : 
; 965  : 	return ret;
; 966  : }

	ret	0
$L57019:

; 962  : 	else
; 963  : 		tail->next=null;

	mov	DWORD PTR [edx+4], 0

; 964  : 
; 965  : 	return ret;
; 966  : }

	ret	0
?remove_tail@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ ENDP ; XChain<CSysObj>::remove_tail
_TEXT	ENDS
PUBLIC	?remove@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z ; XChain<CSysObj>::remove
; Function compile flags: /Ogty
;	COMDAT ?remove@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z
_TEXT	SEGMENT
_ptr$ = 8
?remove@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z PROC NEAR ; XChain<CSysObj>::remove, COMDAT
; _this$ = ecx

; 921  : 	if (ptr->prev)

	mov	eax, DWORD PTR _ptr$[esp-4]
	mov	edx, DWORD PTR [eax+8]
	test	edx, edx
	je	SHORT $L57025
	push	esi

; 922  : 		ptr->prev->next=ptr->next;

	mov	esi, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], esi
	pop	esi

; 923  : 	else

	jmp	SHORT $L57026
$L57025:

; 924  : 		head=ptr->next;

	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx], edx
$L57026:

; 925  : 
; 926  : 	if (ptr->next)

	mov	edx, DWORD PTR [eax+4]
	test	edx, edx
	je	SHORT $L57027

; 927  : 		ptr->next->prev=ptr->prev;

	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], ecx

; 930  : 
; 931  : 	return ptr;
; 932  : }

	ret	4
$L57027:

; 928  : 	else
; 929  : 		tail=ptr->prev;

	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+4], edx

; 930  : 
; 931  : 	return ptr;
; 932  : }

	ret	4
?remove@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z ENDP ; XChain<CSysObj>::remove
_TEXT	ENDS
PUBLIC	??_7XBufferReadInt@@6B@				; XBufferReadInt::`vftable'
PUBLIC	??_GXBufferReadInt@@UAEPAXI@Z			; XBufferReadInt::`scalar deleting destructor'
PUBLIC	??_EXBufferReadInt@@UAEPAXI@Z			; XBufferReadInt::`vector deleting destructor'
;	COMDAT ??_7XBufferReadInt@@6B@
; File C:\duke4\xcore\xcore.h
CONST	SEGMENT
??_7XBufferReadInt@@6B@ DD FLAT:?read_direct@XBufferReadInt@@MAEKPAXKAAK@Z ; XBufferReadInt::`vftable'
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:??_EXBufferReadInt@@UAEPAXI@Z
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ??_GXBufferReadInt@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_GXBufferReadInt@@UAEPAXI@Z PROC NEAR			; XBufferReadInt::`scalar deleting destructor', COMDAT
; _this$ = ecx
	mov	al, BYTE PTR ___flags$[esp-4]
	push	esi
	mov	esi, ecx
	test	al, 1
	mov	DWORD PTR [esi], OFFSET FLAT:??_7XBufferReadInt@@6B@ ; XBufferReadInt::`vftable'
	je	SHORT $L57399
	call	@xfree@4
$L57399:
	mov	eax, esi
	pop	esi
	ret	4
??_GXBufferReadInt@@UAEPAXI@Z ENDP			; XBufferReadInt::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??1XBufferReadInt@@UAE@XZ			; XBufferReadInt::~XBufferReadInt
EXTRN	??_M@YGXPAXIHP6EX0@Z@Z:NEAR			; `eh vector destructor iterator'
; Function compile flags: /Ogty
;	COMDAT ??_EXBufferReadInt@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_EXBufferReadInt@@UAEPAXI@Z PROC NEAR			; XBufferReadInt::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebx
	mov	bl, BYTE PTR ___flags$[esp]
	push	esi
	mov	esi, ecx
	test	bl, 2
	je	SHORT $L56059
	mov	eax, DWORD PTR [esi-4]
	push	edi
	lea	edi, DWORD PTR [esi-4]
	push	OFFSET FLAT:??1XBufferReadInt@@UAE@XZ	; XBufferReadInt::~XBufferReadInt
	push	eax
	push	8
	push	esi
	call	??_M@YGXPAXIHP6EX0@Z@Z			; `eh vector destructor iterator'
	test	bl, 1
	je	SHORT $L57404
	mov	ecx, edi
	call	@xfree@4
$L57404:
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	ret	4
$L56059:
	test	bl, 1
	mov	DWORD PTR [esi], OFFSET FLAT:??_7XBufferReadInt@@6B@ ; XBufferReadInt::`vftable'
	je	SHORT $L57410
	mov	ecx, esi
	call	@xfree@4
$L57410:
	mov	eax, esi
	pop	esi
	pop	ebx
	ret	4
??_EXBufferReadInt@@UAEPAXI@Z ENDP			; XBufferReadInt::`vector deleting destructor'
; Function compile flags: /Ogty
; File C:\duke4\xcore\xstream.h
_TEXT	ENDS
;	COMDAT ??1XBufferReadInt@@UAE@XZ
_TEXT	SEGMENT
??1XBufferReadInt@@UAE@XZ PROC NEAR			; XBufferReadInt::~XBufferReadInt, COMDAT
; _this$ = ecx

; 37   : 	virtual ~XBufferReadInt(void){}

	mov	DWORD PTR [ecx], OFFSET FLAT:??_7XBufferReadInt@@6B@ ; XBufferReadInt::`vftable'
	ret	0
??1XBufferReadInt@@UAE@XZ ENDP				; XBufferReadInt::~XBufferReadInt
_TEXT	ENDS
PUBLIC	??_7XBufferWriteInt@@6B@			; XBufferWriteInt::`vftable'
PUBLIC	??_GXBufferWriteInt@@UAEPAXI@Z			; XBufferWriteInt::`scalar deleting destructor'
PUBLIC	??_EXBufferWriteInt@@UAEPAXI@Z			; XBufferWriteInt::`vector deleting destructor'
;	COMDAT ??_7XBufferWriteInt@@6B@
; File C:\duke4\xcore\xcore.h
CONST	SEGMENT
??_7XBufferWriteInt@@6B@ DD FLAT:?write_direct@XBufferWriteInt@@MAEKPBXKAAK@Z ; XBufferWriteInt::`vftable'
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:??_EXBufferWriteInt@@UAEPAXI@Z
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ??_GXBufferWriteInt@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_GXBufferWriteInt@@UAEPAXI@Z PROC NEAR		; XBufferWriteInt::`scalar deleting destructor', COMDAT
; _this$ = ecx
	mov	al, BYTE PTR ___flags$[esp-4]
	push	esi
	mov	esi, ecx
	test	al, 1
	mov	DWORD PTR [esi], OFFSET FLAT:??_7XBufferWriteInt@@6B@ ; XBufferWriteInt::`vftable'
	je	SHORT $L57421
	call	@xfree@4
$L57421:
	mov	eax, esi
	pop	esi
	ret	4
??_GXBufferWriteInt@@UAEPAXI@Z ENDP			; XBufferWriteInt::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??1XBufferWriteInt@@UAE@XZ			; XBufferWriteInt::~XBufferWriteInt
; Function compile flags: /Ogty
;	COMDAT ??_EXBufferWriteInt@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_EXBufferWriteInt@@UAEPAXI@Z PROC NEAR		; XBufferWriteInt::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebx
	mov	bl, BYTE PTR ___flags$[esp]
	push	esi
	mov	esi, ecx
	test	bl, 2
	je	SHORT $L56111
	mov	eax, DWORD PTR [esi-4]
	push	edi
	lea	edi, DWORD PTR [esi-4]
	push	OFFSET FLAT:??1XBufferWriteInt@@UAE@XZ	; XBufferWriteInt::~XBufferWriteInt
	push	eax
	push	8
	push	esi
	call	??_M@YGXPAXIHP6EX0@Z@Z			; `eh vector destructor iterator'
	test	bl, 1
	je	SHORT $L57426
	mov	ecx, edi
	call	@xfree@4
$L57426:
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	ret	4
$L56111:
	test	bl, 1
	mov	DWORD PTR [esi], OFFSET FLAT:??_7XBufferWriteInt@@6B@ ; XBufferWriteInt::`vftable'
	je	SHORT $L57432
	mov	ecx, esi
	call	@xfree@4
$L57432:
	mov	eax, esi
	pop	esi
	pop	ebx
	ret	4
??_EXBufferWriteInt@@UAEPAXI@Z ENDP			; XBufferWriteInt::`vector deleting destructor'
; Function compile flags: /Ogty
; File C:\duke4\xcore\xstream.h
_TEXT	ENDS
;	COMDAT ??1XBufferWriteInt@@UAE@XZ
_TEXT	SEGMENT
??1XBufferWriteInt@@UAE@XZ PROC NEAR			; XBufferWriteInt::~XBufferWriteInt, COMDAT
; _this$ = ecx

; 56   : 	virtual ~XBufferWriteInt(void){}

	mov	DWORD PTR [ecx], OFFSET FLAT:??_7XBufferWriteInt@@6B@ ; XBufferWriteInt::`vftable'
	ret	0
??1XBufferWriteInt@@UAE@XZ ENDP				; XBufferWriteInt::~XBufferWriteInt
_TEXT	ENDS
PUBLIC	??1XStreamRdDirect@@UAE@XZ			; XStreamRdDirect::~XStreamRdDirect
PUBLIC	??_GXStreamRdDirect@@UAEPAXI@Z			; XStreamRdDirect::`scalar deleting destructor'
; Function compile flags: /Ogty
;	COMDAT ??_GXStreamRdDirect@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_GXStreamRdDirect@@UAEPAXI@Z PROC NEAR		; XStreamRdDirect::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1XStreamRdDirect@@UAE@XZ		; XStreamRdDirect::~XStreamRdDirect
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $L57440
	mov	ecx, esi
	call	@xfree@4
$L57440:
	mov	eax, esi
	pop	esi
	ret	4
??_GXStreamRdDirect@@UAEPAXI@Z ENDP			; XStreamRdDirect::`scalar deleting destructor'
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??1XStreamRdDirect@@UAE@XZ
_TEXT	SEGMENT
??1XStreamRdDirect@@UAE@XZ PROC NEAR			; XStreamRdDirect::~XStreamRdDirect, COMDAT
; _this$ = ecx

; 71   : 	~XStreamRdDirect(void){}

	mov	DWORD PTR [ecx], OFFSET FLAT:??_7XBufferReadInt@@6B@ ; XBufferReadInt::`vftable'
	ret	0
??1XStreamRdDirect@@UAE@XZ ENDP				; XStreamRdDirect::~XStreamRdDirect
_TEXT	ENDS
PUBLIC	??_EXStreamRdDirect@@UAEPAXI@Z			; XStreamRdDirect::`vector deleting destructor'
; Function compile flags: /Ogty
;	COMDAT ??_EXStreamRdDirect@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_EXStreamRdDirect@@UAEPAXI@Z PROC NEAR		; XStreamRdDirect::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebx
	mov	bl, BYTE PTR ___flags$[esp]
	push	esi
	mov	esi, ecx
	test	bl, 2
	je	SHORT $L56163
	mov	eax, DWORD PTR [esi-4]
	push	edi
	lea	edi, DWORD PTR [esi-4]
	push	OFFSET FLAT:??1XStreamRdDirect@@UAE@XZ	; XStreamRdDirect::~XStreamRdDirect
	push	eax
	push	8
	push	esi
	call	??_M@YGXPAXIHP6EX0@Z@Z			; `eh vector destructor iterator'
	test	bl, 1
	je	SHORT $L57451
	mov	ecx, edi
	call	@xfree@4
$L57451:
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	ret	4
$L56163:
	mov	ecx, esi
	call	??1XStreamRdDirect@@UAE@XZ		; XStreamRdDirect::~XStreamRdDirect
	test	bl, 1
	je	SHORT $L57453
	mov	ecx, esi
	call	@xfree@4
$L57453:
	mov	eax, esi
	pop	esi
	pop	ebx
	ret	4
??_EXStreamRdDirect@@UAEPAXI@Z ENDP			; XStreamRdDirect::`vector deleting destructor'
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?seek@XStreamWrDirect@@UAEKJ@Z
_TEXT	SEGMENT
?seek@XStreamWrDirect@@UAEKJ@Z PROC NEAR		; XStreamWrDirect::seek, COMDAT
; _this$ = ecx

; 86   : 	U32 seek(I32 delta_pos){return TRUE;}

	mov	eax, 1
	ret	4
?seek@XStreamWrDirect@@UAEKJ@Z ENDP			; XStreamWrDirect::seek
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?flush@XStreamWrDirect@@UAEKXZ
_TEXT	SEGMENT
?flush@XStreamWrDirect@@UAEKXZ PROC NEAR		; XStreamWrDirect::flush, COMDAT
; _this$ = ecx

; 87   : 	U32 flush(void){return TRUE;}

	mov	eax, 1
	ret	0
?flush@XStreamWrDirect@@UAEKXZ ENDP			; XStreamWrDirect::flush
_TEXT	ENDS
PUBLIC	??1XStreamWrDirect@@UAE@XZ			; XStreamWrDirect::~XStreamWrDirect
PUBLIC	??_GXStreamWrDirect@@UAEPAXI@Z			; XStreamWrDirect::`scalar deleting destructor'
; Function compile flags: /Ogty
;	COMDAT ??_GXStreamWrDirect@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_GXStreamWrDirect@@UAEPAXI@Z PROC NEAR		; XStreamWrDirect::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1XStreamWrDirect@@UAE@XZ		; XStreamWrDirect::~XStreamWrDirect
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $L57464
	mov	ecx, esi
	call	@xfree@4
$L57464:
	mov	eax, esi
	pop	esi
	ret	4
??_GXStreamWrDirect@@UAEPAXI@Z ENDP			; XStreamWrDirect::`scalar deleting destructor'
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??1XStreamWrDirect@@UAE@XZ
_TEXT	SEGMENT
??1XStreamWrDirect@@UAE@XZ PROC NEAR			; XStreamWrDirect::~XStreamWrDirect, COMDAT
; _this$ = ecx

; 88   : 	~XStreamWrDirect(void){}

	mov	DWORD PTR [ecx], OFFSET FLAT:??_7XBufferWriteInt@@6B@ ; XBufferWriteInt::`vftable'
	ret	0
??1XStreamWrDirect@@UAE@XZ ENDP				; XStreamWrDirect::~XStreamWrDirect
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??_EXStreamWrDirect@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_EXStreamWrDirect@@UAEPAXI@Z PROC NEAR		; XStreamWrDirect::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebx
	mov	bl, BYTE PTR ___flags$[esp]
	push	esi
	mov	esi, ecx
	test	bl, 2
	je	SHORT $L56219
	mov	eax, DWORD PTR [esi-4]
	push	edi
	lea	edi, DWORD PTR [esi-4]
	push	OFFSET FLAT:??1XStreamWrDirect@@UAE@XZ	; XStreamWrDirect::~XStreamWrDirect
	push	eax
	push	8
	push	esi
	call	??_M@YGXPAXIHP6EX0@Z@Z			; `eh vector destructor iterator'
	test	bl, 1
	je	SHORT $L57475
	mov	ecx, edi
	call	@xfree@4
$L57475:
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	ret	4
$L56219:
	mov	ecx, esi
	call	??1XStreamWrDirect@@UAE@XZ		; XStreamWrDirect::~XStreamWrDirect
	test	bl, 1
	je	SHORT $L57477
	mov	ecx, esi
	call	@xfree@4
$L57477:
	mov	eax, esi
	pop	esi
	pop	ebx
	ret	4
??_EXStreamWrDirect@@UAEPAXI@Z ENDP			; XStreamWrDirect::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??1XMemRdBuffer@@UAE@XZ				; XMemRdBuffer::~XMemRdBuffer
PUBLIC	??_GXMemRdBuffer@@UAEPAXI@Z			; XMemRdBuffer::`scalar deleting destructor'
; Function compile flags: /Ogty
;	COMDAT ??_GXMemRdBuffer@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_GXMemRdBuffer@@UAEPAXI@Z PROC NEAR			; XMemRdBuffer::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1XMemRdBuffer@@UAE@XZ			; XMemRdBuffer::~XMemRdBuffer
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $L57484
	mov	ecx, esi
	call	@xfree@4
$L57484:
	mov	eax, esi
	pop	esi
	ret	4
??_GXMemRdBuffer@@UAEPAXI@Z ENDP			; XMemRdBuffer::`scalar deleting destructor'
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??1XMemRdBuffer@@UAE@XZ
_TEXT	SEGMENT
??1XMemRdBuffer@@UAE@XZ PROC NEAR			; XMemRdBuffer::~XMemRdBuffer, COMDAT
; _this$ = ecx

; 109  : 	~XMemRdBuffer(void){}

	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET FLAT:??_7XMemRdBuffer@@6B@ ; XMemRdBuffer::`vftable'
	mov	ecx, DWORD PTR [esi+8]
	call	@xfree@4
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi], OFFSET FLAT:??_7XBufferReadInt@@6B@ ; XBufferReadInt::`vftable'
	pop	esi
	ret	0
??1XMemRdBuffer@@UAE@XZ ENDP				; XMemRdBuffer::~XMemRdBuffer
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??_EXMemRdBuffer@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_EXMemRdBuffer@@UAEPAXI@Z PROC NEAR			; XMemRdBuffer::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebx
	mov	bl, BYTE PTR ___flags$[esp]
	push	esi
	mov	esi, ecx
	test	bl, 2
	je	SHORT $L56272
	mov	eax, DWORD PTR [esi-4]
	push	edi
	lea	edi, DWORD PTR [esi-4]
	push	OFFSET FLAT:??1XMemRdBuffer@@UAE@XZ	; XMemRdBuffer::~XMemRdBuffer
	push	eax
	push	24					; 00000018H
	push	esi
	call	??_M@YGXPAXIHP6EX0@Z@Z			; `eh vector destructor iterator'
	test	bl, 1
	je	SHORT $L57500
	mov	ecx, edi
	call	@xfree@4
$L57500:
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	ret	4
$L56272:
	mov	ecx, esi
	call	??1XMemRdBuffer@@UAE@XZ			; XMemRdBuffer::~XMemRdBuffer
	test	bl, 1
	je	SHORT $L57502
	mov	ecx, esi
	call	@xfree@4
$L57502:
	mov	eax, esi
	pop	esi
	pop	ebx
	ret	4
??_EXMemRdBuffer@@UAEPAXI@Z ENDP			; XMemRdBuffer::`vector deleting destructor'
_TEXT	ENDS
END
