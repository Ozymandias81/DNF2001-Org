; Listing generated by Microsoft (R) Optimizing Compiler Version 12.00.8943.0 

	TITLE	C:\duke4\xcore\winmem.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT PARA USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0BF@MBIJ@Cannot?5init?5CPrintfT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
drectve	SEGMENT DWORD USE32 PUBLIC ''
drectve	ENDS
;	COMDAT ??_C@_08GPFK@whooznat?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07KPPF@wheezer?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CRT$XCA	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCA	ENDS
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
CRT$XCL	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCL	ENDS
CRT$XCC	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCC	ENDS
CRT$XCZ	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCZ	ENDS
;	COMDAT ??3MallocInfo@@CAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0MallocBlock@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0MemDebug@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GMallocInfo@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?check_tags@CTrackObj@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?set_tags@CTrackObj@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CTrackList@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$XChain@VXStatistic@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?get_head@?$XList@VXStatistic@@@@QAEPAVXStatistic@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$XChain@VCSysObj@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$XChain@VCSysObj@@@@QAE@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?get_next@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?get_prev@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?get_head@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?get_tail@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$XChain@VMallocInfo@@@@QAE@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?get_next@?$XChain@VMallocInfo@@@@QAEPAVMallocInfo@@PAV2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?get_head@?$XChain@VMallocInfo@@@@QAEPAVMallocInfo@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$XChain@VMallocBlock@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$XChain@VXStatistic@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?free_list@?$XChain@VXStatistic@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$XList@VXStatistic@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$XList@VXStatistic@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?free_list@?$XList@VXStatistic@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?add_head@?$XList@VXStatistic@@@@QAEPAU_XPos@@PAVXStatistic@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?remove_head@?$XList@VXStatistic@@@@QAEPAVXStatistic@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$XChain@VCSysObj@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lose_list@?$XChain@VCSysObj@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?free_list@?$XChain@VCSysObj@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?add_head@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?add_tail@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?remove_head@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?remove_tail@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?remove@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$XList@PAX@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$XRcBase@VCStrObj@@@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$XRcBase@VCStrObj@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$XRcBase@VCStrObj@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$XRcBase@VCStrObj@@@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$XRcPtr@VCPathObj@@@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$XRcPtr@VCPathObj@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$XRcPtr@VCPathObj@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$XRcPtr@VCPathObj@@@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$XList@VXFindLevel@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$XList@VXFindLevel@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$XChain@VMallocInfo@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?add_head@?$XChain@VMallocInfo@@@@QAEPAVMallocInfo@@PAV2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?remove_head@?$XChain@VMallocInfo@@@@QAEPAVMallocInfo@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?remove@?$XChain@VMallocInfo@@@@QAEPAVMallocInfo@@PAV2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$XChain@VMallocBlock@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?free_list@?$XChain@VMallocBlock@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?add_head@?$XChain@VMallocBlock@@@@QAEPAVMallocBlock@@PAV2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCSysObj@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GXFindLevel@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?new_node@?$XList@VXStatistic@@@@IAEPAUXNode@1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?free_nodes@?$XList@VXStatistic@@@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?free_nodes@?$XList@PAX@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?free_nodes@?$XList@VXFindLevel@@@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddRef@?$XRcBase@VCStrObj@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DelRef@?$XRcBase@VCStrObj@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddRef@?$XRcPtr@VCPathObj@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DelRef@?$XRcPtr@VCPathObj@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCStrObj@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCPathObj@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GXStreamWrDirect@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1XStreamWrDirect@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7XStreamWrDirect@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??1XBufferWriteInt@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7XBufferWriteInt@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??3XStreamWrDirect@@SAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_EXStreamWrDirect@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?flush@XStreamWrDirect@@UAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?seek@XStreamWrDirect@@UAEKJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GXStreamRdDirect@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1XStreamRdDirect@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7XStreamRdDirect@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??1XBufferReadInt@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7XBufferReadInt@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??3XStreamRdDirect@@SAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_EXStreamRdDirect@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?seek@XStreamRdDirect@@UAEKJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?base_init@XFile@@EAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4autochar@@QAEAAV0@PAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GXBufferWriteInt@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_EXBufferWriteInt@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GXBufferReadInt@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_EXBufferReadInt@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pos_wr@CBaseStream@@UAEXKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pos_rd@CBaseStream@@UAEXKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?put@CBaseStream@@UAEKD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ioctl_write@CBaseStream@@UAEKKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ioctl_read@CBaseStream@@UAEKKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?seek_int@CBaseStream@@MAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GXMemRdBuffer@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1XMemRdBuffer@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7XMemRdBuffer@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??1autochar@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3XMemRdBuffer@@SAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_EXMemRdBuffer@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3CStrObj@@SAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CStrObj@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1XFindLevel@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CSysObj@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CSysObj@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??3@YAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0XListState@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3XStatistic@@SAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0XChainState@@QAE@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0XChainState@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?list_base@CMallocBlock@@AAEPAKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
FLAT	GROUP _DATA, CONST, _BSS, drectve, CRT$XCA, CRT$XCU, CRT$XCL, CRT$XCC, CRT$XCZ
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?mem_debug@@3PAVMemDebug@@A			; mem_debug
PUBLIC	?mem_debug2@@3PAVMemDebug@@A			; mem_debug2
PUBLIC	?mem_debug3@@3PAVMemDebug@@A			; mem_debug3
PUBLIC	?mem_debug4@@3PAVMemDebug@@A			; mem_debug4
PUBLIC	?dev_val@@3KC					; dev_val
PUBLIC	?_deb_free@@3KA					; _deb_free
PUBLIC	?track_list@@3VCTrackList@@A			; track_list
PUBLIC	?_active_count@@3KA				; _active_count
_BSS	SEGMENT
?mem_debug@@3PAVMemDebug@@A DD 01H DUP (?)		; mem_debug
?mem_debug2@@3PAVMemDebug@@A DD 01H DUP (?)		; mem_debug2
?mem_debug3@@3PAVMemDebug@@A DD 01H DUP (?)		; mem_debug3
?mem_debug4@@3PAVMemDebug@@A DD 01H DUP (?)		; mem_debug4
?dev_val@@3KC DD 01H DUP (?)				; dev_val
?track_list@@3VCTrackList@@A DB 02008H DUP (?)		; track_list
?_active_count@@3KA DD 01H DUP (?)			; _active_count
_BSS	ENDS
_DATA	SEGMENT
?_deb_free@@3KA DD 0deadcafeH				; _deb_free
_DATA	ENDS
CRT$XCU	SEGMENT
_$S3	DD	FLAT:_$E2
CRT$XCU	ENDS
drectve	SEGMENT
$SG56785 DB	'-INCLUDE:___@@_PchSym_@00@UwfpvEUcxlivUlyqUhgwxlivOlyq@', 00H
drectve	ENDS
PUBLIC	??0MemDebug@@QAE@XZ				; MemDebug::MemDebug
PUBLIC	?_mem_debug_init@@YAXXZ				; _mem_debug_init
EXTRN	__imp__malloc:NEAR
; Function compile flags: /Ogty
; File C:\duke4\xcore\winmem.cpp
_TEXT	SEGMENT
?_mem_debug_init@@YAXXZ PROC NEAR			; _mem_debug_init

; 99   : {

	push	esi

; 100  : 	mem_debug=(MemDebug *)malloc(sizeof(MemDebug));

	mov	esi, DWORD PTR __imp__malloc
	push	52					; 00000034H
	call	esi
	add	esp, 4

; 101  : 	mem_debug->MemDebug::MemDebug();

	mov	ecx, eax
	mov	DWORD PTR ?mem_debug@@3PAVMemDebug@@A, eax ; mem_debug
	call	??0MemDebug@@QAE@XZ			; MemDebug::MemDebug

; 102  : 	mem_debug2=(MemDebug *)malloc(sizeof(MemDebug));

	push	52					; 00000034H
	call	esi
	add	esp, 4

; 103  : 	mem_debug2->MemDebug::MemDebug();

	mov	ecx, eax
	mov	DWORD PTR ?mem_debug2@@3PAVMemDebug@@A, eax ; mem_debug2
	call	??0MemDebug@@QAE@XZ			; MemDebug::MemDebug

; 104  : 	mem_debug3=(MemDebug *)malloc(sizeof(MemDebug));

	push	52					; 00000034H
	call	esi
	add	esp, 4

; 105  : 	mem_debug3->MemDebug::MemDebug();

	mov	ecx, eax
	mov	DWORD PTR ?mem_debug3@@3PAVMemDebug@@A, eax ; mem_debug3
	call	??0MemDebug@@QAE@XZ			; MemDebug::MemDebug

; 106  : 	mem_debug4=(MemDebug *)malloc(sizeof(MemDebug));

	push	52					; 00000034H
	call	esi
	add	esp, 4
	mov	DWORD PTR ?mem_debug4@@3PAVMemDebug@@A, eax ; mem_debug4

; 107  : 	mem_debug4->MemDebug::MemDebug();

	mov	ecx, eax
	pop	esi
	jmp	??0MemDebug@@QAE@XZ			; MemDebug::MemDebug
?_mem_debug_init@@YAXXZ ENDP				; _mem_debug_init
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??0MemDebug@@QAE@XZ
_TEXT	SEGMENT
??0MemDebug@@QAE@XZ PROC NEAR				; MemDebug::MemDebug, COMDAT
; _this$ = ecx

; 80   : 	MemDebug(void) : active_count(0),closed(0),free_list(0),used_list(0) {}

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx
	mov	DWORD PTR [eax+16], ecx
	mov	DWORD PTR [eax+20], ecx
	mov	DWORD PTR [eax+24], ecx
	mov	DWORD PTR [eax+28], ecx
	mov	DWORD PTR [eax+32], ecx
	mov	DWORD PTR [eax+36], ecx
	mov	DWORD PTR [eax+40], ecx
	mov	DWORD PTR [eax+44], ecx
	mov	DWORD PTR [eax+48], ecx
	ret	0
??0MemDebug@@QAE@XZ ENDP				; MemDebug::MemDebug
_TEXT	ENDS
PUBLIC	?close@MemDebug@@QAEXXZ				; MemDebug::close
PUBLIC	?_mem_debug_close@@YAXXZ			; _mem_debug_close
EXTRN	__imp__free:NEAR
; Function compile flags: /Ogty
_TEXT	SEGMENT
?_mem_debug_close@@YAXXZ PROC NEAR			; _mem_debug_close

; 112  : 	if (!mem_debug)

	mov	ecx, DWORD PTR ?mem_debug@@3PAVMemDebug@@A ; mem_debug
	push	edi
	xor	edi, edi
	cmp	ecx, edi
	je	SHORT $L57071
	push	esi

; 113  : 		return;
; 114  : 
; 115  : 	mem_debug->close();

	call	?close@MemDebug@@QAEXXZ			; MemDebug::close

; 116  : 	free(mem_debug);

	mov	eax, DWORD PTR ?mem_debug@@3PAVMemDebug@@A ; mem_debug
	mov	esi, DWORD PTR __imp__free
	push	eax
	call	esi

; 117  : 	mem_debug2->close();

	mov	ecx, DWORD PTR ?mem_debug2@@3PAVMemDebug@@A ; mem_debug2
	add	esp, 4
	call	?close@MemDebug@@QAEXXZ			; MemDebug::close

; 118  : 	free(mem_debug2);

	mov	ecx, DWORD PTR ?mem_debug2@@3PAVMemDebug@@A ; mem_debug2
	push	ecx
	call	esi

; 119  : 	mem_debug3->close();

	mov	ecx, DWORD PTR ?mem_debug3@@3PAVMemDebug@@A ; mem_debug3
	add	esp, 4
	call	?close@MemDebug@@QAEXXZ			; MemDebug::close

; 120  : 	free(mem_debug3);

	mov	edx, DWORD PTR ?mem_debug3@@3PAVMemDebug@@A ; mem_debug3
	push	edx
	call	esi

; 121  : 	mem_debug4->close();

	mov	ecx, DWORD PTR ?mem_debug4@@3PAVMemDebug@@A ; mem_debug4
	add	esp, 4
	call	?close@MemDebug@@QAEXXZ			; MemDebug::close

; 122  : 	free(mem_debug4);

	mov	eax, DWORD PTR ?mem_debug4@@3PAVMemDebug@@A ; mem_debug4
	push	eax
	call	esi
	add	esp, 4

; 123  : 	
; 124  : 	mem_debug=null;

	mov	DWORD PTR ?mem_debug@@3PAVMemDebug@@A, edi ; mem_debug

; 125  : 	mem_debug2=null;

	mov	DWORD PTR ?mem_debug2@@3PAVMemDebug@@A, edi ; mem_debug2

; 126  : 	mem_debug3=null;

	mov	DWORD PTR ?mem_debug3@@3PAVMemDebug@@A, edi ; mem_debug3

; 127  : 	mem_debug4=null;

	mov	DWORD PTR ?mem_debug4@@3PAVMemDebug@@A, edi ; mem_debug4
	pop	esi
$L57071:
	pop	edi

; 128  : }

	ret	0
?_mem_debug_close@@YAXXZ ENDP				; _mem_debug_close
_TEXT	ENDS
PUBLIC	??0MallocInfo@@QAE@PAXK@Z			; MallocInfo::MallocInfo
; Function compile flags: /Ogty
_TEXT	SEGMENT
_Ptr$ = 8
_Size$ = 12
??0MallocInfo@@QAE@PAXK@Z PROC NEAR			; MallocInfo::MallocInfo
; _this$ = ecx

; 132  : 	ptr=(U32 *)Ptr;
; 133  : 	size=Size;

	mov	edx, DWORD PTR _Size$[esp-4]
	mov	eax, ecx
	mov	ecx, DWORD PTR _Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx

; 134  : 
; 135  : 	ptr[0]=0xdeadcafe;

	mov	DWORD PTR [ecx], -559035650		; deadcafeH

; 136  : 	ptr++;

	mov	ecx, DWORD PTR [eax]

; 137  : 	
; 138  : 	U32 *end=(U32 *)(((U32)ptr)+size);
; 139  : 	end[0]=0xdeadcafe;

	mov	edx, DWORD PTR [eax+4]
	add	ecx, 4
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [ecx+edx], -559035650		; deadcafeH

; 140  : }

	ret	8
??0MallocInfo@@QAE@PAXK@Z ENDP				; MallocInfo::MallocInfo
_TEXT	ENDS
PUBLIC	??1MallocInfo@@QAE@XZ				; MallocInfo::~MallocInfo
EXTRN	@xxx_throw@4:NEAR
_DATA	SEGMENT
$SG57087 DB	'MallocInfo: Memory Overflow low', 00H
$SG57092 DB	'MallocInfo: Memory Overflow high', 00H
; Function compile flags: /Ogty
_DATA	ENDS
_TEXT	SEGMENT
??1MallocInfo@@QAE@XZ PROC NEAR				; MallocInfo::~MallocInfo
; _this$ = ecx

; 143  : {

	push	esi
	mov	esi, ecx

; 144  : 	if (ptr[-1]!=0xdeadcafe)

	mov	eax, DWORD PTR [esi]
	cmp	DWORD PTR [eax-4], -559035650		; deadcafeH
	je	SHORT $L57086

; 145  : 		xxx_throw("MallocInfo: Memory Overflow low");

	mov	ecx, OFFSET FLAT:$SG57087
	call	@xxx_throw@4
$L57086:

; 146  : 	
; 147  : 	U32 *end=(U32 *)(((U32)ptr)+size);
; 148  : 	if (end[0]!=0xdeadcafe)

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi]
	pop	esi
	cmp	DWORD PTR [ecx+edx], -559035650		; deadcafeH
	je	SHORT $L57091

; 149  : 		xxx_throw("MallocInfo: Memory Overflow high");

	mov	ecx, OFFSET FLAT:$SG57092
	jmp	@xxx_throw@4
$L57091:

; 150  : }

	ret	0
??1MallocInfo@@QAE@XZ ENDP				; MallocInfo::~MallocInfo
_TEXT	ENDS
PUBLIC	??2MallocBlock@@SAPAXI@Z			; MallocBlock::operator new
; Function compile flags: /Ogty
_TEXT	SEGMENT
_size$ = 8
??2MallocBlock@@SAPAXI@Z PROC NEAR			; MallocBlock::operator new

; 154  : 	return _xalloc(size);

	jmp	DWORD PTR __imp__malloc
??2MallocBlock@@SAPAXI@Z ENDP				; MallocBlock::operator new
_TEXT	ENDS
PUBLIC	??3MallocBlock@@SAXPAX@Z			; MallocBlock::operator delete
; Function compile flags: /Ogty
_TEXT	SEGMENT
_ptr$ = 8
??3MallocBlock@@SAXPAX@Z PROC NEAR			; MallocBlock::operator delete

; 159  : 	_xfree(ptr);

	jmp	DWORD PTR __imp__free
??3MallocBlock@@SAXPAX@Z ENDP				; MallocBlock::operator delete
_TEXT	ENDS
PUBLIC	?alloc_block@MemDebug@@AAEXXZ			; MemDebug::alloc_block
PUBLIC	?init@MemDebug@@QAEXXZ				; MemDebug::init
; Function compile flags: /Ogty
_TEXT	SEGMENT
?init@MemDebug@@QAEXXZ PROC NEAR			; MemDebug::init
; _this$ = ecx

; 164  : 	active_count=0;

	xor	eax, eax
	mov	DWORD PTR [ecx+8], eax

; 165  : 	closed=0;

	mov	DWORD PTR [ecx+12], eax

; 166  : 
; 167  : 	num_mallocs=0;

	mov	DWORD PTR [ecx], eax

; 168  : 	num_frees=0;

	mov	DWORD PTR [ecx+4], eax

; 169  : 
; 170  : 	alloc_block();

	jmp	?alloc_block@MemDebug@@AAEXXZ		; MemDebug::alloc_block
?init@MemDebug@@QAEXXZ ENDP				; MemDebug::init
; Function compile flags: /Ogty
?alloc_block@MemDebug@@AAEXXZ PROC NEAR		; MemDebug::alloc_block
; _this$ = ecx

; 174  : {

	push	esi
	push	edi

; 175  : 	MallocBlock *block=new MallocBlock;

	push	8204					; 0000200cH
	mov	esi, ecx
	call	??2MallocBlock@@SAPAXI@Z		; MallocBlock::operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $L57898
	mov	DWORD PTR [eax+8192], eax
	mov	edi, eax
	jmp	SHORT $L57899
$L57898:
	xor	edi, edi
$L57899:

; 176  : 	block_list.add_head(block);

	mov	eax, DWORD PTR [esi+40]
	mov	DWORD PTR [edi+8200], 0
	mov	DWORD PTR [edi+8196], eax
	mov	eax, DWORD PTR [esi+40]
	test	eax, eax
	je	SHORT $L57906
	mov	DWORD PTR [eax+8200], edi
	jmp	SHORT $L57907
$L57906:
	mov	DWORD PTR [esi+44], edi
$L57907:
	mov	DWORD PTR [esi+40], edi
	xor	ecx, ecx
$L57113:

; 177  : 
; 178  : 	for (U32 i=0;i<MALLOC_BLOCK_SIZE;i++)
; 179  : 	{
; 180  : 		free_list.add_head(&block->info[i]);

	mov	eax, DWORD PTR [edi+8192]
	mov	edx, DWORD PTR [esi+16]
	add	eax, ecx
	mov	DWORD PTR [eax+8], edx
	mov	DWORD PTR [eax+12], 0
	mov	edx, DWORD PTR [esi+16]
	test	edx, edx
	je	SHORT $L57912
	mov	DWORD PTR [edx+12], eax
	jmp	SHORT $L57913
$L57912:
	mov	DWORD PTR [esi+20], eax
$L57913:
	add	ecx, 16					; 00000010H
	mov	DWORD PTR [esi+16], eax
	cmp	ecx, 8192				; 00002000H
	jb	SHORT $L57113
	pop	edi
	pop	esi

; 181  : 	}
; 182  : }

	ret	0
?alloc_block@MemDebug@@AAEXXZ ENDP			; MemDebug::alloc_block
; Function compile flags: /Ogty
?close@MemDebug@@QAEXXZ PROC NEAR			; MemDebug::close
; _this$ = ecx

; 187  : {

	push	esi
	mov	esi, ecx

; 188  : 	block_list.free_list();

	mov	eax, DWORD PTR [esi+48]
	test	eax, eax
	jns	SHORT $L57927
	mov	eax, DWORD PTR [esi+40]
	test	eax, eax
	je	SHORT $L57927
	push	edi
$L57926:
	mov	eax, DWORD PTR [esi+40]
	mov	ecx, eax
	mov	edi, DWORD PTR [eax+8196]
	push	ecx
	call	??3MallocBlock@@SAXPAX@Z		; MallocBlock::operator delete
	add	esp, 4
	mov	DWORD PTR [esi+40], edi
	test	edi, edi
	jne	SHORT $L57926
	pop	edi
$L57927:
	mov	DWORD PTR [esi+40], 0
	mov	DWORD PTR [esi+44], 0

; 189  : 	closed=TRUE;

	mov	DWORD PTR [esi+12], 1
	pop	esi

; 190  : }

	ret	0
?close@MemDebug@@QAEXXZ ENDP				; MemDebug::close
_TEXT	ENDS
PUBLIC	?alloc@MemDebug@@QAEPAXK@Z			; MemDebug::alloc
PUBLIC	??2MallocInfo@@SAPAXIPAVMemDebug@@@Z		; MallocInfo::operator new
; Function compile flags: /Ogty
_TEXT	SEGMENT
_size$ = 8
?alloc@MemDebug@@QAEPAXK@Z PROC NEAR			; MemDebug::alloc
; _this$ = ecx

; 193  : {

	push	ebx
	push	esi
	push	edi

; 194  : 	void *mem=_xalloc(size+8);

	mov	edi, DWORD PTR _size$[esp+8]
	mov	esi, ecx
	lea	eax, DWORD PTR [edi+8]
	push	eax
	call	DWORD PTR __imp__malloc

; 195  : 
; 196  : 	MallocInfo *info=new(this) MallocInfo(mem,size);

	push	esi
	push	16					; 00000010H
	mov	ebx, eax
	call	??2MallocInfo@@SAPAXIPAVMemDebug@@@Z	; MallocInfo::operator new
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $L57935
	push	edi
	push	ebx
	mov	ecx, eax
	call	??0MallocInfo@@QAE@PAXK@Z		; MallocInfo::MallocInfo
	jmp	SHORT $L57936
$L57935:
	xor	eax, eax
$L57936:

; 197  : 
; 198  : 	used_list.add_head(info);

	mov	ecx, DWORD PTR [esi+28]
	mov	DWORD PTR [eax+12], 0
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR [esi+28]
	test	ecx, ecx
	je	SHORT $L57941
	mov	DWORD PTR [ecx+12], eax
	jmp	SHORT $L57942
$L57941:
	mov	DWORD PTR [esi+32], eax
$L57942:
	mov	DWORD PTR [esi+28], eax

; 199  : 
; 200  : 	if ((U32)info->ptr==0x0393eb34)

	mov	ecx, DWORD PTR [eax]
	cmp	ecx, 60025652				; 0393eb34H
	jne	SHORT $L57133

; 201  : 		dev_val++;

	mov	edx, DWORD PTR ?dev_val@@3KC		; dev_val
	inc	edx
	mov	DWORD PTR ?dev_val@@3KC, edx		; dev_val
$L57133:

; 202  : 	if ((U32)info->ptr==0x0393e80c)

	cmp	DWORD PTR [eax], 60024844		; 0393e80cH
	jne	SHORT $L57135

; 203  : 		dev_val++;

	mov	ecx, DWORD PTR ?dev_val@@3KC		; dev_val
	inc	ecx
	mov	DWORD PTR ?dev_val@@3KC, ecx		; dev_val
$L57135:

; 204  : 	if ((U32)info->ptr==0x038b15ac)

	cmp	DWORD PTR [eax], 59446700		; 038b15acH
	jne	SHORT $L57137

; 205  : 		dev_val++;

	mov	edx, DWORD PTR ?dev_val@@3KC		; dev_val
	inc	edx
	mov	DWORD PTR ?dev_val@@3KC, edx		; dev_val
$L57137:

; 206  : 
; 207  : 	active_count++;

	mov	ecx, DWORD PTR [esi+8]
	pop	edi
	inc	ecx
	mov	DWORD PTR [esi+8], ecx

; 208  : 	return (void *)info->ptr;

	mov	eax, DWORD PTR [eax]
	pop	esi
	pop	ebx

; 209  : }

	ret	4
?alloc@MemDebug@@QAEPAXK@Z ENDP				; MemDebug::alloc
_TEXT	ENDS
PUBLIC	?find_ptr@MemDebug@@AAEPAVMallocInfo@@PAX@Z	; MemDebug::find_ptr
PUBLIC	?free@MemDebug@@QAEXPAX@Z			; MemDebug::free
PUBLIC	??3MallocInfo@@SAXPAXPAVMemDebug@@@Z		; MallocInfo::operator delete
EXTRN	@xxx_bitch@4:NEAR
_DATA	SEGMENT
	ORG $+3
$SG57145 DB	'MemDebug::free: already closed', 00H
	ORG $+1
$SG57150 DB	'MemDebug::free: Unable to find handle to memory', 00H
; Function compile flags: /Ogty
_DATA	ENDS
_TEXT	SEGMENT
_ptr$ = 8
?free@MemDebug@@QAEXPAX@Z PROC NEAR			; MemDebug::free
; _this$ = ecx

; 214  : {

	push	esi
	mov	esi, ecx
	push	edi

; 215  : 	if (closed)

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $L57144

; 216  : 		xxx_bitch("MemDebug::free: already closed");

	mov	ecx, OFFSET FLAT:$SG57145
	call	@xxx_bitch@4
$L57144:

; 217  : 
; 218  : 	if ((U32)ptr==_deb_free)

	mov	eax, DWORD PTR _ptr$[esp+4]
	mov	ecx, DWORD PTR ?_deb_free@@3KA		; _deb_free
	cmp	eax, ecx
	jne	SHORT $L57147

; 219  : 		dev_val++;

	mov	ecx, DWORD PTR ?dev_val@@3KC		; dev_val
	inc	ecx
	mov	DWORD PTR ?dev_val@@3KC, ecx		; dev_val
$L57147:

; 220  : 	MallocInfo *info=find_ptr(ptr);

	push	eax
	mov	ecx, esi
	call	?find_ptr@MemDebug@@AAEPAVMallocInfo@@PAX@Z ; MemDebug::find_ptr
	mov	edi, eax

; 221  : 	if (!info)

	test	edi, edi
	jne	SHORT $L57149

; 222  : 		xxx_throw("MemDebug::free: Unable to find handle to memory");

	mov	ecx, OFFSET FLAT:$SG57150
	call	@xxx_throw@4
$L57149:

; 223  : 
; 224  : 	info->~MallocInfo();

	mov	ecx, edi
	call	??1MallocInfo@@QAE@XZ			; MallocInfo::~MallocInfo

; 225  : 	MallocInfo::operator delete(info,this);

	push	esi
	push	edi
	call	??3MallocInfo@@SAXPAXPAVMemDebug@@@Z	; MallocInfo::operator delete

; 226  : 
; 227  : 	active_count--;

	mov	eax, DWORD PTR [esi+8]
	add	esp, 8
	dec	eax
	mov	DWORD PTR [esi+8], eax
	pop	edi
	pop	esi

; 228  : }

	ret	4
?free@MemDebug@@QAEXPAX@Z ENDP				; MemDebug::free
; Function compile flags: /Ogty
_ptr$ = 8
?find_ptr@MemDebug@@AAEPAVMallocInfo@@PAX@Z PROC NEAR	; MemDebug::find_ptr
; _this$ = ecx

; 232  : 	MallocInfo *info=used_list.get_head();

	mov	eax, DWORD PTR [ecx+28]

; 233  : 	while(info)

	test	eax, eax
	je	SHORT $L57162
	mov	ecx, DWORD PTR _ptr$[esp-4]
$L57161:

; 234  : 	{
; 235  : 		if (info->ptr==((U32 *)ptr))

	cmp	DWORD PTR [eax], ecx
	je	SHORT $L57158

; 236  : 			return info;
; 237  : 
; 238  : 		info=used_list.get_next(info);

	mov	eax, DWORD PTR [eax+8]
	test	eax, eax
	jne	SHORT $L57161
$L57162:

; 239  : 	}
; 240  : 	return null;

	xor	eax, eax
$L57158:

; 241  : }

	ret	4
?find_ptr@MemDebug@@AAEPAVMallocInfo@@PAX@Z ENDP	; MemDebug::find_ptr
_TEXT	ENDS
PUBLIC	??3@YAXPAX@Z					; operator delete
PUBLIC	@xfree@4
; Function compile flags: /Ogty
; File C:\duke4\xcore\xcore.h
;	COMDAT ??3@YAXPAX@Z
_TEXT	SEGMENT
_ptr$ = 8
??3@YAXPAX@Z PROC NEAR					; operator delete, COMDAT

; 130  : __inline void operator delete(void *ptr){xfree(ptr);}

	mov	ecx, DWORD PTR _ptr$[esp-4]
	jmp	@xfree@4
??3@YAXPAX@Z ENDP					; operator delete
_TEXT	ENDS
PUBLIC	?alloc_info@MemDebug@@QAEPAVMallocInfo@@XZ	; MemDebug::alloc_info
; Function compile flags: /Ogty
; File C:\duke4\xcore\winmem.cpp
_TEXT	SEGMENT
_This$ = 12
??2MallocInfo@@SAPAXIPAVMemDebug@@@Z PROC NEAR		; MallocInfo::operator new

; 245  : 	MallocInfo *info=This->alloc_info();

	mov	ecx, DWORD PTR _This$[esp-4]
	jmp	?alloc_info@MemDebug@@QAEPAVMallocInfo@@XZ ; MemDebug::alloc_info
??2MallocInfo@@SAPAXIPAVMemDebug@@@Z ENDP		; MallocInfo::operator new
_TEXT	ENDS
PUBLIC	?free_info@MemDebug@@QAEXPAVMallocInfo@@@Z	; MemDebug::free_info
; Function compile flags: /Ogty
_TEXT	SEGMENT
_ptr$ = 8
_This$ = 12
??3MallocInfo@@SAXPAXPAVMemDebug@@@Z PROC NEAR		; MallocInfo::operator delete

; 252  : 	This->free_info((MallocInfo *)ptr);

	mov	eax, DWORD PTR _ptr$[esp-4]
	mov	ecx, DWORD PTR _This$[esp-4]
	push	eax
	call	?free_info@MemDebug@@QAEXPAVMallocInfo@@@Z ; MemDebug::free_info

; 253  : }

	ret	0
??3MallocInfo@@SAXPAXPAVMemDebug@@@Z ENDP		; MallocInfo::operator delete
; Function compile flags: /Ogty
?alloc_info@MemDebug@@QAEPAVMallocInfo@@XZ PROC NEAR	; MemDebug::alloc_info
; _this$ = ecx

; 256  : {

	push	esi
	mov	esi, ecx
	push	edi

; 257  : 	MallocInfo *free=free_list.remove_head();

	xor	edi, edi
	mov	eax, DWORD PTR [esi+16]
	cmp	eax, edi
	je	SHORT $L57985
	mov	ecx, DWORD PTR [eax+8]
	cmp	ecx, edi
	mov	DWORD PTR [esi+16], ecx
	jne	SHORT $L57974
	mov	DWORD PTR [esi+20], edi
	jmp	SHORT $L57975
$L57974:
	mov	DWORD PTR [ecx+12], edi
$L57975:

; 258  : 	if (!free)

	cmp	eax, edi
	jne	SHORT $L57979
$L57985:

; 259  : 	{
; 260  : 		alloc_block();

	mov	ecx, esi
	call	?alloc_block@MemDebug@@AAEXXZ		; MemDebug::alloc_block

; 261  : 		free=free_list.remove_head();

	mov	eax, DWORD PTR [esi+16]
	cmp	eax, edi
	jne	SHORT $L57980
	pop	edi
	xor	eax, eax
	pop	esi

; 262  : 	}
; 263  : 
; 264  : 	return free;
; 265  : }

	ret	0

; 261  : 		free=free_list.remove_head();

$L57980:
	mov	ecx, DWORD PTR [eax+8]
	cmp	ecx, edi
	mov	DWORD PTR [esi+16], ecx
	jne	SHORT $L57982
	mov	DWORD PTR [esi+20], edi
	pop	edi
	pop	esi

; 262  : 	}
; 263  : 
; 264  : 	return free;
; 265  : }

	ret	0

; 261  : 		free=free_list.remove_head();

$L57982:
	mov	DWORD PTR [ecx+12], edi
$L57979:
	pop	edi
	pop	esi

; 262  : 	}
; 263  : 
; 264  : 	return free;
; 265  : }

	ret	0
?alloc_info@MemDebug@@QAEPAVMallocInfo@@XZ ENDP		; MemDebug::alloc_info
; Function compile flags: /Ogty
_info$ = 8
?free_info@MemDebug@@QAEXPAVMallocInfo@@@Z PROC NEAR	; MemDebug::free_info
; _this$ = ecx

; 269  : 	used_list.remove(info);

	mov	eax, DWORD PTR _info$[esp-4]
	push	esi
	mov	edx, DWORD PTR [eax+12]
	test	edx, edx
	je	SHORT $L57991
	mov	esi, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], esi
	jmp	SHORT $L57992
$L57991:
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+28], edx
$L57992:
	mov	edx, DWORD PTR [eax+8]
	test	edx, edx
	je	SHORT $L57993
	mov	esi, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+12], esi
	jmp	SHORT $L57994
$L57993:
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+32], edx
$L57994:

; 270  : 	free_list.add_head(info);

	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+12], 0
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx+16]
	test	edx, edx
	pop	esi
	je	SHORT $L57999
	mov	DWORD PTR [edx+12], eax
	mov	DWORD PTR [ecx+16], eax

; 271  : }

	ret	4

; 270  : 	free_list.add_head(info);

$L57999:
	mov	DWORD PTR [ecx+20], eax
	mov	DWORD PTR [ecx+16], eax

; 271  : }

	ret	4
?free_info@MemDebug@@QAEXPAVMallocInfo@@@Z ENDP		; MemDebug::free_info
_TEXT	ENDS
PUBLIC	?leak@MemDebug@@QAEKXZ				; MemDebug::leak
; Function compile flags: /Ogty
_TEXT	SEGMENT
?leak@MemDebug@@QAEKXZ PROC NEAR			; MemDebug::leak
; _this$ = ecx

; 275  : 	MallocInfo *obj=used_list.get_head();

	mov	ecx, DWORD PTR [ecx+28]

; 276  : 	
; 277  : 	U32 count=0;

	xor	eax, eax

; 278  : 	while(obj)

	test	ecx, ecx
	je	SHORT $L57193
$L57192:

; 279  : 	{
; 280  : 		obj=used_list.get_next(obj);

	mov	ecx, DWORD PTR [ecx+8]

; 281  : 		count++;

	inc	eax
	test	ecx, ecx
	jne	SHORT $L57192
$L57193:

; 282  : 	}
; 283  : 	return count;
; 284  : }

	ret	0
?leak@MemDebug@@QAEKXZ ENDP				; MemDebug::leak
_TEXT	ENDS
PUBLIC	__test_leak
; Function compile flags: /Ogty
_TEXT	SEGMENT
__test_leak PROC NEAR

; 288  : 	return mem_debug->leak();

	mov	ecx, DWORD PTR ?mem_debug@@3PAVMemDebug@@A ; mem_debug
	jmp	?leak@MemDebug@@QAEKXZ			; MemDebug::leak
__test_leak ENDP
_TEXT	ENDS
PUBLIC	?alloc@CTrackList@@QAEXPADK@Z			; CTrackList::alloc
; Function compile flags: /Ogty
_TEXT	SEGMENT
_ptr$ = 8
_size$ = 12
?alloc@CTrackList@@QAEXPADK@Z PROC NEAR			; CTrackList::alloc
; _this$ = ecx

; 333  : 	list[active].ptr=ptr;

	mov	eax, DWORD PTR [ecx+8192]
	mov	edx, DWORD PTR _ptr$[esp-4]
	push	esi

; 334  : 	list[active].size=size;

	mov	esi, DWORD PTR _size$[esp]
	mov	DWORD PTR [ecx+eax*8], edx
	mov	eax, DWORD PTR [ecx+8192]
	mov	DWORD PTR [ecx+eax*8+4], esi

; 335  : 	list[active].set_tags();

	mov	edx, DWORD PTR [ecx+8192]
	lea	eax, DWORD PTR [ecx+edx*8]
	mov	edx, DWORD PTR [ecx+edx*8]
	mov	eax, DWORD PTR [eax+4]
	add	eax, edx
	mov	DWORD PTR [edx-4], -559035650		; deadcafeH
	mov	DWORD PTR [eax], -559038737		; deadbeefH

; 336  : 	active++;

	mov	edx, DWORD PTR [ecx+8192]

; 337  : 	total_mem+=size;

	mov	eax, DWORD PTR [ecx+8196]
	inc	edx
	add	eax, esi
	mov	DWORD PTR [ecx+8192], edx
	mov	DWORD PTR [ecx+8196], eax
	pop	esi

; 338  : }

	ret	8
?alloc@CTrackList@@QAEXPADK@Z ENDP			; CTrackList::alloc
_TEXT	ENDS
PUBLIC	??_C@_08GPFK@whooznat?$AA@			; `string'
PUBLIC	??_C@_07KPPF@wheezer?$AA@			; `string'
PUBLIC	?free@CTrackList@@QAEXPAD@Z			; CTrackList::free
_DATA	SEGMENT
$SG57260 DB	'Whizzer not found', 00H
_DATA	ENDS
;	COMDAT ??_C@_08GPFK@whooznat?$AA@
_DATA	SEGMENT
??_C@_08GPFK@whooznat?$AA@ DB 'whooznat', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_07KPPF@wheezer?$AA@
_DATA	SEGMENT
??_C@_07KPPF@wheezer?$AA@ DB 'wheezer', 00H		; `string'
; Function compile flags: /Ogty
_DATA	ENDS
_TEXT	SEGMENT
_ptr$ = 8
?free@CTrackList@@QAEXPAD@Z PROC NEAR			; CTrackList::free
; _this$ = ecx

; 341  : {

	push	esi
	push	edi
	mov	edi, ecx

; 342  : 	for (U32 i=0;i<active;i++)

	xor	esi, esi
	mov	eax, DWORD PTR [edi+8192]
	test	eax, eax
	jbe	SHORT $L57258
	mov	ecx, DWORD PTR _ptr$[esp+4]
$L57256:

; 343  : 	{
; 344  : 		if (list[i].ptr==ptr)

	cmp	DWORD PTR [edi+esi*8], ecx
	je	SHORT $L58032
	inc	esi
	cmp	esi, eax
	jb	SHORT $L57256
$L57258:

; 348  : 			return;
; 349  : 		}
; 350  : 	}
; 351  : 	xxx_bitch("Whizzer not found");

	mov	ecx, OFFSET FLAT:$SG57260
	call	@xxx_bitch@4
	pop	edi
	pop	esi

; 352  : }

	ret	4
$L58032:

; 345  : 		{
; 346  : 			list[i].check_tags();

	mov	eax, DWORD PTR [edi+esi*8]
	push	ebx
	mov	ebx, DWORD PTR [edi+esi*8+4]
	mov	ecx, DWORD PTR [eax-4]
	add	ebx, eax
	cmp	ecx, -559035650				; deadcafeH
	je	SHORT $L58028
	mov	ecx, OFFSET FLAT:??_C@_08GPFK@whooznat?$AA@ ; `string'
	call	@xxx_bitch@4
$L58028:
	mov	eax, DWORD PTR [ebx]
	pop	ebx
	cmp	eax, -559038737				; deadbeefH
	je	SHORT $L58029
	mov	ecx, OFFSET FLAT:??_C@_07KPPF@wheezer?$AA@ ; `string'
	call	@xxx_bitch@4
$L58029:

; 347  : 			list[i].ptr=null;

	mov	DWORD PTR [edi+esi*8], 0
	pop	edi
	pop	esi

; 352  : }

	ret	4
?free@CTrackList@@QAEXPAD@Z ENDP			; CTrackList::free
; Function compile flags: /Ogty
_$E2	PROC NEAR
	jmp	_$E1
_$E2	ENDP
; Function compile flags: /Ogty
_$E1	PROC NEAR

; 354  : CTrackList track_list;

	xor	eax, eax
	mov	DWORD PTR ?track_list@@3VCTrackList@@A+8192, eax
	mov	DWORD PTR ?track_list@@3VCTrackList@@A+8196, eax
	ret	0
_$E1	ENDP
_TEXT	ENDS
PUBLIC	__xheap_check
EXTRN	__imp___heapchk:NEAR
EXTRN	__imp___heapwalk:NEAR
_DATA	SEGMENT
	ORG $+2
$SG57285 DB	'ERROR - bad start of heap', 0aH, 00H
	ORG $+1
$SG57287 DB	'ERROR - bad node in heap', 0aH, 00H
	ORG $+2
$SG57283 DB	'ERROR - bad pointer to heap', 0aH, 00H
	ORG $+3
$SG57288 DB	'Heap is broken', 00H
	ORG $+1
$SG57303 DB	'ERROR - bad start of heap', 0aH, 00H
	ORG $+1
$SG57305 DB	'ERROR - bad node in heap', 0aH, 00H
	ORG $+2
$SG57301 DB	'ERROR - bad pointer to heap', 0aH, 00H
; Function compile flags: /Ogty
_DATA	ENDS
_TEXT	SEGMENT
_hinfo$ = -12
__xheap_check PROC NEAR

; 359  : {

	sub	esp, 12					; 0000000cH

; 360  : 	U32 res=_heapchk();

	call	DWORD PTR __imp___heapchk

; 361  : 
; 362  : 	if ((res!=_HEAPOK)&&(res!=_HEAPEMPTY))

	cmp	eax, -2					; fffffffeH
	je	SHORT $L57277
	cmp	eax, -1
	je	SHORT $L57277

; 363  : 	{
; 364  : 		switch (res)
; 365  : 		{

	cmp	eax, -6					; fffffffaH
	je	SHORT $L57282
	cmp	eax, -4					; fffffffcH
	je	SHORT $L57286
	cmp	eax, -3					; fffffffdH
	jne	SHORT $L57279

; 368  : 				break;
; 369  : 			case _HEAPBADBEGIN:
; 370  : 				xxx_bitch( "ERROR - bad start of heap\n" );

	mov	ecx, OFFSET FLAT:$SG57285

; 371  : 				break;

	jmp	SHORT $L58041
$L57286:

; 372  : 			case _HEAPBADNODE:
; 373  : 				xxx_bitch( "ERROR - bad node in heap\n" );

	mov	ecx, OFFSET FLAT:$SG57287

; 374  : 				break;

	jmp	SHORT $L58041
$L57282:

; 366  : 			case _HEAPBADPTR:
; 367  : 				xxx_bitch( "ERROR - bad pointer to heap\n" );

	mov	ecx, OFFSET FLAT:$SG57283
$L58041:
	call	@xxx_bitch@4
$L57279:

; 375  : 		}
; 376  : 		xxx_bitch("Heap is broken");

	mov	ecx, OFFSET FLAT:$SG57288
	call	@xxx_bitch@4
$L57277:
	push	esi

; 377  : 	}
; 378  : 
; 379  : 	_HEAPINFO hinfo;
; 380  : 	int heapstatus;
; 381  : 	hinfo._pentry = NULL;

	mov	esi, DWORD PTR __imp___heapwalk
	mov	DWORD PTR _hinfo$[esp+16], 0
$L57292:

; 382  : 	
; 383  : 	while( ( heapstatus = _heapwalk( &hinfo ) ) == _HEAPOK );

	lea	eax, DWORD PTR _hinfo$[esp+16]
	push	eax
	call	esi
	add	esp, 4
	cmp	eax, -2					; fffffffeH
	je	SHORT $L57292

; 384  : 
; 385  : 	if (heapstatus==_HEAPEMPTY)

	cmp	eax, -1
	pop	esi
	je	SHORT $L57297

; 386  : 		return;
; 387  : 
; 388  : 	if (heapstatus==_HEAPEND)

	cmp	eax, -5					; fffffffbH
	je	SHORT $L57297

; 389  : 		return;
; 390  : 
; 391  : 	switch( heapstatus )
; 392  : 	{

	cmp	eax, -6					; fffffffaH
	je	SHORT $L57300
	cmp	eax, -4					; fffffffcH
	je	SHORT $L57304
	cmp	eax, -3					; fffffffdH
	jne	SHORT $L57297

; 395  : 			break;
; 396  : 		case _HEAPBADBEGIN:
; 397  : 			xxx_bitch( "ERROR - bad start of heap\n" );

	mov	ecx, OFFSET FLAT:$SG57303

; 393  : 		case _HEAPBADPTR:
; 394  : 			xxx_bitch( "ERROR - bad pointer to heap\n" );

	call	@xxx_bitch@4

; 401  : 			break;
; 402  : 	}
; 403  : }

	add	esp, 12					; 0000000cH
	ret	0
$L57304:

; 398  : 			break;
; 399  : 		case _HEAPBADNODE:
; 400  : 			xxx_bitch( "ERROR - bad node in heap\n" );

	mov	ecx, OFFSET FLAT:$SG57305

; 393  : 		case _HEAPBADPTR:
; 394  : 			xxx_bitch( "ERROR - bad pointer to heap\n" );

	call	@xxx_bitch@4

; 401  : 			break;
; 402  : 	}
; 403  : }

	add	esp, 12					; 0000000cH
	ret	0
$L57300:

; 393  : 		case _HEAPBADPTR:
; 394  : 			xxx_bitch( "ERROR - bad pointer to heap\n" );

	mov	ecx, OFFSET FLAT:$SG57301
	call	@xxx_bitch@4
$L57297:

; 401  : 			break;
; 402  : 	}
; 403  : }

	add	esp, 12					; 0000000cH
	ret	0
__xheap_check ENDP
_TEXT	ENDS
PUBLIC	@xmalloc@4
; Function compile flags: /Ogty
_TEXT	SEGMENT
@xmalloc@4 PROC NEAR
; _size$ = ecx

; 407  : 	void *ptr;
; 408  : 
; 409  : #ifdef MEM_DEBUG
; 410  : 	ptr=mem_debug->alloc(size);
; 411  : #else
; 412  : 	D_ASSERT(size);
; 413  : 	ptr=_xalloc(size);

	push	ecx
	call	DWORD PTR __imp__malloc

; 414  : #endif
; 415  : #ifdef MEM_TRACK
; 416  : 	_global->stats.add_alloc();
; 417  : #endif
; 418  : 	_active_count++;

	mov	edx, DWORD PTR ?_active_count@@3KA	; _active_count
	add	esp, 4
	inc	edx

; 419  : 	if ((U32)ptr==0x01343890)

	cmp	eax, 20199568				; 01343890H
	mov	DWORD PTR ?_active_count@@3KA, edx	; _active_count
	jne	SHORT $L57311

; 420  : 		dev_val++;

	mov	ecx, DWORD PTR ?dev_val@@3KC		; dev_val
	inc	ecx
	mov	DWORD PTR ?dev_val@@3KC, ecx		; dev_val

; 423  : 	
; 424  : 	return ptr;
; 425  : }

	ret	0
$L57311:

; 421  : 	if ((U32)ptr==0x01343030)

	cmp	eax, 20197424				; 01343030H
	jne	SHORT $L57313

; 422  : 		dev_val++;

	mov	edx, DWORD PTR ?dev_val@@3KC		; dev_val
	inc	edx
	mov	DWORD PTR ?dev_val@@3KC, edx		; dev_val
$L57313:

; 423  : 	
; 424  : 	return ptr;
; 425  : }

	ret	0
@xmalloc@4 ENDP
_TEXT	ENDS
PUBLIC	@xrealloc@8
; Function compile flags: /Ogty
_TEXT	SEGMENT
@xrealloc@8 PROC NEAR
; _ptr$ = ecx
; _size$ = edx

; 428  : {

	mov	eax, ecx

; 429  : 	_asm int 3

	int	3

; 430  : 	return ptr;
; 431  : }

	ret	0
@xrealloc@8 ENDP
_TEXT	ENDS
PUBLIC	@xmalloc_tmp@4
; Function compile flags: /Ogty
_TEXT	SEGMENT
@xmalloc_tmp@4 PROC NEAR
; _size$ = ecx

; 435  : #ifdef MEM_DEBUG
; 436  : 	return mem_debug->alloc(size);
; 437  : #else
; 438  : 	return _xalloc(size+8);

	add	ecx, 8
	push	ecx
	call	DWORD PTR __imp__malloc
	add	esp, 4

; 439  : #endif
; 440  : }

	ret	0
@xmalloc_tmp@4 ENDP
; Function compile flags: /Ogty
@xfree@4 PROC NEAR
; _ptr$ = ecx

; 444  : 	if (!ptr)

	test	ecx, ecx
	je	SHORT $L57323

; 445  : 		return;
; 446  : 
; 447  : 	if ((U32)ptr==0x01343890)

	cmp	ecx, 20199568				; 01343890H
	jne	SHORT $L57326

; 448  : 		dev_val++;

	mov	eax, DWORD PTR ?dev_val@@3KC		; dev_val
	inc	eax
	mov	DWORD PTR ?dev_val@@3KC, eax		; dev_val
$L57326:

; 449  : #ifdef MEM_DEBUG
; 450  : 	mem_debug->free(ptr);
; 451  : #else
; 452  : 	_xfree(ptr);

	push	ecx
	call	DWORD PTR __imp__free
	pop	ecx
$L57323:

; 453  : #endif
; 454  : }

	ret	0
@xfree@4 ENDP
_TEXT	ENDS
PUBLIC	@xmalloc2@4
; Function compile flags: /Ogty
_TEXT	SEGMENT
@xmalloc2@4 PROC NEAR
; _size$ = ecx

; 458  : 	void *ptr;
; 459  : #ifdef MEM_DEBUG
; 460  : 	ptr=mem_debug2->alloc(size);
; 461  : #else
; 462  : 	ptr=_xalloc(size+8);

	add	ecx, 8
	push	ecx
	call	DWORD PTR __imp__malloc
	add	esp, 4

; 463  : #endif
; 464  : #ifdef MEM_TRACK
; 465  : 	_global->stats.add_alloc2();
; 466  : #endif
; 467  : 	return ptr;
; 468  : }

	ret	0
@xmalloc2@4 ENDP
_TEXT	ENDS
PUBLIC	@xfree2@4
; Function compile flags: /Ogty
_TEXT	SEGMENT
@xfree2@4 PROC NEAR
; _ptr$ = ecx

; 472  : 	if (!ptr)

	test	ecx, ecx
	je	SHORT $L57333

; 473  : 		return;
; 474  : #ifdef MEM_DEBUG
; 475  : 	mem_debug2->free(ptr);
; 476  : #else
; 477  : 	_xfree(ptr);

	push	ecx
	call	DWORD PTR __imp__free
	pop	ecx
$L57333:

; 478  : #endif
; 479  : }

	ret	0
@xfree2@4 ENDP
_TEXT	ENDS
PUBLIC	@xmalloc3@4
; Function compile flags: /Ogty
_TEXT	SEGMENT
@xmalloc3@4 PROC NEAR
; _size$ = ecx

; 483  : 	void *ptr;
; 484  : #ifdef MEM_DEBUG
; 485  : 	ptr=mem_debug3->alloc(size);
; 486  : #else
; 487  : 	ptr=_xalloc(size+8);

	add	ecx, 8
	push	ecx
	call	DWORD PTR __imp__malloc
	add	esp, 4

; 488  : #endif
; 489  : #ifdef MEM_TRACK
; 490  : 	_global->stats.add_alloc3();
; 491  : #endif
; 492  : 	return ptr;
; 493  : }

	ret	0
@xmalloc3@4 ENDP
_TEXT	ENDS
PUBLIC	@xfree3@4
; Function compile flags: /Ogty
_TEXT	SEGMENT
@xfree3@4 PROC NEAR
; _ptr$ = ecx

; 497  : 	if (!ptr)

	test	ecx, ecx
	je	SHORT $L57341

; 498  : 		return;
; 499  : #ifdef MEM_DEBUG
; 500  : 	mem_debug3->free(ptr);
; 501  : #else
; 502  : 	_xfree(ptr);

	push	ecx
	call	DWORD PTR __imp__free
	pop	ecx
$L57341:

; 503  : #endif
; 504  : }

	ret	0
@xfree3@4 ENDP
_TEXT	ENDS
PUBLIC	@xmalloc4@4
; Function compile flags: /Ogty
_TEXT	SEGMENT
@xmalloc4@4 PROC NEAR
; _size$ = ecx

; 508  : #ifdef MEM_DEBUG
; 509  : 	return mem_debug4->alloc(size);
; 510  : #else
; 511  : 	return _xalloc(size+8);

	add	ecx, 8
	push	ecx
	call	DWORD PTR __imp__malloc
	add	esp, 4

; 512  : #endif
; 513  : }

	ret	0
@xmalloc4@4 ENDP
_TEXT	ENDS
PUBLIC	@xfree4@4
; Function compile flags: /Ogty
_TEXT	SEGMENT
@xfree4@4 PROC NEAR
; _ptr$ = ecx

; 517  : 	if (!ptr)

	test	ecx, ecx
	je	SHORT $L57348

; 518  : 		return;
; 519  : #ifdef MEM_DEBUG
; 520  : 	mem_debug4->free(ptr);
; 521  : #else
; 522  : 	_xfree(ptr);

	push	ecx
	call	DWORD PTR __imp__free
	pop	ecx
$L57348:

; 523  : #endif
; 524  : }

	ret	0
@xfree4@4 ENDP
_TEXT	ENDS
PUBLIC	??1CMallocBlock@@QAE@XZ				; CMallocBlock::~CMallocBlock
_DATA	SEGMENT
	ORG $+3
$SG57355 DB	'Never fully allocated', 00H
; Function compile flags: /Ogty
_DATA	ENDS
_TEXT	SEGMENT
??1CMallocBlock@@QAE@XZ PROC NEAR			; CMallocBlock::~CMallocBlock
; _this$ = ecx

; 528  :    if (cur!=num_blocks)

	mov	al, BYTE PTR [ecx+1]
	mov	dl, BYTE PTR [ecx]
	cmp	al, dl
	je	SHORT $L57354

; 529  :       xxx_bitch("Never fully allocated");

	mov	ecx, OFFSET FLAT:$SG57355
	jmp	@xxx_bitch@4
$L57354:

; 530  : }

	ret	0
??1CMallocBlock@@QAE@XZ ENDP				; CMallocBlock::~CMallocBlock
_TEXT	ENDS
PUBLIC	?get_next@CMallocBlock@@QAEPAXXZ		; CMallocBlock::get_next
_DATA	SEGMENT
	ORG $+6
$SG57361 DB	'CMallocBlock::get_next: attempted to get more blocks tha'
	DB	'n allocated', 00H
; Function compile flags: /Ogty
_DATA	ENDS
_TEXT	SEGMENT
?get_next@CMallocBlock@@QAEPAXXZ PROC NEAR		; CMallocBlock::get_next
; _this$ = ecx

; 534  : 	if (cur>=num_blocks)

	mov	dl, BYTE PTR [ecx+1]
	mov	al, BYTE PTR [ecx]
	cmp	dl, al
	jb	SHORT $L57360

; 535  : 	{
; 536  : 		xxx_throw("CMallocBlock::get_next: attempted to get more blocks than allocated");

	mov	ecx, OFFSET FLAT:$SG57361
	call	@xxx_throw@4

; 537  : 		return null;

	xor	eax, eax

; 541  : }

	ret	0
$L57360:

; 538  : 	}
; 539  : 
; 540  : 	return ((void *)(list_base())[cur++]);

	mov	eax, edx
	and	eax, 255				; 000000ffH
	inc	dl
	mov	eax, DWORD PTR [ecx+eax*4+4]
	mov	BYTE PTR [ecx+1], dl

; 541  : }

	ret	0
?get_next@CMallocBlock@@QAEPAXXZ ENDP			; CMallocBlock::get_next
_TEXT	ENDS
PUBLIC	??2CMallocBlock@@SAPAXIKPBKK@Z			; CMallocBlock::operator new
_DATA	SEGMENT
$SG57407 DB	'CMallocBlock::new: final address is bad', 00H
; Function compile flags: /Ogty
_DATA	ENDS
_TEXT	SEGMENT
_size$ = 8
_num$ = 12
_list$ = 16
_align$ = 20
_tmp_not$ = -4
??2CMallocBlock@@SAPAXIKPBKK@Z PROC NEAR		; CMallocBlock::operator new

; 544  : {

	push	ecx

; 545  : 	CMallocBlock   *obj;
; 546  : 	U32 i,size_align,addr,*ptr_list;
; 547  : 
; 548  : 	D_ASSERT(num<256);
; 549  : 	D_ASSERT(IS_POW2(align));
; 550  : 	D_ASSERT(align<=128);
; 551  : 
; 552  : 	U32 tmp_mask=align - 1;

	mov	eax, DWORD PTR _align$[esp]
	push	ebx

; 553  : 	U32 tmp_not=~tmp_mask;
; 554  : 	size_align=align - 1;
; 555  : 
; 556  : 	for (i=0,size=0;i<num;i++)

	mov	ebx, DWORD PTR _num$[esp+4]
	push	ebp
	push	esi
	lea	esi, DWORD PTR [eax-1]
	mov	eax, esi
	xor	ecx, ecx
	not	eax
	xor	ebp, ebp
	push	edi
	test	ebx, ebx
	mov	DWORD PTR _tmp_not$[esp+20], eax
	mov	edi, esi
	mov	DWORD PTR _size$[esp+16], ebp
	jbe	SHORT $L57378
$L57376:

; 557  : 	{
; 558  : 		U32 tmp=list[i],tmp2;

	mov	edx, DWORD PTR _list$[esp+16]
	mov	edx, DWORD PTR [edx+ecx*4]

; 559  : 
; 560  : 		tmp2=tmp&tmp_mask;

	mov	eax, edx
	and	eax, esi

; 561  : 
; 562  : 		size_align+=((tmp2 + tmp_mask) & tmp_not) - tmp2;

	lea	ebp, DWORD PTR [eax+esi]
	and	ebp, DWORD PTR _tmp_not$[esp+20]
	sub	ebp, eax
	add	edi, ebp

; 563  : 
; 564  : 		size+=tmp;

	mov	ebp, DWORD PTR _size$[esp+16]
	add	ebp, edx
	inc	ecx
	cmp	ecx, ebx
	mov	DWORD PTR _size$[esp+16], ebp
	jb	SHORT $L57376
$L57378:

; 565  : 	}
; 566  : 	/* add room for worst case alignment */
; 567  : 	size+=size_align;
; 568  : 	/* make room for object itself */
; 569  : 	size+=sizeof(CMallocBlock);
; 570  : 	/* make room for the ptr list */
; 571  : 	size+=num*4;

	lea	eax, DWORD PTR [edi+ebx*4+4]
	add	ebp, eax

; 572  : 	obj=(CMallocBlock *)xmalloc(size);

	mov	ecx, ebp
	call	@xmalloc@4
	mov	edi, eax

; 573  : 
; 574  : 	obj->num_blocks=(U8)num;
; 575  : 	obj->align_size=(U8)align;

	mov	eax, DWORD PTR _align$[esp+16]

; 576  : 
; 577  : 	/* setup ptr list */
; 578  : 	ptr_list=(U32 *)(obj+1);
; 579  : 	addr=((U32)ptr_list)+num*4;
; 580  : 	/* align ptrs to align value */
; 581  : 	addr=ALIGN_POW2(addr,align);

	not	esi
	lea	edx, DWORD PTR [edi+4]
	mov	BYTE PTR [edi+2], al
	mov	BYTE PTR [edi], bl
	lea	ecx, DWORD PTR [edx+ebx*4]
	lea	eax, DWORD PTR [ecx+eax-1]
	and	eax, esi

; 582  : 	for (i=0;i<num;i++)

	test	ebx, ebx
	jbe	SHORT $L57396

; 591  : 
; 592  : 	return obj;

	mov	ecx, DWORD PTR _list$[esp+16]
	mov	DWORD PTR 8+[esp+16], ebx
	sub	edx, ecx
$L57394:
	mov	DWORD PTR [edx+ecx], eax
	mov	ebx, DWORD PTR [ecx]
	test	ebx, ebx
	jne	SHORT $L57397

; 583  : 	{
; 584  : 		ptr_list[i]=addr;
; 585  : 		if (!list[i])
; 586  : 			ptr_list[i]=null;

	mov	DWORD PTR [edx+ecx], 0
$L57397:

; 587  : 		addr=ALIGN_POW2((addr + list[i]),align);

	mov	ebx, DWORD PTR [ecx]
	add	ecx, 4
	add	ebx, eax
	mov	eax, DWORD PTR _align$[esp+16]
	lea	eax, DWORD PTR [ebx+eax-1]
	mov	ebx, DWORD PTR 8+[esp+16]
	and	eax, esi
	dec	ebx
	mov	DWORD PTR 8+[esp+16], ebx
	jne	SHORT $L57394
$L57396:

; 588  : 	}
; 589  : 	if (addr > (((U32)obj)+size))

	lea	ecx, DWORD PTR [edi+ebp]
	cmp	eax, ecx
	jbe	SHORT $L58064

; 590  : 		xxx_throw("CMallocBlock::new: final address is bad");

	mov	ecx, OFFSET FLAT:$SG57407
	call	@xxx_throw@4
$L58064:

; 591  : 
; 592  : 	return obj;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 593  : }

	pop	ecx
	ret	0
??2CMallocBlock@@SAPAXIKPBKK@Z ENDP			; CMallocBlock::operator new
_TEXT	ENDS
PUBLIC	??0?$XChain@VCSysObj@@@@QAE@XZ			; XChain<CSysObj>::XChain<CSysObj>
; Function compile flags: /Ogty
; File C:\duke4\xcore\xclass.h
;	COMDAT ??0?$XChain@VCSysObj@@@@QAE@XZ
_TEXT	SEGMENT
??0?$XChain@VCSysObj@@@@QAE@XZ PROC NEAR		; XChain<CSysObj>::XChain<CSysObj>, COMDAT
; _this$ = ecx

; 830  : 	XChain(void) : head(null),tail(null) {}

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$XChain@VCSysObj@@@@QAE@XZ ENDP			; XChain<CSysObj>::XChain<CSysObj>
_TEXT	ENDS
PUBLIC	??0?$XChain@VCSysObj@@@@QAE@K@Z			; XChain<CSysObj>::XChain<CSysObj>
; Function compile flags: /Ogty
;	COMDAT ??0?$XChain@VCSysObj@@@@QAE@K@Z
_TEXT	SEGMENT
_owned$ = 8
??0?$XChain@VCSysObj@@@@QAE@K@Z PROC NEAR		; XChain<CSysObj>::XChain<CSysObj>, COMDAT
; _this$ = ecx

; 831  : 	XChain(U32 owned) : head(null),tail(null),xchain_state(owned) {}

	mov	eax, ecx
	mov	ecx, DWORD PTR _owned$[esp-4]
	shl	ecx, 31					; 0000001fH
	and	ecx, -2147483648			; 80000000H
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], ecx
	ret	4
??0?$XChain@VCSysObj@@@@QAE@K@Z ENDP			; XChain<CSysObj>::XChain<CSysObj>
_TEXT	ENDS
PUBLIC	?get_next@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z ; XChain<CSysObj>::get_next
; Function compile flags: /Ogty
;	COMDAT ?get_next@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z
_TEXT	SEGMENT
_ptr$ = 8
?get_next@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z PROC NEAR ; XChain<CSysObj>::get_next, COMDAT
; _this$ = ecx

; 840  : 	TYPE *get_next(TYPE *ptr){return ptr->next;}

	mov	eax, DWORD PTR _ptr$[esp-4]
	mov	eax, DWORD PTR [eax+4]
	ret	4
?get_next@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z ENDP ; XChain<CSysObj>::get_next
_TEXT	ENDS
PUBLIC	?get_prev@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z ; XChain<CSysObj>::get_prev
; Function compile flags: /Ogty
;	COMDAT ?get_prev@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z
_TEXT	SEGMENT
_ptr$ = 8
?get_prev@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z PROC NEAR ; XChain<CSysObj>::get_prev, COMDAT
; _this$ = ecx

; 841  : 	TYPE *get_prev(TYPE *ptr){return ptr->prev;}

	mov	eax, DWORD PTR _ptr$[esp-4]
	mov	eax, DWORD PTR [eax+8]
	ret	4
?get_prev@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z ENDP ; XChain<CSysObj>::get_prev
_TEXT	ENDS
PUBLIC	?get_head@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ ; XChain<CSysObj>::get_head
; Function compile flags: /Ogty
;	COMDAT ?get_head@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ
_TEXT	SEGMENT
?get_head@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ PROC NEAR ; XChain<CSysObj>::get_head, COMDAT
; _this$ = ecx

; 847  : 	inline TYPE *get_head(void){return head;}

	mov	eax, DWORD PTR [ecx]
	ret	0
?get_head@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ ENDP	; XChain<CSysObj>::get_head
_TEXT	ENDS
PUBLIC	?get_tail@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ ; XChain<CSysObj>::get_tail
; Function compile flags: /Ogty
;	COMDAT ?get_tail@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ
_TEXT	SEGMENT
?get_tail@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ PROC NEAR ; XChain<CSysObj>::get_tail, COMDAT
; _this$ = ecx

; 848  : 	inline TYPE *get_tail(void){return tail;}

	mov	eax, DWORD PTR [ecx+4]
	ret	0
?get_tail@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ ENDP	; XChain<CSysObj>::get_tail
_TEXT	ENDS
PUBLIC	??1?$XChain@VCSysObj@@@@QAE@XZ			; XChain<CSysObj>::~XChain<CSysObj>
PUBLIC	??_7CSysObj@@6B@				; CSysObj::`vftable'
EXTRN	__purecall:NEAR
EXTRN	?_global@@3PAVXGlobal@@A:DWORD			; _global
EXTRN	?unreg_global_object@XGlobal@@QAEXPAVCSysObj@@@Z:NEAR ; XGlobal::unreg_global_object
;	COMDAT ??_7CSysObj@@6B@
; File C:\duke4\xcore\xcore.h
CONST	SEGMENT
??_7CSysObj@@6B@ DD FLAT:__purecall			; CSysObj::`vftable'
; Function compile flags: /Ogty
; File C:\duke4\xcore\xclass.h
CONST	ENDS
;	COMDAT ??1?$XChain@VCSysObj@@@@QAE@XZ
_TEXT	SEGMENT
??1?$XChain@VCSysObj@@@@QAE@XZ PROC NEAR		; XChain<CSysObj>::~XChain<CSysObj>, COMDAT
; _this$ = ecx

; 853  : {

	push	esi
	mov	esi, ecx

; 854  : 	if (xchain_state.owned)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	jns	SHORT $L58108

; 855  : 	{
; 856  : 		while(head)

	cmp	DWORD PTR [esi], 0
	je	SHORT $L58108
	push	ebx
	push	edi
$L57501:

; 857  : 		{
; 858  : 			TYPE *tmp=(TYPE *)head->next;

	mov	eax, DWORD PTR [esi]

; 859  : 			delete head;

	mov	edi, eax
	mov	ebx, DWORD PTR [eax+4]
	test	edi, edi
	je	SHORT $L58089
	mov	DWORD PTR [edi], OFFSET FLAT:??_7CSysObj@@6B@ ; CSysObj::`vftable'
	mov	ecx, DWORD PTR ?_global@@3PAVXGlobal@@A	; _global
	push	edi
	call	?unreg_global_object@XGlobal@@QAEXPAVCSysObj@@@Z ; XGlobal::unreg_global_object
	mov	ecx, edi
	call	@xfree@4
$L58089:
	test	ebx, ebx

; 860  : 			head=tmp;

	mov	DWORD PTR [esi], ebx
	jne	SHORT $L57501
	pop	edi
	pop	ebx
$L58108:

; 861  : 		}
; 862  : 	}
; 863  : 	head=null;

	mov	DWORD PTR [esi], 0

; 864  : 	tail=null;

	mov	DWORD PTR [esi+4], 0
	pop	esi

; 865  : }

	ret	0
??1?$XChain@VCSysObj@@@@QAE@XZ ENDP			; XChain<CSysObj>::~XChain<CSysObj>
_TEXT	ENDS
PUBLIC	?lose_list@?$XChain@VCSysObj@@@@QAEXXZ		; XChain<CSysObj>::lose_list
; Function compile flags: /Ogty
;	COMDAT ?lose_list@?$XChain@VCSysObj@@@@QAEXXZ
_TEXT	SEGMENT
?lose_list@?$XChain@VCSysObj@@@@QAEXXZ PROC NEAR	; XChain<CSysObj>::lose_list, COMDAT
; _this$ = ecx

; 870  : 	head=null;tail=null;xchain_state.count=0;

	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [ecx], 0
	and	eax, -2147483648			; 80000000H
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], eax

; 871  : }

	ret	0
?lose_list@?$XChain@VCSysObj@@@@QAEXXZ ENDP		; XChain<CSysObj>::lose_list
_TEXT	ENDS
PUBLIC	?free_list@?$XChain@VCSysObj@@@@QAEXXZ		; XChain<CSysObj>::free_list
; Function compile flags: /Ogty
;	COMDAT ?free_list@?$XChain@VCSysObj@@@@QAEXXZ
_TEXT	SEGMENT
?free_list@?$XChain@VCSysObj@@@@QAEXXZ PROC NEAR	; XChain<CSysObj>::free_list, COMDAT
; _this$ = ecx

; 875  : {

	push	esi
	mov	esi, ecx

; 876  : 	if (xchain_state.owned)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	jns	SHORT $L58134

; 877  : 	{
; 878  : 		while(head)

	cmp	DWORD PTR [esi], 0
	je	SHORT $L58134
	push	ebx
	push	edi
$L57517:

; 879  : 		{
; 880  : 			TYPE *tmp=(TYPE *)head->next;

	mov	eax, DWORD PTR [esi]

; 881  : 			delete head;

	mov	edi, eax
	mov	ebx, DWORD PTR [eax+4]
	test	edi, edi
	je	SHORT $L58115
	mov	DWORD PTR [edi], OFFSET FLAT:??_7CSysObj@@6B@ ; CSysObj::`vftable'
	mov	ecx, DWORD PTR ?_global@@3PAVXGlobal@@A	; _global
	push	edi
	call	?unreg_global_object@XGlobal@@QAEXPAVCSysObj@@@Z ; XGlobal::unreg_global_object
	mov	ecx, edi
	call	@xfree@4
$L58115:
	test	ebx, ebx

; 882  : 			head=tmp;

	mov	DWORD PTR [esi], ebx
	jne	SHORT $L57517
	pop	edi
	pop	ebx
$L58134:

; 883  : 		}
; 884  : 	}
; 885  : 	head=null;tail=null;

	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+4], 0
	pop	esi

; 886  : }

	ret	0
?free_list@?$XChain@VCSysObj@@@@QAEXXZ ENDP		; XChain<CSysObj>::free_list
_TEXT	ENDS
PUBLIC	?add_head@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z ; XChain<CSysObj>::add_head
; Function compile flags: /Ogty
;	COMDAT ?add_head@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z
_TEXT	SEGMENT
_ptr$ = 8
?add_head@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z PROC NEAR ; XChain<CSysObj>::add_head, COMDAT
; _this$ = ecx

; 891  : 	ptr->next=head;

	mov	eax, DWORD PTR _ptr$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx

; 892  : 	ptr->prev=null;

	mov	DWORD PTR [eax+8], 0

; 893  : 	if (head)

	mov	edx, DWORD PTR [ecx]
	test	edx, edx
	je	SHORT $L57527

; 894  : 		head->prev=ptr;

	mov	DWORD PTR [edx+8], eax

; 897  : 	
; 898  : 	head=ptr;

	mov	DWORD PTR [ecx], eax

; 899  : 
; 900  : 	return head;
; 901  : }

	ret	4
$L57527:

; 895  : 	else
; 896  : 		tail=ptr;

	mov	DWORD PTR [ecx+4], eax

; 897  : 	
; 898  : 	head=ptr;

	mov	DWORD PTR [ecx], eax

; 899  : 
; 900  : 	return head;
; 901  : }

	ret	4
?add_head@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z ENDP ; XChain<CSysObj>::add_head
_TEXT	ENDS
PUBLIC	?add_tail@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z ; XChain<CSysObj>::add_tail
; Function compile flags: /Ogty
;	COMDAT ?add_tail@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z
_TEXT	SEGMENT
_ptr$ = 8
?add_tail@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z PROC NEAR ; XChain<CSysObj>::add_tail, COMDAT
; _this$ = ecx

; 906  : 	ptr->prev=tail;

	mov	eax, DWORD PTR _ptr$[esp-4]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+8], edx

; 907  : 	ptr->next=null;

	mov	DWORD PTR [eax+4], 0

; 908  : 	if (tail)

	mov	edx, DWORD PTR [ecx+4]
	test	edx, edx
	je	SHORT $L57533

; 909  : 		tail->next=ptr;

	mov	DWORD PTR [edx+4], eax

; 912  : 	
; 913  : 	tail=ptr;

	mov	DWORD PTR [ecx+4], eax

; 914  : 
; 915  : 	return tail;
; 916  : }

	ret	4
$L57533:

; 910  : 	else
; 911  : 		head=ptr;

	mov	DWORD PTR [ecx], eax

; 912  : 	
; 913  : 	tail=ptr;

	mov	DWORD PTR [ecx+4], eax

; 914  : 
; 915  : 	return tail;
; 916  : }

	ret	4
?add_tail@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z ENDP ; XChain<CSysObj>::add_tail
_TEXT	ENDS
PUBLIC	?remove_head@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ ; XChain<CSysObj>::remove_head
; Function compile flags: /Ogty
;	COMDAT ?remove_head@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ
_TEXT	SEGMENT
?remove_head@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ PROC NEAR ; XChain<CSysObj>::remove_head, COMDAT
; _this$ = ecx

; 937  : 	if (!head)

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	jne	SHORT $L57539

; 947  : 
; 948  : 	return ret;
; 949  : }

	ret	0
$L57539:

; 938  : 		return null;
; 939  : 
; 940  : 	TYPE *ret=head;
; 941  : 
; 942  : 	head=head->next;

	mov	edx, DWORD PTR [eax+4]

; 943  : 	if (!head)

	test	edx, edx
	mov	DWORD PTR [ecx], edx
	jne	SHORT $L57541

; 944  : 		tail=null;

	mov	DWORD PTR [ecx+4], edx

; 947  : 
; 948  : 	return ret;
; 949  : }

	ret	0
$L57541:

; 945  : 	else
; 946  : 		head->prev=null;

	mov	DWORD PTR [edx+8], 0

; 947  : 
; 948  : 	return ret;
; 949  : }

	ret	0
?remove_head@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ ENDP ; XChain<CSysObj>::remove_head
_TEXT	ENDS
PUBLIC	?remove_tail@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ ; XChain<CSysObj>::remove_tail
; Function compile flags: /Ogty
;	COMDAT ?remove_tail@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ
_TEXT	SEGMENT
?remove_tail@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ PROC NEAR ; XChain<CSysObj>::remove_tail, COMDAT
; _this$ = ecx

; 954  : 	if (!tail)

	mov	eax, DWORD PTR [ecx+4]
	test	eax, eax
	jne	SHORT $L57547

; 964  : 
; 965  : 	return ret;
; 966  : }

	ret	0
$L57547:

; 955  : 		return null;
; 956  : 
; 957  : 	TYPE *ret=tail;
; 958  : 
; 959  : 	tail=tail->prev;

	mov	edx, DWORD PTR [eax+8]

; 960  : 	if (!tail)

	test	edx, edx
	mov	DWORD PTR [ecx+4], edx
	jne	SHORT $L57549

; 961  : 		head=null;

	mov	DWORD PTR [ecx], edx

; 964  : 
; 965  : 	return ret;
; 966  : }

	ret	0
$L57549:

; 962  : 	else
; 963  : 		tail->next=null;

	mov	DWORD PTR [edx+4], 0

; 964  : 
; 965  : 	return ret;
; 966  : }

	ret	0
?remove_tail@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ ENDP ; XChain<CSysObj>::remove_tail
_TEXT	ENDS
PUBLIC	?remove@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z ; XChain<CSysObj>::remove
; Function compile flags: /Ogty
;	COMDAT ?remove@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z
_TEXT	SEGMENT
_ptr$ = 8
?remove@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z PROC NEAR ; XChain<CSysObj>::remove, COMDAT
; _this$ = ecx

; 921  : 	if (ptr->prev)

	mov	eax, DWORD PTR _ptr$[esp-4]
	mov	edx, DWORD PTR [eax+8]
	test	edx, edx
	je	SHORT $L57555
	push	esi

; 922  : 		ptr->prev->next=ptr->next;

	mov	esi, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], esi
	pop	esi

; 923  : 	else

	jmp	SHORT $L57556
$L57555:

; 924  : 		head=ptr->next;

	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx], edx
$L57556:

; 925  : 
; 926  : 	if (ptr->next)

	mov	edx, DWORD PTR [eax+4]
	test	edx, edx
	je	SHORT $L57557

; 927  : 		ptr->next->prev=ptr->prev;

	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], ecx

; 930  : 
; 931  : 	return ptr;
; 932  : }

	ret	4
$L57557:

; 928  : 	else
; 929  : 		tail=ptr->prev;

	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+4], edx

; 930  : 
; 931  : 	return ptr;
; 932  : }

	ret	4
?remove@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z ENDP ; XChain<CSysObj>::remove
_TEXT	ENDS
PUBLIC	??_7XBufferReadInt@@6B@				; XBufferReadInt::`vftable'
PUBLIC	??_GXBufferReadInt@@UAEPAXI@Z			; XBufferReadInt::`scalar deleting destructor'
PUBLIC	??_EXBufferReadInt@@UAEPAXI@Z			; XBufferReadInt::`vector deleting destructor'
EXTRN	?read_direct@XBufferReadInt@@MAEKPAXKAAK@Z:NEAR	; XBufferReadInt::read_direct
;	COMDAT ??_7XBufferReadInt@@6B@
; File C:\duke4\xcore\xcore.h
CONST	SEGMENT
??_7XBufferReadInt@@6B@ DD FLAT:?read_direct@XBufferReadInt@@MAEKPAXKAAK@Z ; XBufferReadInt::`vftable'
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:??_EXBufferReadInt@@UAEPAXI@Z
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ??_GXBufferReadInt@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_GXBufferReadInt@@UAEPAXI@Z PROC NEAR			; XBufferReadInt::`scalar deleting destructor', COMDAT
; _this$ = ecx
	mov	al, BYTE PTR ___flags$[esp-4]
	push	esi
	mov	esi, ecx
	test	al, 1
	mov	DWORD PTR [esi], OFFSET FLAT:??_7XBufferReadInt@@6B@ ; XBufferReadInt::`vftable'
	je	SHORT $L58155
	call	@xfree@4
$L58155:
	mov	eax, esi
	pop	esi
	ret	4
??_GXBufferReadInt@@UAEPAXI@Z ENDP			; XBufferReadInt::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??1XBufferReadInt@@UAE@XZ			; XBufferReadInt::~XBufferReadInt
EXTRN	??_M@YGXPAXIHP6EX0@Z@Z:NEAR			; `eh vector destructor iterator'
; Function compile flags: /Ogty
;	COMDAT ??_EXBufferReadInt@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_EXBufferReadInt@@UAEPAXI@Z PROC NEAR			; XBufferReadInt::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebx
	mov	bl, BYTE PTR ___flags$[esp]
	push	esi
	mov	esi, ecx
	test	bl, 2
	je	SHORT $L56059
	mov	eax, DWORD PTR [esi-4]
	push	edi
	lea	edi, DWORD PTR [esi-4]
	push	OFFSET FLAT:??1XBufferReadInt@@UAE@XZ	; XBufferReadInt::~XBufferReadInt
	push	eax
	push	8
	push	esi
	call	??_M@YGXPAXIHP6EX0@Z@Z			; `eh vector destructor iterator'
	test	bl, 1
	je	SHORT $L58160
	mov	ecx, edi
	call	@xfree@4
$L58160:
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	ret	4
$L56059:
	test	bl, 1
	mov	DWORD PTR [esi], OFFSET FLAT:??_7XBufferReadInt@@6B@ ; XBufferReadInt::`vftable'
	je	SHORT $L58166
	mov	ecx, esi
	call	@xfree@4
$L58166:
	mov	eax, esi
	pop	esi
	pop	ebx
	ret	4
??_EXBufferReadInt@@UAEPAXI@Z ENDP			; XBufferReadInt::`vector deleting destructor'
; Function compile flags: /Ogty
; File C:\duke4\xcore\xstream.h
_TEXT	ENDS
;	COMDAT ??1XBufferReadInt@@UAE@XZ
_TEXT	SEGMENT
??1XBufferReadInt@@UAE@XZ PROC NEAR			; XBufferReadInt::~XBufferReadInt, COMDAT
; _this$ = ecx

; 37   : 	virtual ~XBufferReadInt(void){}

	mov	DWORD PTR [ecx], OFFSET FLAT:??_7XBufferReadInt@@6B@ ; XBufferReadInt::`vftable'
	ret	0
??1XBufferReadInt@@UAE@XZ ENDP				; XBufferReadInt::~XBufferReadInt
_TEXT	ENDS
PUBLIC	??_7XBufferWriteInt@@6B@			; XBufferWriteInt::`vftable'
PUBLIC	??_GXBufferWriteInt@@UAEPAXI@Z			; XBufferWriteInt::`scalar deleting destructor'
PUBLIC	??_EXBufferWriteInt@@UAEPAXI@Z			; XBufferWriteInt::`vector deleting destructor'
EXTRN	?write_direct@XBufferWriteInt@@MAEKPBXKAAK@Z:NEAR ; XBufferWriteInt::write_direct
;	COMDAT ??_7XBufferWriteInt@@6B@
; File C:\duke4\xcore\xcore.h
CONST	SEGMENT
??_7XBufferWriteInt@@6B@ DD FLAT:?write_direct@XBufferWriteInt@@MAEKPBXKAAK@Z ; XBufferWriteInt::`vftable'
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:??_EXBufferWriteInt@@UAEPAXI@Z
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ??_GXBufferWriteInt@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_GXBufferWriteInt@@UAEPAXI@Z PROC NEAR		; XBufferWriteInt::`scalar deleting destructor', COMDAT
; _this$ = ecx
	mov	al, BYTE PTR ___flags$[esp-4]
	push	esi
	mov	esi, ecx
	test	al, 1
	mov	DWORD PTR [esi], OFFSET FLAT:??_7XBufferWriteInt@@6B@ ; XBufferWriteInt::`vftable'
	je	SHORT $L58177
	call	@xfree@4
$L58177:
	mov	eax, esi
	pop	esi
	ret	4
??_GXBufferWriteInt@@UAEPAXI@Z ENDP			; XBufferWriteInt::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??1XBufferWriteInt@@UAE@XZ			; XBufferWriteInt::~XBufferWriteInt
; Function compile flags: /Ogty
;	COMDAT ??_EXBufferWriteInt@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_EXBufferWriteInt@@UAEPAXI@Z PROC NEAR		; XBufferWriteInt::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebx
	mov	bl, BYTE PTR ___flags$[esp]
	push	esi
	mov	esi, ecx
	test	bl, 2
	je	SHORT $L56111
	mov	eax, DWORD PTR [esi-4]
	push	edi
	lea	edi, DWORD PTR [esi-4]
	push	OFFSET FLAT:??1XBufferWriteInt@@UAE@XZ	; XBufferWriteInt::~XBufferWriteInt
	push	eax
	push	8
	push	esi
	call	??_M@YGXPAXIHP6EX0@Z@Z			; `eh vector destructor iterator'
	test	bl, 1
	je	SHORT $L58182
	mov	ecx, edi
	call	@xfree@4
$L58182:
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	ret	4
$L56111:
	test	bl, 1
	mov	DWORD PTR [esi], OFFSET FLAT:??_7XBufferWriteInt@@6B@ ; XBufferWriteInt::`vftable'
	je	SHORT $L58188
	mov	ecx, esi
	call	@xfree@4
$L58188:
	mov	eax, esi
	pop	esi
	pop	ebx
	ret	4
??_EXBufferWriteInt@@UAEPAXI@Z ENDP			; XBufferWriteInt::`vector deleting destructor'
; Function compile flags: /Ogty
; File C:\duke4\xcore\xstream.h
_TEXT	ENDS
;	COMDAT ??1XBufferWriteInt@@UAE@XZ
_TEXT	SEGMENT
??1XBufferWriteInt@@UAE@XZ PROC NEAR			; XBufferWriteInt::~XBufferWriteInt, COMDAT
; _this$ = ecx

; 56   : 	virtual ~XBufferWriteInt(void){}

	mov	DWORD PTR [ecx], OFFSET FLAT:??_7XBufferWriteInt@@6B@ ; XBufferWriteInt::`vftable'
	ret	0
??1XBufferWriteInt@@UAE@XZ ENDP				; XBufferWriteInt::~XBufferWriteInt
_TEXT	ENDS
PUBLIC	??1XStreamRdDirect@@UAE@XZ			; XStreamRdDirect::~XStreamRdDirect
PUBLIC	??_GXStreamRdDirect@@UAEPAXI@Z			; XStreamRdDirect::`scalar deleting destructor'
; Function compile flags: /Ogty
;	COMDAT ??_GXStreamRdDirect@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_GXStreamRdDirect@@UAEPAXI@Z PROC NEAR		; XStreamRdDirect::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1XStreamRdDirect@@UAE@XZ		; XStreamRdDirect::~XStreamRdDirect
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $L58196
	mov	ecx, esi
	call	@xfree@4
$L58196:
	mov	eax, esi
	pop	esi
	ret	4
??_GXStreamRdDirect@@UAEPAXI@Z ENDP			; XStreamRdDirect::`scalar deleting destructor'
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??1XStreamRdDirect@@UAE@XZ
_TEXT	SEGMENT
??1XStreamRdDirect@@UAE@XZ PROC NEAR			; XStreamRdDirect::~XStreamRdDirect, COMDAT
; _this$ = ecx

; 71   : 	~XStreamRdDirect(void){}

	mov	DWORD PTR [ecx], OFFSET FLAT:??_7XBufferReadInt@@6B@ ; XBufferReadInt::`vftable'
	ret	0
??1XStreamRdDirect@@UAE@XZ ENDP				; XStreamRdDirect::~XStreamRdDirect
_TEXT	ENDS
PUBLIC	??_EXStreamRdDirect@@UAEPAXI@Z			; XStreamRdDirect::`vector deleting destructor'
; Function compile flags: /Ogty
;	COMDAT ??_EXStreamRdDirect@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_EXStreamRdDirect@@UAEPAXI@Z PROC NEAR		; XStreamRdDirect::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebx
	mov	bl, BYTE PTR ___flags$[esp]
	push	esi
	mov	esi, ecx
	test	bl, 2
	je	SHORT $L56163
	mov	eax, DWORD PTR [esi-4]
	push	edi
	lea	edi, DWORD PTR [esi-4]
	push	OFFSET FLAT:??1XStreamRdDirect@@UAE@XZ	; XStreamRdDirect::~XStreamRdDirect
	push	eax
	push	8
	push	esi
	call	??_M@YGXPAXIHP6EX0@Z@Z			; `eh vector destructor iterator'
	test	bl, 1
	je	SHORT $L58207
	mov	ecx, edi
	call	@xfree@4
$L58207:
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	ret	4
$L56163:
	mov	ecx, esi
	call	??1XStreamRdDirect@@UAE@XZ		; XStreamRdDirect::~XStreamRdDirect
	test	bl, 1
	je	SHORT $L58209
	mov	ecx, esi
	call	@xfree@4
$L58209:
	mov	eax, esi
	pop	esi
	pop	ebx
	ret	4
??_EXStreamRdDirect@@UAEPAXI@Z ENDP			; XStreamRdDirect::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??1XStreamWrDirect@@UAE@XZ			; XStreamWrDirect::~XStreamWrDirect
PUBLIC	??_GXStreamWrDirect@@UAEPAXI@Z			; XStreamWrDirect::`scalar deleting destructor'
; Function compile flags: /Ogty
;	COMDAT ??_GXStreamWrDirect@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_GXStreamWrDirect@@UAEPAXI@Z PROC NEAR		; XStreamWrDirect::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1XStreamWrDirect@@UAE@XZ		; XStreamWrDirect::~XStreamWrDirect
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $L58216
	mov	ecx, esi
	call	@xfree@4
$L58216:
	mov	eax, esi
	pop	esi
	ret	4
??_GXStreamWrDirect@@UAEPAXI@Z ENDP			; XStreamWrDirect::`scalar deleting destructor'
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??1XStreamWrDirect@@UAE@XZ
_TEXT	SEGMENT
??1XStreamWrDirect@@UAE@XZ PROC NEAR			; XStreamWrDirect::~XStreamWrDirect, COMDAT
; _this$ = ecx

; 88   : 	~XStreamWrDirect(void){}

	mov	DWORD PTR [ecx], OFFSET FLAT:??_7XBufferWriteInt@@6B@ ; XBufferWriteInt::`vftable'
	ret	0
??1XStreamWrDirect@@UAE@XZ ENDP				; XStreamWrDirect::~XStreamWrDirect
_TEXT	ENDS
PUBLIC	??_EXStreamWrDirect@@UAEPAXI@Z			; XStreamWrDirect::`vector deleting destructor'
; Function compile flags: /Ogty
;	COMDAT ??_EXStreamWrDirect@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_EXStreamWrDirect@@UAEPAXI@Z PROC NEAR		; XStreamWrDirect::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebx
	mov	bl, BYTE PTR ___flags$[esp]
	push	esi
	mov	esi, ecx
	test	bl, 2
	je	SHORT $L56219
	mov	eax, DWORD PTR [esi-4]
	push	edi
	lea	edi, DWORD PTR [esi-4]
	push	OFFSET FLAT:??1XStreamWrDirect@@UAE@XZ	; XStreamWrDirect::~XStreamWrDirect
	push	eax
	push	8
	push	esi
	call	??_M@YGXPAXIHP6EX0@Z@Z			; `eh vector destructor iterator'
	test	bl, 1
	je	SHORT $L58227
	mov	ecx, edi
	call	@xfree@4
$L58227:
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	ret	4
$L56219:
	mov	ecx, esi
	call	??1XStreamWrDirect@@UAE@XZ		; XStreamWrDirect::~XStreamWrDirect
	test	bl, 1
	je	SHORT $L58230
	mov	ecx, esi
	call	@xfree@4
$L58230:
	mov	eax, esi
	pop	esi
	pop	ebx
	ret	4
??_EXStreamWrDirect@@UAEPAXI@Z ENDP			; XStreamWrDirect::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??1XMemRdBuffer@@UAE@XZ				; XMemRdBuffer::~XMemRdBuffer
PUBLIC	??_GXMemRdBuffer@@UAEPAXI@Z			; XMemRdBuffer::`scalar deleting destructor'
; Function compile flags: /Ogty
;	COMDAT ??_GXMemRdBuffer@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_GXMemRdBuffer@@UAEPAXI@Z PROC NEAR			; XMemRdBuffer::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1XMemRdBuffer@@UAE@XZ			; XMemRdBuffer::~XMemRdBuffer
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $L58236
	mov	ecx, esi
	call	@xfree@4
$L58236:
	mov	eax, esi
	pop	esi
	ret	4
??_GXMemRdBuffer@@UAEPAXI@Z ENDP			; XMemRdBuffer::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_7XMemRdBuffer@@6B@				; XMemRdBuffer::`vftable'
PUBLIC	??_EXMemRdBuffer@@UAEPAXI@Z			; XMemRdBuffer::`vector deleting destructor'
EXTRN	?read@XMemRdBuffer@@UAEKPAXKAAK1@Z:NEAR		; XMemRdBuffer::read
EXTRN	?seek@XMemRdBuffer@@UAEKJ@Z:NEAR		; XMemRdBuffer::seek
;	COMDAT ??_7XMemRdBuffer@@6B@
CONST	SEGMENT
??_7XMemRdBuffer@@6B@ DD FLAT:?read_direct@XBufferReadInt@@MAEKPAXKAAK@Z ; XMemRdBuffer::`vftable'
	DD	FLAT:?read@XMemRdBuffer@@UAEKPAXKAAK1@Z
	DD	FLAT:?seek@XMemRdBuffer@@UAEKJ@Z
	DD	FLAT:??_EXMemRdBuffer@@UAEPAXI@Z
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ??1XMemRdBuffer@@UAE@XZ
_TEXT	SEGMENT
??1XMemRdBuffer@@UAE@XZ PROC NEAR			; XMemRdBuffer::~XMemRdBuffer, COMDAT
; _this$ = ecx

; 109  : 	~XMemRdBuffer(void){}

	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET FLAT:??_7XMemRdBuffer@@6B@ ; XMemRdBuffer::`vftable'
	mov	ecx, DWORD PTR [esi+8]
	call	@xfree@4
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi], OFFSET FLAT:??_7XBufferReadInt@@6B@ ; XBufferReadInt::`vftable'
	pop	esi
	ret	0
??1XMemRdBuffer@@UAE@XZ ENDP				; XMemRdBuffer::~XMemRdBuffer
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??_EXMemRdBuffer@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_EXMemRdBuffer@@UAEPAXI@Z PROC NEAR			; XMemRdBuffer::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebx
	mov	bl, BYTE PTR ___flags$[esp]
	push	esi
	mov	esi, ecx
	test	bl, 2
	je	SHORT $L56272
	mov	eax, DWORD PTR [esi-4]
	push	edi
	lea	edi, DWORD PTR [esi-4]
	push	OFFSET FLAT:??1XMemRdBuffer@@UAE@XZ	; XMemRdBuffer::~XMemRdBuffer
	push	eax
	push	24					; 00000018H
	push	esi
	call	??_M@YGXPAXIHP6EX0@Z@Z			; `eh vector destructor iterator'
	test	bl, 1
	je	SHORT $L58252
	mov	ecx, edi
	call	@xfree@4
$L58252:
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	ret	4
$L56272:
	mov	ecx, esi
	call	??1XMemRdBuffer@@UAE@XZ			; XMemRdBuffer::~XMemRdBuffer
	test	bl, 1
	je	SHORT $L58255
	mov	ecx, esi
	call	@xfree@4
$L58255:
	mov	eax, esi
	pop	esi
	pop	ebx
	ret	4
??_EXMemRdBuffer@@UAEPAXI@Z ENDP			; XMemRdBuffer::`vector deleting destructor'
_TEXT	ENDS
END
