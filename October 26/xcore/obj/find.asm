; Listing generated by Microsoft (R) Optimizing Compiler Version 12.00.8943.0 

	TITLE	C:\duke4\xcore\find.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0BF@MBIJ@Cannot?5init?5CPrintfT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
drectve	SEGMENT DWORD USE32 PUBLIC ''
drectve	ENDS
;	COMDAT ??0FindHandle@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1FindHandle@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4FindHandle@@QAEAAV0@PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BFindHandle@@QAEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GXFindInfo@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1XFindInfo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0XFindInfo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GXFindLevel@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$XChain@VXStatistic@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?get_head@?$XList@VXStatistic@@@@QAEPAVXStatistic@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$XChain@VCSysObj@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$XChain@VCSysObj@@@@QAE@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?get_next@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?get_prev@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?get_head@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?get_tail@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?get_head@?$XList@VXFindLevel@@@@QAEPAVXFindLevel@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$XChain@VXStatistic@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?free_list@?$XChain@VXStatistic@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$XList@VXStatistic@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$XList@VXStatistic@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?free_list@?$XList@VXStatistic@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?add_head@?$XList@VXStatistic@@@@QAEPAU_XPos@@PAVXStatistic@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?remove_head@?$XList@VXStatistic@@@@QAEPAVXStatistic@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$XChain@VCSysObj@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lose_list@?$XChain@VCSysObj@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?free_list@?$XChain@VCSysObj@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?add_head@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?add_tail@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?remove_head@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?remove_tail@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?remove@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$XList@PAX@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$XRcBase@VCStrObj@@@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$XRcBase@VCStrObj@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$XRcBase@VCStrObj@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$XRcBase@VCStrObj@@@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$XRcPtr@VCPathObj@@@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$XRcPtr@VCPathObj@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$XRcPtr@VCPathObj@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$XRcPtr@VCPathObj@@@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$XList@VXFindLevel@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$XList@VXFindLevel@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?add_head@?$XList@VXFindLevel@@@@QAEPAU_XPos@@PAVXFindLevel@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?remove_head@?$XList@VXFindLevel@@@@QAEPAVXFindLevel@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCSysObj@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?new_node@?$XList@VXStatistic@@@@IAEPAUXNode@1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?free_nodes@?$XList@VXStatistic@@@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?free_nodes@?$XList@PAX@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?new_node@?$XList@VXFindLevel@@@@IAEPAUXNode@1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?free_nodes@?$XList@VXFindLevel@@@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddRef@?$XRcBase@VCStrObj@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DelRef@?$XRcBase@VCStrObj@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddRef@?$XRcPtr@VCPathObj@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DelRef@?$XRcPtr@VCPathObj@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCStrObj@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCPathObj@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GXStreamWrDirect@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1XStreamWrDirect@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7XStreamWrDirect@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??1XBufferWriteInt@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7XBufferWriteInt@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??3XStreamWrDirect@@SAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_EXStreamWrDirect@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?flush@XStreamWrDirect@@UAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?seek@XStreamWrDirect@@UAEKJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GXStreamRdDirect@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1XStreamRdDirect@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7XStreamRdDirect@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??1XBufferReadInt@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7XBufferReadInt@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??3XStreamRdDirect@@SAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_EXStreamRdDirect@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?seek@XStreamRdDirect@@UAEKJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?base_init@XFile@@EAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GXBufferWriteInt@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_EXBufferWriteInt@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GXBufferReadInt@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_EXBufferReadInt@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pos_wr@CBaseStream@@UAEXKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pos_rd@CBaseStream@@UAEXKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?put@CBaseStream@@UAEKD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ioctl_write@CBaseStream@@UAEKKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ioctl_read@CBaseStream@@UAEKKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?seek_int@CBaseStream@@MAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GXMemRdBuffer@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1XMemRdBuffer@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7XMemRdBuffer@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??3XMemRdBuffer@@SAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_EXMemRdBuffer@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3CStrObj@@SAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CStrObj@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CSysObj@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CSysObj@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??0XListState@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3XStatistic@@SAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0XChainState@@QAE@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0XChainState@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4StrGrow@@QAEAAV0@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?reset@StrGrow@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?reset@FindInfoFlags@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?get_full_path@XFindInfo@@QAEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BStrGrow@@QAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1XFindLevel@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?get_filename@XFindInfo@@QAEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?is_dir@XFindInfo@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?get_path@XFindLevel@@QAEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?has_handle@XFindLevel@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FindInfoFlags@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0StrGrow@@QAE@KK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0MemGrow@@QAE@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1MemGrow@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BCStr@@QBEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?reset@FindState@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?release@autochar@@QAEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Bautochar@@QAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4autochar@@QAEAAV0@PAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0autochar@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1StrGrow@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3@YAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1autochar@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
FLAT	GROUP _DATA, CONST, _BSS, drectve
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

drectve	SEGMENT
$SG56785 DB	'-INCLUDE:___@@_PchSym_@00@UwfpvEUcxlivUlyqUhgwxlivOlyq@', 00H
drectve	ENDS
PUBLIC	?init@restore_path@@QAEXXZ			; restore_path::init
EXTRN	__imp__GetCurrentDirectoryA@8:NEAR
EXTRN	@xmalloc@4:NEAR
; Function compile flags: /Ogty
; File C:\duke4\xcore\find.cpp
_TEXT	SEGMENT
?init@restore_path@@QAEXXZ PROC NEAR			; restore_path::init
; _this$ = ecx

; 32   : {

	push	ebx

; 33   : 	U32 size=GetCurrentDirectory(0,null);

	mov	ebx, DWORD PTR __imp__GetCurrentDirectoryA@8
	push	esi
	push	edi
	push	0
	push	0
	mov	edi, ecx
	call	ebx
	mov	esi, eax

; 34   : 
; 35   : 	start_path=(char *)xmalloc(size);

	mov	ecx, esi
	call	@xmalloc@4

; 36   : 	GetCurrentDirectory(size,start_path);

	push	eax
	push	esi
	mov	DWORD PTR [edi], eax
	call	ebx
	pop	edi
	pop	esi
	pop	ebx

; 37   : }

	ret	0
?init@restore_path@@QAEXXZ ENDP				; restore_path::init
_TEXT	ENDS
PUBLIC	??1restore_path@@QAE@XZ				; restore_path::~restore_path
EXTRN	@xxx_throw@4:NEAR
EXTRN	__imp__SetCurrentDirectoryA@4:NEAR
_DATA	SEGMENT
$SG56938 DB	'Unable to restore path', 00H
; Function compile flags: /Ogty
_DATA	ENDS
_TEXT	SEGMENT
??1restore_path@@QAE@XZ PROC NEAR			; restore_path::~restore_path
; _this$ = ecx

; 41   : 	if (start_path)

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $L56937

; 42   : 	{
; 43   : 		if (!SetCurrentDirectory(start_path))

	push	eax
	call	DWORD PTR __imp__SetCurrentDirectoryA@4
	test	eax, eax
	jne	SHORT $L56937

; 44   : 			xxx_throw("Unable to restore path");

	mov	ecx, OFFSET FLAT:$SG56938
	jmp	@xxx_throw@4
$L56937:

; 45   : 	}
; 46   : }

	ret	0
??1restore_path@@QAE@XZ ENDP				; restore_path::~restore_path
_TEXT	ENDS
PUBLIC	??1XFindFile@@QAE@XZ				; XFindFile::~XFindFile
EXTRN	@xlist_free_nodes@4:NEAR
EXTRN	@xfree@4:NEAR
; Function compile flags: /Ogty
_TEXT	SEGMENT
??1XFindFile@@QAE@XZ PROC NEAR				; XFindFile::~XFindFile
; _this$ = ecx

; 49   : {

	push	ebx
	mov	ebx, ecx
	push	ebp
	push	esi

; 50   : 	delete info;

	mov	esi, DWORD PTR [ebx+36]
	xor	ebp, ebp
	cmp	esi, ebp
	push	edi
	je	SHORT $L57700
	mov	ecx, DWORD PTR [esi+20]
	call	@xfree@4
	mov	ecx, DWORD PTR [esi]
	call	@xfree@4
	mov	ecx, esi
	call	@xfree@4
$L57700:

; 51   : 	info=null;
; 52   : 	delete private_info;

	mov	esi, DWORD PTR [ebx+40]
	mov	DWORD PTR [ebx+36], ebp
	cmp	esi, ebp
	je	SHORT $L57704
	mov	ecx, DWORD PTR [esi+20]
	call	@xfree@4
	mov	ecx, DWORD PTR [esi]
	call	@xfree@4
	mov	ecx, esi
	call	@xfree@4
$L57704:

; 53   : 	private_info=null;
; 54   : }

	lea	edi, DWORD PTR [ebx+12]
	mov	DWORD PTR [ebx+40], ebp
	test	BYTE PTR [edi+19], 1
	je	SHORT $L57855
	cmp	DWORD PTR [edi], ebp
	je	SHORT $L57855
$L57854:
	mov	eax, DWORD PTR [edi]
	mov	esi, DWORD PTR [eax+8]
	cmp	esi, ebp
	je	SHORT $L57859
	mov	ecx, DWORD PTR [esi+8]
	call	@xfree@4
	mov	DWORD PTR [esi+8], ebp
	mov	ecx, DWORD PTR [esi+4]
	call	@xfree@4
	mov	ecx, esi
	mov	DWORD PTR [esi+4], ebp
	call	@xfree@4
$L57859:
	mov	ecx, DWORD PTR [edi]
	mov	eax, DWORD PTR [ecx]
	cmp	eax, ebp
	mov	DWORD PTR [edi], eax
	jne	SHORT $L57854
$L57855:
	mov	ecx, edi
	call	@xlist_free_nodes@4
	mov	ecx, DWORD PTR [ebx+8]
	call	@xfree@4
	mov	DWORD PTR [ebx+8], ebp
	mov	ecx, DWORD PTR [ebx+4]
	call	@xfree@4
	mov	DWORD PTR [ebx+4], ebp
	mov	ecx, DWORD PTR [ebx]
	call	@xfree@4
	pop	edi
	mov	DWORD PTR [ebx], ebp
	pop	esi
	pop	ebp
	pop	ebx
	ret	0
??1XFindFile@@QAE@XZ ENDP				; XFindFile::~XFindFile
_TEXT	ENDS
PUBLIC	?set_current_dir@XFindFile@@IAEPBDPBDK@Z	; XFindFile::set_current_dir
EXTRN	@fstrcpy@8:NEAR
_DATA	SEGMENT
	ORG $+1
$SG56965 DB	'XFindFile::set_current_dir: invalid_params', 00H
	ORG $+1
$SG56968 DB	'XFindFile::set_current_dir: path variable is bad', 00H
; Function compile flags: /Ogty
_DATA	ENDS
_TEXT	SEGMENT
_path$ = 8
_len$ = 12
?set_current_dir@XFindFile@@IAEPBDPBDK@Z PROC NEAR	; XFindFile::set_current_dir
; _this$ = ecx

; 57   : {

	push	ebx

; 58   : 	autochar new_path;
; 59   : 
; 60   : 	U32 size=GetCurrentDirectory(0,null);

	mov	ebx, DWORD PTR __imp__GetCurrentDirectoryA@8
	push	esi
	push	edi
	push	0
	push	0
	call	ebx

; 61   : 	if (len<3)

	mov	edi, DWORD PTR _len$[esp+8]
	mov	esi, eax
	cmp	edi, 3
	jae	SHORT $L56964

; 62   : 	{
; 63   : 		/* just set current directory to working path */
; 64   : 		if (len==2)

	cmp	edi, 2
	jne	SHORT $L56961

; 65   : 		{
; 66   : 			new_path=(char *)xmalloc(size);

	mov	ecx, esi
	call	@xmalloc@4
	mov	edi, eax

; 67   : 			GetCurrentDirectory(size,new_path);

	push	edi
	push	esi
	call	ebx

; 68   : 			return new_path;

	mov	ecx, edi

; 82   : 	new_path[size]=OS_SLASH;
; 83   : 	fstrcpy(new_path+size+1,path);
; 84   : 
; 85   : 	return new_path.release();

	call	@xfree@4
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 86   : }

	ret	8
$L56961:

; 69   : 		}
; 70   : 		else
; 71   : 			xxx_throw("XFindFile::set_current_dir: invalid_params");

	mov	ecx, OFFSET FLAT:$SG56965
	call	@xxx_throw@4
$L56964:

; 72   : 	}
; 73   : 	/* more than enough */
; 74   : 	new_path=(char *)xmalloc(size+len);

	lea	ecx, DWORD PTR [esi+edi]
	call	@xmalloc@4
	mov	edi, eax

; 75   : 	GetCurrentDirectory(size,new_path);

	push	edi
	push	esi
	call	ebx

; 76   : 
; 77   : 	/* tack on path after .\ to end */
; 78   : 	if ((path[0]!='.') && (path[1]!=OS_SLASH))

	mov	ebx, DWORD PTR _path$[esp+8]
	cmp	BYTE PTR [ebx], 46			; 0000002eH
	je	SHORT $L56967
	cmp	BYTE PTR [ebx+1], 92			; 0000005cH
	je	SHORT $L56967

; 79   : 		xxx_throw("XFindFile::set_current_dir: path variable is bad");

	mov	ecx, OFFSET FLAT:$SG56968
	call	@xxx_throw@4
$L56967:

; 80   : 	
; 81   : 	path+=2;

	lea	edx, DWORD PTR [ebx+2]

; 82   : 	new_path[size]=OS_SLASH;
; 83   : 	fstrcpy(new_path+size+1,path);
; 84   : 
; 85   : 	return new_path.release();

	lea	ecx, DWORD PTR [esi+edi+1]
	mov	BYTE PTR [esi+edi], 92			; 0000005cH
	call	@fstrcpy@8
	xor	ecx, ecx
	call	@xfree@4
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 86   : }

	ret	8
?set_current_dir@XFindFile@@IAEPBDPBDK@Z ENDP		; XFindFile::set_current_dir
_TEXT	ENDS
PUBLIC	?set_parent_dir@XFindFile@@IAEPBDPBDK@Z		; XFindFile::set_parent_dir
EXTRN	__imp__GetFullPathNameA@16:NEAR
_DATA	SEGMENT
	ORG $+3
$SG56978 DB	'..', 00H
	ORG $+1
$SG56984 DB	'XFindFile::set_parent_dir: invalid_params', 00H
	ORG $+2
$SG56986 DB	'..', 00H
	ORG $+1
$SG56988 DB	'XFindFile::set_parent_dir: path variable is bad', 00H
; Function compile flags: /Ogty
_DATA	ENDS
_TEXT	SEGMENT
_path$ = 8
_len$ = 12
_file_part$ = -4
?set_parent_dir@XFindFile@@IAEPBDPBDK@Z PROC NEAR	; XFindFile::set_parent_dir
; _this$ = ecx

; 89   : {

	push	ecx
	push	ebx

; 90   : 	autochar new_path;
; 91   : 
; 92   : 	char *file_part;
; 93   : 
; 94   : 	U32 size=GetFullPathName("..",0,null,&file_part);

	mov	ebx, DWORD PTR __imp__GetFullPathNameA@16
	push	esi
	lea	eax, DWORD PTR _file_part$[esp+12]
	push	edi
	push	eax
	push	0
	push	0
	push	OFFSET FLAT:$SG56978
	call	ebx

; 95   : 
; 96   : 	if (len<4)

	mov	edi, DWORD PTR _len$[esp+12]
	mov	esi, eax
	cmp	edi, 4
	jae	SHORT $L56983

; 97   : 	{
; 98   : 		/* just set current directory to working path */
; 99   : 		if (len==3)

	cmp	edi, 3
	jne	SHORT $L56980

; 100  : 		{
; 101  : 			new_path=(char *)xmalloc(size);

	mov	ecx, esi
	call	@xmalloc@4
	mov	edi, eax

; 102  : 			GetCurrentDirectory(size,new_path);

	push	edi
	push	esi
	call	DWORD PTR __imp__GetCurrentDirectoryA@8

; 103  : 			return new_path;

	mov	ecx, edi

; 117  : 	new_path[size]=OS_SLASH;
; 118  : 	fstrcpy(new_path+size+1,path);
; 119  : 
; 120  : 	return new_path.release();

	call	@xfree@4
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 121  : }

	pop	ecx
	ret	8
$L56980:

; 104  : 		}
; 105  : 		else
; 106  : 			xxx_throw("XFindFile::set_parent_dir: invalid_params");

	mov	ecx, OFFSET FLAT:$SG56984
	call	@xxx_throw@4
$L56983:

; 107  : 	}
; 108  : 	/* more than enough */
; 109  : 	new_path=(char *)xmalloc(size+len);

	lea	ecx, DWORD PTR [esi+edi]
	call	@xmalloc@4

; 110  : 	GetFullPathName("..",size,new_path,&file_part);

	lea	ecx, DWORD PTR _file_part$[esp+16]
	mov	edi, eax
	push	ecx
	push	edi
	push	esi
	push	OFFSET FLAT:$SG56986
	call	ebx

; 111  : 
; 112  : 	/* tack on path after .\ to end */
; 113  : 	if ((path[0]!='.') && (path[1]!='.') && (path[2]!=OS_SLASH))

	mov	ebx, DWORD PTR _path$[esp+12]
	cmp	BYTE PTR [ebx], 46			; 0000002eH
	je	SHORT $L56987
	cmp	BYTE PTR [ebx+1], 46			; 0000002eH
	je	SHORT $L56987
	cmp	BYTE PTR [ebx+2], 92			; 0000005cH
	je	SHORT $L56987

; 114  : 		xxx_throw("XFindFile::set_parent_dir: path variable is bad");

	mov	ecx, OFFSET FLAT:$SG56988
	call	@xxx_throw@4
$L56987:

; 115  : 	
; 116  : 	path+=3;

	lea	edx, DWORD PTR [ebx+3]

; 117  : 	new_path[size]=OS_SLASH;
; 118  : 	fstrcpy(new_path+size+1,path);
; 119  : 
; 120  : 	return new_path.release();

	lea	ecx, DWORD PTR [esi+edi+1]
	mov	BYTE PTR [esi+edi], 92			; 0000005cH
	call	@fstrcpy@8
	xor	ecx, ecx
	call	@xfree@4
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 121  : }

	pop	ecx
	ret	8
?set_parent_dir@XFindFile@@IAEPBDPBDK@Z ENDP		; XFindFile::set_parent_dir
_TEXT	ENDS
PUBLIC	?set_state@XFindFile@@IAEXK@Z			; XFindFile::set_state
; Function compile flags: /Ogty
_TEXT	SEGMENT
_flags$ = 8
?set_state@XFindFile@@IAEXK@Z PROC NEAR			; XFindFile::set_state
; _this$ = ecx

; 124  : {

	push	esi
	mov	esi, ecx

; 125  : 	/* reset search state */
; 126  : 	state.reset();
; 127  : 	/* delete ptrs */
; 128  : 	if (base_path)

	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [esi+44], 0
	test	ecx, ecx
	je	SHORT $L57986

; 129  : 		delete base_path;

	call	@xfree@4
$L57986:

; 130  : 	if (match_str)

	mov	ecx, DWORD PTR [esi+4]
	test	ecx, ecx
	je	SHORT $L57996

; 131  : 		delete match_str;

	call	@xfree@4
$L57996:

; 132  : 	if (search_str)

	mov	ecx, DWORD PTR [esi+8]
	test	ecx, ecx
	je	SHORT $L58006

; 133  : 		delete search_str;

	call	@xfree@4
$L58006:

; 134  : 
; 135  : 	/* set flags */
; 136  : 	if (flags & FIND_RECURSIVE)

	mov	al, BYTE PTR _flags$[esp]
	test	al, 1
	je	SHORT $L57000

; 137  : 	{
; 138  : 		state.is_recursive=TRUE;
; 139  : 		state.search_extra=TRUE;

	or	DWORD PTR [esi+44], 6
$L57000:

; 140  : 	}
; 141  : 	if (flags & FIND_CASE_SENSITIVE)

	test	al, 8
	je	SHORT $L57001

; 142  : 		state.case_sensitive=TRUE;

	mov	ecx, DWORD PTR [esi+44]
	or	ch, 1
	mov	DWORD PTR [esi+44], ecx
$L57001:

; 143  : 	if (flags & FIND_WILD_ACROSS_SLASH)

	test	al, 16					; 00000010H
	je	SHORT $L57002

; 144  : 		state.wild_cross_slash=TRUE;

	mov	ecx, DWORD PTR [esi+44]
	or	ch, 2
	mov	DWORD PTR [esi+44], ecx
$L57002:

; 145  : 	if (flags & FIND_DIRECTORY)

	test	al, 2
	je	SHORT $L58007

; 146  : 		state.find_directories=TRUE;

	mov	ecx, DWORD PTR [esi+44]
	or	ch, 4
	mov	DWORD PTR [esi+44], ecx
$L58007:

; 147  : 
; 148  : 	state.search_extra=TRUE;

	mov	eax, DWORD PTR [esi+44]
	or	al, 4
	mov	DWORD PTR [esi+44], eax
	pop	esi

; 149  : }

	ret	4
?set_state@XFindFile@@IAEXK@Z ENDP			; XFindFile::set_state
_TEXT	ENDS
PUBLIC	??2@YAPAXI@Z					; operator new
; Function compile flags: /Ogty
; File C:\duke4\xcore\xcore.h
;	COMDAT ??2@YAPAXI@Z
_TEXT	SEGMENT
_size$ = 8
??2@YAPAXI@Z PROC NEAR					; operator new, COMDAT

; 129  : __inline void *operator new(size_t size){return xmalloc(size);}

	mov	ecx, DWORD PTR _size$[esp-4]
	jmp	@xmalloc@4
??2@YAPAXI@Z ENDP					; operator new
_TEXT	ENDS
PUBLIC	??3@YAXPAX@Z					; operator delete
; Function compile flags: /Ogty
;	COMDAT ??3@YAXPAX@Z
_TEXT	SEGMENT
_ptr$ = 8
??3@YAXPAX@Z PROC NEAR					; operator delete, COMDAT

; 130  : __inline void operator delete(void *ptr){xfree(ptr);}

	mov	ecx, DWORD PTR _ptr$[esp-4]
	jmp	@xfree@4
??3@YAXPAX@Z ENDP					; operator delete
_TEXT	ENDS
PUBLIC	?build_paths@XFindFile@@IAEXPBD0@Z		; XFindFile::build_paths
EXTRN	__alloca_probe:NEAR
EXTRN	??0CStr@@QAE@PBDK@Z:NEAR			; CStr::CStr
EXTRN	??0CStr@@QAE@PBD@Z:NEAR				; CStr::CStr
EXTRN	?_app_char_flags@@3QBEB:BYTE			; _app_char_flags
EXTRN	@fstrlen@4:NEAR
_DATA	SEGMENT
$SG57010 DB	'*', 00H
; Function compile flags: /Ogty
; File C:\duke4\xcore\find.cpp
_DATA	ENDS
_TEXT	SEGMENT
$T58014 = -8
$T58015 = -16
$T58016 = -16
$T58017 = -16
_base$ = 8
_match$ = 12
_part$57012 = -4
?build_paths@XFindFile@@IAEXPBD0@Z PROC NEAR		; XFindFile::build_paths
; _this$ = ecx

; 152  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	push	edi
	mov	edi, ecx

; 153  : 	search_str=CStr("*");

	push	OFFSET FLAT:$SG57010
	lea	ecx, DWORD PTR $T58014[ebp]
	call	??0CStr@@QAE@PBD@Z			; CStr::CStr
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [edi+8], eax

; 154  : 	
; 155  : 	if (!state.absolute_path)

	mov	al, BYTE PTR [edi+44]
	test	al, 8
	jne	SHORT $L57011

; 156  : 	{
; 157  : 		char *part;
; 158  : 		U32 size;
; 159  : 
; 160  : 		size=GetFullPathName(base,0,null,&part);

	mov	edx, DWORD PTR _base$[ebp]
	lea	ecx, DWORD PTR _part$57012[ebp]
	push	ecx
	push	0
	push	0
	push	edx
	call	DWORD PTR __imp__GetFullPathNameA@16
	mov	esi, eax

; 161  : 		char *tmp=(char *)_alloca(size);

	add	eax, 3
	and	al, -4					; fffffffcH
	call	__alloca_probe

; 162  : 		GetFullPathName(base,size,tmp,&part);

	mov	ecx, DWORD PTR _base$[ebp]
	lea	eax, DWORD PTR _part$57012[ebp]
	mov	ebx, esp
	push	eax
	push	ebx
	push	esi
	push	ecx
	call	DWORD PTR __imp__GetFullPathNameA@16

; 163  : 		
; 164  : 		size--;

	dec	esi

; 165  : 		base_path=CStr(tmp,size);

	lea	ecx, DWORD PTR $T58015[ebp]
	push	esi
	push	ebx
	call	??0CStr@@QAE@PBDK@Z			; CStr::CStr
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [edi], edx

; 166  : 	}
; 167  : 	else

	jmp	SHORT $L58041
$L57011:

; 168  : 	{
; 169  : 		base_path=CStr(base);

	mov	eax, DWORD PTR _base$[ebp]
	lea	ecx, DWORD PTR $T58016[ebp]
	push	eax
	call	??0CStr@@QAE@PBD@Z			; CStr::CStr
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edi], ecx
$L58041:

; 170  : 	}
; 171  : 
; 172  : 	U32 len=fstrlen(base_path);

	mov	ecx, DWORD PTR [edi]
	call	@fstrlen@4

; 173  : 
; 174  : 	if (len==3)

	cmp	eax, 3
	jne	SHORT $L57022

; 175  : 	{
; 176  : 		if ((is_alpha(base_path[0])) && (base_path[1]==':') && (base_path[2]==OS_SLASH))

	mov	eax, DWORD PTR [edi]
	xor	edx, edx
	mov	dl, BYTE PTR [eax]
	test	BYTE PTR ?_app_char_flags@@3QBEB[edx], 4
	je	SHORT $L57022
	cmp	BYTE PTR [eax+1], 58			; 0000003aH
	jne	SHORT $L57022
	cmp	BYTE PTR [eax+2], 92			; 0000005cH
	jne	SHORT $L57022

; 177  : 			state.base_is_volume=TRUE;

	mov	eax, DWORD PTR [edi+44]
	or	al, -128				; ffffff80H
	mov	DWORD PTR [edi+44], eax
$L57022:

; 178  : 	}
; 179  : 
; 180  : 	match_str=CStr(match);

	mov	eax, DWORD PTR _match$[ebp]
	lea	ecx, DWORD PTR $T58017[ebp]
	push	eax
	call	??0CStr@@QAE@PBD@Z			; CStr::CStr
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edi+4], ecx

; 181  : }

	lea	esp, DWORD PTR [ebp-28]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?build_paths@XFindFile@@IAEXPBD0@Z ENDP			; XFindFile::build_paths
_TEXT	ENDS
PUBLIC	??1autochar@@QAE@XZ				; autochar::~autochar
PUBLIC	??0StrGrow@@QAE@KK@Z				; StrGrow::StrGrow
PUBLIC	??1StrGrow@@QAE@XZ				; StrGrow::~StrGrow
PUBLIC	??0XFindLevel@@QAE@PBD00@Z			; XFindLevel::XFindLevel
PUBLIC	?do_search@XFindFile@@IAEKXZ			; XFindFile::do_search
PUBLIC	?find_dir@XFindFile@@IAEKPBD@Z			; XFindFile::find_dir
PUBLIC	?search@XFindFile@@QAEKPBD0K@Z			; XFindFile::search
EXTRN	@xlist_new_node@8:NEAR
EXTRN	__imp__GetLogicalDrives@0:NEAR
EXTRN	__except_list:DWORD
EXTRN	___CxxFrameHandler:NEAR
EXTRN	@fstrchr@8:NEAR
EXTRN	@fclean_path@8:NEAR
xdata$x	SEGMENT
$T58248	DD	0ffffffffH
	DD	FLAT:$L58086
	DD	00H
	DD	FLAT:$L58095
	DD	0ffffffffH
	DD	FLAT:$L58087
	DD	02H
	DD	FLAT:$L58088
	DD	03H
	DD	FLAT:$L58089
	DD	03H
	DD	FLAT:$L58090
$T58240	DD	019930520H
	DD	06H
	DD	FLAT:$T58248
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
_DATA	SEGMENT
	ORG $+2
$SG57042 DB	'XFindFile::search: Invalid path format', 00H
	ORG $+1
$SG57045 DB	'XFindFile::search: Invalid path format', 00H
	ORG $+1
$SG57048 DB	'XFindFile::search: Invalid match format', 00H
; Function compile flags: /Ogty
_DATA	ENDS
_TEXT	SEGMENT
_base$ = 8
_match$ = 12
_flags$ = 16
_clean_path$ = -16
_clean_match$ = -20
_len$ = 8
_new_path$57052 = 12
$T58071 = -16
$T58080 = 12
$T58081 = 12
$T58121 = 12
__$EHRec$ = -12
?search@XFindFile@@QAEKPBD0K@Z PROC NEAR		; XFindFile::search
; _this$ = ecx

; 184  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	$L58244
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 8

; 185  : 	if (!match)

	mov	eax, DWORD PTR _match$[ebp]
	push	ebx
	xor	ebx, ebx
	push	esi
	push	edi
	cmp	eax, ebx
	mov	edi, ecx

; 186  : 		return FALSE;

	je	$L58246

; 187  : 
; 188  : 	/* make sure we aren't already doing a search with this object */
; 189  : 	D_ASSERT(!search_stack.get_head());
; 190  : 
; 191  : 	/* allocate info structure if doesn't exist */
; 192  : 	if (!info)

	cmp	DWORD PTR [edi+36], ebx
	jne	SHORT $L57031

; 193  : 		info=new XFindInfo;

	mov	ecx, 44					; 0000002cH
	call	@xmalloc@4
	mov	esi, eax
	mov	DWORD PTR $T58071[ebp], esi
	cmp	esi, ebx
	mov	DWORD PTR __$EHRec$[ebp+8], ebx
	je	SHORT $L58072
	push	64					; 00000040H
	push	64					; 00000040H
	mov	ecx, esi
	call	??0StrGrow@@QAE@KK@Z			; StrGrow::StrGrow
	push	64					; 00000040H
	push	64					; 00000040H
	lea	ecx, DWORD PTR [esi+20]
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	call	??0StrGrow@@QAE@KK@Z			; StrGrow::StrGrow
	mov	DWORD PTR [esi+40], ebx
	jmp	SHORT $L58073
$L58072:
	xor	esi, esi
$L58073:
	mov	DWORD PTR [edi+36], esi
$L57031:

; 194  : 
; 195  : 	autochar clean_path;

	mov	DWORD PTR _clean_path$[ebp], ebx

; 196  : 	autochar clean_match;
; 197  : 
; 198  : 	U32 len,len_match;
; 199  : 	/* tidy up path strings */
; 200  : 	if (base)

	mov	esi, DWORD PTR _base$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 3
	cmp	esi, ebx
	je	SHORT $L57044

; 201  : 	{
; 202  : 		len=fstrlen(base);

	mov	ecx, esi
	call	@fstrlen@4
	mov	ebx, eax

; 203  : 		if (fstrchr(base,'*'))

	mov	dl, 42					; 0000002aH
	mov	ecx, esi
	mov	DWORD PTR _len$[ebp], ebx
	call	@fstrchr@8
	test	eax, eax
	je	SHORT $L57041

; 204  : 			xxx_throw("XFindFile::search: Invalid path format");

	mov	ecx, OFFSET FLAT:$SG57042
	call	@xxx_throw@4
$L57041:

; 205  : 		base=clean_path=(char *)fclean_path(base,len);

	mov	edx, ebx
	mov	ecx, esi
	call	@fclean_path@8

; 206  : 		if (!base)

	test	eax, eax
	mov	DWORD PTR _clean_path$[ebp], eax
	mov	esi, eax
	jne	SHORT $L57044

; 207  : 			xxx_throw("XFindFile::search: Invalid path format");

	mov	ecx, OFFSET FLAT:$SG57045
	call	@xxx_throw@4
$L57044:

; 208  : 	}
; 209  : 	
; 210  : 	len_match=fstrlen(match);

	mov	ecx, DWORD PTR _match$[ebp]
	call	@fstrlen@4

; 211  : 	match=clean_match=(char *)fclean_path(match,len_match);

	mov	ecx, DWORD PTR _match$[ebp]
	mov	edx, eax
	call	@fclean_path@8
	mov	ebx, eax

; 212  : 	if (!match)

	test	ebx, ebx
	mov	DWORD PTR $T58121[ebp], ebx
	mov	DWORD PTR _clean_match$[ebp], ebx
	jne	SHORT $L57047

; 213  : 		xxx_throw("XFindFile::search: Invalid match format");

	mov	ecx, OFFSET FLAT:$SG57048
	call	@xxx_throw@4
$L57047:

; 214  : 
; 215  : 	set_state(flags);

	mov	eax, DWORD PTR _flags$[ebp]
	mov	ecx, edi
	push	eax
	call	?set_state@XFindFile@@IAEXK@Z		; XFindFile::set_state

; 216  : 
; 217  : 	if ((base) && (len > 1))

	test	esi, esi
	je	$L58241
	mov	ecx, DWORD PTR _len$[ebp]
	cmp	ecx, 1
	jbe	$L57068

; 218  : 	{
; 219  : 		/* probably absolute path using ..\ or .\  or c:\ \\server */
; 220  : 		if ((base[0]=='.') || (base[1]==':') || (base[0]==OS_SLASH))

	mov	al, BYTE PTR [esi]
	cmp	al, 46					; 0000002eH
	je	SHORT $L57051
	cmp	BYTE PTR [esi+1], 58			; 0000003aH
	je	SHORT $L57051
	cmp	al, 92					; 0000005cH
	jne	$L57068
$L57051:

; 221  : 		{
; 222  : 			autochar	new_path;

	mov	dl, 4

; 223  : 
; 224  : 			if ((base[0]=='.') && (base[1]==OS_SLASH))

	cmp	al, 46					; 0000002eH
	mov	BYTE PTR __$EHRec$[ebp+8], dl
	jne	SHORT $L57053
	cmp	BYTE PTR [esi+1], 92			; 0000005cH
	jne	SHORT $L57053

; 225  : 			{
; 226  : 				new_path=(char *)set_current_dir(base,len);

	push	ecx
	push	esi
	mov	ecx, edi
	call	?set_current_dir@XFindFile@@IAEPBDPBDK@Z ; XFindFile::set_current_dir

; 227  : 				return search(new_path,match,flags);

	mov	ecx, DWORD PTR _flags$[ebp]
	mov	esi, eax
	push	ecx
	push	ebx
	push	esi
	mov	ecx, edi
	mov	DWORD PTR _new_path$57052[ebp], esi
	call	?search@XFindFile@@QAEKPBD0K@Z		; XFindFile::search
	mov	ecx, esi
	mov	edi, eax
	call	@xfree@4
	mov	ecx, ebx
	call	@xfree@4
	mov	ecx, DWORD PTR _clean_path$[ebp]
	call	@xfree@4
	mov	eax, edi
	jmp	$L57029
$L57053:

; 228  : 			}
; 229  : 			
; 230  : 			/* if server share based string */
; 231  : 			if ((base[0]=='\\') && (base[1]=='\\'))

	cmp	al, 92					; 0000005cH
	jne	SHORT $L57056
	cmp	BYTE PTR [esi+1], 92			; 0000005cH
	jne	SHORT $L57056

; 232  : 			{
; 233  : 				if (len < 3)

	cmp	ecx, 3

; 234  : 					return FALSE;

	jb	$L58247

; 235  : 				if (!is_alpha(base[2]))

	xor	eax, eax
	mov	al, BYTE PTR [esi+2]
	test	BYTE PTR ?_app_char_flags@@3QBEB[eax], dl

; 236  : 					return FALSE;

	je	$L58247

; 237  : 
; 238  : 				state.absolute_path=TRUE;
; 239  : 				state.server_type=TRUE;

	mov	eax, DWORD PTR [edi+44]
	or	al, 40					; 00000028H
	mov	DWORD PTR [edi+44], eax
$L57056:

; 240  : 			}
; 241  : 
; 242  : 			if (len > 2)

	cmp	ecx, 2
	jbe	SHORT $L57067

; 243  : 			{
; 244  : 				if ((base[1]=='.') && (base[2]=='.') && (base[3]==OS_SLASH))

	mov	al, BYTE PTR [esi+1]
	cmp	al, 46					; 0000002eH
	jne	SHORT $L57063
	cmp	BYTE PTR [esi+2], al
	jne	SHORT $L57063
	cmp	BYTE PTR [esi+3], 92			; 0000005cH
	jne	SHORT $L57063

; 245  : 				{
; 246  : 					new_path=(char *)set_parent_dir(base,len);

	push	ecx
	push	esi
	mov	ecx, edi
	call	?set_parent_dir@XFindFile@@IAEPBDPBDK@Z	; XFindFile::set_parent_dir

; 247  : 					return search(new_path,match,flags);

	mov	ecx, DWORD PTR _flags$[ebp]
	mov	esi, eax
	push	ecx
	push	ebx
	push	esi
	mov	ecx, edi
	mov	DWORD PTR _new_path$57052[ebp], esi
	call	?search@XFindFile@@QAEKPBD0K@Z		; XFindFile::search
	mov	ecx, esi
	mov	edi, eax
	call	@xfree@4
	mov	ecx, ebx
	call	@xfree@4
	mov	ecx, DWORD PTR _clean_path$[ebp]
	call	@xfree@4
	mov	eax, edi
	jmp	$L57029
$L57063:

; 248  : 				}
; 249  : 				if ((base[1]==':') && (is_alpha(base[0])) && (base[2]=='\\'))

	cmp	al, 58					; 0000003aH
	jne	SHORT $L57067
	xor	eax, eax
	mov	al, BYTE PTR [esi]
	test	BYTE PTR ?_app_char_flags@@3QBEB[eax], dl
	je	SHORT $L57067
	cmp	BYTE PTR [esi+2], 92			; 0000005cH
	jne	SHORT $L57067

; 250  : 				{
; 251  : 					state.absolute_path=TRUE;
; 252  : 					state.local_type=TRUE;

	mov	eax, DWORD PTR [edi+44]
	or	al, 72					; 00000048H
	mov	DWORD PTR [edi+44], eax
$L57067:

; 253  : 				}
; 254  : 			}
; 255  : 		}

	xor	ecx, ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	call	@xfree@4

; 256  : 	}
; 257  : 
; 258  : 	if (!base)

	jmp	SHORT $L57068
$L58241:

; 259  : 	{
; 260  : 		U32 size=GetCurrentDirectory(0,null);

	push	0
	push	0
	call	DWORD PTR __imp__GetCurrentDirectoryA@8
	mov	esi, eax

; 261  : 		char *tmp=(char *)_alloca(size);

	add	eax, 3
	and	al, -4					; fffffffcH
	call	__alloca_probe
	mov	ebx, esp

; 262  : 		GetCurrentDirectory(size,tmp);

	push	ebx
	push	esi
	call	DWORD PTR __imp__GetCurrentDirectoryA@8

; 263  : 		base=tmp;
; 264  : 		state.absolute_path=TRUE;

	mov	eax, DWORD PTR [edi+44]
	mov	esi, ebx
	mov	ebx, DWORD PTR $T58121[ebp]
	or	al, 8
	mov	DWORD PTR [edi+44], eax
$L57068:

; 265  : 	}
; 266  : 
; 267  : 	/* check for wildcards */
; 268  : 	if (!fstrchr(match,'*'))

	mov	dl, 42					; 0000002aH
	mov	ecx, ebx
	call	@fstrchr@8
	test	eax, eax
	jne	SHORT $L57072

; 269  : 		state.no_wildcard=TRUE;

	mov	eax, DWORD PTR [edi+44]
	or	al, 16					; 00000010H
	mov	DWORD PTR [edi+44], eax
$L57072:

; 270  : 
; 271  : 	/* calculate needed paths base_path,search_str*/
; 272  : 	build_paths(base,match);

	push	ebx
	push	esi
	mov	ecx, edi
	call	?build_paths@XFindFile@@IAEXPBD0@Z	; XFindFile::build_paths

; 273  : 
; 274  : 	/* if base_path is volume, like c:\ */
; 275  : 	/* then check if volume is available */
; 276  : 	if (state.base_is_volume)

	mov	al, BYTE PTR [edi+44]
	test	al, al
	jns	SHORT $L57073

; 277  : 	{
; 278  : 		U32 volume=GetLogicalDrives();

	call	DWORD PTR __imp__GetLogicalDrives@0
	mov	esi, eax

; 279  : 		U32 letter=base_path[0];

	mov	eax, DWORD PTR [edi]
	movsx	ecx, BYTE PTR [eax]

; 280  : 
; 281  : 		letter=fsetlower(letter) - 'a';

	mov	edx, ecx
	and	edx, 255				; 000000ffH
	mov	al, BYTE PTR ?_app_char_flags@@3QBEB[edx]

; 282  : 		if (!((1<<letter) & volume))

	mov	edx, 1
	and	eax, 32					; 00000020H
	lea	ecx, DWORD PTR [ecx+eax-97]
	shl	edx, cl
	test	edx, esi
	jne	SHORT $L57080

; 283  : 			return FALSE;

	jmp	$L57087
$L57073:

; 284  : 	}
; 285  : 	else
; 286  : 	{
; 287  : 		if (!find_dir(base_path))

	mov	eax, DWORD PTR [edi]
	mov	ecx, edi
	push	eax
	call	?find_dir@XFindFile@@IAEKPBD@Z		; XFindFile::find_dir
	test	eax, eax

; 288  : 			return FALSE;

	je	$L57087
$L57080:

; 289  : 	}
; 290  : 
; 291  : 	XFindLevel *level=new XFindLevel(base_path,null,search_str);

	mov	ecx, 12					; 0000000cH
	call	@xmalloc@4
	mov	DWORD PTR $T58081[ebp], eax
	test	eax, eax
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	je	SHORT $L58082
	mov	edx, DWORD PTR [edi+8]
	mov	esi, DWORD PTR [edi]
	push	edx
	push	0
	push	esi
	mov	ecx, eax
	call	??0XFindLevel@@QAE@PBD00@Z		; XFindLevel::XFindLevel
	mov	DWORD PTR $T58080[ebp], eax
	jmp	SHORT $L58083
$L58082:
	mov	DWORD PTR $T58080[ebp], 0
$L58083:

; 292  : 	search_stack.add_head(level);

	mov	eax, DWORD PTR [edi+20]
	lea	esi, DWORD PTR [edi+12]
	test	eax, eax
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	jne	SHORT $L58220
	mov	edx, 12					; 0000000cH
	mov	ecx, esi
	call	@xlist_new_node@8
	mov	DWORD PTR [esi+8], eax
$L58220:
	mov	eax, DWORD PTR [esi+8]
	mov	edx, DWORD PTR $T58080[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [esi+8], ecx
	mov	DWORD PTR [eax+8], edx
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	jne	SHORT $L58222
	mov	DWORD PTR [esi+4], eax
	jmp	SHORT $L58223
$L58222:
	mov	DWORD PTR [ecx+4], eax
$L58223:

; 293  : 
; 294  : 	/* actually do search */
; 295  : 	if (do_search())

	mov	ecx, edi
	mov	DWORD PTR [esi], eax
	call	?do_search@XFindFile@@IAEKXZ		; XFindFile::do_search
	test	eax, eax
	je	SHORT $L57087

; 296  : 		return TRUE;

	mov	ecx, ebx
	call	@xfree@4
	mov	ecx, DWORD PTR _clean_path$[ebp]
	call	@xfree@4
	mov	eax, 1
	jmp	SHORT $L57029
$L58247:

; 234  : 					return FALSE;

	xor	ecx, ecx
	call	@xfree@4
$L57087:

; 297  : 
; 298  : 	return FALSE;

	mov	ecx, ebx
	call	@xfree@4
	mov	ecx, DWORD PTR _clean_path$[ebp]
	call	@xfree@4
$L58246:
	xor	eax, eax
$L57029:

; 299  : }

	lea	esp, DWORD PTR [ebp-32]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
text$x	SEGMENT
$L58086:
	mov	eax, DWORD PTR $T58071[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
$L58095:
	mov	ecx, DWORD PTR $T58071[ebp]
	jmp	??1StrGrow@@QAE@XZ			; StrGrow::~StrGrow
$L58087:
	lea	ecx, DWORD PTR _clean_path$[ebp]
	jmp	??1autochar@@QAE@XZ			; autochar::~autochar
$L58088:
	lea	ecx, DWORD PTR _clean_match$[ebp]
	jmp	??1autochar@@QAE@XZ			; autochar::~autochar
$L58089:
	lea	ecx, DWORD PTR _new_path$57052[ebp]
	jmp	??1autochar@@QAE@XZ			; autochar::~autochar
$L58090:
	mov	eax, DWORD PTR $T58081[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
$L58244:
	mov	eax, OFFSET FLAT:$T58240
	jmp	___CxxFrameHandler
text$x	ENDS
?search@XFindFile@@QAEKPBD0K@Z ENDP			; XFindFile::search
; Function compile flags: /Ogty
; File C:\duke4\xcore\xclass.h
;	COMDAT ??1autochar@@QAE@XZ
_TEXT	SEGMENT
??1autochar@@QAE@XZ PROC NEAR				; autochar::~autochar, COMDAT
; _this$ = ecx

; 69   : 	inline ~autochar(void){xfree(ptr);ptr=null;}

	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR [esi]
	call	@xfree@4
	mov	DWORD PTR [esi], 0
	pop	esi
	ret	0
??1autochar@@QAE@XZ ENDP				; autochar::~autochar
_TEXT	ENDS
PUBLIC	?next@XFindFile@@QAEPAVXFindInfo@@AAK@Z		; XFindFile::next
; Function compile flags: /Ogty
; File C:\duke4\xcore\find.cpp
_TEXT	SEGMENT
_depth$ = 8
?next@XFindFile@@QAEPAVXFindInfo@@AAK@Z PROC NEAR	; XFindFile::next
; _this$ = ecx

; 302  : {

	push	esi
	mov	esi, ecx

; 303  : 	while(!state.has_info)

	test	BYTE PTR [esi+44], 1
	jne	SHORT $L57098
$L57097:

; 304  : 	{
; 305  : 		/* if search fails */
; 306  : 		if (!do_search())

	mov	ecx, esi
	call	?do_search@XFindFile@@IAEKXZ		; XFindFile::do_search
	test	eax, eax
	je	SHORT $L58254
	test	BYTE PTR [esi+44], 1
	je	SHORT $L57097
$L57098:

; 308  : 	}
; 309  : 
; 310  : 	state.has_info=FALSE;

	mov	eax, DWORD PTR [esi+44]

; 311  : 	depth=state.depth;

	mov	ecx, DWORD PTR _depth$[esp]
	and	al, -2					; fffffffeH
	mov	DWORD PTR [esi+44], eax
	shr	eax, 13					; 0000000dH
	and	eax, 1023				; 000003ffH
	mov	DWORD PTR [ecx], eax

; 312  : 	return info;

	mov	eax, DWORD PTR [esi+36]
	pop	esi

; 313  : }

	ret	4
$L58254:

; 307  : 			return null;

	xor	eax, eax
	pop	esi

; 313  : }

	ret	4
?next@XFindFile@@QAEPAVXFindInfo@@AAK@Z ENDP		; XFindFile::next
_TEXT	ENDS
PUBLIC	?set@XFindInfo@@IAEXPBDPAU_WIN32_FIND_DATAA@@@Z	; XFindInfo::set
PUBLIC	?init@XFindLevel@@QAEKPAU_WIN32_FIND_DATAA@@@Z	; XFindLevel::init
PUBLIC	?next@XFindLevel@@QAEKPAU_WIN32_FIND_DATAA@@@Z	; XFindLevel::next
PUBLIC	?match_request@XFindFile@@IAEKXZ		; XFindFile::match_request
xdata$x	SEGMENT
$T58404	DD	0ffffffffH
	DD	FLAT:$L58264
$T58391	DD	019930520H
	DD	01H
	DD	FLAT:$T58404
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
_TEXT	SEGMENT
_skip$57107 = -16
$T58261 = -16
__$EHRec$ = -12
?do_search@XFindFile@@IAEKXZ PROC NEAR			; XFindFile::do_search
; _this$ = ecx

; 316  : {

	push	-1
	push	$L58401
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	esi, ecx
$L57105:

; 317  : 	while(1)
; 318  : 	{
; 319  : 		U32 skip;
; 320  : 
; 321  : 		if (state.has_info)

	mov	eax, DWORD PTR [esi+44]
	test	al, 1
	jne	$L57121

; 322  : 			return TRUE;
; 323  : 
; 324  : 		XFindLevel *head=search_stack.get_head();

	mov	ecx, DWORD PTR [esi+12]
	lea	edi, DWORD PTR [esi+12]
	test	ecx, ecx
	je	$L58394
	mov	ebx, DWORD PTR [ecx+8]

; 325  : 		if (!head)

	test	ebx, ebx
	je	$L58394

; 327  : 
; 328  : 		skip=FALSE;
; 329  : 
; 330  : 		/* if at directory we need to go down tree instead of finding next file */
; 331  : 		if (state.at_directory)

	test	ah, 16					; 00000010H
	mov	DWORD PTR _skip$57107[esp+32], 0
	je	SHORT $L57112

; 332  : 		{
; 333  : 			state.at_directory=FALSE;

	and	ah, -17					; ffffffefH

; 334  : 			if (state.is_recursive)

	test	al, 2
	mov	DWORD PTR [esi+44], eax
	jne	$skip_to_recursive$57113
$L57112:

; 335  : 				goto skip_to_recursive;
; 336  : 		}
; 337  : 		/* reset at directory state */
; 338  : 		state.at_directory=FALSE;

	mov	ecx, DWORD PTR [esi+44]

; 339  : 		if (!head->has_handle())
; 340  : 		{
; 341  : 			if (!head->init(&find_data))

	lea	ebp, DWORD PTR [esi+48]
	and	ch, -17					; ffffffefH
	push	ebp
	mov	DWORD PTR [esi+44], ecx
	mov	eax, DWORD PTR [ebx]
	cmp	eax, -1
	mov	ecx, ebx
	jne	SHORT $L57115
	call	?init@XFindLevel@@QAEKPAU_WIN32_FIND_DATAA@@@Z ; XFindLevel::init
	test	eax, eax
	jne	$L57118

; 342  : 			{
; 343  : 				search_stack.remove_head();

	mov	ecx, DWORD PTR [edi]
	test	ecx, ecx
	je	SHORT $L57105
	mov	eax, DWORD PTR [ecx]
	xor	edx, edx
	cmp	eax, edx
	mov	DWORD PTR [edi], eax
	je	SHORT $L58281
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR [edi+8]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [edi+8], ecx

; 344  : 				continue;

	jmp	SHORT $L57105

; 342  : 			{
; 343  : 				search_stack.remove_head();

$L58281:
	mov	eax, DWORD PTR [edi+8]
	mov	DWORD PTR [edi], edx
	mov	DWORD PTR [edi+4], edx
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [edi+8], ecx

; 344  : 				continue;

	jmp	$L57105
$L57115:

; 345  : 			}
; 346  : 		}
; 347  : 		else
; 348  : 		{
; 349  : 			if (!head->next(&find_data))

	call	?next@XFindLevel@@QAEKPAU_WIN32_FIND_DATAA@@@Z ; XFindLevel::next
	test	eax, eax
	jne	SHORT $L57118

; 350  : 			{
; 351  : 				head=search_stack.remove_head();

	mov	eax, DWORD PTR [edi]
	xor	ebx, ebx
	cmp	eax, ebx
	je	SHORT $L58258
	mov	ecx, DWORD PTR [eax]
	mov	ebp, DWORD PTR [eax+8]
	cmp	ecx, ebx
	mov	DWORD PTR [edi], ecx
	je	SHORT $L58290
	mov	DWORD PTR [ecx+4], ebx
	jmp	SHORT $L58291
$L58290:
	mov	DWORD PTR [edi], ebx
	mov	DWORD PTR [edi+4], ebx
$L58291:
	mov	ecx, DWORD PTR [edi+8]

; 352  : 				delete head;

	cmp	ebp, ebx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [edi+8], eax
	je	SHORT $L58258
	mov	ecx, DWORD PTR [ebp+8]
	call	@xfree@4
	mov	DWORD PTR [ebp+8], ebx
	mov	ecx, DWORD PTR [ebp+4]
	call	@xfree@4
	mov	ecx, ebp
	mov	DWORD PTR [ebp+4], ebx
	call	@xfree@4
$L58258:

; 353  : 				state.depth--;

	mov	eax, DWORD PTR [esi+44]
	mov	edx, eax
	and	edx, -8192				; ffffe000H
	dec	edx
	xor	edx, eax
	and	edx, 8380416				; 007fe000H
	xor	edx, eax
	mov	DWORD PTR [esi+44], edx

; 354  : 				continue;

	jmp	$L57105
$L57118:

; 355  : 			}
; 356  : 		}
; 357  : 		info->set(head->get_path(),&find_data);

	mov	eax, DWORD PTR [ebx+8]
	mov	ecx, DWORD PTR [esi+36]
	push	ebp
	push	eax
	call	?set@XFindInfo@@IAEXPBDPAU_WIN32_FIND_DATAA@@@Z ; XFindInfo::set

; 358  : 		if (state.search_extra)

	test	BYTE PTR [esi+44], 4
	je	$L57121

; 359  : 		{
; 360  : 			if (info->is_dir())

	mov	eax, DWORD PTR [esi+36]
	test	BYTE PTR [eax+40], 1
	je	SHORT $L57131

; 361  : 			{
; 362  : 				CC8 *name=info->get_filename();

	mov	ebp, DWORD PTR [eax]

; 363  : 				U32 len=fstrlen(name);

	mov	ecx, ebp
	call	@fstrlen@4

; 364  : 
; 365  : 				if (len==1)

	mov	ecx, 1
	cmp	eax, ecx
	jne	SHORT $L57125

; 366  : 				{
; 367  : 					if (name[0]=='.')

	mov	al, BYTE PTR [ebp]

; 368  : 						skip=TRUE;
; 369  : 				}
; 370  : 				else if (len==2)

	jmp	SHORT $L58403
$L57125:
	cmp	eax, 2
	jne	SHORT $L57131

; 371  : 				{
; 372  : 					if ((name[0]=='.') && (name[1]=='.'))

	cmp	BYTE PTR [ebp], 46			; 0000002eH
	jne	SHORT $L57131
	mov	al, BYTE PTR [ebp+1]
$L58403:
	cmp	al, 46					; 0000002eH
	jne	SHORT $L57131

; 373  : 						skip=TRUE;
; 374  : 				}
; 375  : 			}
; 376  : 			if ((!skip) || (state.want_dots))

	mov	eax, DWORD PTR [esi+44]
	mov	DWORD PTR _skip$57107[esp+32], ecx
	test	ah, 8
	je	SHORT $skip_to_recursive$57113
$L57131:

; 377  : 			{
; 378  : 				if (match_request())

	mov	ecx, esi
	call	?match_request@XFindFile@@IAEKXZ	; XFindFile::match_request
	test	eax, eax
	jne	$L58395
$skip_to_recursive$57113:

; 383  : 					return TRUE;
; 384  : 				}
; 385  : 			}
; 386  : skip_to_recursive:
; 387  : 			if (state.is_recursive)

	mov	eax, DWORD PTR [esi+44]
	test	al, 2
	je	$L57105

; 388  : 			{
; 389  : 				if (info->is_dir())

	mov	ecx, DWORD PTR [esi+36]
	test	BYTE PTR [ecx+40], 1
	je	$L57105

; 390  : 				{
; 391  : 					/* don't change directories if the directory is "." or ".." */
; 392  : 					if (!skip)

	mov	ecx, DWORD PTR _skip$57107[esp+32]
	test	ecx, ecx
	jne	$L57105

; 393  : 					{
; 394  : 						if (state.depth<FIND_MAX_DEPTH)

	mov	edx, eax
	and	edx, 8380416				; 007fe000H
	cmp	edx, 8388608				; 00800000H
	jae	$L57105

; 395  : 						{
; 396  : 							state.depth++;

	mov	ecx, eax
	and	ecx, -8192				; ffffe000H
	add	ecx, 8192				; 00002000H
	xor	ecx, eax
	and	ecx, 8380416				; 007fe000H
	xor	ecx, eax
	mov	DWORD PTR [esi+44], ecx

; 397  : 							XFindLevel *level=new XFindLevel(head->get_path(),info->get_filename(),search_str);

	mov	ecx, 12					; 0000000cH
	call	@xmalloc@4
	mov	DWORD PTR $T58261[esp+32], eax
	xor	ebp, ebp
	cmp	eax, ebp
	mov	DWORD PTR __$EHRec$[esp+40], ebp
	je	SHORT $L58263
	mov	edx, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [esi+8]
	mov	ebp, DWORD PTR [ebx+8]
	push	ecx
	mov	edx, DWORD PTR [edx]
	mov	ecx, eax
	push	edx
	push	ebp
	call	??0XFindLevel@@QAE@PBD00@Z		; XFindLevel::XFindLevel
	mov	ebp, eax
$L58263:

; 398  : 							search_stack.add_head(level);

	mov	eax, DWORD PTR [edi+8]
	mov	DWORD PTR __$EHRec$[esp+40], -1
	test	eax, eax
	jne	SHORT $L58385
	mov	edx, 12					; 0000000cH
	mov	ecx, edi
	call	@xlist_new_node@8
	mov	DWORD PTR [edi+8], eax
$L58385:
	mov	eax, DWORD PTR [edi+8]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edi+8], ecx
	mov	DWORD PTR [eax+8], ebp
	mov	edx, DWORD PTR [edi]
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [edi]
	test	ecx, ecx
	jne	SHORT $L58387
	mov	DWORD PTR [edi+4], eax
	mov	DWORD PTR [edi], eax
	jmp	$L57105
$L58387:
	mov	DWORD PTR [ecx+4], eax
	mov	DWORD PTR [edi], eax
	jmp	$L57105
$L58394:
	pop	edi
	pop	esi
	pop	ebp

; 326  : 			return FALSE;

	xor	eax, eax
	pop	ebx

; 399  : 						}
; 400  : 					}
; 401  : 				}
; 402  : 			}
; 403  : 		}
; 404  : 		else
; 405  : 			return TRUE;
; 406  : 		/* keep on searching along */
; 407  : 	}
; 408  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+16]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	ret	0
$L58395:

; 379  : 				{
; 380  : 					state.has_info=TRUE;

	mov	edi, DWORD PTR [esi+44]

; 381  : 					if (info->is_dir())

	mov	ecx, DWORD PTR [esi+36]
	or	edi, 1
	mov	DWORD PTR [esi+44], edi
	mov	dl, BYTE PTR [ecx+40]
	test	dl, 1
	mov	eax, edi
	je	SHORT $L57121

; 382  : 						state.at_directory=TRUE;

	or	ah, 16					; 00000010H
	mov	DWORD PTR [esi+44], eax
$L57121:

; 399  : 						}
; 400  : 					}
; 401  : 				}
; 402  : 			}
; 403  : 		}
; 404  : 		else
; 405  : 			return TRUE;
; 406  : 		/* keep on searching along */
; 407  : 	}
; 408  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+32]
	pop	edi
	pop	esi
	pop	ebp
	mov	eax, 1
	pop	ebx
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
text$x	SEGMENT
$L58264:
	mov	eax, DWORD PTR $T58261[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
$L58401:
	mov	eax, OFFSET FLAT:$T58391
	jmp	___CxxFrameHandler
text$x	ENDS
?do_search@XFindFile@@IAEKXZ ENDP			; XFindFile::do_search
PUBLIC	?find_path@XFindFile@@IAEKPBD@Z			; XFindFile::find_path
; Function compile flags: /Ogty
_TEXT	SEGMENT
_path$ = 8
?find_dir@XFindFile@@IAEKPBD@Z PROC NEAR		; XFindFile::find_dir
; _this$ = ecx

; 412  : 	U32 ret=find_path(path);

	mov	eax, DWORD PTR _path$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?find_path@XFindFile@@IAEKPBD@Z		; XFindFile::find_path

; 413  : 
; 414  : 	return private_info->is_dir();

	mov	ecx, DWORD PTR [esi+40]
	pop	esi
	mov	eax, DWORD PTR [ecx+40]
	and	eax, 1

; 415  : }

	ret	4
?find_dir@XFindFile@@IAEKPBD@Z ENDP			; XFindFile::find_dir
_TEXT	ENDS
PUBLIC	?reset@StrGrow@@QAEXXZ				; StrGrow::reset
PUBLIC	??0MemGrow@@QAE@K@Z				; MemGrow::MemGrow
PUBLIC	??1MemGrow@@QAE@XZ				; MemGrow::~MemGrow
PUBLIC	?set_path@XFindInfo@@IAEXPBDPAU_WIN32_FIND_DATAA@@@Z ; XFindInfo::set_path
PUBLIC	??1FindHandle@@QAE@XZ				; FindHandle::~FindHandle
EXTRN	__imp__FindClose@4:NEAR
EXTRN	__imp__FindFirstFileA@8:NEAR
xdata$x	SEGMENT
$T58466	DD	0ffffffffH
	DD	FLAT:$L58416
	DD	00H
	DD	FLAT:$L58417
	DD	01H
	DD	FLAT:$L58428
	DD	01H
	DD	FLAT:$L58425
	DD	03H
	DD	FLAT:$L58432
$T58464	DD	019930520H
	DD	05H
	DD	FLAT:$T58466
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
_TEXT	SEGMENT
_path$ = 8
_handle$ = -24
$T58411 = -20
$T58435 = -16
__$EHRec$ = -12
?find_path@XFindFile@@IAEKPBD@Z PROC NEAR		; XFindFile::find_path
; _this$ = ecx

; 418  : {

	push	-1
	push	$L58465
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	ebp, ecx

; 419  : 	FindHandle handle;

	mov	DWORD PTR _handle$[esp+40], -1

; 420  : 	
; 421  : 	if (!private_info)

	mov	eax, DWORD PTR [ebp+40]
	xor	ebx, ebx
	cmp	eax, ebx
	mov	DWORD PTR __$EHRec$[esp+48], ebx
	jne	SHORT $L57158

; 422  : 		private_info=new XFindInfo;

	mov	ecx, 44					; 0000002cH
	call	@xmalloc@4
	mov	esi, eax
	mov	DWORD PTR $T58411[esp+40], esi
	cmp	esi, ebx
	mov	BYTE PTR __$EHRec$[esp+48], 1
	je	SHORT $L58412
	push	64					; 00000040H
	mov	ecx, esi
	call	??0MemGrow@@QAE@K@Z			; MemGrow::MemGrow
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+48], 2
	mov	DWORD PTR [esi+16], 64			; 00000040H
	call	?reset@StrGrow@@QAEXXZ			; StrGrow::reset
	lea	edi, DWORD PTR [esi+20]
	push	64					; 00000040H
	mov	ecx, edi
	mov	BYTE PTR __$EHRec$[esp+52], 3
	mov	DWORD PTR $T58435[esp+44], edi
	call	??0MemGrow@@QAE@K@Z			; MemGrow::MemGrow
	mov	ecx, edi
	mov	BYTE PTR __$EHRec$[esp+48], 4
	mov	DWORD PTR [edi+16], 64			; 00000040H
	call	?reset@StrGrow@@QAEXXZ			; StrGrow::reset
	mov	DWORD PTR [esi+40], ebx
	jmp	SHORT $L58413
$L58412:
	xor	esi, esi
$L58413:
	mov	BYTE PTR __$EHRec$[esp+48], bl
	mov	DWORD PTR [ebp+40], esi
$L57158:

; 423  : 
; 424  : 	handle=FindFirstFile(path,&find_data);

	mov	ebx, DWORD PTR _path$[esp+36]
	lea	esi, DWORD PTR [ebp+48]
	push	esi
	push	ebx
	call	DWORD PTR __imp__FindFirstFileA@8
	mov	edi, eax

; 425  : 	if ((HANDLE)handle!=INVALID_XHANDLE_VALUE)

	cmp	edi, -1
	mov	DWORD PTR _handle$[esp+40], edi
	je	SHORT $L57165

; 426  : 	{
; 427  : 		private_info->set_path(path,&find_data);

	mov	ecx, DWORD PTR [ebp+40]
	push	esi
	push	ebx
	call	?set_path@XFindInfo@@IAEXPBDPAU_WIN32_FIND_DATAA@@@Z ; XFindInfo::set_path

; 428  : 		return TRUE;

	push	edi
	call	DWORD PTR __imp__FindClose@4
	mov	eax, 1
	jmp	SHORT $L57156
$L57165:

; 429  : 	}
; 430  : 	return FALSE;

	xor	eax, eax
$L57156:

; 431  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 24					; 00000018H
	ret	4
_TEXT	ENDS
text$x	SEGMENT
$L58416:
	lea	ecx, DWORD PTR _handle$[ebp]
	jmp	??1FindHandle@@QAE@XZ			; FindHandle::~FindHandle
$L58417:
	mov	eax, DWORD PTR $T58411[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
$L58428:
	mov	ecx, DWORD PTR $T58411[ebp]
	jmp	??1MemGrow@@QAE@XZ			; MemGrow::~MemGrow
$L58425:
	mov	ecx, DWORD PTR $T58411[ebp]
	jmp	??1StrGrow@@QAE@XZ			; StrGrow::~StrGrow
$L58432:
	mov	ecx, DWORD PTR $T58435[ebp]
	jmp	??1MemGrow@@QAE@XZ			; MemGrow::~MemGrow
$L58465:
	mov	eax, OFFSET FLAT:$T58464
	jmp	___CxxFrameHandler
text$x	ENDS
?find_path@XFindFile@@IAEKPBD@Z ENDP			; XFindFile::find_path
; Function compile flags: /Ogty
;	COMDAT ??1FindHandle@@QAE@XZ
_TEXT	SEGMENT
??1FindHandle@@QAE@XZ PROC NEAR				; FindHandle::~FindHandle, COMDAT
; _this$ = ecx

; 10   : 	~FindHandle(void) {if (handle!=INVALID_XHANDLE_VALUE) FindClose(handle);}

	mov	eax, DWORD PTR [ecx]
	cmp	eax, -1
	je	SHORT $L56894
	push	eax
	call	DWORD PTR __imp__FindClose@4
$L56894:
	ret	0
??1FindHandle@@QAE@XZ ENDP				; FindHandle::~FindHandle
; Function compile flags: /Ogty
; File C:\duke4\xcore\xclass.h
_TEXT	ENDS
;	COMDAT ??0MemGrow@@QAE@K@Z
_TEXT	SEGMENT
_start$ = 8
??0MemGrow@@QAE@K@Z PROC NEAR				; MemGrow::MemGrow, COMDAT
; _this$ = ecx

; 1132 : 	MemGrow(U32 start) : size(start) {base=(char *)xmalloc(size);}

	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR _start$[esp]
	mov	DWORD PTR [esi+4], ecx
	call	@xmalloc@4
	mov	DWORD PTR [esi], eax
	mov	eax, esi
	pop	esi
	ret	4
??0MemGrow@@QAE@K@Z ENDP				; MemGrow::MemGrow
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??1MemGrow@@QAE@XZ
_TEXT	SEGMENT
??1MemGrow@@QAE@XZ PROC NEAR				; MemGrow::~MemGrow, COMDAT
; _this$ = ecx

; 1133 : 	~MemGrow(void){xfree(base);}

	mov	ecx, DWORD PTR [ecx]
	jmp	@xfree@4
??1MemGrow@@QAE@XZ ENDP					; MemGrow::~MemGrow
_TEXT	ENDS
PUBLIC	?match_in_wild@XFindFile@@IAEKPBD0JJPAPAD@Z	; XFindFile::match_in_wild
; Function compile flags: /Ogty
; File C:\duke4\xcore\find.cpp
_TEXT	SEGMENT
_s_exp$ = 8
_s_str$ = 12
_exp_left$ = 16
_str_left$ = 20
_partial$ = 24
_this$ = -4
_match_left$ = 8
?match_in_wild@XFindFile@@IAEKPBD0JJPAPAD@Z PROC NEAR	; XFindFile::match_in_wild
; _this$ = ecx

; 436  : {

	push	ecx
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _s_exp$[esp+8]
	mov	edx, ecx
	push	esi
	mov	esi, DWORD PTR _exp_left$[esp+12]
	push	edi
	mov	DWORD PTR _this$[esp+20], edx
$L57182:

; 437  : 	CC8 *exp=s_exp;
; 438  : 	CC8 *str=s_str;
; 439  : 
; 440  : 	U32 key1,key2;
; 441  : 
; 442  : 	/* advance key1 to non-wildcard */
; 443  : 	do
; 444  : 	{
; 445  : 		D_ASSERT(exp_left>=0);
; 446  : 		key1=exp[exp_left--];

	movsx	edi, BYTE PTR [esi+ebp]
	dec	esi

; 447  : 		if (key1!='*')

	cmp	edi, 42					; 0000002aH
	jne	SHORT $L57184

; 448  : 			break;
; 449  : 		if (exp_left<0)

	test	esi, esi

; 451  : 	}while(1);

	jge	SHORT $L57182
$L58487:
	pop	edi
	pop	esi
	pop	ebp

; 450  : 			return MATCH_EXACT;

	mov	eax, 2
	pop	ebx

; 510  : 	}while(1);
; 511  : }

	pop	ecx
	ret	20					; 00000014H
$L57184:

; 450  : 			return MATCH_EXACT;

	mov	ebx, DWORD PTR _s_str$[esp+16]
	mov	eax, DWORD PTR _str_left$[esp+16]
$find_match$57188:

; 452  : 	/* scan till we hit matching character */
; 453  : 	U32 match_left;
; 454  : 
; 455  : find_match:
; 456  : 	do
; 457  : 	{
; 458  : 		D_ASSERT(str_left>=0);
; 459  : 		key2=str[str_left--];

	movsx	ecx, BYTE PTR [ebx+eax]
	dec	eax

; 460  : 		if (key2==OS_SLASH)

	cmp	ecx, 92					; 0000005cH
	jne	SHORT $L57193

; 461  : 		{
; 462  : 			if (!state.wild_cross_slash)

	test	BYTE PTR [edx+45], 2
	je	SHORT $L58486
$L57193:

; 463  : 				return FALSE;
; 464  : 		}
; 465  : 		if (key2==key1)

	cmp	ecx, edi
	je	SHORT $L57191

; 466  : 			break;
; 467  : 		if (str_left<0)

	test	eax, eax
	jge	SHORT $find_match$57188
$L58486:

; 509  : 			return FALSE;

	xor	eax, eax
$L57198:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 510  : 	}while(1);
; 511  : }

	pop	ecx
	ret	20					; 00000014H
$L57191:

; 468  : 			return FALSE;
; 469  : 	}while(1);
; 470  : 	match_left=str_left;

	mov	DWORD PTR _match_left$[esp+16], eax
$L57196:

; 471  : 	/* scan matches till failure */
; 472  : 	do
; 473  : 	{
; 474  : 		if (exp_left<0)

	test	esi, esi
	jl	SHORT $L58483

; 481  : 				return MATCH_PARTIAL;
; 482  : 
; 483  : 			return FALSE;
; 484  : 		}
; 485  : 		if (str_left<0)

	test	eax, eax
	jl	SHORT $L58486

; 486  : 		{
; 487  : 			/* still have some expression left, but no more string */
; 488  : 			/* no match */
; 489  : 			return FALSE;
; 490  : 		}
; 491  : 		D_ASSERT(exp_left>=0);D_ASSERT(str_left>=0);
; 492  : 		key1=exp[exp_left--];

	movsx	edi, BYTE PTR [esi+ebp]

; 493  : 		key2=str[str_left--];

	movsx	ecx, BYTE PTR [ebx+eax]
	dec	esi
	dec	eax

; 494  : 		if (key1=='*')

	cmp	edi, 42					; 0000002aH
	je	SHORT $L58485

; 507  : 		}
; 508  : 		else if (key1!=key2)

	cmp	edi, ecx
	je	SHORT $L57196
	pop	edi
	pop	esi
	pop	ebp

; 509  : 			return FALSE;

	xor	eax, eax
	pop	ebx

; 510  : 	}while(1);
; 511  : }

	pop	ecx
	ret	20					; 00000014H
$L58485:

; 495  : 		{
; 496  : 			/* special case if * is first character */
; 497  : 			if (exp_left<0)

	test	esi, esi
	jl	SHORT $L58487

; 498  : 				return MATCH_EXACT;
; 499  : 
; 500  : 			U32 ret;
; 501  : 			if (ret=match_in_wild(exp,str,exp_left,++str_left,partial))

	mov	ecx, DWORD PTR _partial$[esp+16]
	inc	eax
	push	ecx
	push	eax
	push	esi
	push	ebx
	push	ebp
	mov	ecx, edx
	call	?match_in_wild@XFindFile@@IAEKPBD0JJPAPAD@Z ; XFindFile::match_in_wild
	test	eax, eax
	jne	SHORT $L57198

; 502  : 				return ret;
; 503  : 
; 504  : 			/* go to next matching character and continue */
; 505  : 			str_left=match_left;

	mov	eax, DWORD PTR _match_left$[esp+16]

; 506  : 			goto find_match;

	mov	edx, DWORD PTR _this$[esp+20]
	jmp	SHORT $find_match$57188
$L58483:

; 475  : 		{
; 476  : 			/* if no string and no expression left, is match */
; 477  : 			if (str_left<0)

	test	eax, eax
	jge	SHORT $L57200
	pop	edi
	pop	esi
	pop	ebp

; 478  : 				return MATCH_EXACT;

	mov	eax, 2
	pop	ebx

; 510  : 	}while(1);
; 511  : }

	pop	ecx
	ret	20					; 00000014H
$L57200:

; 479  : 
; 480  : 			if (str[str_left]==OS_SLASH)

	mov	cl, BYTE PTR [ebx+eax]
	xor	edx, edx
	cmp	cl, 92					; 0000005cH
	pop	edi
	sete	dl
	pop	esi
	pop	ebp
	mov	eax, edx
	pop	ebx

; 510  : 	}while(1);
; 511  : }

	pop	ecx
	ret	20					; 00000014H
?match_in_wild@XFindFile@@IAEKPBD0JJPAPAD@Z ENDP	; XFindFile::match_in_wild
_TEXT	ENDS
PUBLIC	?fstrrexp_eq@XFindFile@@IAEKPBD0PAPAD@Z		; XFindFile::fstrrexp_eq
EXTRN	@fstrcpy_tolower@8:NEAR
; Function compile flags: /Ogty
_TEXT	SEGMENT
_exp$ = 8
_str$ = 12
_partial$ = 16
_this$ = -4
_new_exp$57218 = 12
_new_str$57220 = -8
?fstrrexp_eq@XFindFile@@IAEKPBD0PAPAD@Z PROC NEAR	; XFindFile::fstrrexp_eq
; _this$ = ecx

; 514  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 515  : 	I32 len_exp,len_str;
; 516  : 
; 517  : 	D_ASSERT(exp);D_ASSERT(str);
; 518  : 	
; 519  : 	len_exp=fstrlen(exp);

	mov	ecx, DWORD PTR _exp$[ebp]
	push	edi
	call	@fstrlen@4

; 520  : 	len_str=fstrlen(str);

	mov	ebx, DWORD PTR _str$[ebp]
	mov	edi, eax
	mov	ecx, ebx
	call	@fstrlen@4
	mov	esi, eax

; 521  : 
; 522  : 	/* convert the strings to lower case, if not case sensitive */
; 523  : 	if (!state.case_sensitive)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	test	ch, 1
	jne	SHORT $L58498

; 524  : 	{
; 525  : 		char *new_exp=(char *)_alloca(len_exp+1);

	lea	eax, DWORD PTR [edi+1]
	add	eax, 3
	and	al, -4					; fffffffcH
	call	__alloca_probe

; 526  : 		char *new_str=(char *)_alloca(len_str+1);

	lea	eax, DWORD PTR [esi+1]
	mov	DWORD PTR _new_exp$57218[ebp], esp
	add	eax, 3
	and	al, -4					; fffffffcH
	call	__alloca_probe

; 527  : 
; 528  : 		fstrcpy_tolower(new_exp,exp);

	mov	edx, DWORD PTR _exp$[ebp]
	mov	ecx, DWORD PTR _new_exp$57218[ebp]
	mov	DWORD PTR _new_str$57220[ebp], esp
	call	@fstrcpy_tolower@8

; 529  : 		fstrcpy_tolower(new_str,str);

	mov	edx, ebx
	mov	ebx, DWORD PTR _new_str$57220[ebp]
	mov	ecx, ebx
	call	@fstrcpy_tolower@8

; 530  : 
; 531  : 		exp=new_exp;

	mov	edx, DWORD PTR _new_exp$57218[ebp]

; 532  : 		str=new_str;

	jmp	SHORT $L57217
$L58498:
	mov	edx, DWORD PTR _exp$[ebp]
$L57217:

; 533  : 	}
; 534  : 
; 535  : 	/* if either string is empty */
; 536  : 	if ((!len_exp) || (!len_str))

	test	edi, edi
	je	$L57223
	test	esi, esi
	je	SHORT $L57224

; 542  : 	}
; 543  : 
; 544  : 	len_str--;len_exp--;

	dec	esi
	dec	edi
$L57225:

; 545  : 
; 546  : 	do
; 547  : 	{
; 548  : 		U32 key1,key2;
; 549  : 
; 550  : 		key1=exp[len_exp--];

	movsx	eax, BYTE PTR [edi+edx]

; 551  : 		key2=str[len_str--];

	movsx	ecx, BYTE PTR [esi+ebx]
	dec	edi
	dec	esi

; 552  : 
; 553  : 		if (key1=='*')

	cmp	eax, 42					; 0000002aH
	je	SHORT $L58491

; 559  : 		}
; 560  : 		else if (key1!=key2)

	cmp	eax, ecx
	jne	SHORT $L57224

; 561  : 			return FALSE;
; 562  : 		if (len_exp<0)

	test	edi, edi
	jl	SHORT $L58494

; 567  : 				return MATCH_PARTIAL;
; 568  : 			return FALSE;
; 569  : 		}
; 570  : 		if (len_str<0)

	test	esi, esi
	jge	SHORT $L57225
$L57224:

; 541  : 		return FALSE;

	xor	eax, eax

; 571  : 		{
; 572  : 			/* still have some expression left, but no more string */
; 573  : 			/* no match */
; 574  : 			return FALSE;
; 575  : 		}
; 576  : 	}while(1);
; 577  : 
; 578  : 	return TRUE;
; 579  : }

	lea	esp, DWORD PTR [ebp-20]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$L58491:

; 554  : 		{
; 555  : 			/* special case if * is first character */
; 556  : 			if (len_exp<0)

	test	edi, edi
	jge	SHORT $L57231

; 557  : 				return MATCH_EXACT;

	mov	eax, 2

; 571  : 		{
; 572  : 			/* still have some expression left, but no more string */
; 573  : 			/* no match */
; 574  : 			return FALSE;
; 575  : 		}
; 576  : 	}while(1);
; 577  : 
; 578  : 	return TRUE;
; 579  : }

	lea	esp, DWORD PTR [ebp-20]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$L57231:

; 558  : 			return match_in_wild(exp,str,len_exp,++len_str,partial);

	mov	ecx, DWORD PTR _partial$[ebp]
	inc	esi
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	push	esi
	push	edi
	push	ebx
	push	edx
	call	?match_in_wild@XFindFile@@IAEKPBD0JJPAPAD@Z ; XFindFile::match_in_wild

; 571  : 		{
; 572  : 			/* still have some expression left, but no more string */
; 573  : 			/* no match */
; 574  : 			return FALSE;
; 575  : 		}
; 576  : 	}while(1);
; 577  : 
; 578  : 	return TRUE;
; 579  : }

	lea	esp, DWORD PTR [ebp-20]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$L58494:

; 563  : 		{
; 564  : 			if (len_str<0)

	test	esi, esi
	jge	SHORT $L57235

; 565  : 				return MATCH_EXACT;

	mov	eax, 2

; 571  : 		{
; 572  : 			/* still have some expression left, but no more string */
; 573  : 			/* no match */
; 574  : 			return FALSE;
; 575  : 		}
; 576  : 	}while(1);
; 577  : 
; 578  : 	return TRUE;
; 579  : }

	lea	esp, DWORD PTR [ebp-20]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$L57235:

; 566  : 			if (str[len_str]==OS_SLASH)

	mov	cl, BYTE PTR [esi+ebx]
	xor	eax, eax
	cmp	cl, 92					; 0000005cH
	sete	al

; 571  : 		{
; 572  : 			/* still have some expression left, but no more string */
; 573  : 			/* no match */
; 574  : 			return FALSE;
; 575  : 		}
; 576  : 	}while(1);
; 577  : 
; 578  : 	return TRUE;
; 579  : }

	lea	esp, DWORD PTR [ebp-20]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$L57223:

; 537  : 	{
; 538  : 		/* if both strings are empty */
; 539  : 		if ((!len_str)&&(!len_exp))

	test	esi, esi
	jne	SHORT $L57224

; 540  : 			return TRUE;

	mov	eax, 1

; 571  : 		{
; 572  : 			/* still have some expression left, but no more string */
; 573  : 			/* no match */
; 574  : 			return FALSE;
; 575  : 		}
; 576  : 	}while(1);
; 577  : 
; 578  : 	return TRUE;
; 579  : }

	lea	esp, DWORD PTR [ebp-20]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?fstrrexp_eq@XFindFile@@IAEKPBD0PAPAD@Z ENDP		; XFindFile::fstrrexp_eq
; Function compile flags: /Ogty
_partial$ = -4
?match_request@XFindFile@@IAEKXZ PROC NEAR		; XFindFile::match_request
; _this$ = ecx

; 583  : {

	push	ecx

; 584  : 	char *partial;
; 585  : 
; 586  : 	if ((state.find_directories) && (info->is_dir()))

	mov	eax, DWORD PTR [ecx+44]
	test	ah, 4
	je	SHORT $L57243
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	test	BYTE PTR [edx+40], al

; 587  : 		return TRUE;

	jne	SHORT $L57245
$L57243:

; 588  : 
; 589  : 	U32 ret=fstrrexp_eq(match_str,info->get_full_path(),&partial);

	mov	eax, DWORD PTR [ecx+36]
	mov	edx, DWORD PTR [ecx+4]
	push	esi
	lea	esi, DWORD PTR _partial$[esp+8]
	mov	eax, DWORD PTR [eax+20]
	push	esi
	push	eax
	push	edx
	call	?fstrrexp_eq@XFindFile@@IAEKPBD0PAPAD@Z	; XFindFile::fstrrexp_eq

; 590  : 
; 591  : 	if (!ret)

	neg	eax
	sbb	eax, eax
	pop	esi
	neg	eax
$L57245:

; 592  : 		return FALSE;
; 593  : 
; 594  : 	return TRUE;
; 595  : }

	pop	ecx
	ret	0
?match_request@XFindFile@@IAEKXZ ENDP			; XFindFile::match_request
; Function compile flags: /Ogty
_path$ = 8
_info$ = 12
_this$ = -4
_file_part$ = 8
?set_path@XFindInfo@@IAEXPBDPAU_WIN32_FIND_DATAA@@@Z PROC NEAR ; XFindInfo::set_path
; _this$ = ecx

; 598  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx

; 599  : 	char *file_part;
; 600  : 
; 601  : 	U32 size=GetFullPathName(path,0,null,&file_part);

	mov	ebx, DWORD PTR _path$[ebp]
	push	esi
	lea	eax, DWORD PTR _file_part$[ebp]
	push	edi
	push	eax
	push	0
	push	0
	push	ebx
	mov	DWORD PTR _this$[ebp], ecx
	call	DWORD PTR __imp__GetFullPathNameA@16
	mov	esi, eax

; 602  : 	char *tmp_path=(char *)_alloca(size);

	add	eax, 3
	and	al, -4					; fffffffcH
	call	__alloca_probe

; 603  : 	GetFullPathName(path,size,tmp_path,&file_part);

	lea	ecx, DWORD PTR _file_part$[ebp]
	mov	edi, esp
	push	ecx
	push	edi
	push	esi
	push	ebx
	call	DWORD PTR __imp__GetFullPathNameA@16

; 604  : 
; 605  : 	if (file_part)

	mov	eax, DWORD PTR _file_part$[ebp]
	test	eax, eax
	je	SHORT $L57256

; 606  : 	{
; 607  : 		/* chop off filename */
; 608  : 		if (file_part > tmp_path)

	cmp	eax, edi
	jbe	SHORT $L57256

; 609  : 			file_part[-1]=0;

	mov	BYTE PTR [eax-1], 0
$L57256:

; 610  : 	}
; 611  : 
; 612  : 	set(tmp_path,info);

	mov	edx, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	push	edx
	push	edi
	call	?set@XFindInfo@@IAEXPBDPAU_WIN32_FIND_DATAA@@@Z ; XFindInfo::set

; 613  : }

	lea	esp, DWORD PTR [ebp-16]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?set_path@XFindInfo@@IAEXPBDPAU_WIN32_FIND_DATAA@@@Z ENDP ; XFindInfo::set_path
_TEXT	ENDS
EXTRN	?copy@StrGrow@@QAEXPBD@Z:NEAR			; StrGrow::copy
EXTRN	?path_append@StrGrow@@QAEXPBD@Z:NEAR		; StrGrow::path_append
; Function compile flags: /Ogty
_TEXT	SEGMENT
_path$ = 8
_info$ = 12
?set@XFindInfo@@IAEXPBDPAU_WIN32_FIND_DATAA@@@Z PROC NEAR ; XFindInfo::set
; _this$ = ecx

; 616  : {

	push	esi
	mov	esi, ecx

; 617  : 	D_ASSERT(path);D_ASSERT(info);
; 618  : 
; 619  : 	flags.reset();
; 620  : 
; 621  : 	if (info->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)

	mov	ecx, DWORD PTR _info$[esp]
	push	edi
	mov	DWORD PTR [esi+40], 0
	test	BYTE PTR [ecx], 16			; 00000010H
	je	SHORT $L57262

; 622  : 		flags.directory=TRUE;

	mov	DWORD PTR [esi+40], 1
$L57262:

; 623  : 	if (info->dwFileAttributes & FILE_ATTRIBUTE_HIDDEN)

	test	BYTE PTR [ecx], 2
	je	SHORT $L57263

; 624  : 		flags.hidden=TRUE;

	mov	eax, DWORD PTR [esi+40]
	or	al, 4
	mov	DWORD PTR [esi+40], eax
$L57263:

; 625  : 	if (info->dwFileAttributes & FILE_ATTRIBUTE_READONLY)

	test	BYTE PTR [ecx], 1
	je	SHORT $L57264

; 626  : 		flags.read_only=TRUE;

	mov	eax, DWORD PTR [esi+40]
	or	al, 2
	mov	DWORD PTR [esi+40], eax
$L57264:

; 627  : 
; 628  : 	name=info->cFileName;

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	mov	DWORD PTR [esi+8], eax
	je	SHORT $L58530
	mov	edx, DWORD PTR [esi+4]
	add	edx, eax
	mov	DWORD PTR [esi+12], edx
$L58530:
	lea	edi, DWORD PTR [ecx+44]
	mov	ecx, esi
	push	edi
	call	?copy@StrGrow@@QAEXPBD@Z		; StrGrow::copy

; 629  : 	full_path=path;

	mov	eax, DWORD PTR [esi+20]
	add	esi, 20					; 00000014H
	test	eax, eax
	mov	DWORD PTR [esi+8], eax
	je	SHORT $L58540
	mov	ecx, DWORD PTR [esi+4]
	add	ecx, eax
	mov	DWORD PTR [esi+12], ecx
$L58540:
	mov	edx, DWORD PTR _path$[esp+4]
	mov	ecx, esi
	push	edx
	call	?copy@StrGrow@@QAEXPBD@Z		; StrGrow::copy

; 630  : 
; 631  : 	full_path.path_append(info->cFileName);

	push	edi
	mov	ecx, esi
	call	?path_append@StrGrow@@QAEXPBD@Z		; StrGrow::path_append
	pop	edi
	pop	esi

; 632  : }

	ret	8
?set@XFindInfo@@IAEXPBDPAU_WIN32_FIND_DATAA@@@Z ENDP	; XFindInfo::set
_TEXT	ENDS
EXTRN	@fpath_append@8:NEAR
xdata$x	SEGMENT
$T58581	DD	0ffffffffH
	DD	FLAT:$L58545
	DD	00H
	DD	FLAT:$L58546
$T58579	DD	019930520H
	DD	02H
	DD	FLAT:$T58581
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
_TEXT	SEGMENT
_Path$ = 8
_add_path$ = 12
_search$ = 16
_this$ = -24
$T58544 = -20
__$EHRec$ = -12
??0XFindLevel@@QAE@PBD00@Z PROC NEAR			; XFindLevel::XFindLevel
; _this$ = ecx

; 635  : {

	push	-1
	push	$L58580
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	esi, ecx
	xor	eax, eax
	mov	DWORD PTR _this$[esp+28], esi
	mov	DWORD PTR [esi], -1
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR __$EHRec$[esp+36], eax
	mov	DWORD PTR [esi+8], eax

; 636  : 	if (add_path)

	mov	edx, DWORD PTR _add_path$[esp+24]
	mov	BYTE PTR __$EHRec$[esp+36], 1
	cmp	edx, eax
	je	SHORT $L57272

; 637  : 		path=(char *)fpath_append(Path,add_path);

	mov	ecx, DWORD PTR _Path$[esp+24]
	call	@fpath_append@8
	mov	DWORD PTR [esi+8], eax

; 638  : 	else

	jmp	SHORT $L58566
$L57272:

; 639  : 		path=CStr(Path);

	mov	eax, DWORD PTR _Path$[esp+24]
	lea	ecx, DWORD PTR $T58544[esp+28]
	push	eax
	call	??0CStr@@QAE@PBD@Z			; CStr::CStr
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [esi+8], ecx
$L58566:

; 640  : 
; 641  : 	str=(char *)fpath_append(path,search);

	mov	ecx, DWORD PTR [esi+8]
	mov	edx, DWORD PTR _search$[esp+24]
	call	@fpath_append@8

; 642  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR [esi+4], eax
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 24					; 00000018H
	ret	12					; 0000000cH
_TEXT	ENDS
text$x	SEGMENT
$L58545:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	??1autochar@@QAE@XZ			; autochar::~autochar
$L58546:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1autochar@@QAE@XZ			; autochar::~autochar
$L58580:
	mov	eax, OFFSET FLAT:$T58579
	jmp	___CxxFrameHandler
text$x	ENDS
??0XFindLevel@@QAE@PBD00@Z ENDP				; XFindLevel::XFindLevel
; Function compile flags: /Ogty
_TEXT	SEGMENT
_data$ = 8
?init@XFindLevel@@QAEKPAU_WIN32_FIND_DATAA@@@Z PROC NEAR ; XFindLevel::init
; _this$ = ecx

; 645  : {

	push	esi
	mov	esi, ecx

; 646  : 	handle=FindFirstFile(str,data);

	mov	ecx, DWORD PTR _data$[esp]
	mov	eax, DWORD PTR [esi+4]
	push	ecx
	push	eax
	call	DWORD PTR __imp__FindFirstFileA@8

; 647  : 	if (handle==INVALID_HANDLE_VALUE)

	xor	edx, edx
	cmp	eax, -1
	setne	dl
	mov	DWORD PTR [esi], eax
	mov	eax, edx
	pop	esi

; 648  : 		return FALSE;
; 649  : 	return TRUE;
; 650  : }

	ret	4
?init@XFindLevel@@QAEKPAU_WIN32_FIND_DATAA@@@Z ENDP	; XFindLevel::init
_TEXT	ENDS
EXTRN	__imp__FindNextFileA@8:NEAR
; Function compile flags: /Ogty
_TEXT	SEGMENT
_data$ = 8
?next@XFindLevel@@QAEKPAU_WIN32_FIND_DATAA@@@Z PROC NEAR ; XFindLevel::next
; _this$ = ecx

; 654  : 	if (!FindNextFile(handle,data))

	mov	eax, DWORD PTR _data$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	push	ecx
	call	DWORD PTR __imp__FindNextFileA@8
	neg	eax
	sbb	eax, eax
	neg	eax

; 655  : 		return FALSE;
; 656  : 
; 657  : 	return TRUE;
; 658  : }

	ret	4
?next@XFindLevel@@QAEKPAU_WIN32_FIND_DATAA@@@Z ENDP	; XFindLevel::next
_TEXT	ENDS
PUBLIC	??0?$XChain@VCSysObj@@@@QAE@XZ			; XChain<CSysObj>::XChain<CSysObj>
; Function compile flags: /Ogty
; File C:\duke4\xcore\xclass.h
;	COMDAT ??0?$XChain@VCSysObj@@@@QAE@XZ
_TEXT	SEGMENT
??0?$XChain@VCSysObj@@@@QAE@XZ PROC NEAR		; XChain<CSysObj>::XChain<CSysObj>, COMDAT
; _this$ = ecx

; 830  : 	XChain(void) : head(null),tail(null) {}

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$XChain@VCSysObj@@@@QAE@XZ ENDP			; XChain<CSysObj>::XChain<CSysObj>
_TEXT	ENDS
PUBLIC	??0?$XChain@VCSysObj@@@@QAE@K@Z			; XChain<CSysObj>::XChain<CSysObj>
; Function compile flags: /Ogty
;	COMDAT ??0?$XChain@VCSysObj@@@@QAE@K@Z
_TEXT	SEGMENT
_owned$ = 8
??0?$XChain@VCSysObj@@@@QAE@K@Z PROC NEAR		; XChain<CSysObj>::XChain<CSysObj>, COMDAT
; _this$ = ecx

; 831  : 	XChain(U32 owned) : head(null),tail(null),xchain_state(owned) {}

	mov	eax, ecx
	mov	ecx, DWORD PTR _owned$[esp-4]
	shl	ecx, 31					; 0000001fH
	and	ecx, -2147483648			; 80000000H
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], ecx
	ret	4
??0?$XChain@VCSysObj@@@@QAE@K@Z ENDP			; XChain<CSysObj>::XChain<CSysObj>
_TEXT	ENDS
PUBLIC	?get_next@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z ; XChain<CSysObj>::get_next
; Function compile flags: /Ogty
;	COMDAT ?get_next@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z
_TEXT	SEGMENT
_ptr$ = 8
?get_next@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z PROC NEAR ; XChain<CSysObj>::get_next, COMDAT
; _this$ = ecx

; 840  : 	TYPE *get_next(TYPE *ptr){return ptr->next;}

	mov	eax, DWORD PTR _ptr$[esp-4]
	mov	eax, DWORD PTR [eax+4]
	ret	4
?get_next@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z ENDP ; XChain<CSysObj>::get_next
_TEXT	ENDS
PUBLIC	?get_prev@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z ; XChain<CSysObj>::get_prev
; Function compile flags: /Ogty
;	COMDAT ?get_prev@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z
_TEXT	SEGMENT
_ptr$ = 8
?get_prev@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z PROC NEAR ; XChain<CSysObj>::get_prev, COMDAT
; _this$ = ecx

; 841  : 	TYPE *get_prev(TYPE *ptr){return ptr->prev;}

	mov	eax, DWORD PTR _ptr$[esp-4]
	mov	eax, DWORD PTR [eax+8]
	ret	4
?get_prev@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z ENDP ; XChain<CSysObj>::get_prev
_TEXT	ENDS
PUBLIC	?get_head@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ ; XChain<CSysObj>::get_head
; Function compile flags: /Ogty
;	COMDAT ?get_head@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ
_TEXT	SEGMENT
?get_head@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ PROC NEAR ; XChain<CSysObj>::get_head, COMDAT
; _this$ = ecx

; 847  : 	inline TYPE *get_head(void){return head;}

	mov	eax, DWORD PTR [ecx]
	ret	0
?get_head@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ ENDP	; XChain<CSysObj>::get_head
_TEXT	ENDS
PUBLIC	?get_tail@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ ; XChain<CSysObj>::get_tail
; Function compile flags: /Ogty
;	COMDAT ?get_tail@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ
_TEXT	SEGMENT
?get_tail@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ PROC NEAR ; XChain<CSysObj>::get_tail, COMDAT
; _this$ = ecx

; 848  : 	inline TYPE *get_tail(void){return tail;}

	mov	eax, DWORD PTR [ecx+4]
	ret	0
?get_tail@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ ENDP	; XChain<CSysObj>::get_tail
_TEXT	ENDS
PUBLIC	??1?$XChain@VCSysObj@@@@QAE@XZ			; XChain<CSysObj>::~XChain<CSysObj>
PUBLIC	??_7CSysObj@@6B@				; CSysObj::`vftable'
EXTRN	__purecall:NEAR
EXTRN	?_global@@3PAVXGlobal@@A:DWORD			; _global
EXTRN	?unreg_global_object@XGlobal@@QAEXPAVCSysObj@@@Z:NEAR ; XGlobal::unreg_global_object
;	COMDAT ??_7CSysObj@@6B@
; File C:\duke4\xcore\xcore.h
CONST	SEGMENT
??_7CSysObj@@6B@ DD FLAT:__purecall			; CSysObj::`vftable'
; Function compile flags: /Ogty
; File C:\duke4\xcore\xclass.h
CONST	ENDS
;	COMDAT ??1?$XChain@VCSysObj@@@@QAE@XZ
_TEXT	SEGMENT
??1?$XChain@VCSysObj@@@@QAE@XZ PROC NEAR		; XChain<CSysObj>::~XChain<CSysObj>, COMDAT
; _this$ = ecx

; 853  : {

	push	esi
	mov	esi, ecx

; 854  : 	if (xchain_state.owned)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	jns	SHORT $L58630

; 855  : 	{
; 856  : 		while(head)

	cmp	DWORD PTR [esi], 0
	je	SHORT $L58630
	push	ebx
	push	edi
$L57376:

; 857  : 		{
; 858  : 			TYPE *tmp=(TYPE *)head->next;

	mov	eax, DWORD PTR [esi]

; 859  : 			delete head;

	mov	edi, eax
	mov	ebx, DWORD PTR [eax+4]
	test	edi, edi
	je	SHORT $L58611
	mov	DWORD PTR [edi], OFFSET FLAT:??_7CSysObj@@6B@ ; CSysObj::`vftable'
	mov	ecx, DWORD PTR ?_global@@3PAVXGlobal@@A	; _global
	push	edi
	call	?unreg_global_object@XGlobal@@QAEXPAVCSysObj@@@Z ; XGlobal::unreg_global_object
	mov	ecx, edi
	call	@xfree@4
$L58611:
	test	ebx, ebx

; 860  : 			head=tmp;

	mov	DWORD PTR [esi], ebx
	jne	SHORT $L57376
	pop	edi
	pop	ebx
$L58630:

; 861  : 		}
; 862  : 	}
; 863  : 	head=null;

	mov	DWORD PTR [esi], 0

; 864  : 	tail=null;

	mov	DWORD PTR [esi+4], 0
	pop	esi

; 865  : }

	ret	0
??1?$XChain@VCSysObj@@@@QAE@XZ ENDP			; XChain<CSysObj>::~XChain<CSysObj>
_TEXT	ENDS
PUBLIC	?lose_list@?$XChain@VCSysObj@@@@QAEXXZ		; XChain<CSysObj>::lose_list
; Function compile flags: /Ogty
;	COMDAT ?lose_list@?$XChain@VCSysObj@@@@QAEXXZ
_TEXT	SEGMENT
?lose_list@?$XChain@VCSysObj@@@@QAEXXZ PROC NEAR	; XChain<CSysObj>::lose_list, COMDAT
; _this$ = ecx

; 870  : 	head=null;tail=null;xchain_state.count=0;

	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [ecx], 0
	and	eax, -2147483648			; 80000000H
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], eax

; 871  : }

	ret	0
?lose_list@?$XChain@VCSysObj@@@@QAEXXZ ENDP		; XChain<CSysObj>::lose_list
_TEXT	ENDS
PUBLIC	?free_list@?$XChain@VCSysObj@@@@QAEXXZ		; XChain<CSysObj>::free_list
; Function compile flags: /Ogty
;	COMDAT ?free_list@?$XChain@VCSysObj@@@@QAEXXZ
_TEXT	SEGMENT
?free_list@?$XChain@VCSysObj@@@@QAEXXZ PROC NEAR	; XChain<CSysObj>::free_list, COMDAT
; _this$ = ecx

; 875  : {

	push	esi
	mov	esi, ecx

; 876  : 	if (xchain_state.owned)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	jns	SHORT $L58656

; 877  : 	{
; 878  : 		while(head)

	cmp	DWORD PTR [esi], 0
	je	SHORT $L58656
	push	ebx
	push	edi
$L57392:

; 879  : 		{
; 880  : 			TYPE *tmp=(TYPE *)head->next;

	mov	eax, DWORD PTR [esi]

; 881  : 			delete head;

	mov	edi, eax
	mov	ebx, DWORD PTR [eax+4]
	test	edi, edi
	je	SHORT $L58637
	mov	DWORD PTR [edi], OFFSET FLAT:??_7CSysObj@@6B@ ; CSysObj::`vftable'
	mov	ecx, DWORD PTR ?_global@@3PAVXGlobal@@A	; _global
	push	edi
	call	?unreg_global_object@XGlobal@@QAEXPAVCSysObj@@@Z ; XGlobal::unreg_global_object
	mov	ecx, edi
	call	@xfree@4
$L58637:
	test	ebx, ebx

; 882  : 			head=tmp;

	mov	DWORD PTR [esi], ebx
	jne	SHORT $L57392
	pop	edi
	pop	ebx
$L58656:

; 883  : 		}
; 884  : 	}
; 885  : 	head=null;tail=null;

	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+4], 0
	pop	esi

; 886  : }

	ret	0
?free_list@?$XChain@VCSysObj@@@@QAEXXZ ENDP		; XChain<CSysObj>::free_list
_TEXT	ENDS
PUBLIC	?add_head@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z ; XChain<CSysObj>::add_head
; Function compile flags: /Ogty
;	COMDAT ?add_head@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z
_TEXT	SEGMENT
_ptr$ = 8
?add_head@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z PROC NEAR ; XChain<CSysObj>::add_head, COMDAT
; _this$ = ecx

; 891  : 	ptr->next=head;

	mov	eax, DWORD PTR _ptr$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx

; 892  : 	ptr->prev=null;

	mov	DWORD PTR [eax+8], 0

; 893  : 	if (head)

	mov	edx, DWORD PTR [ecx]
	test	edx, edx
	je	SHORT $L57402

; 894  : 		head->prev=ptr;

	mov	DWORD PTR [edx+8], eax

; 897  : 	
; 898  : 	head=ptr;

	mov	DWORD PTR [ecx], eax

; 899  : 
; 900  : 	return head;
; 901  : }

	ret	4
$L57402:

; 895  : 	else
; 896  : 		tail=ptr;

	mov	DWORD PTR [ecx+4], eax

; 897  : 	
; 898  : 	head=ptr;

	mov	DWORD PTR [ecx], eax

; 899  : 
; 900  : 	return head;
; 901  : }

	ret	4
?add_head@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z ENDP ; XChain<CSysObj>::add_head
_TEXT	ENDS
PUBLIC	?add_tail@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z ; XChain<CSysObj>::add_tail
; Function compile flags: /Ogty
;	COMDAT ?add_tail@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z
_TEXT	SEGMENT
_ptr$ = 8
?add_tail@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z PROC NEAR ; XChain<CSysObj>::add_tail, COMDAT
; _this$ = ecx

; 906  : 	ptr->prev=tail;

	mov	eax, DWORD PTR _ptr$[esp-4]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+8], edx

; 907  : 	ptr->next=null;

	mov	DWORD PTR [eax+4], 0

; 908  : 	if (tail)

	mov	edx, DWORD PTR [ecx+4]
	test	edx, edx
	je	SHORT $L57408

; 909  : 		tail->next=ptr;

	mov	DWORD PTR [edx+4], eax

; 912  : 	
; 913  : 	tail=ptr;

	mov	DWORD PTR [ecx+4], eax

; 914  : 
; 915  : 	return tail;
; 916  : }

	ret	4
$L57408:

; 910  : 	else
; 911  : 		head=ptr;

	mov	DWORD PTR [ecx], eax

; 912  : 	
; 913  : 	tail=ptr;

	mov	DWORD PTR [ecx+4], eax

; 914  : 
; 915  : 	return tail;
; 916  : }

	ret	4
?add_tail@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z ENDP ; XChain<CSysObj>::add_tail
_TEXT	ENDS
PUBLIC	?remove_head@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ ; XChain<CSysObj>::remove_head
; Function compile flags: /Ogty
;	COMDAT ?remove_head@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ
_TEXT	SEGMENT
?remove_head@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ PROC NEAR ; XChain<CSysObj>::remove_head, COMDAT
; _this$ = ecx

; 937  : 	if (!head)

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	jne	SHORT $L57414

; 947  : 
; 948  : 	return ret;
; 949  : }

	ret	0
$L57414:

; 938  : 		return null;
; 939  : 
; 940  : 	TYPE *ret=head;
; 941  : 
; 942  : 	head=head->next;

	mov	edx, DWORD PTR [eax+4]

; 943  : 	if (!head)

	test	edx, edx
	mov	DWORD PTR [ecx], edx
	jne	SHORT $L57416

; 944  : 		tail=null;

	mov	DWORD PTR [ecx+4], edx

; 947  : 
; 948  : 	return ret;
; 949  : }

	ret	0
$L57416:

; 945  : 	else
; 946  : 		head->prev=null;

	mov	DWORD PTR [edx+8], 0

; 947  : 
; 948  : 	return ret;
; 949  : }

	ret	0
?remove_head@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ ENDP ; XChain<CSysObj>::remove_head
_TEXT	ENDS
PUBLIC	?remove_tail@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ ; XChain<CSysObj>::remove_tail
; Function compile flags: /Ogty
;	COMDAT ?remove_tail@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ
_TEXT	SEGMENT
?remove_tail@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ PROC NEAR ; XChain<CSysObj>::remove_tail, COMDAT
; _this$ = ecx

; 954  : 	if (!tail)

	mov	eax, DWORD PTR [ecx+4]
	test	eax, eax
	jne	SHORT $L57422

; 964  : 
; 965  : 	return ret;
; 966  : }

	ret	0
$L57422:

; 955  : 		return null;
; 956  : 
; 957  : 	TYPE *ret=tail;
; 958  : 
; 959  : 	tail=tail->prev;

	mov	edx, DWORD PTR [eax+8]

; 960  : 	if (!tail)

	test	edx, edx
	mov	DWORD PTR [ecx+4], edx
	jne	SHORT $L57424

; 961  : 		head=null;

	mov	DWORD PTR [ecx], edx

; 964  : 
; 965  : 	return ret;
; 966  : }

	ret	0
$L57424:

; 962  : 	else
; 963  : 		tail->next=null;

	mov	DWORD PTR [edx+4], 0

; 964  : 
; 965  : 	return ret;
; 966  : }

	ret	0
?remove_tail@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ ENDP ; XChain<CSysObj>::remove_tail
_TEXT	ENDS
PUBLIC	?remove@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z ; XChain<CSysObj>::remove
; Function compile flags: /Ogty
;	COMDAT ?remove@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z
_TEXT	SEGMENT
_ptr$ = 8
?remove@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z PROC NEAR ; XChain<CSysObj>::remove, COMDAT
; _this$ = ecx

; 921  : 	if (ptr->prev)

	mov	eax, DWORD PTR _ptr$[esp-4]
	mov	edx, DWORD PTR [eax+8]
	test	edx, edx
	je	SHORT $L57430
	push	esi

; 922  : 		ptr->prev->next=ptr->next;

	mov	esi, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], esi
	pop	esi

; 923  : 	else

	jmp	SHORT $L57431
$L57430:

; 924  : 		head=ptr->next;

	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx], edx
$L57431:

; 925  : 
; 926  : 	if (ptr->next)

	mov	edx, DWORD PTR [eax+4]
	test	edx, edx
	je	SHORT $L57432

; 927  : 		ptr->next->prev=ptr->prev;

	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], ecx

; 930  : 
; 931  : 	return ptr;
; 932  : }

	ret	4
$L57432:

; 928  : 	else
; 929  : 		tail=ptr->prev;

	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+4], edx

; 930  : 
; 931  : 	return ptr;
; 932  : }

	ret	4
?remove@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z ENDP ; XChain<CSysObj>::remove
; Function compile flags: /Ogty
; File C:\duke4\xcore\xstring.h
_TEXT	ENDS
;	COMDAT ?reset@StrGrow@@QAEXXZ
_TEXT	SEGMENT
?reset@StrGrow@@QAEXXZ PROC NEAR			; StrGrow::reset, COMDAT
; _this$ = ecx

; 326  : 		cur=base;

	mov	eax, DWORD PTR [ecx]

; 327  : 		if (base)

	test	eax, eax
	mov	DWORD PTR [ecx+8], eax
	je	SHORT $L55968

; 328  : 			end=cur+size;

	mov	edx, DWORD PTR [ecx+4]
	add	edx, eax
	mov	DWORD PTR [ecx+12], edx
$L55968:

; 329  : 	}

	ret	0
?reset@StrGrow@@QAEXXZ ENDP				; StrGrow::reset
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??0StrGrow@@QAE@KK@Z
_TEXT	SEGMENT
_size$ = 8
_IncSize$ = 12
??0StrGrow@@QAE@KK@Z PROC NEAR				; StrGrow::StrGrow, COMDAT
; _this$ = ecx

; 331  : 	{

	mov	eax, DWORD PTR _size$[esp-4]
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [eax+63]
	and	ecx, -64				; ffffffc0H
	mov	DWORD PTR [esi+4], ecx
	call	@xmalloc@4
	mov	ecx, DWORD PTR _IncSize$[esp]
	mov	DWORD PTR [esi], eax

; 332  : 		reset();

	test	eax, eax
	mov	DWORD PTR [esi+16], ecx
	mov	DWORD PTR [esi+8], eax
	je	SHORT $L58681
	mov	edx, DWORD PTR [esi+4]
	add	edx, eax
	mov	DWORD PTR [esi+12], edx
$L58681:

; 333  : 	}

	mov	eax, esi
	pop	esi
	ret	8
??0StrGrow@@QAE@KK@Z ENDP				; StrGrow::StrGrow
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??1StrGrow@@QAE@XZ
_TEXT	SEGMENT
??1StrGrow@@QAE@XZ PROC NEAR				; StrGrow::~StrGrow, COMDAT
; _this$ = ecx
	mov	ecx, DWORD PTR [ecx]
	jmp	@xfree@4
??1StrGrow@@QAE@XZ ENDP					; StrGrow::~StrGrow
_TEXT	ENDS
PUBLIC	??_7XBufferReadInt@@6B@				; XBufferReadInt::`vftable'
PUBLIC	??_GXBufferReadInt@@UAEPAXI@Z			; XBufferReadInt::`scalar deleting destructor'
PUBLIC	??_EXBufferReadInt@@UAEPAXI@Z			; XBufferReadInt::`vector deleting destructor'
EXTRN	?read_direct@XBufferReadInt@@MAEKPAXKAAK@Z:NEAR	; XBufferReadInt::read_direct
;	COMDAT ??_7XBufferReadInt@@6B@
; File C:\duke4\xcore\xcore.h
CONST	SEGMENT
??_7XBufferReadInt@@6B@ DD FLAT:?read_direct@XBufferReadInt@@MAEKPAXKAAK@Z ; XBufferReadInt::`vftable'
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:??_EXBufferReadInt@@UAEPAXI@Z
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ??_GXBufferReadInt@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_GXBufferReadInt@@UAEPAXI@Z PROC NEAR			; XBufferReadInt::`scalar deleting destructor', COMDAT
; _this$ = ecx
	mov	al, BYTE PTR ___flags$[esp-4]
	push	esi
	mov	esi, ecx
	test	al, 1
	mov	DWORD PTR [esi], OFFSET FLAT:??_7XBufferReadInt@@6B@ ; XBufferReadInt::`vftable'
	je	SHORT $L58696
	call	@xfree@4
$L58696:
	mov	eax, esi
	pop	esi
	ret	4
??_GXBufferReadInt@@UAEPAXI@Z ENDP			; XBufferReadInt::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??1XBufferReadInt@@UAE@XZ			; XBufferReadInt::~XBufferReadInt
EXTRN	??_M@YGXPAXIHP6EX0@Z@Z:NEAR			; `eh vector destructor iterator'
; Function compile flags: /Ogty
;	COMDAT ??_EXBufferReadInt@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_EXBufferReadInt@@UAEPAXI@Z PROC NEAR			; XBufferReadInt::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebx
	mov	bl, BYTE PTR ___flags$[esp]
	push	esi
	mov	esi, ecx
	test	bl, 2
	je	SHORT $L56059
	mov	eax, DWORD PTR [esi-4]
	push	edi
	lea	edi, DWORD PTR [esi-4]
	push	OFFSET FLAT:??1XBufferReadInt@@UAE@XZ	; XBufferReadInt::~XBufferReadInt
	push	eax
	push	8
	push	esi
	call	??_M@YGXPAXIHP6EX0@Z@Z			; `eh vector destructor iterator'
	test	bl, 1
	je	SHORT $L58701
	mov	ecx, edi
	call	@xfree@4
$L58701:
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	ret	4
$L56059:
	test	bl, 1
	mov	DWORD PTR [esi], OFFSET FLAT:??_7XBufferReadInt@@6B@ ; XBufferReadInt::`vftable'
	je	SHORT $L58707
	mov	ecx, esi
	call	@xfree@4
$L58707:
	mov	eax, esi
	pop	esi
	pop	ebx
	ret	4
??_EXBufferReadInt@@UAEPAXI@Z ENDP			; XBufferReadInt::`vector deleting destructor'
; Function compile flags: /Ogty
; File C:\duke4\xcore\xstream.h
_TEXT	ENDS
;	COMDAT ??1XBufferReadInt@@UAE@XZ
_TEXT	SEGMENT
??1XBufferReadInt@@UAE@XZ PROC NEAR			; XBufferReadInt::~XBufferReadInt, COMDAT
; _this$ = ecx

; 37   : 	virtual ~XBufferReadInt(void){}

	mov	DWORD PTR [ecx], OFFSET FLAT:??_7XBufferReadInt@@6B@ ; XBufferReadInt::`vftable'
	ret	0
??1XBufferReadInt@@UAE@XZ ENDP				; XBufferReadInt::~XBufferReadInt
_TEXT	ENDS
PUBLIC	??_7XBufferWriteInt@@6B@			; XBufferWriteInt::`vftable'
PUBLIC	??_GXBufferWriteInt@@UAEPAXI@Z			; XBufferWriteInt::`scalar deleting destructor'
PUBLIC	??_EXBufferWriteInt@@UAEPAXI@Z			; XBufferWriteInt::`vector deleting destructor'
EXTRN	?write_direct@XBufferWriteInt@@MAEKPBXKAAK@Z:NEAR ; XBufferWriteInt::write_direct
;	COMDAT ??_7XBufferWriteInt@@6B@
; File C:\duke4\xcore\xcore.h
CONST	SEGMENT
??_7XBufferWriteInt@@6B@ DD FLAT:?write_direct@XBufferWriteInt@@MAEKPBXKAAK@Z ; XBufferWriteInt::`vftable'
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:??_EXBufferWriteInt@@UAEPAXI@Z
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ??_GXBufferWriteInt@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_GXBufferWriteInt@@UAEPAXI@Z PROC NEAR		; XBufferWriteInt::`scalar deleting destructor', COMDAT
; _this$ = ecx
	mov	al, BYTE PTR ___flags$[esp-4]
	push	esi
	mov	esi, ecx
	test	al, 1
	mov	DWORD PTR [esi], OFFSET FLAT:??_7XBufferWriteInt@@6B@ ; XBufferWriteInt::`vftable'
	je	SHORT $L58718
	call	@xfree@4
$L58718:
	mov	eax, esi
	pop	esi
	ret	4
??_GXBufferWriteInt@@UAEPAXI@Z ENDP			; XBufferWriteInt::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??1XBufferWriteInt@@UAE@XZ			; XBufferWriteInt::~XBufferWriteInt
; Function compile flags: /Ogty
;	COMDAT ??_EXBufferWriteInt@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_EXBufferWriteInt@@UAEPAXI@Z PROC NEAR		; XBufferWriteInt::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebx
	mov	bl, BYTE PTR ___flags$[esp]
	push	esi
	mov	esi, ecx
	test	bl, 2
	je	SHORT $L56111
	mov	eax, DWORD PTR [esi-4]
	push	edi
	lea	edi, DWORD PTR [esi-4]
	push	OFFSET FLAT:??1XBufferWriteInt@@UAE@XZ	; XBufferWriteInt::~XBufferWriteInt
	push	eax
	push	8
	push	esi
	call	??_M@YGXPAXIHP6EX0@Z@Z			; `eh vector destructor iterator'
	test	bl, 1
	je	SHORT $L58723
	mov	ecx, edi
	call	@xfree@4
$L58723:
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	ret	4
$L56111:
	test	bl, 1
	mov	DWORD PTR [esi], OFFSET FLAT:??_7XBufferWriteInt@@6B@ ; XBufferWriteInt::`vftable'
	je	SHORT $L58729
	mov	ecx, esi
	call	@xfree@4
$L58729:
	mov	eax, esi
	pop	esi
	pop	ebx
	ret	4
??_EXBufferWriteInt@@UAEPAXI@Z ENDP			; XBufferWriteInt::`vector deleting destructor'
; Function compile flags: /Ogty
; File C:\duke4\xcore\xstream.h
_TEXT	ENDS
;	COMDAT ??1XBufferWriteInt@@UAE@XZ
_TEXT	SEGMENT
??1XBufferWriteInt@@UAE@XZ PROC NEAR			; XBufferWriteInt::~XBufferWriteInt, COMDAT
; _this$ = ecx

; 56   : 	virtual ~XBufferWriteInt(void){}

	mov	DWORD PTR [ecx], OFFSET FLAT:??_7XBufferWriteInt@@6B@ ; XBufferWriteInt::`vftable'
	ret	0
??1XBufferWriteInt@@UAE@XZ ENDP				; XBufferWriteInt::~XBufferWriteInt
_TEXT	ENDS
PUBLIC	??1XStreamRdDirect@@UAE@XZ			; XStreamRdDirect::~XStreamRdDirect
PUBLIC	??_GXStreamRdDirect@@UAEPAXI@Z			; XStreamRdDirect::`scalar deleting destructor'
; Function compile flags: /Ogty
;	COMDAT ??_GXStreamRdDirect@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_GXStreamRdDirect@@UAEPAXI@Z PROC NEAR		; XStreamRdDirect::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1XStreamRdDirect@@UAE@XZ		; XStreamRdDirect::~XStreamRdDirect
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $L58737
	mov	ecx, esi
	call	@xfree@4
$L58737:
	mov	eax, esi
	pop	esi
	ret	4
??_GXStreamRdDirect@@UAEPAXI@Z ENDP			; XStreamRdDirect::`scalar deleting destructor'
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??1XStreamRdDirect@@UAE@XZ
_TEXT	SEGMENT
??1XStreamRdDirect@@UAE@XZ PROC NEAR			; XStreamRdDirect::~XStreamRdDirect, COMDAT
; _this$ = ecx

; 71   : 	~XStreamRdDirect(void){}

	mov	DWORD PTR [ecx], OFFSET FLAT:??_7XBufferReadInt@@6B@ ; XBufferReadInt::`vftable'
	ret	0
??1XStreamRdDirect@@UAE@XZ ENDP				; XStreamRdDirect::~XStreamRdDirect
_TEXT	ENDS
PUBLIC	??_EXStreamRdDirect@@UAEPAXI@Z			; XStreamRdDirect::`vector deleting destructor'
; Function compile flags: /Ogty
;	COMDAT ??_EXStreamRdDirect@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_EXStreamRdDirect@@UAEPAXI@Z PROC NEAR		; XStreamRdDirect::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebx
	mov	bl, BYTE PTR ___flags$[esp]
	push	esi
	mov	esi, ecx
	test	bl, 2
	je	SHORT $L56163
	mov	eax, DWORD PTR [esi-4]
	push	edi
	lea	edi, DWORD PTR [esi-4]
	push	OFFSET FLAT:??1XStreamRdDirect@@UAE@XZ	; XStreamRdDirect::~XStreamRdDirect
	push	eax
	push	8
	push	esi
	call	??_M@YGXPAXIHP6EX0@Z@Z			; `eh vector destructor iterator'
	test	bl, 1
	je	SHORT $L58748
	mov	ecx, edi
	call	@xfree@4
$L58748:
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	ret	4
$L56163:
	mov	ecx, esi
	call	??1XStreamRdDirect@@UAE@XZ		; XStreamRdDirect::~XStreamRdDirect
	test	bl, 1
	je	SHORT $L58750
	mov	ecx, esi
	call	@xfree@4
$L58750:
	mov	eax, esi
	pop	esi
	pop	ebx
	ret	4
??_EXStreamRdDirect@@UAEPAXI@Z ENDP			; XStreamRdDirect::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??1XStreamWrDirect@@UAE@XZ			; XStreamWrDirect::~XStreamWrDirect
PUBLIC	??_GXStreamWrDirect@@UAEPAXI@Z			; XStreamWrDirect::`scalar deleting destructor'
; Function compile flags: /Ogty
;	COMDAT ??_GXStreamWrDirect@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_GXStreamWrDirect@@UAEPAXI@Z PROC NEAR		; XStreamWrDirect::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1XStreamWrDirect@@UAE@XZ		; XStreamWrDirect::~XStreamWrDirect
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $L58757
	mov	ecx, esi
	call	@xfree@4
$L58757:
	mov	eax, esi
	pop	esi
	ret	4
??_GXStreamWrDirect@@UAEPAXI@Z ENDP			; XStreamWrDirect::`scalar deleting destructor'
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??1XStreamWrDirect@@UAE@XZ
_TEXT	SEGMENT
??1XStreamWrDirect@@UAE@XZ PROC NEAR			; XStreamWrDirect::~XStreamWrDirect, COMDAT
; _this$ = ecx

; 88   : 	~XStreamWrDirect(void){}

	mov	DWORD PTR [ecx], OFFSET FLAT:??_7XBufferWriteInt@@6B@ ; XBufferWriteInt::`vftable'
	ret	0
??1XStreamWrDirect@@UAE@XZ ENDP				; XStreamWrDirect::~XStreamWrDirect
_TEXT	ENDS
PUBLIC	??_EXStreamWrDirect@@UAEPAXI@Z			; XStreamWrDirect::`vector deleting destructor'
; Function compile flags: /Ogty
;	COMDAT ??_EXStreamWrDirect@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_EXStreamWrDirect@@UAEPAXI@Z PROC NEAR		; XStreamWrDirect::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebx
	mov	bl, BYTE PTR ___flags$[esp]
	push	esi
	mov	esi, ecx
	test	bl, 2
	je	SHORT $L56219
	mov	eax, DWORD PTR [esi-4]
	push	edi
	lea	edi, DWORD PTR [esi-4]
	push	OFFSET FLAT:??1XStreamWrDirect@@UAE@XZ	; XStreamWrDirect::~XStreamWrDirect
	push	eax
	push	8
	push	esi
	call	??_M@YGXPAXIHP6EX0@Z@Z			; `eh vector destructor iterator'
	test	bl, 1
	je	SHORT $L58768
	mov	ecx, edi
	call	@xfree@4
$L58768:
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	ret	4
$L56219:
	mov	ecx, esi
	call	??1XStreamWrDirect@@UAE@XZ		; XStreamWrDirect::~XStreamWrDirect
	test	bl, 1
	je	SHORT $L58770
	mov	ecx, esi
	call	@xfree@4
$L58770:
	mov	eax, esi
	pop	esi
	pop	ebx
	ret	4
??_EXStreamWrDirect@@UAEPAXI@Z ENDP			; XStreamWrDirect::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??1XMemRdBuffer@@UAE@XZ				; XMemRdBuffer::~XMemRdBuffer
PUBLIC	??_GXMemRdBuffer@@UAEPAXI@Z			; XMemRdBuffer::`scalar deleting destructor'
; Function compile flags: /Ogty
;	COMDAT ??_GXMemRdBuffer@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_GXMemRdBuffer@@UAEPAXI@Z PROC NEAR			; XMemRdBuffer::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1XMemRdBuffer@@UAE@XZ			; XMemRdBuffer::~XMemRdBuffer
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $L58777
	mov	ecx, esi
	call	@xfree@4
$L58777:
	mov	eax, esi
	pop	esi
	ret	4
??_GXMemRdBuffer@@UAEPAXI@Z ENDP			; XMemRdBuffer::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_7XMemRdBuffer@@6B@				; XMemRdBuffer::`vftable'
PUBLIC	??_EXMemRdBuffer@@UAEPAXI@Z			; XMemRdBuffer::`vector deleting destructor'
EXTRN	?read@XMemRdBuffer@@UAEKPAXKAAK1@Z:NEAR		; XMemRdBuffer::read
EXTRN	?seek@XMemRdBuffer@@UAEKJ@Z:NEAR		; XMemRdBuffer::seek
;	COMDAT ??_7XMemRdBuffer@@6B@
CONST	SEGMENT
??_7XMemRdBuffer@@6B@ DD FLAT:?read_direct@XBufferReadInt@@MAEKPAXKAAK@Z ; XMemRdBuffer::`vftable'
	DD	FLAT:?read@XMemRdBuffer@@UAEKPAXKAAK1@Z
	DD	FLAT:?seek@XMemRdBuffer@@UAEKJ@Z
	DD	FLAT:??_EXMemRdBuffer@@UAEPAXI@Z
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ??1XMemRdBuffer@@UAE@XZ
_TEXT	SEGMENT
??1XMemRdBuffer@@UAE@XZ PROC NEAR			; XMemRdBuffer::~XMemRdBuffer, COMDAT
; _this$ = ecx

; 109  : 	~XMemRdBuffer(void){}

	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET FLAT:??_7XMemRdBuffer@@6B@ ; XMemRdBuffer::`vftable'
	mov	ecx, DWORD PTR [esi+8]
	call	@xfree@4
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi], OFFSET FLAT:??_7XBufferReadInt@@6B@ ; XBufferReadInt::`vftable'
	pop	esi
	ret	0
??1XMemRdBuffer@@UAE@XZ ENDP				; XMemRdBuffer::~XMemRdBuffer
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??_EXMemRdBuffer@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_EXMemRdBuffer@@UAEPAXI@Z PROC NEAR			; XMemRdBuffer::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebx
	mov	bl, BYTE PTR ___flags$[esp]
	push	esi
	mov	esi, ecx
	test	bl, 2
	je	SHORT $L56272
	mov	eax, DWORD PTR [esi-4]
	push	edi
	lea	edi, DWORD PTR [esi-4]
	push	OFFSET FLAT:??1XMemRdBuffer@@UAE@XZ	; XMemRdBuffer::~XMemRdBuffer
	push	eax
	push	24					; 00000018H
	push	esi
	call	??_M@YGXPAXIHP6EX0@Z@Z			; `eh vector destructor iterator'
	test	bl, 1
	je	SHORT $L58793
	mov	ecx, edi
	call	@xfree@4
$L58793:
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	ret	4
$L56272:
	mov	ecx, esi
	call	??1XMemRdBuffer@@UAE@XZ			; XMemRdBuffer::~XMemRdBuffer
	test	bl, 1
	je	SHORT $L58795
	mov	ecx, esi
	call	@xfree@4
$L58795:
	mov	eax, esi
	pop	esi
	pop	ebx
	ret	4
??_EXMemRdBuffer@@UAEPAXI@Z ENDP			; XMemRdBuffer::`vector deleting destructor'
_TEXT	ENDS
END
