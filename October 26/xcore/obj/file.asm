; Listing generated by Microsoft (R) Optimizing Compiler Version 12.00.8943.0 

	TITLE	C:\duke4\xcore\file.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0BF@MBIJ@Cannot?5init?5CPrintfT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
drectve	SEGMENT DWORD USE32 PUBLIC ''
drectve	ENDS
;	COMDAT ??0?$XChain@VXStatistic@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?get_head@?$XList@VXStatistic@@@@QAEPAVXStatistic@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$XChain@VCSysObj@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$XChain@VCSysObj@@@@QAE@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?get_next@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?get_prev@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?get_head@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?get_tail@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$XChain@VXStatistic@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?free_list@?$XChain@VXStatistic@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$XList@VXStatistic@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$XList@VXStatistic@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?free_list@?$XList@VXStatistic@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?add_head@?$XList@VXStatistic@@@@QAEPAU_XPos@@PAVXStatistic@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?remove_head@?$XList@VXStatistic@@@@QAEPAVXStatistic@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$XChain@VCSysObj@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lose_list@?$XChain@VCSysObj@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?free_list@?$XChain@VCSysObj@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?add_head@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?add_tail@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?remove_head@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?remove_tail@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?remove@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$XList@PAX@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$XRcBase@VCStrObj@@@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$XRcBase@VCStrObj@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$XRcBase@VCStrObj@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$XRcBase@VCStrObj@@@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$XRcPtr@VCPathObj@@@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$XRcPtr@VCPathObj@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$XRcPtr@VCPathObj@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$XRcPtr@VCPathObj@@@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$XList@VXFindLevel@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$XList@VXFindLevel@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCSysObj@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GXFindLevel@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?new_node@?$XList@VXStatistic@@@@IAEPAUXNode@1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?free_nodes@?$XList@VXStatistic@@@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?free_nodes@?$XList@PAX@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?free_nodes@?$XList@VXFindLevel@@@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddRef@?$XRcBase@VCStrObj@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DelRef@?$XRcBase@VCStrObj@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddRef@?$XRcPtr@VCPathObj@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DelRef@?$XRcPtr@VCPathObj@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCStrObj@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCPathObj@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GXStreamWrDirect@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1XStreamWrDirect@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7XStreamWrDirect@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??1XBufferWriteInt@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7XBufferWriteInt@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_EXStreamWrDirect@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?flush@XStreamWrDirect@@UAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?seek@XStreamWrDirect@@UAEKJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GXStreamRdDirect@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1XStreamRdDirect@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7XStreamRdDirect@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??1XBufferReadInt@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7XBufferReadInt@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_EXStreamRdDirect@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?seek@XStreamRdDirect@@UAEKJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GXBufferWriteInt@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_EXBufferWriteInt@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GXBufferReadInt@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_EXBufferReadInt@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pos_wr@CBaseStream@@UAEXKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pos_rd@CBaseStream@@UAEXKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?put@CBaseStream@@UAEKD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ioctl_write@CBaseStream@@UAEKKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ioctl_read@CBaseStream@@UAEKKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?seek_int@CBaseStream@@MAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GXMemRdBuffer@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1XMemRdBuffer@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7XMemRdBuffer@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??3XMemRdBuffer@@SAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_EXMemRdBuffer@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3CStrObj@@SAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CStrObj@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1XFindLevel@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0XListState@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3XStatistic@@SAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0XChainState@@QAE@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0XChainState@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?release@autochar@@QAEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CStdOut@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??3@YAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Bautochar@@QAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?is_open@CBaseStream@@IAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0XStreamWrDirect@@QAE@PAVCBaseStream@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0XBufferWriteInt@@QAE@PAVCBaseStream@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3XStreamWrDirect@@SAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2XStreamWrDirect@@SAPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0XStreamRdDirect@@QAE@PAVCBaseStream@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0XBufferReadInt@@QAE@PAVCBaseStream@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3XStreamRdDirect@@SAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2XStreamRdDirect@@SAPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BCStr@@QBEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4autochar@@QAEAAV0@PAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?base_init@XFile@@EAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7XFile@@6BCSysObj@@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7XFile@@6BCBaseStream@@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??1autochar@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0autochar@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CSysObj@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CSysObj@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??0CSysObj@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CBaseStream@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CBaseStream@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??0CBaseStream@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0XStreamState@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
FLAT	GROUP _DATA, CONST, _BSS, drectve
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

drectve	SEGMENT
$SG56785 DB	'-INCLUDE:___@@_PchSym_@00@UwfpvEUcxlivUlyqUhgwxlivOlyq@', 00H
drectve	ENDS
PUBLIC	?conv_flags@XFile@@AAEKPBD@Z			; XFile::conv_flags
; Function compile flags: /Ogty
; File C:\duke4\xcore\file.cpp
_TEXT	SEGMENT
_file_flags$ = 8
?conv_flags@XFile@@AAEKPBD@Z PROC NEAR			; XFile::conv_flags
; _this$ = ecx

; 6    : {

	push	esi

; 7    : 	char key;
; 8    : 	U32 flags=0;
; 9    : 	
; 10   : 	while(key=*file_flags++)

	mov	esi, DWORD PTR _file_flags$[esp]
	mov	al, BYTE PTR [esi]
	test	al, al
	je	SHORT $L57295
	mov	edx, 32					; 00000020H
	push	ebx
$L56794:

; 11   : 	{
; 12   : 		switch(key)
; 13   : 		{

	movsx	eax, al
	add	eax, -97				; ffffff9fH
	inc	esi
	cmp	eax, 22					; 00000016H
	ja	SHORT $L56797
	xor	ebx, ebx
	mov	bl, BYTE PTR $L57296[eax]
	jmp	DWORD PTR $L57299[ebx*4]
$L56800:

; 14   : 			case 'a':
; 15   : 				state.append=TRUE;

	mov	eax, DWORD PTR [ecx+4]
	or	al, 8

; 16   : 				break;

	jmp	SHORT $L57298
$L56801:

; 17   : 			case 'w':
; 18   : 				state.write=TRUE;

	mov	eax, DWORD PTR [ecx+4]
	or	al, 4

; 19   : 				break;

	jmp	SHORT $L57298
$L56802:

; 20   : 			case 'r':
; 21   : 				state.read=TRUE;

	mov	eax, DWORD PTR [ecx+4]
	or	al, 2

; 22   : 				break;

	jmp	SHORT $L57298
$L56803:

; 23   : 			case 'b':
; 24   : 				state.binary=TRUE;

	mov	eax, DWORD PTR [ecx+4]
	or	al, 16					; 00000010H

; 25   : 				break;

	jmp	SHORT $L57298
$L56804:

; 26   : 			case 't':
; 27   : 				state.text=TRUE;

	mov	eax, DWORD PTR [ecx+4]
	or	eax, edx

; 28   : 				break;

	jmp	SHORT $L57298
$L56805:

; 29   : 			case 'c':
; 30   : 				state.create=TRUE;

	mov	eax, DWORD PTR [ecx+4]
	or	al, 64					; 00000040H

; 31   : 				break;

	jmp	SHORT $L57298
$L56806:

; 32   : 			case 'n':
; 33   : 				state.truncate=TRUE;

	mov	eax, DWORD PTR [ecx+4]
	or	al, -128				; ffffff80H
$L57298:
	mov	DWORD PTR [ecx+4], eax
$L56797:

; 7    : 	char key;
; 8    : 	U32 flags=0;
; 9    : 	
; 10   : 	while(key=*file_flags++)

	mov	al, BYTE PTR [esi]
	test	al, al
	jne	SHORT $L56794
	pop	ebx
$L57295:

; 34   : 				break;
; 35   : 		}
; 36   : 	}
; 37   : 	if (state.binary & state.text)

	mov	ecx, DWORD PTR [ecx+4]
	pop	esi
	mov	eax, ecx
	shr	eax, 1
	and	al, cl
	not	al
	and	eax, 255				; 000000ffH
	shr	eax, 4
	and	eax, 1

; 38   : 		return FALSE;
; 39   : 
; 40   : 	return TRUE;
; 41   : }

	ret	4
	npad	1
$L57299:
	DD	$L56800
	DD	$L56803
	DD	$L56805
	DD	$L56806
	DD	$L56802
	DD	$L56804
	DD	$L56801
	DD	$L56797
$L57296:
	DB	0
	DB	1
	DB	2
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	3
	DB	7
	DB	7
	DB	7
	DB	4
	DB	7
	DB	5
	DB	7
	DB	7
	DB	6
?conv_flags@XFile@@AAEKPBD@Z ENDP			; XFile::conv_flags
_TEXT	ENDS
PUBLIC	?seek_int@CBaseStream@@MAEJXZ			; CBaseStream::seek_int
PUBLIC	??1CBaseStream@@QAE@XZ				; CBaseStream::~CBaseStream
PUBLIC	?ioctl_read@CBaseStream@@UAEKKK@Z		; CBaseStream::ioctl_read
PUBLIC	?ioctl_write@CBaseStream@@UAEKKK@Z		; CBaseStream::ioctl_write
PUBLIC	?put@CBaseStream@@UAEKD@Z			; CBaseStream::put
PUBLIC	?pos_rd@CBaseStream@@UAEXKK@Z			; CBaseStream::pos_rd
PUBLIC	?pos_wr@CBaseStream@@UAEXKK@Z			; CBaseStream::pos_wr
PUBLIC	??_7CBaseStream@@6B@				; CBaseStream::`vftable'
PUBLIC	?base_init@XFile@@EAEXXZ			; XFile::base_init
PUBLIC	??0XFile@@QAE@XZ				; XFile::XFile
PUBLIC	?close@XFile@@UAEKXZ				; XFile::close
PUBLIC	?pos_rd@XFile@@UAEXKK@Z				; XFile::pos_rd
PUBLIC	?pos_wr@XFile@@UAEXKK@Z				; XFile::pos_wr
PUBLIC	??_7XFile@@6BCBaseStream@@@			; XFile::`vftable'
PUBLIC	??_7XFile@@6BCSysObj@@@				; XFile::`vftable'
PUBLIC	??_7CSysObj@@6B@				; CSysObj::`vftable'
EXTRN	__purecall:NEAR
EXTRN	?_global@@3PAVXGlobal@@A:DWORD			; _global
EXTRN	?reg_global_object@XGlobal@@QAEXPAVCSysObj@@@Z:NEAR ; XGlobal::reg_global_object
EXTRN	?base_init@CBaseStream@@MAEXXZ:NEAR		; CBaseStream::base_init
EXTRN	__except_list:DWORD
EXTRN	___CxxFrameHandler:NEAR
EXTRN	?write@CBaseStream@@UAEKPBXKAAK@Z:NEAR		; CBaseStream::write
EXTRN	?write@CBaseStream@@UAEKPBXK@Z:NEAR		; CBaseStream::write
EXTRN	?read@CBaseStream@@UAEKPAXKAAK@Z:NEAR		; CBaseStream::read
EXTRN	?read@CBaseStream@@UAEKPAXK@Z:NEAR		; CBaseStream::read
EXTRN	?flush@CBaseStream@@UAEKXZ:NEAR			; CBaseStream::flush
EXTRN	??6CBaseStream@@UAEAAV0@PBD@Z:NEAR		; CBaseStream::operator<<
EXTRN	??6CBaseStream@@UAEAAV0@K@Z:NEAR		; CBaseStream::operator<<
EXTRN	??6CBaseStream@@UAEAAV0@D@Z:NEAR		; CBaseStream::operator<<
EXTRN	?destroy@XFile@@EAEKXZ:NEAR			; XFile::destroy
xdata$x	SEGMENT
$T57327	DD	0ffffffffH
	DD	FLAT:$L57301
$T57324	DD	019930520H
	DD	01H
	DD	FLAT:$T57327
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_7CBaseStream@@6B@
; File C:\duke4\xcore\xclass.h
CONST	SEGMENT
??_7CBaseStream@@6B@ DD FLAT:?base_init@CBaseStream@@MAEXXZ ; CBaseStream::`vftable'
	DD	FLAT:?seek_int@CBaseStream@@MAEJXZ
	DD	FLAT:__purecall
	DD	FLAT:?ioctl_read@CBaseStream@@UAEKKK@Z
	DD	FLAT:?ioctl_write@CBaseStream@@UAEKKK@Z
	DD	FLAT:?write@CBaseStream@@UAEKPBXK@Z
	DD	FLAT:?write@CBaseStream@@UAEKPBXKAAK@Z
	DD	FLAT:?read@CBaseStream@@UAEKPAXK@Z
	DD	FLAT:?read@CBaseStream@@UAEKPAXKAAK@Z
	DD	FLAT:?flush@CBaseStream@@UAEKXZ
	DD	FLAT:?put@CBaseStream@@UAEKD@Z
	DD	FLAT:??6CBaseStream@@UAEAAV0@D@Z
	DD	FLAT:??6CBaseStream@@UAEAAV0@K@Z
	DD	FLAT:??6CBaseStream@@UAEAAV0@PBD@Z
	DD	FLAT:?pos_rd@CBaseStream@@UAEXKK@Z
	DD	FLAT:?pos_wr@CBaseStream@@UAEXKK@Z
CONST	ENDS
;	COMDAT ??_7CSysObj@@6B@
CONST	SEGMENT
??_7CSysObj@@6B@ DD FLAT:__purecall			; CSysObj::`vftable'
CONST	ENDS
;	COMDAT ??_7XFile@@6BCSysObj@@@
CONST	SEGMENT
??_7XFile@@6BCSysObj@@@ DD FLAT:?destroy@XFile@@EAEKXZ	; XFile::`vftable'
CONST	ENDS
;	COMDAT ??_7XFile@@6BCBaseStream@@@
CONST	SEGMENT
??_7XFile@@6BCBaseStream@@@ DD FLAT:?base_init@XFile@@EAEXXZ ; XFile::`vftable'
	DD	FLAT:?seek_int@CBaseStream@@MAEJXZ
	DD	FLAT:?close@XFile@@UAEKXZ
	DD	FLAT:?ioctl_read@CBaseStream@@UAEKKK@Z
	DD	FLAT:?ioctl_write@CBaseStream@@UAEKKK@Z
	DD	FLAT:?write@CBaseStream@@UAEKPBXK@Z
	DD	FLAT:?write@CBaseStream@@UAEKPBXKAAK@Z
	DD	FLAT:?read@CBaseStream@@UAEKPAXK@Z
	DD	FLAT:?read@CBaseStream@@UAEKPAXKAAK@Z
	DD	FLAT:?flush@CBaseStream@@UAEKXZ
	DD	FLAT:?put@CBaseStream@@UAEKD@Z
	DD	FLAT:??6CBaseStream@@UAEAAV0@D@Z
	DD	FLAT:??6CBaseStream@@UAEAAV0@K@Z
	DD	FLAT:??6CBaseStream@@UAEAAV0@PBD@Z
	DD	FLAT:?pos_rd@XFile@@UAEXKK@Z
	DD	FLAT:?pos_wr@XFile@@UAEXKK@Z
; Function compile flags: /Ogty
; File C:\duke4\xcore\file.cpp
CONST	ENDS
_TEXT	SEGMENT
__$EHRec$ = -12
_this$ = -16
??0XFile@@QAE@XZ PROC NEAR				; XFile::XFile
; _this$ = ecx

; 44   : {

	push	-1
	push	$L57325
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	push	ebx
	push	esi
	mov	esi, ecx
	xor	ebx, ebx
	push	edi
	mov	DWORD PTR _this$[esp+28], esi
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [esi+8], ebx
	and	eax, -4080				; fffff010H
	mov	DWORD PTR [esi+12], ebx
	or	al, 16					; 00000010H
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi], OFFSET FLAT:??_7CBaseStream@@6B@ ; CBaseStream::`vftable'
	lea	edi, DWORD PTR [esi+28]
	mov	DWORD PTR __$EHRec$[esp+36], ebx
	push	edi
	mov	DWORD PTR [edi], OFFSET FLAT:??_7CSysObj@@6B@ ; CSysObj::`vftable'
	mov	ecx, DWORD PTR ?_global@@3PAVXGlobal@@A	; _global
	call	?reg_global_object@XGlobal@@QAEXPAVCSysObj@@@Z ; XGlobal::reg_global_object

; 45   : }

	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR [esi+40], ebx
	mov	DWORD PTR [edi], OFFSET FLAT:??_7XFile@@6BCSysObj@@@ ; XFile::`vftable'
	mov	DWORD PTR [esi], OFFSET FLAT:??_7XFile@@6BCBaseStream@@@ ; XFile::`vftable'
	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
text$x	SEGMENT
$L57301:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CBaseStream@@QAE@XZ			; CBaseStream::~CBaseStream
$L57325:
	mov	eax, OFFSET FLAT:$T57324
	jmp	___CxxFrameHandler
text$x	ENDS
??0XFile@@QAE@XZ ENDP					; XFile::XFile
PUBLIC	??1autochar@@QAE@XZ				; autochar::~autochar
PUBLIC	?seek@XStreamRdDirect@@UAEKJ@Z			; XStreamRdDirect::seek
PUBLIC	??_7XStreamRdDirect@@6B@			; XStreamRdDirect::`vftable'
PUBLIC	??_EXStreamRdDirect@@UAEPAXI@Z			; XStreamRdDirect::`vector deleting destructor'
PUBLIC	?seek@XStreamWrDirect@@UAEKJ@Z			; XStreamWrDirect::seek
PUBLIC	?flush@XStreamWrDirect@@UAEKXZ			; XStreamWrDirect::flush
PUBLIC	??_7XStreamWrDirect@@6B@			; XStreamWrDirect::`vftable'
PUBLIC	??_EXStreamWrDirect@@UAEPAXI@Z			; XStreamWrDirect::`vector deleting destructor'
PUBLIC	??0XStreamState@@QAE@XZ				; XStreamState::XStreamState
PUBLIC	??0XFile@@QAE@PBD0@Z				; XFile::XFile
PUBLIC	??1CSysObj@@QAE@XZ				; CSysObj::~CSysObj
EXTRN	?read_direct@XBufferReadInt@@MAEKPAXKAAK@Z:NEAR	; XBufferReadInt::read_direct
EXTRN	?write_direct@XBufferWriteInt@@MAEKPBXKAAK@Z:NEAR ; XBufferWriteInt::write_direct
EXTRN	?read@XStreamRdDirect@@UAEKPAXKAAK1@Z:NEAR	; XStreamRdDirect::read
EXTRN	?write@XStreamWrDirect@@UAEKPBXKAAK1@Z:NEAR	; XStreamWrDirect::write
EXTRN	?set_rd_interface@CBaseStream@@IAEXPAVXBufferReadInt@@@Z:NEAR ; CBaseStream::set_rd_interface
EXTRN	?set_wr_interface@CBaseStream@@IAEXPAVXBufferWriteInt@@@Z:NEAR ; CBaseStream::set_wr_interface
EXTRN	@xxx_throw@4:NEAR
EXTRN	??0CStr@@QAE@PBD@Z:NEAR				; CStr::CStr
EXTRN	?std_open@XFile@@AAEKXZ:NEAR			; XFile::std_open
EXTRN	@xmalloc@4:NEAR
xdata$x	SEGMENT
$T57400	DD	0ffffffffH
	DD	FLAT:$L57339
	DD	00H
	DD	FLAT:$L57340
	DD	01H
	DD	FLAT:$L57341
$T57398	DD	019930520H
	DD	03H
	DD	FLAT:$T57400
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
_DATA	SEGMENT
$SG56819 DB	'XFile::XFile: invalid flags to open file', 00H
	ORG $+3
$SG56821 DB	'XFile::XFile: unable to open file', 00H
_DATA	ENDS
;	COMDAT ??_7XStreamRdDirect@@6B@
; File C:\duke4\xcore\xstream.h
CONST	SEGMENT
??_7XStreamRdDirect@@6B@ DD FLAT:?read_direct@XBufferReadInt@@MAEKPAXKAAK@Z ; XStreamRdDirect::`vftable'
	DD	FLAT:?read@XStreamRdDirect@@UAEKPAXKAAK1@Z
	DD	FLAT:?seek@XStreamRdDirect@@UAEKJ@Z
	DD	FLAT:??_EXStreamRdDirect@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7XStreamWrDirect@@6B@
CONST	SEGMENT
??_7XStreamWrDirect@@6B@ DD FLAT:?write_direct@XBufferWriteInt@@MAEKPBXKAAK@Z ; XStreamWrDirect::`vftable'
	DD	FLAT:?write@XStreamWrDirect@@UAEKPBXKAAK1@Z
	DD	FLAT:?seek@XStreamWrDirect@@UAEKJ@Z
	DD	FLAT:?flush@XStreamWrDirect@@UAEKXZ
	DD	FLAT:??_EXStreamWrDirect@@UAEPAXI@Z
; Function compile flags: /Ogty
; File C:\duke4\xcore\file.cpp
CONST	ENDS
_TEXT	SEGMENT
$T57330 = -20
__$EHRec$ = -12
_Name$ = 8
_file_flags$ = 12
_this$ = -24
??0XFile@@QAE@PBD0@Z PROC NEAR				; XFile::XFile
; _this$ = ecx

; 48   : {

	push	-1
	push	$L57399
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+32], esi
	lea	ecx, DWORD PTR [esi+4]
	call	??0XStreamState@@QAE@XZ			; XStreamState::XStreamState
	mov	DWORD PTR [esi], OFFSET FLAT:??_7CBaseStream@@6B@ ; CBaseStream::`vftable'
	lea	edi, DWORD PTR [esi+28]
	mov	DWORD PTR __$EHRec$[esp+40], 0
	push	edi
	mov	DWORD PTR [edi], OFFSET FLAT:??_7CSysObj@@6B@ ; CSysObj::`vftable'
	mov	ecx, DWORD PTR ?_global@@3PAVXGlobal@@A	; _global
	call	?reg_global_object@XGlobal@@QAEXPAVCSysObj@@@Z ; XGlobal::reg_global_object
	mov	DWORD PTR [esi+40], 0

; 49   : 	base_init();

	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+40], 2
	mov	DWORD PTR [esi], OFFSET FLAT:??_7XFile@@6BCBaseStream@@@ ; XFile::`vftable'
	mov	DWORD PTR [edi], OFFSET FLAT:??_7XFile@@6BCSysObj@@@ ; XFile::`vftable'
	call	?base_init@CBaseStream@@MAEXXZ		; CBaseStream::base_init

; 50   : 
; 51   : 	name=CStr(Name);

	mov	eax, DWORD PTR _Name$[esp+28]
	lea	ecx, DWORD PTR $T57330[esp+32]
	push	eax
	mov	DWORD PTR [esi+40], 0
	call	??0CStr@@QAE@PBD@Z			; CStr::CStr
	mov	ecx, DWORD PTR [eax+4]

; 52   : 
; 53   : 	if (!conv_flags(file_flags))

	mov	edx, DWORD PTR _file_flags$[esp+28]
	mov	DWORD PTR [esi+40], ecx
	push	edx
	mov	ecx, esi
	call	?conv_flags@XFile@@AAEKPBD@Z		; XFile::conv_flags
	test	eax, eax
	jne	SHORT $L56818

; 54   : 		xxx_throw("XFile::XFile: invalid flags to open file");

	mov	ecx, OFFSET FLAT:$SG56819
	call	@xxx_throw@4
$L56818:

; 55   : 
; 56   : 	if (!std_open())

	mov	ecx, esi
	call	?std_open@XFile@@AAEKXZ			; XFile::std_open
	test	eax, eax
	jne	SHORT $L56820

; 57   : 		xxx_throw("XFile::XFile: unable to open file");

	mov	ecx, OFFSET FLAT:$SG56821
	call	@xxx_throw@4
$L56820:

; 58   : 
; 59   : 	set_rd_interface(new XStreamRdDirect(this));

	mov	ecx, 8
	call	@xmalloc@4
	test	eax, eax
	je	SHORT $L57333
	mov	DWORD PTR [eax+4], esi
	mov	DWORD PTR [eax], OFFSET FLAT:??_7XStreamRdDirect@@6B@ ; XStreamRdDirect::`vftable'
	jmp	SHORT $L57334
$L57333:
	xor	eax, eax
$L57334:
	push	eax
	mov	ecx, esi
	call	?set_rd_interface@CBaseStream@@IAEXPAVXBufferReadInt@@@Z ; CBaseStream::set_rd_interface

; 60   : 	set_wr_interface(new XStreamWrDirect(this));

	mov	ecx, 8
	call	@xmalloc@4
	test	eax, eax
	je	SHORT $L57337
	mov	DWORD PTR [eax+4], esi
	mov	DWORD PTR [eax], OFFSET FLAT:??_7XStreamWrDirect@@6B@ ; XStreamWrDirect::`vftable'
	jmp	SHORT $L57338
$L57337:
	xor	eax, eax
$L57338:
	push	eax
	mov	ecx, esi
	call	?set_wr_interface@CBaseStream@@IAEXPAVXBufferWriteInt@@@Z ; CBaseStream::set_wr_interface

; 61   : }

	mov	ecx, DWORD PTR __$EHRec$[esp+32]
	mov	eax, esi
	pop	edi
	pop	esi
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 24					; 00000018H
	ret	8
_TEXT	ENDS
text$x	SEGMENT
$L57339:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CBaseStream@@QAE@XZ			; CBaseStream::~CBaseStream
$L57340:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	jmp	??1CSysObj@@QAE@XZ			; CSysObj::~CSysObj
$L57341:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	jmp	??1autochar@@QAE@XZ			; autochar::~autochar
$L57399:
	mov	eax, OFFSET FLAT:$T57398
	jmp	___CxxFrameHandler
text$x	ENDS
??0XFile@@QAE@PBD0@Z ENDP				; XFile::XFile
PUBLIC	?open@XFile@@QAEKPBD0@Z				; XFile::open
EXTRN	@xfree@4:NEAR
; Function compile flags: /Ogty
_TEXT	SEGMENT
$T57403 = -8
_Name$ = 8
_file_flags$ = 12
?open@XFile@@QAEKPBD0@Z PROC NEAR			; XFile::open
; _this$ = ecx

; 64   : {

	sub	esp, 8
	push	esi
	mov	esi, ecx

; 65   : 	if (is_open())

	mov	eax, DWORD PTR [esi+4]
	test	ah, 1
	je	SHORT $L56835

; 66   : 		close();

	mov	eax, DWORD PTR [esi]
	call	DWORD PTR [eax+8]
$L56835:

; 67   : 
; 68   : 	base_init();

	mov	edx, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [edx]

; 69   : 
; 70   : 	if (name)

	mov	ecx, DWORD PTR [esi+40]
	test	ecx, ecx
	je	SHORT $L57426

; 71   : 		delete name;

	call	@xfree@4
$L57426:

; 72   : 
; 73   : 	name=CStr(Name);

	mov	eax, DWORD PTR _Name$[esp+8]
	lea	ecx, DWORD PTR $T57403[esp+12]
	push	eax
	call	??0CStr@@QAE@PBD@Z			; CStr::CStr
	mov	ecx, DWORD PTR [eax+4]

; 74   : 
; 75   : 	if (!conv_flags(file_flags))

	mov	edx, DWORD PTR _file_flags$[esp+8]
	mov	DWORD PTR [esi+40], ecx
	push	edx
	mov	ecx, esi
	call	?conv_flags@XFile@@AAEKPBD@Z		; XFile::conv_flags
	test	eax, eax
	jne	SHORT $L56839
	pop	esi

; 85   : }

	add	esp, 8
	ret	8
$L56839:

; 76   : 		return FALSE;
; 77   : 
; 78   : 	if (!std_open())

	mov	ecx, esi
	call	?std_open@XFile@@AAEKXZ			; XFile::std_open
	test	eax, eax
	jne	SHORT $L56840
	pop	esi

; 85   : }

	add	esp, 8
	ret	8
$L56840:

; 79   : 		return FALSE;
; 80   : 
; 81   : 	set_rd_interface(new XStreamRdDirect(this));

	mov	ecx, 8
	call	@xmalloc@4
	test	eax, eax
	je	SHORT $L57406
	mov	DWORD PTR [eax+4], esi
	mov	DWORD PTR [eax], OFFSET FLAT:??_7XStreamRdDirect@@6B@ ; XStreamRdDirect::`vftable'
	jmp	SHORT $L57407
$L57406:
	xor	eax, eax
$L57407:
	push	eax
	mov	ecx, esi
	call	?set_rd_interface@CBaseStream@@IAEXPAVXBufferReadInt@@@Z ; CBaseStream::set_rd_interface

; 82   : 	set_wr_interface(new XStreamWrDirect(this));

	mov	ecx, 8
	call	@xmalloc@4
	test	eax, eax
	je	SHORT $L57410
	push	eax
	mov	ecx, esi
	mov	DWORD PTR [eax+4], esi
	mov	DWORD PTR [eax], OFFSET FLAT:??_7XStreamWrDirect@@6B@ ; XStreamWrDirect::`vftable'
	call	?set_wr_interface@CBaseStream@@IAEXPAVXBufferWriteInt@@@Z ; CBaseStream::set_wr_interface

; 83   : 
; 84   : 	return TRUE;

	mov	eax, 1
	pop	esi

; 85   : }

	add	esp, 8
	ret	8
$L57410:

; 82   : 	set_wr_interface(new XStreamWrDirect(this));

	xor	eax, eax
	mov	ecx, esi
	push	eax
	call	?set_wr_interface@CBaseStream@@IAEXPAVXBufferWriteInt@@@Z ; CBaseStream::set_wr_interface

; 83   : 
; 84   : 	return TRUE;

	mov	eax, 1
	pop	esi

; 85   : }

	add	esp, 8
	ret	8
?open@XFile@@QAEKPBD0@Z ENDP				; XFile::open
_TEXT	ENDS
EXTRN	?std_close@XFile@@AAEKXZ:NEAR			; XFile::std_close
; Function compile flags: /Ogty
_TEXT	SEGMENT
?close@XFile@@UAEKXZ PROC NEAR				; XFile::close
; _this$ = ecx

; 88   : {

	push	esi
	mov	esi, ecx

; 89   : 	if (name)

	mov	ecx, DWORD PTR [esi+40]
	test	ecx, ecx
	je	SHORT $L57471

; 90   : 		delete name;

	call	@xfree@4
$L57471:

; 91   : 	name=null;
; 92   : 	
; 93   : 	if (!std_close())

	mov	ecx, esi
	mov	DWORD PTR [esi+40], 0
	call	?std_close@XFile@@AAEKXZ		; XFile::std_close
	test	eax, eax
	jne	SHORT $L56855
	pop	esi

; 99   : }

	ret	0
$L56855:

; 94   : 		return FALSE;
; 95   : 
; 96   : 	state.is_open=FALSE;

	mov	eax, DWORD PTR [esi+4]
	and	ah, -2					; fffffffeH
	mov	DWORD PTR [esi+4], eax

; 97   : 
; 98   : 	return TRUE;

	mov	eax, 1
	pop	esi

; 99   : }

	ret	0
?close@XFile@@UAEKXZ ENDP				; XFile::close
_TEXT	ENDS
PUBLIC	?seek@XFile@@QAEKJK@Z				; XFile::seek
EXTRN	?std_seek@XFile@@AAEKJK@Z:NEAR			; XFile::std_seek
; Function compile flags: /Ogty
_TEXT	SEGMENT
_offset$ = 8
_type$ = 12
?seek@XFile@@QAEKJK@Z PROC NEAR				; XFile::seek
; _this$ = ecx

; 105  : 	I32 old_pos_should,delta;
; 106  : 
; 107  : 	if (type==FILE_SEEK_CUR)

	mov	eax, DWORD PTR _type$[esp-4]
	push	ebx
	push	edi
	cmp	eax, 2

; 108  : 		offset=(state.pos_should + offset);

	mov	eax, DWORD PTR _offset$[esp+4]
	mov	edi, ecx
	jne	SHORT $L56863
	add	eax, DWORD PTR [edi+12]
$L56863:

; 109  : 
; 110  : #if 0
; 111  : 	switch(type)
; 112  : 	{
; 113  : 		case FILE_SEEK_SET:
; 114  : 			delta=(offset - state.pos_should);
; 115  : 			break;
; 116  : 		case FILE_SEEK_CUR:
; 117  : 			delta=offset;
; 118  : 			offset=(state.pos_should - offset);
; 119  : 			break;
; 120  : 		case FILE_SEEK_END:
; 121  : 			delta=;
; 122  : 			break;
; 123  : 	}
; 124  : #endif
; 125  : 	
; 126  : 	old_pos_should=state.pos_should;

	mov	ebx, DWORD PTR [edi+12]

; 127  : 	U32 ret=std_seek(offset,FILE_SEEK_SET);

	push	1
	push	eax
	mov	ecx, edi
	call	?std_seek@XFile@@AAEKJK@Z		; XFile::std_seek

; 128  : 	if (!ret)

	test	eax, eax
	jne	SHORT $L56865
	pop	edi
	pop	ebx

; 136  : }

	ret	8
$L56865:

; 129  : 		return FALSE;
; 130  : 
; 131  : 	delta=state.pos_should - old_pos_should;
; 132  : 
; 133  : 	rd_int->seek(delta);

	mov	ecx, DWORD PTR [edi+20]
	push	esi
	mov	esi, DWORD PTR [edi+12]
	mov	eax, DWORD PTR [ecx]
	sub	esi, ebx
	push	esi
	call	DWORD PTR [eax+8]

; 134  : 	wr_int->seek(delta);

	mov	ecx, DWORD PTR [edi+24]
	push	esi
	mov	edx, DWORD PTR [ecx]
	call	DWORD PTR [edx+8]
	pop	esi
	pop	edi

; 135  : 	return TRUE;

	mov	eax, 1
	pop	ebx

; 136  : }

	ret	8
?seek@XFile@@QAEKJK@Z ENDP				; XFile::seek
; Function compile flags: /Ogty
_adj$ = 8
_at_adj$ = 12
?pos_rd@XFile@@UAEXKK@Z PROC NEAR			; XFile::pos_rd
; _this$ = ecx

; 140  : 	state.pos_should+=adj;

	mov	eax, DWORD PTR _adj$[esp-4]
	mov	edx, DWORD PTR [ecx+12]
	add	edx, eax
	push	esi

; 141  : 	state.pos_at+=at_adj;

	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [ecx+12], edx
	mov	edx, DWORD PTR _at_adj$[esp]

; 142  : 	wr_int->seek(adj);

	push	eax
	add	esi, edx
	mov	DWORD PTR [ecx+8], esi
	mov	ecx, DWORD PTR [ecx+24]
	mov	edx, DWORD PTR [ecx]
	call	DWORD PTR [edx+8]
	pop	esi

; 143  : }

	ret	8
?pos_rd@XFile@@UAEXKK@Z ENDP				; XFile::pos_rd
; Function compile flags: /Ogty
_adj$ = 8
_at_adj$ = 12
?pos_wr@XFile@@UAEXKK@Z PROC NEAR			; XFile::pos_wr
; _this$ = ecx

; 147  : 	state.pos_should+=adj;

	mov	eax, DWORD PTR _adj$[esp-4]
	mov	edx, DWORD PTR [ecx+12]
	add	edx, eax
	push	esi

; 148  : 	state.pos_at+=at_adj;

	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [ecx+12], edx
	mov	edx, DWORD PTR _at_adj$[esp]

; 149  : 	rd_int->seek(adj);

	push	eax
	add	esi, edx
	mov	DWORD PTR [ecx+8], esi
	mov	ecx, DWORD PTR [ecx+20]
	mov	edx, DWORD PTR [ecx]
	call	DWORD PTR [edx+8]
	pop	esi

; 150  : }

	ret	8
?pos_wr@XFile@@UAEXKK@Z ENDP				; XFile::pos_wr
_TEXT	ENDS
PUBLIC	??0CStdOut@@QAE@XZ				; CStdOut::CStdOut
PUBLIC	?close@CStdOut@@UAEKXZ				; CStdOut::close
PUBLIC	??_7CStdOut@@6B@				; CStdOut::`vftable'
EXTRN	?open@CStdOut@@QAEKXZ:NEAR			; CStdOut::open
xdata$x	SEGMENT
$T57495	DD	0ffffffffH
	DD	FLAT:$L57481
$T57492	DD	019930520H
	DD	01H
	DD	FLAT:$T57495
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_7CStdOut@@6B@
; File C:\duke4\xcore\xstream.h
CONST	SEGMENT
??_7CStdOut@@6B@ DD FLAT:?base_init@CBaseStream@@MAEXXZ	; CStdOut::`vftable'
	DD	FLAT:?seek_int@CBaseStream@@MAEJXZ
	DD	FLAT:?close@CStdOut@@UAEKXZ
	DD	FLAT:?ioctl_read@CBaseStream@@UAEKKK@Z
	DD	FLAT:?ioctl_write@CBaseStream@@UAEKKK@Z
	DD	FLAT:?write@CBaseStream@@UAEKPBXK@Z
	DD	FLAT:?write@CBaseStream@@UAEKPBXKAAK@Z
	DD	FLAT:?read@CBaseStream@@UAEKPAXK@Z
	DD	FLAT:?read@CBaseStream@@UAEKPAXKAAK@Z
	DD	FLAT:?flush@CBaseStream@@UAEKXZ
	DD	FLAT:?put@CBaseStream@@UAEKD@Z
	DD	FLAT:??6CBaseStream@@UAEAAV0@D@Z
	DD	FLAT:??6CBaseStream@@UAEAAV0@K@Z
	DD	FLAT:??6CBaseStream@@UAEAAV0@PBD@Z
	DD	FLAT:?pos_rd@CBaseStream@@UAEXKK@Z
	DD	FLAT:?pos_wr@CBaseStream@@UAEXKK@Z
CONST	ENDS
_DATA	SEGMENT
	ORG $+2
$SG56881 DB	'CStdOut: unable to open stdout in constructor', 00H
; Function compile flags: /Ogty
; File C:\duke4\xcore\file.cpp
_DATA	ENDS
_TEXT	SEGMENT
__$EHRec$ = -12
_this$ = -16
??0CStdOut@@QAE@XZ PROC NEAR				; CStdOut::CStdOut
; _this$ = ecx

; 153  : {

	push	-1
	push	$L57494
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi
	mov	eax, DWORD PTR [esi+4]
	and	eax, -4080				; fffff010H
	or	al, 16					; 00000010H
	mov	DWORD PTR [esi+4], eax
	xor	eax, eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR __$EHRec$[esp+28], eax
	mov	DWORD PTR [esi], OFFSET FLAT:??_7CStdOut@@6B@ ; CStdOut::`vftable'

; 154  : 	if (!open())

	call	?open@CStdOut@@QAEKXZ			; CStdOut::open
	test	eax, eax
	jne	SHORT $L57493

; 155  : 		xxx_throw("CStdOut: unable to open stdout in constructor");

	mov	ecx, OFFSET FLAT:$SG56881
	call	@xxx_throw@4
$L57493:

; 156  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
text$x	SEGMENT
$L57481:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CBaseStream@@QAE@XZ			; CBaseStream::~CBaseStream
$L57494:
	mov	eax, OFFSET FLAT:$T57492
	jmp	___CxxFrameHandler
text$x	ENDS
??0CStdOut@@QAE@XZ ENDP					; CStdOut::CStdOut
PUBLIC	??3@YAXPAX@Z					; operator delete
; Function compile flags: /Ogty
; File C:\duke4\xcore\xcore.h
;	COMDAT ??3@YAXPAX@Z
_TEXT	SEGMENT
_ptr$ = 8
??3@YAXPAX@Z PROC NEAR					; operator delete, COMDAT

; 130  : __inline void operator delete(void *ptr){xfree(ptr);}

	mov	ecx, DWORD PTR _ptr$[esp-4]
	jmp	@xfree@4
??3@YAXPAX@Z ENDP					; operator delete
; Function compile flags: /Ogty
; File C:\duke4\xcore\file.cpp
_TEXT	ENDS
_TEXT	SEGMENT
?close@CStdOut@@UAEKXZ PROC NEAR			; CStdOut::close
; _this$ = ecx

; 160  : 	handle=null;
; 161  : 	state.is_open=FALSE;

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx+16], 0
	and	ah, -2					; fffffffeH
	mov	DWORD PTR [ecx+4], eax

; 162  : 	
; 163  : 	return TRUE;

	mov	eax, 1

; 164  : }

	ret	0
?close@CStdOut@@UAEKXZ ENDP				; CStdOut::close
; Function compile flags: /Ogty
; File C:\duke4\xcore\xclass.h
_TEXT	ENDS
;	COMDAT ??1autochar@@QAE@XZ
_TEXT	SEGMENT
??1autochar@@QAE@XZ PROC NEAR				; autochar::~autochar, COMDAT
; _this$ = ecx

; 69   : 	inline ~autochar(void){xfree(ptr);ptr=null;}

	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR [esi]
	call	@xfree@4
	mov	DWORD PTR [esi], 0
	pop	esi
	ret	0
??1autochar@@QAE@XZ ENDP				; autochar::~autochar
_TEXT	ENDS
PUBLIC	@fclean_path@8
EXTRN	?_app_char_flags@@3QBEB:BYTE			; _app_char_flags
EXTRN	@fstrlen@4:NEAR
EXTRN	@fstrcpy@8:NEAR
EXTRN	@fstrchr@8:NEAR
_DATA	SEGMENT
	ORG $+2
$SG56892 DB	'fclean_path: path is null', 00H
; Function compile flags: /Ogty
; File C:\duke4\xcore\file.cpp
_DATA	ENDS
_TEXT	SEGMENT
@fclean_path@8 PROC NEAR
; _path$ = ecx
; _len$ = edx

; 174  : {

	push	ebx
	push	ebp
	mov	ebp, ecx
	push	esi

; 175  : 	char *cur;
; 176  : 	
; 177  : 	if (!path)

	test	ebp, ebp
	push	edi
	mov	ebx, edx
	jne	SHORT $L56891

; 178  : 		xxx_throw("fclean_path: path is null");

	mov	ecx, OFFSET FLAT:$SG56892
	call	@xxx_throw@4
$L56891:

; 179  : 
; 180  : 	if (!len)

	test	ebx, ebx
	jne	SHORT $L56893

; 181  : 		fstrlen(path);

	mov	ecx, ebp
	call	@fstrlen@4
$L56893:

; 182  : 	
; 183  : 	autochar new_path;
; 184  : 
; 185  : 	new_path=(char *)xmalloc(len+1);

	lea	ecx, DWORD PTR [ebx+1]
	call	@xmalloc@4
	mov	edi, eax

; 186  : 	cur=new_path;

	mov	esi, edi
$L56897:

; 187  : 
; 188  : 	/* clean up slashes */
; 189  : 	while(1)
; 190  : 	{
; 191  : 		U8 key=*path++;

	mov	al, BYTE PTR [ebp]
	inc	ebp

; 192  : 		if (key==OS_SLASH_OTHER)

	cmp	al, 47					; 0000002fH
	jne	SHORT $L56900

; 193  : 			key=OS_SLASH;

	mov	al, 92					; 0000005cH
$L56900:

; 194  : 		*cur++=key;

	mov	BYTE PTR [esi], al
	inc	esi

; 195  : 		if (!key)

	test	al, al
	jne	SHORT $L56897

; 196  : 			break;
; 197  : 	}
; 198  : 
; 199  : 	/* check for more than 2 slashes at beginning */
; 200  : 	if (len > 2)

	cmp	ebx, 2
	jbe	SHORT $L56903

; 201  : 	{
; 202  : 		if ((new_path[0]==OS_SLASH) && 
; 203  : 			(new_path[1]==OS_SLASH) &&
; 204  : 			(new_path[2]==OS_SLASH))

	cmp	BYTE PTR [edi], 92			; 0000005cH
	jne	SHORT $L56903
	cmp	BYTE PTR [edi+1], 92			; 0000005cH
	jne	SHORT $L56903
	cmp	BYTE PTR [edi+2], 92			; 0000005cH
	jne	SHORT $L56903

; 205  : 			return null;

	mov	ecx, edi
	call	@xfree@4
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 263  : }

	ret	0
$L56903:

; 206  : 	}
; 207  : 	
; 208  : 	/* validate and determine path like \\server\share */
; 209  : 	U32 server_type=FALSE;

	xor	ebp, ebp

; 210  : 	if (len > 1)

	cmp	ebx, 1
	jbe	SHORT $L56913

; 211  : 	{
; 212  : 		if ((new_path[0]==OS_SLASH) && 
; 213  : 			(new_path[1]==OS_SLASH))

	cmp	BYTE PTR [edi], 92			; 0000005cH
	jne	SHORT $L56907
	cmp	BYTE PTR [edi+1], 92			; 0000005cH
	jne	SHORT $L56907

; 214  : 		{
; 215  : 			if (len<3)

	cmp	ebx, 3
	jae	SHORT $L56908

; 216  : 				return null;

	mov	ecx, edi
	call	@xfree@4
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 263  : }

	ret	0
$L56908:

; 217  : 			server_type=TRUE;

	mov	ebp, 1
$L56907:

; 218  : 		}
; 219  : 	}
; 220  : 	/* remove double slashes */
; 221  : 	if (len > 1)
; 222  : 	cur=new_path;
; 223  : 	/* if server type path, skip past first double slash */
; 224  : 	if (server_type)

	test	ebp, ebp
	mov	esi, edi
	je	SHORT $L56913

; 225  : 		cur+=2;

	lea	esi, DWORD PTR [edi+2]
$L56913:

; 227  : 	{
; 228  : 		cur=fstrchr(cur,OS_SLASH);

	mov	dl, 92					; 0000005cH
	mov	ecx, esi
	call	@fstrchr@8
	mov	esi, eax

; 229  : 		if (!cur)

	test	esi, esi
	je	SHORT $L57576

; 230  : 			break;
; 231  : 		/* if double slash, reduce it to one */
; 232  : 		if (cur[1]==OS_SLASH) /* safe since it will be null if we are at end */

	mov	al, BYTE PTR [esi+1]
	lea	edx, DWORD PTR [esi+1]
	cmp	al, 92					; 0000005cH
	jne	SHORT $L56916

; 233  : 		{
; 234  : 			fstrcpy(cur,cur+1);

	mov	ecx, esi
	call	@fstrcpy@8

; 235  : 			len--;

	dec	ebx

; 236  : 			/* so we redo, in case there is another slash following */
; 237  : 			cur--;

	dec	esi
$L56916:

; 238  : 		}
; 239  : 		cur++;

	inc	esi

; 226  : 	while(1)

	jmp	SHORT $L56913
$L57576:

; 240  : 	}
; 241  : 
; 242  : 	/* chop off starting slash */
; 243  : 	if (!server_type)

	test	ebp, ebp
	jne	SHORT $L56918

; 244  : 	{
; 245  : 		if (new_path[0]==OS_SLASH)

	cmp	BYTE PTR [edi], 92			; 0000005cH
	jne	SHORT $L56918

; 246  : 			fstrcpy(new_path,new_path+1);

	lea	edx, DWORD PTR [edi+1]
	mov	ecx, edi
	call	@fstrcpy@8
$L56918:

; 247  : 	}
; 248  : 
; 249  : 	/* skip past end slash chopping if something like c:\ */
; 250  : 	if (len==3)

	cmp	ebx, 3
	jne	SHORT $L56921

; 251  : 	{
; 252  : 		if ((new_path[1]==':') && (new_path[2]==OS_SLASH) && (is_alpha(new_path[0])))

	cmp	BYTE PTR [edi+1], 58			; 0000003aH
	jne	SHORT $L56921
	cmp	BYTE PTR [edi+2], 92			; 0000005cH
	jne	SHORT $L56921
	xor	eax, eax
	mov	al, BYTE PTR [edi]
	test	BYTE PTR ?_app_char_flags@@3QBEB[eax], 4
	jne	SHORT $done_path$56922
$L56921:

; 253  : 			goto done_path;
; 254  : 	}
; 255  : 
; 256  : 	/* chop off end slash */
; 257  : 	len=fstrlen(new_path);

	mov	ecx, edi
	call	@fstrlen@4

; 258  : 	if (new_path[len-1]==OS_SLASH)

	cmp	BYTE PTR [edi+eax-1], 92		; 0000005cH
	jne	SHORT $done_path$56922

; 259  : 		new_path[len-1]=0;

	mov	BYTE PTR [edi+eax-1], 0
$done_path$56922:

; 260  : 
; 261  : done_path:
; 262  : 	return new_path.release();

	xor	ecx, ecx
	call	@xfree@4
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 263  : }

	ret	0
@fclean_path@8 ENDP
_TEXT	ENDS
PUBLIC	??0?$XChain@VCSysObj@@@@QAE@XZ			; XChain<CSysObj>::XChain<CSysObj>
; Function compile flags: /Ogty
; File C:\duke4\xcore\xclass.h
;	COMDAT ??0?$XChain@VCSysObj@@@@QAE@XZ
_TEXT	SEGMENT
??0?$XChain@VCSysObj@@@@QAE@XZ PROC NEAR		; XChain<CSysObj>::XChain<CSysObj>, COMDAT
; _this$ = ecx

; 830  : 	XChain(void) : head(null),tail(null) {}

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$XChain@VCSysObj@@@@QAE@XZ ENDP			; XChain<CSysObj>::XChain<CSysObj>
_TEXT	ENDS
PUBLIC	??0?$XChain@VCSysObj@@@@QAE@K@Z			; XChain<CSysObj>::XChain<CSysObj>
; Function compile flags: /Ogty
;	COMDAT ??0?$XChain@VCSysObj@@@@QAE@K@Z
_TEXT	SEGMENT
_owned$ = 8
??0?$XChain@VCSysObj@@@@QAE@K@Z PROC NEAR		; XChain<CSysObj>::XChain<CSysObj>, COMDAT
; _this$ = ecx

; 831  : 	XChain(U32 owned) : head(null),tail(null),xchain_state(owned) {}

	mov	eax, ecx
	mov	ecx, DWORD PTR _owned$[esp-4]
	shl	ecx, 31					; 0000001fH
	and	ecx, -2147483648			; 80000000H
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], ecx
	ret	4
??0?$XChain@VCSysObj@@@@QAE@K@Z ENDP			; XChain<CSysObj>::XChain<CSysObj>
_TEXT	ENDS
PUBLIC	?get_next@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z ; XChain<CSysObj>::get_next
; Function compile flags: /Ogty
;	COMDAT ?get_next@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z
_TEXT	SEGMENT
_ptr$ = 8
?get_next@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z PROC NEAR ; XChain<CSysObj>::get_next, COMDAT
; _this$ = ecx

; 840  : 	TYPE *get_next(TYPE *ptr){return ptr->next;}

	mov	eax, DWORD PTR _ptr$[esp-4]
	mov	eax, DWORD PTR [eax+4]
	ret	4
?get_next@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z ENDP ; XChain<CSysObj>::get_next
_TEXT	ENDS
PUBLIC	?get_prev@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z ; XChain<CSysObj>::get_prev
; Function compile flags: /Ogty
;	COMDAT ?get_prev@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z
_TEXT	SEGMENT
_ptr$ = 8
?get_prev@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z PROC NEAR ; XChain<CSysObj>::get_prev, COMDAT
; _this$ = ecx

; 841  : 	TYPE *get_prev(TYPE *ptr){return ptr->prev;}

	mov	eax, DWORD PTR _ptr$[esp-4]
	mov	eax, DWORD PTR [eax+8]
	ret	4
?get_prev@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z ENDP ; XChain<CSysObj>::get_prev
_TEXT	ENDS
PUBLIC	?get_head@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ ; XChain<CSysObj>::get_head
; Function compile flags: /Ogty
;	COMDAT ?get_head@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ
_TEXT	SEGMENT
?get_head@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ PROC NEAR ; XChain<CSysObj>::get_head, COMDAT
; _this$ = ecx

; 847  : 	inline TYPE *get_head(void){return head;}

	mov	eax, DWORD PTR [ecx]
	ret	0
?get_head@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ ENDP	; XChain<CSysObj>::get_head
_TEXT	ENDS
PUBLIC	?get_tail@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ ; XChain<CSysObj>::get_tail
; Function compile flags: /Ogty
;	COMDAT ?get_tail@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ
_TEXT	SEGMENT
?get_tail@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ PROC NEAR ; XChain<CSysObj>::get_tail, COMDAT
; _this$ = ecx

; 848  : 	inline TYPE *get_tail(void){return tail;}

	mov	eax, DWORD PTR [ecx+4]
	ret	0
?get_tail@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ ENDP	; XChain<CSysObj>::get_tail
_TEXT	ENDS
PUBLIC	??1?$XChain@VCSysObj@@@@QAE@XZ			; XChain<CSysObj>::~XChain<CSysObj>
EXTRN	?unreg_global_object@XGlobal@@QAEXPAVCSysObj@@@Z:NEAR ; XGlobal::unreg_global_object
; Function compile flags: /Ogty
;	COMDAT ??1?$XChain@VCSysObj@@@@QAE@XZ
_TEXT	SEGMENT
??1?$XChain@VCSysObj@@@@QAE@XZ PROC NEAR		; XChain<CSysObj>::~XChain<CSysObj>, COMDAT
; _this$ = ecx

; 853  : {

	push	esi
	mov	esi, ecx

; 854  : 	if (xchain_state.owned)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	jns	SHORT $L57624

; 855  : 	{
; 856  : 		while(head)

	cmp	DWORD PTR [esi], 0
	je	SHORT $L57624
	push	ebx
	push	edi
$L57011:

; 857  : 		{
; 858  : 			TYPE *tmp=(TYPE *)head->next;

	mov	eax, DWORD PTR [esi]

; 859  : 			delete head;

	mov	edi, eax
	mov	ebx, DWORD PTR [eax+4]
	test	edi, edi
	je	SHORT $L57605
	mov	DWORD PTR [edi], OFFSET FLAT:??_7CSysObj@@6B@ ; CSysObj::`vftable'
	mov	ecx, DWORD PTR ?_global@@3PAVXGlobal@@A	; _global
	push	edi
	call	?unreg_global_object@XGlobal@@QAEXPAVCSysObj@@@Z ; XGlobal::unreg_global_object
	mov	ecx, edi
	call	@xfree@4
$L57605:
	test	ebx, ebx

; 860  : 			head=tmp;

	mov	DWORD PTR [esi], ebx
	jne	SHORT $L57011
	pop	edi
	pop	ebx
$L57624:

; 861  : 		}
; 862  : 	}
; 863  : 	head=null;

	mov	DWORD PTR [esi], 0

; 864  : 	tail=null;

	mov	DWORD PTR [esi+4], 0
	pop	esi

; 865  : }

	ret	0
??1?$XChain@VCSysObj@@@@QAE@XZ ENDP			; XChain<CSysObj>::~XChain<CSysObj>
_TEXT	ENDS
PUBLIC	?lose_list@?$XChain@VCSysObj@@@@QAEXXZ		; XChain<CSysObj>::lose_list
; Function compile flags: /Ogty
;	COMDAT ?lose_list@?$XChain@VCSysObj@@@@QAEXXZ
_TEXT	SEGMENT
?lose_list@?$XChain@VCSysObj@@@@QAEXXZ PROC NEAR	; XChain<CSysObj>::lose_list, COMDAT
; _this$ = ecx

; 870  : 	head=null;tail=null;xchain_state.count=0;

	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [ecx], 0
	and	eax, -2147483648			; 80000000H
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], eax

; 871  : }

	ret	0
?lose_list@?$XChain@VCSysObj@@@@QAEXXZ ENDP		; XChain<CSysObj>::lose_list
_TEXT	ENDS
PUBLIC	?free_list@?$XChain@VCSysObj@@@@QAEXXZ		; XChain<CSysObj>::free_list
; Function compile flags: /Ogty
;	COMDAT ?free_list@?$XChain@VCSysObj@@@@QAEXXZ
_TEXT	SEGMENT
?free_list@?$XChain@VCSysObj@@@@QAEXXZ PROC NEAR	; XChain<CSysObj>::free_list, COMDAT
; _this$ = ecx

; 875  : {

	push	esi
	mov	esi, ecx

; 876  : 	if (xchain_state.owned)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	jns	SHORT $L57650

; 877  : 	{
; 878  : 		while(head)

	cmp	DWORD PTR [esi], 0
	je	SHORT $L57650
	push	ebx
	push	edi
$L57027:

; 879  : 		{
; 880  : 			TYPE *tmp=(TYPE *)head->next;

	mov	eax, DWORD PTR [esi]

; 881  : 			delete head;

	mov	edi, eax
	mov	ebx, DWORD PTR [eax+4]
	test	edi, edi
	je	SHORT $L57631
	mov	DWORD PTR [edi], OFFSET FLAT:??_7CSysObj@@6B@ ; CSysObj::`vftable'
	mov	ecx, DWORD PTR ?_global@@3PAVXGlobal@@A	; _global
	push	edi
	call	?unreg_global_object@XGlobal@@QAEXPAVCSysObj@@@Z ; XGlobal::unreg_global_object
	mov	ecx, edi
	call	@xfree@4
$L57631:
	test	ebx, ebx

; 882  : 			head=tmp;

	mov	DWORD PTR [esi], ebx
	jne	SHORT $L57027
	pop	edi
	pop	ebx
$L57650:

; 883  : 		}
; 884  : 	}
; 885  : 	head=null;tail=null;

	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+4], 0
	pop	esi

; 886  : }

	ret	0
?free_list@?$XChain@VCSysObj@@@@QAEXXZ ENDP		; XChain<CSysObj>::free_list
_TEXT	ENDS
PUBLIC	?add_head@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z ; XChain<CSysObj>::add_head
; Function compile flags: /Ogty
;	COMDAT ?add_head@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z
_TEXT	SEGMENT
_ptr$ = 8
?add_head@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z PROC NEAR ; XChain<CSysObj>::add_head, COMDAT
; _this$ = ecx

; 891  : 	ptr->next=head;

	mov	eax, DWORD PTR _ptr$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx

; 892  : 	ptr->prev=null;

	mov	DWORD PTR [eax+8], 0

; 893  : 	if (head)

	mov	edx, DWORD PTR [ecx]
	test	edx, edx
	je	SHORT $L57037

; 894  : 		head->prev=ptr;

	mov	DWORD PTR [edx+8], eax

; 897  : 	
; 898  : 	head=ptr;

	mov	DWORD PTR [ecx], eax

; 899  : 
; 900  : 	return head;
; 901  : }

	ret	4
$L57037:

; 895  : 	else
; 896  : 		tail=ptr;

	mov	DWORD PTR [ecx+4], eax

; 897  : 	
; 898  : 	head=ptr;

	mov	DWORD PTR [ecx], eax

; 899  : 
; 900  : 	return head;
; 901  : }

	ret	4
?add_head@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z ENDP ; XChain<CSysObj>::add_head
_TEXT	ENDS
PUBLIC	?add_tail@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z ; XChain<CSysObj>::add_tail
; Function compile flags: /Ogty
;	COMDAT ?add_tail@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z
_TEXT	SEGMENT
_ptr$ = 8
?add_tail@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z PROC NEAR ; XChain<CSysObj>::add_tail, COMDAT
; _this$ = ecx

; 906  : 	ptr->prev=tail;

	mov	eax, DWORD PTR _ptr$[esp-4]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+8], edx

; 907  : 	ptr->next=null;

	mov	DWORD PTR [eax+4], 0

; 908  : 	if (tail)

	mov	edx, DWORD PTR [ecx+4]
	test	edx, edx
	je	SHORT $L57043

; 909  : 		tail->next=ptr;

	mov	DWORD PTR [edx+4], eax

; 912  : 	
; 913  : 	tail=ptr;

	mov	DWORD PTR [ecx+4], eax

; 914  : 
; 915  : 	return tail;
; 916  : }

	ret	4
$L57043:

; 910  : 	else
; 911  : 		head=ptr;

	mov	DWORD PTR [ecx], eax

; 912  : 	
; 913  : 	tail=ptr;

	mov	DWORD PTR [ecx+4], eax

; 914  : 
; 915  : 	return tail;
; 916  : }

	ret	4
?add_tail@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z ENDP ; XChain<CSysObj>::add_tail
_TEXT	ENDS
PUBLIC	?remove_head@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ ; XChain<CSysObj>::remove_head
; Function compile flags: /Ogty
;	COMDAT ?remove_head@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ
_TEXT	SEGMENT
?remove_head@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ PROC NEAR ; XChain<CSysObj>::remove_head, COMDAT
; _this$ = ecx

; 937  : 	if (!head)

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	jne	SHORT $L57049

; 947  : 
; 948  : 	return ret;
; 949  : }

	ret	0
$L57049:

; 938  : 		return null;
; 939  : 
; 940  : 	TYPE *ret=head;
; 941  : 
; 942  : 	head=head->next;

	mov	edx, DWORD PTR [eax+4]

; 943  : 	if (!head)

	test	edx, edx
	mov	DWORD PTR [ecx], edx
	jne	SHORT $L57051

; 944  : 		tail=null;

	mov	DWORD PTR [ecx+4], edx

; 947  : 
; 948  : 	return ret;
; 949  : }

	ret	0
$L57051:

; 945  : 	else
; 946  : 		head->prev=null;

	mov	DWORD PTR [edx+8], 0

; 947  : 
; 948  : 	return ret;
; 949  : }

	ret	0
?remove_head@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ ENDP ; XChain<CSysObj>::remove_head
_TEXT	ENDS
PUBLIC	?remove_tail@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ ; XChain<CSysObj>::remove_tail
; Function compile flags: /Ogty
;	COMDAT ?remove_tail@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ
_TEXT	SEGMENT
?remove_tail@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ PROC NEAR ; XChain<CSysObj>::remove_tail, COMDAT
; _this$ = ecx

; 954  : 	if (!tail)

	mov	eax, DWORD PTR [ecx+4]
	test	eax, eax
	jne	SHORT $L57057

; 964  : 
; 965  : 	return ret;
; 966  : }

	ret	0
$L57057:

; 955  : 		return null;
; 956  : 
; 957  : 	TYPE *ret=tail;
; 958  : 
; 959  : 	tail=tail->prev;

	mov	edx, DWORD PTR [eax+8]

; 960  : 	if (!tail)

	test	edx, edx
	mov	DWORD PTR [ecx+4], edx
	jne	SHORT $L57059

; 961  : 		head=null;

	mov	DWORD PTR [ecx], edx

; 964  : 
; 965  : 	return ret;
; 966  : }

	ret	0
$L57059:

; 962  : 	else
; 963  : 		tail->next=null;

	mov	DWORD PTR [edx+4], 0

; 964  : 
; 965  : 	return ret;
; 966  : }

	ret	0
?remove_tail@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@XZ ENDP ; XChain<CSysObj>::remove_tail
_TEXT	ENDS
PUBLIC	?remove@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z ; XChain<CSysObj>::remove
; Function compile flags: /Ogty
;	COMDAT ?remove@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z
_TEXT	SEGMENT
_ptr$ = 8
?remove@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z PROC NEAR ; XChain<CSysObj>::remove, COMDAT
; _this$ = ecx

; 921  : 	if (ptr->prev)

	mov	eax, DWORD PTR _ptr$[esp-4]
	mov	edx, DWORD PTR [eax+8]
	test	edx, edx
	je	SHORT $L57065
	push	esi

; 922  : 		ptr->prev->next=ptr->next;

	mov	esi, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], esi
	pop	esi

; 923  : 	else

	jmp	SHORT $L57066
$L57065:

; 924  : 		head=ptr->next;

	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx], edx
$L57066:

; 925  : 
; 926  : 	if (ptr->next)

	mov	edx, DWORD PTR [eax+4]
	test	edx, edx
	je	SHORT $L57067

; 927  : 		ptr->next->prev=ptr->prev;

	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], ecx

; 930  : 
; 931  : 	return ptr;
; 932  : }

	ret	4
$L57067:

; 928  : 	else
; 929  : 		tail=ptr->prev;

	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+4], edx

; 930  : 
; 931  : 	return ptr;
; 932  : }

	ret	4
?remove@?$XChain@VCSysObj@@@@QAEPAVCSysObj@@PAV2@@Z ENDP ; XChain<CSysObj>::remove
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??1CSysObj@@QAE@XZ
_TEXT	SEGMENT
??1CSysObj@@QAE@XZ PROC NEAR				; CSysObj::~CSysObj, COMDAT
; _this$ = ecx

; 1470 : inline CSysObj::~CSysObj(void){_global->unreg_global_object(this);}

	mov	DWORD PTR [ecx], OFFSET FLAT:??_7CSysObj@@6B@ ; CSysObj::`vftable'
	push	ecx
	mov	ecx, DWORD PTR ?_global@@3PAVXGlobal@@A	; _global
	call	?unreg_global_object@XGlobal@@QAEXPAVCSysObj@@@Z ; XGlobal::unreg_global_object
	ret	0
??1CSysObj@@QAE@XZ ENDP					; CSysObj::~CSysObj
_TEXT	ENDS
PUBLIC	??_7XBufferReadInt@@6B@				; XBufferReadInt::`vftable'
PUBLIC	??_GXBufferReadInt@@UAEPAXI@Z			; XBufferReadInt::`scalar deleting destructor'
PUBLIC	??_EXBufferReadInt@@UAEPAXI@Z			; XBufferReadInt::`vector deleting destructor'
;	COMDAT ??_7XBufferReadInt@@6B@
; File C:\duke4\xcore\xcore.h
CONST	SEGMENT
??_7XBufferReadInt@@6B@ DD FLAT:?read_direct@XBufferReadInt@@MAEKPAXKAAK@Z ; XBufferReadInt::`vftable'
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:??_EXBufferReadInt@@UAEPAXI@Z
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ??_GXBufferReadInt@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_GXBufferReadInt@@UAEPAXI@Z PROC NEAR			; XBufferReadInt::`scalar deleting destructor', COMDAT
; _this$ = ecx
	mov	al, BYTE PTR ___flags$[esp-4]
	push	esi
	mov	esi, ecx
	test	al, 1
	mov	DWORD PTR [esi], OFFSET FLAT:??_7XBufferReadInt@@6B@ ; XBufferReadInt::`vftable'
	je	SHORT $L57673
	call	@xfree@4
$L57673:
	mov	eax, esi
	pop	esi
	ret	4
??_GXBufferReadInt@@UAEPAXI@Z ENDP			; XBufferReadInt::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??1XBufferReadInt@@UAE@XZ			; XBufferReadInt::~XBufferReadInt
EXTRN	??_M@YGXPAXIHP6EX0@Z@Z:NEAR			; `eh vector destructor iterator'
; Function compile flags: /Ogty
;	COMDAT ??_EXBufferReadInt@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_EXBufferReadInt@@UAEPAXI@Z PROC NEAR			; XBufferReadInt::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebx
	mov	bl, BYTE PTR ___flags$[esp]
	push	esi
	mov	esi, ecx
	test	bl, 2
	je	SHORT $L56059
	mov	eax, DWORD PTR [esi-4]
	push	edi
	lea	edi, DWORD PTR [esi-4]
	push	OFFSET FLAT:??1XBufferReadInt@@UAE@XZ	; XBufferReadInt::~XBufferReadInt
	push	eax
	push	8
	push	esi
	call	??_M@YGXPAXIHP6EX0@Z@Z			; `eh vector destructor iterator'
	test	bl, 1
	je	SHORT $L57678
	mov	ecx, edi
	call	@xfree@4
$L57678:
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	ret	4
$L56059:
	test	bl, 1
	mov	DWORD PTR [esi], OFFSET FLAT:??_7XBufferReadInt@@6B@ ; XBufferReadInt::`vftable'
	je	SHORT $L57684
	mov	ecx, esi
	call	@xfree@4
$L57684:
	mov	eax, esi
	pop	esi
	pop	ebx
	ret	4
??_EXBufferReadInt@@UAEPAXI@Z ENDP			; XBufferReadInt::`vector deleting destructor'
; Function compile flags: /Ogty
; File C:\duke4\xcore\xstream.h
_TEXT	ENDS
;	COMDAT ??1XBufferReadInt@@UAE@XZ
_TEXT	SEGMENT
??1XBufferReadInt@@UAE@XZ PROC NEAR			; XBufferReadInt::~XBufferReadInt, COMDAT
; _this$ = ecx

; 37   : 	virtual ~XBufferReadInt(void){}

	mov	DWORD PTR [ecx], OFFSET FLAT:??_7XBufferReadInt@@6B@ ; XBufferReadInt::`vftable'
	ret	0
??1XBufferReadInt@@UAE@XZ ENDP				; XBufferReadInt::~XBufferReadInt
_TEXT	ENDS
PUBLIC	??_7XBufferWriteInt@@6B@			; XBufferWriteInt::`vftable'
PUBLIC	??_GXBufferWriteInt@@UAEPAXI@Z			; XBufferWriteInt::`scalar deleting destructor'
PUBLIC	??_EXBufferWriteInt@@UAEPAXI@Z			; XBufferWriteInt::`vector deleting destructor'
;	COMDAT ??_7XBufferWriteInt@@6B@
; File C:\duke4\xcore\xcore.h
CONST	SEGMENT
??_7XBufferWriteInt@@6B@ DD FLAT:?write_direct@XBufferWriteInt@@MAEKPBXKAAK@Z ; XBufferWriteInt::`vftable'
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:??_EXBufferWriteInt@@UAEPAXI@Z
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ??_GXBufferWriteInt@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_GXBufferWriteInt@@UAEPAXI@Z PROC NEAR		; XBufferWriteInt::`scalar deleting destructor', COMDAT
; _this$ = ecx
	mov	al, BYTE PTR ___flags$[esp-4]
	push	esi
	mov	esi, ecx
	test	al, 1
	mov	DWORD PTR [esi], OFFSET FLAT:??_7XBufferWriteInt@@6B@ ; XBufferWriteInt::`vftable'
	je	SHORT $L57695
	call	@xfree@4
$L57695:
	mov	eax, esi
	pop	esi
	ret	4
??_GXBufferWriteInt@@UAEPAXI@Z ENDP			; XBufferWriteInt::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??1XBufferWriteInt@@UAE@XZ			; XBufferWriteInt::~XBufferWriteInt
; Function compile flags: /Ogty
;	COMDAT ??_EXBufferWriteInt@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_EXBufferWriteInt@@UAEPAXI@Z PROC NEAR		; XBufferWriteInt::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebx
	mov	bl, BYTE PTR ___flags$[esp]
	push	esi
	mov	esi, ecx
	test	bl, 2
	je	SHORT $L56111
	mov	eax, DWORD PTR [esi-4]
	push	edi
	lea	edi, DWORD PTR [esi-4]
	push	OFFSET FLAT:??1XBufferWriteInt@@UAE@XZ	; XBufferWriteInt::~XBufferWriteInt
	push	eax
	push	8
	push	esi
	call	??_M@YGXPAXIHP6EX0@Z@Z			; `eh vector destructor iterator'
	test	bl, 1
	je	SHORT $L57700
	mov	ecx, edi
	call	@xfree@4
$L57700:
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	ret	4
$L56111:
	test	bl, 1
	mov	DWORD PTR [esi], OFFSET FLAT:??_7XBufferWriteInt@@6B@ ; XBufferWriteInt::`vftable'
	je	SHORT $L57706
	mov	ecx, esi
	call	@xfree@4
$L57706:
	mov	eax, esi
	pop	esi
	pop	ebx
	ret	4
??_EXBufferWriteInt@@UAEPAXI@Z ENDP			; XBufferWriteInt::`vector deleting destructor'
; Function compile flags: /Ogty
; File C:\duke4\xcore\xstream.h
_TEXT	ENDS
;	COMDAT ??1XBufferWriteInt@@UAE@XZ
_TEXT	SEGMENT
??1XBufferWriteInt@@UAE@XZ PROC NEAR			; XBufferWriteInt::~XBufferWriteInt, COMDAT
; _this$ = ecx

; 56   : 	virtual ~XBufferWriteInt(void){}

	mov	DWORD PTR [ecx], OFFSET FLAT:??_7XBufferWriteInt@@6B@ ; XBufferWriteInt::`vftable'
	ret	0
??1XBufferWriteInt@@UAE@XZ ENDP				; XBufferWriteInt::~XBufferWriteInt
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?seek@XStreamRdDirect@@UAEKJ@Z
_TEXT	SEGMENT
?seek@XStreamRdDirect@@UAEKJ@Z PROC NEAR		; XStreamRdDirect::seek, COMDAT
; _this$ = ecx

; 70   : 	U32 seek(I32 delta_pos){return TRUE;}

	mov	eax, 1
	ret	4
?seek@XStreamRdDirect@@UAEKJ@Z ENDP			; XStreamRdDirect::seek
_TEXT	ENDS
PUBLIC	??1XStreamRdDirect@@UAE@XZ			; XStreamRdDirect::~XStreamRdDirect
PUBLIC	??_GXStreamRdDirect@@UAEPAXI@Z			; XStreamRdDirect::`scalar deleting destructor'
; Function compile flags: /Ogty
;	COMDAT ??_GXStreamRdDirect@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_GXStreamRdDirect@@UAEPAXI@Z PROC NEAR		; XStreamRdDirect::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1XStreamRdDirect@@UAE@XZ		; XStreamRdDirect::~XStreamRdDirect
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $L57716
	mov	ecx, esi
	call	@xfree@4
$L57716:
	mov	eax, esi
	pop	esi
	ret	4
??_GXStreamRdDirect@@UAEPAXI@Z ENDP			; XStreamRdDirect::`scalar deleting destructor'
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??1XStreamRdDirect@@UAE@XZ
_TEXT	SEGMENT
??1XStreamRdDirect@@UAE@XZ PROC NEAR			; XStreamRdDirect::~XStreamRdDirect, COMDAT
; _this$ = ecx

; 71   : 	~XStreamRdDirect(void){}

	mov	DWORD PTR [ecx], OFFSET FLAT:??_7XBufferReadInt@@6B@ ; XBufferReadInt::`vftable'
	ret	0
??1XStreamRdDirect@@UAE@XZ ENDP				; XStreamRdDirect::~XStreamRdDirect
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??_EXStreamRdDirect@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_EXStreamRdDirect@@UAEPAXI@Z PROC NEAR		; XStreamRdDirect::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebx
	mov	bl, BYTE PTR ___flags$[esp]
	push	esi
	mov	esi, ecx
	test	bl, 2
	je	SHORT $L56163
	mov	eax, DWORD PTR [esi-4]
	push	edi
	lea	edi, DWORD PTR [esi-4]
	push	OFFSET FLAT:??1XStreamRdDirect@@UAE@XZ	; XStreamRdDirect::~XStreamRdDirect
	push	eax
	push	8
	push	esi
	call	??_M@YGXPAXIHP6EX0@Z@Z			; `eh vector destructor iterator'
	test	bl, 1
	je	SHORT $L57727
	mov	ecx, edi
	call	@xfree@4
$L57727:
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	ret	4
$L56163:
	mov	ecx, esi
	call	??1XStreamRdDirect@@UAE@XZ		; XStreamRdDirect::~XStreamRdDirect
	test	bl, 1
	je	SHORT $L57729
	mov	ecx, esi
	call	@xfree@4
$L57729:
	mov	eax, esi
	pop	esi
	pop	ebx
	ret	4
??_EXStreamRdDirect@@UAEPAXI@Z ENDP			; XStreamRdDirect::`vector deleting destructor'
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?seek@XStreamWrDirect@@UAEKJ@Z
_TEXT	SEGMENT
?seek@XStreamWrDirect@@UAEKJ@Z PROC NEAR		; XStreamWrDirect::seek, COMDAT
; _this$ = ecx

; 86   : 	U32 seek(I32 delta_pos){return TRUE;}

	mov	eax, 1
	ret	4
?seek@XStreamWrDirect@@UAEKJ@Z ENDP			; XStreamWrDirect::seek
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?flush@XStreamWrDirect@@UAEKXZ
_TEXT	SEGMENT
?flush@XStreamWrDirect@@UAEKXZ PROC NEAR		; XStreamWrDirect::flush, COMDAT
; _this$ = ecx

; 87   : 	U32 flush(void){return TRUE;}

	mov	eax, 1
	ret	0
?flush@XStreamWrDirect@@UAEKXZ ENDP			; XStreamWrDirect::flush
_TEXT	ENDS
PUBLIC	??1XStreamWrDirect@@UAE@XZ			; XStreamWrDirect::~XStreamWrDirect
PUBLIC	??_GXStreamWrDirect@@UAEPAXI@Z			; XStreamWrDirect::`scalar deleting destructor'
; Function compile flags: /Ogty
;	COMDAT ??_GXStreamWrDirect@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_GXStreamWrDirect@@UAEPAXI@Z PROC NEAR		; XStreamWrDirect::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1XStreamWrDirect@@UAE@XZ		; XStreamWrDirect::~XStreamWrDirect
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $L57740
	mov	ecx, esi
	call	@xfree@4
$L57740:
	mov	eax, esi
	pop	esi
	ret	4
??_GXStreamWrDirect@@UAEPAXI@Z ENDP			; XStreamWrDirect::`scalar deleting destructor'
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??1XStreamWrDirect@@UAE@XZ
_TEXT	SEGMENT
??1XStreamWrDirect@@UAE@XZ PROC NEAR			; XStreamWrDirect::~XStreamWrDirect, COMDAT
; _this$ = ecx

; 88   : 	~XStreamWrDirect(void){}

	mov	DWORD PTR [ecx], OFFSET FLAT:??_7XBufferWriteInt@@6B@ ; XBufferWriteInt::`vftable'
	ret	0
??1XStreamWrDirect@@UAE@XZ ENDP				; XStreamWrDirect::~XStreamWrDirect
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??_EXStreamWrDirect@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_EXStreamWrDirect@@UAEPAXI@Z PROC NEAR		; XStreamWrDirect::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebx
	mov	bl, BYTE PTR ___flags$[esp]
	push	esi
	mov	esi, ecx
	test	bl, 2
	je	SHORT $L56219
	mov	eax, DWORD PTR [esi-4]
	push	edi
	lea	edi, DWORD PTR [esi-4]
	push	OFFSET FLAT:??1XStreamWrDirect@@UAE@XZ	; XStreamWrDirect::~XStreamWrDirect
	push	eax
	push	8
	push	esi
	call	??_M@YGXPAXIHP6EX0@Z@Z			; `eh vector destructor iterator'
	test	bl, 1
	je	SHORT $L57751
	mov	ecx, edi
	call	@xfree@4
$L57751:
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	ret	4
$L56219:
	mov	ecx, esi
	call	??1XStreamWrDirect@@UAE@XZ		; XStreamWrDirect::~XStreamWrDirect
	test	bl, 1
	je	SHORT $L57753
	mov	ecx, esi
	call	@xfree@4
$L57753:
	mov	eax, esi
	pop	esi
	pop	ebx
	ret	4
??_EXStreamWrDirect@@UAEPAXI@Z ENDP			; XStreamWrDirect::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??1XMemRdBuffer@@UAE@XZ				; XMemRdBuffer::~XMemRdBuffer
PUBLIC	??_GXMemRdBuffer@@UAEPAXI@Z			; XMemRdBuffer::`scalar deleting destructor'
; Function compile flags: /Ogty
;	COMDAT ??_GXMemRdBuffer@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_GXMemRdBuffer@@UAEPAXI@Z PROC NEAR			; XMemRdBuffer::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1XMemRdBuffer@@UAE@XZ			; XMemRdBuffer::~XMemRdBuffer
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $L57760
	mov	ecx, esi
	call	@xfree@4
$L57760:
	mov	eax, esi
	pop	esi
	ret	4
??_GXMemRdBuffer@@UAEPAXI@Z ENDP			; XMemRdBuffer::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_7XMemRdBuffer@@6B@				; XMemRdBuffer::`vftable'
PUBLIC	??_EXMemRdBuffer@@UAEPAXI@Z			; XMemRdBuffer::`vector deleting destructor'
EXTRN	?read@XMemRdBuffer@@UAEKPAXKAAK1@Z:NEAR		; XMemRdBuffer::read
EXTRN	?seek@XMemRdBuffer@@UAEKJ@Z:NEAR		; XMemRdBuffer::seek
;	COMDAT ??_7XMemRdBuffer@@6B@
CONST	SEGMENT
??_7XMemRdBuffer@@6B@ DD FLAT:?read_direct@XBufferReadInt@@MAEKPAXKAAK@Z ; XMemRdBuffer::`vftable'
	DD	FLAT:?read@XMemRdBuffer@@UAEKPAXKAAK1@Z
	DD	FLAT:?seek@XMemRdBuffer@@UAEKJ@Z
	DD	FLAT:??_EXMemRdBuffer@@UAEPAXI@Z
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ??1XMemRdBuffer@@UAE@XZ
_TEXT	SEGMENT
??1XMemRdBuffer@@UAE@XZ PROC NEAR			; XMemRdBuffer::~XMemRdBuffer, COMDAT
; _this$ = ecx

; 109  : 	~XMemRdBuffer(void){}

	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET FLAT:??_7XMemRdBuffer@@6B@ ; XMemRdBuffer::`vftable'
	mov	ecx, DWORD PTR [esi+8]
	call	@xfree@4
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi], OFFSET FLAT:??_7XBufferReadInt@@6B@ ; XBufferReadInt::`vftable'
	pop	esi
	ret	0
??1XMemRdBuffer@@UAE@XZ ENDP				; XMemRdBuffer::~XMemRdBuffer
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??_EXMemRdBuffer@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_EXMemRdBuffer@@UAEPAXI@Z PROC NEAR			; XMemRdBuffer::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebx
	mov	bl, BYTE PTR ___flags$[esp]
	push	esi
	mov	esi, ecx
	test	bl, 2
	je	SHORT $L56272
	mov	eax, DWORD PTR [esi-4]
	push	edi
	lea	edi, DWORD PTR [esi-4]
	push	OFFSET FLAT:??1XMemRdBuffer@@UAE@XZ	; XMemRdBuffer::~XMemRdBuffer
	push	eax
	push	24					; 00000018H
	push	esi
	call	??_M@YGXPAXIHP6EX0@Z@Z			; `eh vector destructor iterator'
	test	bl, 1
	je	SHORT $L57776
	mov	ecx, edi
	call	@xfree@4
$L57776:
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	ret	4
$L56272:
	mov	ecx, esi
	call	??1XMemRdBuffer@@UAE@XZ			; XMemRdBuffer::~XMemRdBuffer
	test	bl, 1
	je	SHORT $L57778
	mov	ecx, esi
	call	@xfree@4
$L57778:
	mov	eax, esi
	pop	esi
	pop	ebx
	ret	4
??_EXMemRdBuffer@@UAEPAXI@Z ENDP			; XMemRdBuffer::`vector deleting destructor'
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??0XStreamState@@QAE@XZ
_TEXT	SEGMENT
??0XStreamState@@QAE@XZ PROC NEAR			; XStreamState::XStreamState, COMDAT
; _this$ = ecx

; 131  : 	XStreamState(void) : loaded(0),read(0),write(0),append(0),binary(1),text(0),create(0),truncate(0),is_open(0),error(0),pos_at(0),pos_should(0) {}

	mov	eax, ecx
	mov	ecx, DWORD PTR [eax]
	and	ecx, -4080				; fffff010H
	or	ecx, 16					; 00000010H
	mov	DWORD PTR [eax], ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0XStreamState@@QAE@XZ ENDP				; XStreamState::XStreamState
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?seek_int@CBaseStream@@MAEJXZ
_TEXT	SEGMENT
?seek_int@CBaseStream@@MAEJXZ PROC NEAR			; CBaseStream::seek_int, COMDAT
; _this$ = ecx

; 163  : 	virtual I32 seek_int(void){return TRUE;}

	mov	eax, 1
	ret	0
?seek_int@CBaseStream@@MAEJXZ ENDP			; CBaseStream::seek_int
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??1CBaseStream@@QAE@XZ
_TEXT	SEGMENT
??1CBaseStream@@QAE@XZ PROC NEAR			; CBaseStream::~CBaseStream, COMDAT
; _this$ = ecx

; 167  : 	{

	push	esi
	mov	esi, ecx

; 168  : 		delete rd_int;

	mov	ecx, DWORD PTR [esi+20]
	mov	DWORD PTR [esi], OFFSET FLAT:??_7CBaseStream@@6B@ ; CBaseStream::`vftable'
	test	ecx, ecx
	je	SHORT $L57788
	mov	eax, DWORD PTR [ecx]
	push	1
	call	DWORD PTR [eax+12]
$L57788:

; 169  : 		delete wr_int;

	mov	ecx, DWORD PTR [esi+24]
	pop	esi
	test	ecx, ecx
	je	SHORT $L57792
	mov	edx, DWORD PTR [ecx]
	push	1
	call	DWORD PTR [edx+16]
$L57792:

; 170  : 	}

	ret	0
??1CBaseStream@@QAE@XZ ENDP				; CBaseStream::~CBaseStream
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?ioctl_read@CBaseStream@@UAEKKK@Z
_TEXT	SEGMENT
?ioctl_read@CBaseStream@@UAEKKK@Z PROC NEAR		; CBaseStream::ioctl_read, COMDAT
; _this$ = ecx

; 173  : 	virtual U32 ioctl_read(U32 type,U32 size){return TRUE;}

	mov	eax, 1
	ret	8
?ioctl_read@CBaseStream@@UAEKKK@Z ENDP			; CBaseStream::ioctl_read
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?ioctl_write@CBaseStream@@UAEKKK@Z
_TEXT	SEGMENT
?ioctl_write@CBaseStream@@UAEKKK@Z PROC NEAR		; CBaseStream::ioctl_write, COMDAT
; _this$ = ecx

; 174  : 	virtual U32 ioctl_write(U32 type,U32 size){return TRUE;}

	mov	eax, 1
	ret	8
?ioctl_write@CBaseStream@@UAEKKK@Z ENDP			; CBaseStream::ioctl_write
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?put@CBaseStream@@UAEKD@Z
_TEXT	SEGMENT
_val$ = 8
?put@CBaseStream@@UAEKD@Z PROC NEAR			; CBaseStream::put, COMDAT
; _this$ = ecx

; 181  : 	virtual U32 put(char val){return write(&val,1);}

	mov	eax, DWORD PTR [ecx]
	lea	edx, DWORD PTR _val$[esp-4]
	push	1
	push	edx
	call	DWORD PTR [eax+20]
	ret	4
?put@CBaseStream@@UAEKD@Z ENDP				; CBaseStream::put
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?pos_rd@CBaseStream@@UAEXKK@Z
_TEXT	SEGMENT
?pos_rd@CBaseStream@@UAEXKK@Z PROC NEAR			; CBaseStream::pos_rd, COMDAT
; _this$ = ecx

; 187  : 	virtual void pos_rd(U32 adj,U32 at_adj){}

	ret	8
?pos_rd@CBaseStream@@UAEXKK@Z ENDP			; CBaseStream::pos_rd
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?pos_wr@CBaseStream@@UAEXKK@Z
_TEXT	SEGMENT
?pos_wr@CBaseStream@@UAEXKK@Z PROC NEAR			; CBaseStream::pos_wr, COMDAT
; _this$ = ecx

; 188  : 	virtual void pos_wr(U32 adj,U32 at_adj){}

	ret	8
?pos_wr@CBaseStream@@UAEXKK@Z ENDP			; CBaseStream::pos_wr
; Function compile flags: /Ogty
; File C:\duke4\xcore\filex.h
_TEXT	ENDS
;	COMDAT ?base_init@XFile@@EAEXXZ
_TEXT	SEGMENT
?base_init@XFile@@EAEXXZ PROC NEAR			; XFile::base_init, COMDAT
; _this$ = ecx

; 12   : 	void base_init(void){CBaseStream::base_init();name=null;}

	push	esi
	mov	esi, ecx
	call	?base_init@CBaseStream@@MAEXXZ		; CBaseStream::base_init
	mov	DWORD PTR [esi+40], 0
	pop	esi
	ret	0
?base_init@XFile@@EAEXXZ ENDP				; XFile::base_init
_TEXT	ENDS
END
