; Listing generated by Microsoft (R) Optimizing Compiler Version 12.00.8943.0 

	TITLE	C:\duke4\Fire\Src\UnFractal.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT PARA USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_1HO@DOMN@?$AAG?$AAe?$AAt?$AAA?$AAl?$AAl?$AAo?$AAc?$AAs?$AAS?$AAt?$AAa?$AAt?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AAn?$AAo?$AAt@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_17JBDG@?$AAn?$AAe?$AAw?$AA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_11A@?$AA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_13HMCP@?$AA?2?$AA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BM@MLGP@?4?4?2?4?4?2Core?2Inc?2UnTemplate?4h?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06DIHH@Pos?$DO?$DN0?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BF@JEDA@Pos?$CLNum?$DM?$DNBytes?4Num?$CI?$CJ?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08NOIE@InPos?$DO?$DN0?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BD@PKIF@InPos?$DM?$DNBytes?4Num?$CI?$CJ?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_1BM@LKB@?$AAU?$AAn?$AAi?$AAn?$AAi?$AAt?$AAi?$AAa?$AAl?$AAi?$AAz?$AAe?$AAd?$AA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_1CC@CPAJ@?$AA?$CF?$AA0?$AA8?$AAX?$AA?$CF?$AA0?$AA8?$AAX?$AA?$CF?$AA0?$AA8?$AAX?$AA?$CF?$AA0?$AA8?$AAX?$AA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_1O@KHFL@?$AAS?$AAy?$AAs?$AAt?$AAe?$AAm?$AA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BK@IPGH@?4?4?2?4?4?2Core?2Inc?2UnObjBas?4h?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05LCAF@Class?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_17HGCB@?$AAF?$AA?$CF?$AAs?$AA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_1M@NOGP@?$AAA?$AAc?$AAt?$AAo?$AAr?$AA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_13NHLM@?$AAA?$AA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_13LOIM@?$AAU?$AA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_19FLGB@?$AA?$CF?$AAs?$AA?$CF?$AAs?$AA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BJ@DMLA@?4?4?2?4?4?2Core?2Inc?2UnClass?4h?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DA@NIKO@Defaults?$FLCPD_Normal?$FN?4Num?$CI?$CJ?$DN?$DNGetP@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BL@BEPO@Defaults?$FLCPD_Normal?$FN?4Num?$CI?$CJ?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_19NGFL@?$AAN?$AAo?$AAn?$AAe?$AA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_1BM@ECHK@?$AAU?$AAn?$AAh?$AAa?$AAs?$AAh?$AAe?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAm?$AA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BH@IEJK@?4?4?2?4?4?2Core?2Inc?2UnMem?4h?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0P@DFNF@TopChunk?$DN?$DNNULL?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BI@BION@?4?4?2?4?4?2Core?2Inc?2UnMath?4h?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04JDHJ@i?$DO?91?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03FBPA@i?$DM3?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03PLGH@i?$DM2?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_1CA@BFE@?$AAR?$AAe?$AAs?$AAo?$AAl?$AAv?$AAi?$AAn?$AAg?$AA?5?$AA?$CF?$AAs?$AA?4?$AA?4?$AA?4?$AA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BO@EDDF@?4?4?2?4?4?2Engine?2Inc?2UnNetStuff?4h?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07GDHO@hThread?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_15DEDE@?$AA?$CF?$AAs?$AA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BK@JICC@?4?4?2?4?4?2Engine?2Inc?2ABrush?4h?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05NJDM@Brush?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05DJGJ@Other?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@ELOE@Other?9?$DOBrush?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_1M@NPJG@?$AAT?$AAi?$AAt?$AAl?$AAe?$AA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_1BG@COBA@?$AAL?$AAe?$AAv?$AAe?$AAl?$AAI?$AAn?$AAf?$AAo?$AA0?$AA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_1CC@JMMP@?$AAI?$AAd?$AAe?$AAa?$AAl?$AAP?$AAl?$AAa?$AAy?$AAe?$AAr?$AAC?$AAo?$AAu?$AAn?$AAt?$AA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BL@IIGF@?4?4?2?4?4?2Engine?2Inc?2UnLevel?4h?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BA@DADJ@Actors?4Num?$CI?$CJ?$DO?$DN2?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BA@OIOI@Actors?$CI1?$CJ?$CB?$DNNULL?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BH@EHGL@Actors?$CI1?$CJ?9?$DOBrush?$CB?$DNNULL?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_1CI@PENI@?$AAA?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAf?$AAo?$AAu?$AAn?$AAd?$AA?3?$AA?5?$AA?$CF?$AAs?$AA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09HBFO@Actors?$CI0?$CJ?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CK@OLMN@Actors?$CI0?$CJ?9?$DOIsA?$CIALevelInfo?3?3Stati@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_19PPKP@?$AAU?$AAs?$AAe?$AAr?$AA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_1M@KAEM@?$AAR?$AAe?$AAs?$AAe?$AAt?$AA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_1BE@ECAA@?$AAH?$AAH?$AAi?$AAt?$AAP?$AAr?$AAo?$AAx?$AAy?$AA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_1BK@BNHE@?$AAH?$AAA?$AAc?$AAt?$AAo?$AAr?$AAV?$AAe?$AAr?$AAt?$AAe?$AAx?$AA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_1BO@JBP@?$AAF?$AAr?$AAa?$AAc?$AAt?$AAa?$AAl?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_1M@BHOC@?$AAU?$AAM?$AAa?$AAs?$AAk?$AA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_1FK@OIBJ@?$AAC?$AAl?$AAa?$AAs?$AAs?$AA?5?$AA?$CF?$AAs?$AA?5?$AAM?$AAe?$AAm?$AAb?$AAe?$AAr?$AA?5?$AA?$CF?$AAs?$AA?5?$AAp@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CA@CDIN@C?3?2duke4?2Fire?2Src?2UnFractal?4cpp?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BJ@LFBK@?$CIInUSize?$CG?$CIInUSize?91?$CJ?$CJ?$DN?$DN0?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BJ@LDOB@?$CIInVSize?$CG?$CIInVSize?91?$CJ?$CJ?$DN?$DN0?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_1CA@OMBM@?$AAU?$AAF?$AAr?$AAa?$AAc?$AAt?$AAa?$AAl?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_1BI@MMMC@?$AAF?$AAi?$AAr?$AAe?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_1BE@GEFN@?$AAS?$AAp?$AAa?$AAr?$AAk?$AAT?$AAy?$AAp?$AAe?$AA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0EH@ILJB@sizeof?$CIUFireTexture?$CJ?$DN?$DNUFireTextu@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0EF@LBFJ@sizeof?$CIUWetTexture?$CJ?$DN?$DNUWetTexture@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0EH@HCKF@sizeof?$CIUWaveTexture?$CJ?$DN?$DNUWaveTextu@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0EN@CEKJ@sizeof?$CIUFractalTexture?$CJ?$DN?$DNUFracta@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_1BK@KFIN@?$AAU?$AAF?$AAi?$AAr?$AAe?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_1BK@KFM@?$AAW?$AAa?$AAt?$AAe?$AAr?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_1BC@DDHO@?$AAD?$AAr?$AAo?$AAp?$AAT?$AAy?$AAp?$AAe?$AA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_1BM@IGJG@?$AAU?$AAW?$AAa?$AAt?$AAe?$AAr?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_1BI@GIPJ@?$AAW?$AAa?$AAv?$AAe?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_1BK@BJIE@?$AAB?$AAu?$AAm?$AAp?$AAM?$AAa?$AAp?$AAA?$AAn?$AAg?$AAl?$AAe?$AA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_1BK@BLG@?$AAU?$AAW?$AAa?$AAv?$AAe?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_1BI@JHNI@?$AAU?$AAW?$AAe?$AAt?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_1BI@MCDB@?$AAU?$AAI?$AAc?$AAe?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08GCAE@Index?$DO?$DN0?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BA@FEMP@Index?$DM?$DNArrayNum?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BG@BEDF@Index?$CLCount?$DM?$DNArrayNum?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_1BI@IADD@?$AAH?$AAa?$AAs?$AAh?$AAM?$AAa?$AAp?$AAH?$AAa?$AAs?$AAh?$AA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CRT$XCA	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCA	ENDS
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
CRT$XCL	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCL	ENDS
CRT$XCC	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCC	ENDS
CRT$XCZ	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCZ	ENDS
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??8@YAHABU_GUID@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sqrtf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXVECTOR3@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXMATRIX@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXQUATERNION@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXVECTOR2@@QAE@MM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXVECTOR3@@QAE@MMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXVECTOR4@@QAE@MMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXMATRIX@@QAE@MMMMMMMMMMMMMMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXQUATERNION@@QAE@MMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXPLANE@@QAE@MMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXCOLOR@@QAE@MMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?appRound@@YAHM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?Serialize@FOutputDevice@@UAEXPBDW4EName@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?Flush@FOutputDevice@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1FConfigCache@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GFConfigCache@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?appToUpper@@YAGG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?appToLower@@YAGG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?appStrihash@@YAKPBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?appSin@@YANN@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?appCos@@YANN@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?appAcos@@YANN@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?appRand@@YAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?appFrand@@YAMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?appSqrt@@YANN@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?appFloor@@YAHM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?appMemcpy@@YAXPAXPBXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?appMemzero@@YAXPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXIPBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3@YAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_U@YAPAXIPBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_U@YAPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_V@YAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1FArchive@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?SerializeBits@FArchive@@UAEXPAXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?SerializeInt@FArchive@@UAEXAAKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?Preload@FArchive@@UAEXPAVUObject@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?CountBytes@FArchive@@UAEXKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??6FArchive@@UAEAAV0@AAVFName@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??6FArchive@@UAEAAV0@AAPAVUObject@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?MapName@FArchive@@UAEHPAVFName@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?MapObject@FArchive@@UAEHPAVUObject@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?TotalSize@FArchive@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?AtEnd@FArchive@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?AttachLazyLoader@FArchive@@UAEXPAVFLazyLoader@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?DetachLazyLoader@FArchive@@UAEXPAVFLazyLoader@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?Precache@FArchive@@UAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?Flush@FArchive@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?Close@FArchive@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?GetError@FArchive@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?ByteOrderSerialize@FArchive@@QAEAAV1@PAXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FArchive@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?Ver@FArchive@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?IsLoading@FArchive@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?IsSaving@FArchive@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?IsTrans@FArchive@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?IsPersistent@FArchive@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6@YAAAVFArchive@@AAV0@AAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6@YAAAVFArchive@@AAV0@AAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6@YAAAVFArchive@@AAV0@AAK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6@YAAAVFArchive@@AAV0@AAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6@YAAAVFArchive@@AAV0@AAM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6@YAAAVFArchive@@AAV0@AAN@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6@YAAAVFArchive@@AAV0@AA_K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NeedsDestructor@?$TTypeInfo@E@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NeedsDestructor@?$TTypeInfo@H@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NeedsDestructor@?$TTypeInfo@G@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NeedsDestructor@?$TTypeInfo@VFName@@@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?Num@FArray@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?Insert@FArray@@QAEXHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?Add@FArray@@QAEHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?Shrink@FArray@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?Empty@FArray@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FArray@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FArray@@QAE@W4ENoInit@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1FArray@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?CountBytes@FArray@@QAEXAAVFArchive@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FArray@@IAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FLazyLoader@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FString@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FString@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FString@@QAE@PBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FString@@QAE@W4ENoInit@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??4FString@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1FString@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??DFString@@QBEPBGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??YFString@@QAEAAV0@PBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??HFString@@QAE?AV0@PBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??XFString@@QAEAAV0@PBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??DFString@@QBE?AV0@PBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?Len@FString@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?Left@FString@@QBE?AV1@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?Mid@FString@@QBE?AV1@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?InStr@FString@@QBEHPBGH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?InStr@FString@@QBEHABV1@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FString@@AAE@HPBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FStringNoInit@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??4FStringNoInit@@QAEAAU0@PBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetTypeHash@@YAKABVFString@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Serialize@FStringOutputDevice@@UAEXPBGW4EName@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FOutputDevice@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FBufferWriter@@QAE@AAV?$TArray@E@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Serialize@FBufferWriter@@UAEXPAXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Tell@FBufferWriter@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Seek@FBufferWriter@@UAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TotalSize@FBufferWriter@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GFBufferWriter@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1FBufferWriter@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GFBufferArchive@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1FBufferArchive@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1FBufferReader@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??DFName@@QBEPBGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?GetIndex@FName@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FName@@QAE@W4EName@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FName@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetTypeHash@@YAKVFName@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1FFrame@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FIteratorList@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FIteratorList@@QAE@PAU0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FGuid@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FGuid@@QAE@KKKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6@YAAAVFArchive@@AAV0@AAVFGuid@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@UObject@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2UObject@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticConfigName@UObject@@SAPBGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??3UObject@@SAXPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?IsPendingKill@UObject@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?GetClass@UObject@@QBEPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?GetFlags@UObject@@QBEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?GetName@UObject@@UBEPBGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?GetFName@UObject@@QBE?BVFName@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?GetOuter@UObject@@QBEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?GetIndex@UObject@@QBEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUObject@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetTypeHash@@YAKPBVUObject@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??EFObjectIterator@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@UPackageMap@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2UPackageMap@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1UPackageMap@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?GetMaxObjectIndex@UPackageMap@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUPackageMap@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TMap@PAVUObject@@H@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TMap@PAVUObject@@PAVFClassNetCache@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0UPackageMap@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TMap@PAVUObject@@H@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TMap@PAVUObject@@PAVFClassNetCache@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@UPackage@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2UPackage@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1UPackage@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUPackage@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@USubsystem@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1USubsystem@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0USubsystem@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?Tick@USubsystem@@UAIXM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FExec@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@UCommandlet@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2UCommandlet@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1UCommandlet@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUCommandlet@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1FStringNoInit@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0UCommandlet_eventMain_Parms@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1UCommandlet_eventMain_Parms@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@ULanguage@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1ULanguage@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@UTextBuffer@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2UTextBuffer@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1UTextBuffer@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUTextBuffer@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@USystem@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2USystem@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1USystem@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUSystem@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@UField@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1UField@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0UField@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@UStruct@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2UStruct@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1UStruct@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0UStruct@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?GetInheritanceSuper@UStruct@@UAEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?GetPropertiesSize@UStruct@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?GetNameCPP@UStruct@@UAEPAGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?GetSuperStruct@UStruct@@QBEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUStruct@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@UFunction@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2UFunction@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1UFunction@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0UFunction@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?MergeBools@UFunction@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?GetInheritanceSuper@UFunction@@UAEPAVUStruct@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUFunction@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@UState@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2UState@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1UState@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0UState@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?MergeBools@UState@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?GetInheritanceSuper@UState@@UAEPAVUStruct@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?GetSuperState@UState@@QBEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUState@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@UEnum@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2UEnum@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1UEnum@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0UEnum@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUEnum@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@UClass@@SAPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2UClass@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1UClass@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?MergeBools@UClass@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?GetInheritanceSuper@UClass@@UAEPAVUStruct@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?GetNameCPP@UClass@@UAEPAGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?GetSuperClass@UClass@@QBEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?GetDefaultActor@UClass@@QAEPAVAActor@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUClass@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@UConst@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2UConst@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1UConst@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0UConst@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUConst@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@UProperty@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1UProperty@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?Matches@UProperty@@QBEHPBX0H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@UByteProperty@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2UByteProperty@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1UByteProperty@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0UByteProperty@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUByteProperty@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@UIntProperty@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2UIntProperty@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1UIntProperty@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0UIntProperty@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUIntProperty@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@UBoolProperty@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2UBoolProperty@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1UBoolProperty@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0UBoolProperty@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUBoolProperty@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@UFloatProperty@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2UFloatProperty@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1UFloatProperty@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0UFloatProperty@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUFloatProperty@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@UObjectProperty@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2UObjectProperty@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1UObjectProperty@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0UObjectProperty@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0UObjectProperty@@QAE@W4ECppProperty@@HPBGKPAVUClass@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUObjectProperty@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@UClassProperty@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2UClassProperty@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1UClassProperty@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0UClassProperty@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?GetID@UClassProperty@@UBEEXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUClassProperty@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@UNameProperty@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2UNameProperty@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1UNameProperty@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0UNameProperty@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUNameProperty@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@UStrProperty@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2UStrProperty@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1UStrProperty@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0UStrProperty@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUStrProperty@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@UFixedArrayProperty@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2UFixedArrayProperty@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1UFixedArrayProperty@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0UFixedArrayProperty@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUFixedArrayProperty@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@UArrayProperty@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2UArrayProperty@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1UArrayProperty@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0UArrayProperty@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUArrayProperty@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@UMapProperty@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2UMapProperty@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1UMapProperty@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0UMapProperty@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUMapProperty@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@UStructProperty@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2UStructProperty@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1UStructProperty@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0UStructProperty@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUStructProperty@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?IsA@UObject@@QBIHPAVUClass@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?IsProbing@UObject@@QAEHVFName@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FFrame@@QAE@PAVUObject@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1FStateFrame@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GFStateFrame@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FGenerationInfo@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6@YAAAVFArchive@@AAV0@AAUFGenerationInfo@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FPackageFileSummary@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@ULinker@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2ULinker@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1ULinker@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0ULinker@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GULinker@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1FPackageFileSummary@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StaticClass@ULinkerLoad@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2ULinkerLoad@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1ULinkerLoad@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ULinkerLoad@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GULinkerLoad@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StaticClass@ULinkerSave@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2ULinkerSave@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1ULinkerSave@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ULinkerSave@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GULinkerSave@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@UFactory@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1UFactory@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@UExporter@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1UExporter@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?GHash@FMemCache@@QAEKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?PushBytes@FMemStack@@QAEPAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?Tick@FMemStack@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FSnap@@YAMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FSheerSnap@@YAMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FAddAngleConfined@@YIGHHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FVector@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FVector@@QAE@MMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??TFVector@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??UFVector@@QBEMABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??D@YA?AVFVector@@MABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??HFVector@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??GFVector@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??DFVector@@QBE?AV0@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??KFVector@@QBE?AV0@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??8FVector@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??9FVector@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??GFVector@@QBE?AV0@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??YFVector@@QAE?AV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??ZFVector@@QAE?AV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??XFVector@@QAE?AV0@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??_0FVector@@QAE?AV0@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??XFVector@@QAE?AV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??_0FVector@@QAE?AV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?SizeSquared@FVector@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?Normalize@FVector@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?UnsafeNormal@FVector@@QBE?AV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?BoundToCube@FVector@@QAE?AV1@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6@YAAAVFArchive@@AAV0@AAVFVector@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?ToStd@FVector@@QBE?AV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?ToUnr@FVector@@QBE?AV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FVectorDouble@@QAE@NNN@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??HFVectorDouble@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?BoundToCube@FVectorDouble@@QAE?AV1@N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FQuat@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FQuat@@QAE@ABVFVector@@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??4FQuat@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?SizeSquared@FQuat@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?Size@FQuat@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?Normalize@FQuat@@QAEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??GFQuat@@QBE?AV0@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??DFQuat@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??UFQuat@@QBEMABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??8FQuat@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_H@YGXPAXIHP6EX0@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FPlane@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FPlane@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FPlane@@QAE@ABVFVector@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FPlane@@QAE@MMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FPlane@@QAE@VFVector@@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?PlaneDot@FPlane@@QBEMABVFVector@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6@YAAAVFArchive@@AAV0@AAVFPlane@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FSphere@@QAE@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FScale@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?Orientation@FScale@@QAEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FCoords@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FCoords@@QAE@ABVFVector@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FCoords@@QAE@ABVFVector@@000@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FModelCoords@@QAE@ABVFCoords@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FRotator@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FRotator@@QAE@HHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??HFRotator@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??DFRotator@@QBE?AV0@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??D@YA?AVFRotator@@MABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FRange@@QAE@MM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FBox@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FBox@@QAE@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FBox@@QAE@ABVFVector@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?GetExtrema@FBox@@QBEABVFVector@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?Init@FBox@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??YFBox@@QAEAAV0@ABVFVector@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??YFBox@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?SinTab@FGlobalMath@@QAEMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?CosTab@FGlobalMath@@QAEMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReduceAngle@@YAHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ASMTransformPoint@@YAXABVFCoords@@ABVFVector@@AAV2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ASMTransformVector@@YAXABVFCoords@@ABVFVector@@AAV2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?TransformPointBy@FVector@@QBE?AV1@ABVFCoords@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?TransformVectorBy@FVector@@QBE?AV1@ABVFCoords@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?MirrorByVector@FVector@@QBE?AV1@ABV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?MirrorByPlane@FVector@@QBE?AV1@ABVFPlane@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FPointPlaneDist@@YAMABVFVector@@00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FParallel@@YAHABVFVector@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?Transpose@FCoords@@QBE?AV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??XFCoords@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??DFCoords@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??XFCoords@@QAEAAV0@ABVFRotator@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??DFCoords@@QBE?AV0@ABVFRotator@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??XFCoords@@QAEAAV0@ABVFVector@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??DFCoords@@QBE?AV0@ABVFVector@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??_0FCoords@@QAEAAV0@ABVFRotator@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??KFCoords@@QBE?AV0@ABVFRotator@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??_0FCoords@@QAEAAV0@ABVFVector@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??KFCoords@@QBE?AV0@ABVFVector@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??XFCoords@@QAEAAV0@ABVFScale@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??DFCoords@@QBE?AV0@ABVFScale@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??_0FCoords@@QAEAAV0@ABVFScale@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??KFCoords@@QBE?AV0@ABVFScale@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FMatrix@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FMatrix@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??6FCoords@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??SFCoords@@QBE?AV0@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Splerp@@YAMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FPointRegion@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsCsg@FBspNode@@QBEHK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@UPolys@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2UPolys@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1UPolys@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0UPolys@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?Serialize@UPolys@@UAEXAAVFArchive@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUPolys@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TTransArray@VFPoly@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FIteratorActorList@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FIteratorActorList@@QAE@PAU0@PAVAActor@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@UPrimitive@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2UPrimitive@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1UPrimitive@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0UPrimitive@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUPrimitive@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@UModel@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2UModel@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1UModel@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0UModel@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUModel@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TTransArray@VFBspNode@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TTransArray@VFVert@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TTransArray@VFVector@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TTransArray@VFBspSurf@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FColor@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FColor@@QAE@EEE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FColor@@QAE@ABVFPlane@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?Plane@FColor@@QBE?AVFVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@UPalette@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2UPalette@@SAPAXIPAVUObject@@VFName@@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2UPalette@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1UPalette@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUPalette@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FMipmapBase@@QAE@EE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FMipmapBase@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@UBitmap@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1UBitmap@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@UTexture@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2UTexture@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6@YAAAVFArchive@@AAV0@AAPAVUTexture@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1UTexture@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?InternalConstructor@UTexture@@SAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?GetMip@UTexture@@UAEPAUFMipmapBase@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?MousePosition@UTexture@@UAEXKMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?Click@UTexture@@UAEXKMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUTexture@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6@YAAAVFArchive@@AAV0@AAUFFontCharacter@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@UFont@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2UFont@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1UFont@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUFont@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@UFontTrueType@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2UFontTrueType@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1UFontTrueType@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUFontTrueType@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TMap@GH@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@UProceduralTexture@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1UProceduralTexture@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@UMesh@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2UMesh@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1UMesh@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?GetInstanceClass@UMesh@@UAEPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUMesh@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@UMeshInstance@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2UMeshInstance@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1UMeshInstance@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?PointCheck@UMeshInstance@@UAEHAAUFCheckResult@@PAVAActor@@VFVector@@2K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?LineCheck@UMeshInstance@@UAEHAAUFCheckResult@@PAVAActor@@VFVector@@22KH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?GetRenderBoundingBox@UMeshInstance@@UAE?AVFBox@@PBVAActor@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?GetCollisionBoundingBox@UMeshInstance@@UBE?AVFBox@@PBVAActor@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?GetMesh@UMeshInstance@@UAEPAVUMesh@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?SetMesh@UMeshInstance@@UAEXPAVUMesh@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?GetActor@UMeshInstance@@UAEPAVAActor@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?SetActor@UMeshInstance@@UAEXPAVAActor@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?GetNumSequences@UMeshInstance@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?GetSequence@UMeshInstance@@UAEPAXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?FindSequence@UMeshInstance@@UAEPAXVFName@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?GetSeqName@UMeshInstance@@UAE?AVFName@@PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?SetSeqGroupName@UMeshInstance@@UAEXVFName@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?GetSeqGroupName@UMeshInstance@@UAE?AVFName@@V2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?GetSeqNumFrames@UMeshInstance@@UAEHPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?GetSeqRate@UMeshInstance@@UAEMPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?GetSeqNumEvents@UMeshInstance@@UAEHPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?GetSeqEventType@UMeshInstance@@UAE?AW4EMeshSeqEvent@@PAXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?GetSeqEventTime@UMeshInstance@@UAEMPAXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?GetSeqEventString@UMeshInstance@@UAEPBGPAXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?PlaySequence@UMeshInstance@@UAEHPAXEHMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?DriveSequences@UMeshInstance@@UAEXM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?GetTexture@UMeshInstance@@UAEPAVUTexture@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?GetStringValue@UMeshInstance@@UAEXAAVFOutputDevice@@PBGH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?SendStringCommand@UMeshInstance@@UAEXPBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?GetBasisCoords@UMeshInstance@@UAE?AVFCoords@@V2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?GetFrame@UMeshInstance@@UAEHPAVFVector@@PAEHVFCoords@@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?GetMountCoords@UMeshInstance@@UAEHVFName@@HAAVFCoords@@PAVAActor@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?Draw@UMeshInstance@@UAEXPAX0VFCoords@@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUMeshInstance@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0UMeshInstance@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FMeshChannel@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@AActor@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2AActor@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6@YAAAVFArchive@@AAV0@AAPAVAActor@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1AActor@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0AActor@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?ShouldDoScriptReplication@AActor@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?GetLevel@AActor@@QBEPAVULevel@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?WorldLightRadius@AActor@@UBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?PostEditMove@AActor@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?PreRaytrace@AActor@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?PostRaytrace@AActor@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?Spawned@AActor@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?ToLocal@AActor@@UBE?AVFCoords@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?ToWorld@AActor@@UBE?AVFCoords@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?IsPendingKill@AActor@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?GetMeshInstance@AActor@@QAEPAVUMeshInstance@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0AActor_eventCalcView_Parms@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0AActor_eventGlobalTrigger_Parms@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0AActor_eventEnumSurfsInRadiusCB_Parms@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0AActor_eventBroadcastMessage_Parms@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1AActor_eventBroadcastMessage_Parms@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0AActor_eventTakeDamage_Parms@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0AActor_eventPushedByMover_Parms@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0AActor_eventLanded_Parms@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0AActor_eventHitWall_Parms@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAActor@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@AInfoActor@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2AInfoActor@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1AInfoActor@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0AInfoActor@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAInfoActor@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@AInfo@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2AInfo@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1AInfo@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0AInfo@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAInfo@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@AInternetInfo@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2AInternetInfo@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1AInternetInfo@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0AInternetInfo@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAInternetInfo@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@AInternetLink@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2AInternetLink@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1AInternetLink@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAInternetLink@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@AUdpLink@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2AUdpLink@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1AUdpLink@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0AUdpLink_eventReceivedLine_Parms@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1AUdpLink_eventReceivedLine_Parms@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0AUdpLink_eventReceivedText_Parms@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1AUdpLink_eventReceivedText_Parms@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAUdpLink@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@ATcpLink@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2ATcpLink@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1ATcpLink@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ATcpLink_eventReceivedLine_Parms@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1ATcpLink_eventReceivedLine_Parms@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ATcpLink_eventReceivedText_Parms@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1ATcpLink_eventReceivedText_Parms@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GATcpLink@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@AMapLocations@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2AMapLocations@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1AMapLocations@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0AMapLocations@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAMapLocations@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1FMapInfoData@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FMapInfoData@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@ADOTAffector@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2ADOTAffector@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1ADOTAffector@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0ADOTAffector@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GADOTAffector@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@AActorDamageEffect@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2AActorDamageEffect@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1AActorDamageEffect@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0AActorDamageEffect@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAActorDamageEffect@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@AMutator@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2AMutator@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1AMutator@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0AMutator@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAMutator@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@AReplicationInfo@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2AReplicationInfo@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1AReplicationInfo@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0AReplicationInfo@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAReplicationInfo@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@AGameReplicationInfo@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2AGameReplicationInfo@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1AGameReplicationInfo@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0AGameReplicationInfo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAGameReplicationInfo@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@APlayerReplicationInfo@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2APlayerReplicationInfo@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1APlayerReplicationInfo@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0APlayerReplicationInfo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAPlayerReplicationInfo@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@ASavedMove@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2ASavedMove@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1ASavedMove@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0ASavedMove@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GASavedMove@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@AZoneInfo@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2AZoneInfo@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1AZoneInfo@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0AZoneInfo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAZoneInfo@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@AWarpZoneInfo@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2AWarpZoneInfo@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1AWarpZoneInfo@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0AWarpZoneInfo@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAWarpZoneInfo@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@ASkyZoneInfo@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2ASkyZoneInfo@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1ASkyZoneInfo@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0ASkyZoneInfo@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GASkyZoneInfo@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@ALevelInfo@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2ALevelInfo@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1ALevelInfo@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0ALevelInfo@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ALevelInfo_eventServerTravel_Parms@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1ALevelInfo_eventServerTravel_Parms@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GALevelInfo@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1FObjectiveInfo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FObjectiveInfo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@AGameInfo@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2AGameInfo@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1AGameInfo@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0AGameInfo@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0AGameInfo_eventLoginNewClass_Parms@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1AGameInfo_eventLoginNewClass_Parms@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0AGameInfo_eventLogin_Parms@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1AGameInfo_eventLogin_Parms@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0AGameInfo_eventPreLogin_Parms@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1AGameInfo_eventPreLogin_Parms@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0AGameInfo_eventGetBeaconText_Parms@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1AGameInfo_eventGetBeaconText_Parms@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0AGameInfo_eventInitGame_Parms@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1AGameInfo_eventInitGame_Parms@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAGameInfo@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@AMaterial@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2AMaterial@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1AMaterial@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0AMaterial@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAMaterial@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FDamageCategoryEffectStruct@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@AFocalPoint@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2AFocalPoint@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1AFocalPoint@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAFocalPoint@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0AFocalPoint@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@ALight@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2ALight@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1ALight@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0ALight@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GALight@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@AFlareLight@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2AFlareLight@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1AFlareLight@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0AFlareLight@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAFlareLight@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@ATriggerLight@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2ATriggerLight@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1ATriggerLight@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0ATriggerLight@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GATriggerLight@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@ADamageType@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2ADamageType@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1ADamageType@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0ADamageType@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GADamageType@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@AKeypoint@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2AKeypoint@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1AKeypoint@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0AKeypoint@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAKeypoint@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@AInterpolationStation@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2AInterpolationStation@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1AInterpolationStation@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0AInterpolationStation@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAInterpolationStation@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@Alocationid@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2Alocationid@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1Alocationid@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0Alocationid@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAlocationid@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@AInterpolationPoint@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2AInterpolationPoint@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1AInterpolationPoint@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0AInterpolationPoint@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAInterpolationPoint@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@APolyMarker@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2APolyMarker@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1APolyMarker@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0APolyMarker@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAPolyMarker@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@AClipMarker@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2AClipMarker@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1AClipMarker@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0AClipMarker@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAClipMarker@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@AMeshEffect@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2AMeshEffect@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1AMeshEffect@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0AMeshEffect@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0AMeshEffect_eventEvalVert_Parms@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAMeshEffect@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@ASpawnNotify@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2ASpawnNotify@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1ASpawnNotify@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0ASpawnNotify@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GASpawnNotify@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@ANavigationPoint@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2ANavigationPoint@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1ANavigationPoint@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0ANavigationPoint@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GANavigationPoint@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@ALiftExit@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2ALiftExit@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1ALiftExit@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0ALiftExit@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GALiftExit@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@ALiftCenter@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2ALiftCenter@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1ALiftCenter@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0ALiftCenter@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GALiftCenter@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@AWarpZoneMarker@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2AWarpZoneMarker@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1AWarpZoneMarker@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0AWarpZoneMarker@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAWarpZoneMarker@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@AButtonMarker@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2AButtonMarker@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1AButtonMarker@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0AButtonMarker@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAButtonMarker@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@ATriggerMarker@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2ATriggerMarker@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1ATriggerMarker@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0ATriggerMarker@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GATriggerMarker@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@AInventorySpot@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2AInventorySpot@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1AInventorySpot@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0AInventorySpot@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAInventorySpot@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@APlayerStart@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2APlayerStart@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1APlayerStart@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0APlayerStart@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAPlayerStart@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@ATeleporter@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2ATeleporter@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1ATeleporter@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0ATeleporter@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GATeleporter@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@APathNode@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2APathNode@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1APathNode@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0APathNode@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAPathNode@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@AHUD@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2AHUD@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1AHUD@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0AHUD@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAHUD@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@ATriggers@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2ATriggers@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1ATriggers@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0ATriggers@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GATriggers@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@ATrigger@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2ATrigger@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1ATrigger@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0ATrigger@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GATrigger@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@ADukeNet@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2ADukeNet@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1ADukeNet@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0ADukeNet@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ADukeNet_eventdncServerCommand_Parms@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1ADukeNet_eventdncServerCommand_Parms@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GADukeNet@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@ARenderActor@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2ARenderActor@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1ARenderActor@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GARenderActor@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0ARenderActor@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@APawn@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2APawn@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1APawn@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0APawn@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0APawn_eventClientHearSound_Parms@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0APawn_eventWalkTexture_Parms@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0APawn_eventTeamMessage_Parms@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1APawn_eventTeamMessage_Parms@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0APawn_eventClientMessage_Parms@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1APawn_eventClientMessage_Parms@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAPawn@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FSFacialExpression@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FFacialNoiseInfo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FSFacialExpressionFrame@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@APlayerPawn@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2APlayerPawn@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1APlayerPawn@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0APlayerPawn_eventPlayerCalcView_Parms@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0APlayerPawn_eventClientTravel_Parms@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1APlayerPawn_eventClientTravel_Parms@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAPlayerPawn@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0APlayerPawn@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@ACamera@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2ACamera@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1ACamera@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0ACamera@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GACamera@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@AScout@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2AScout@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1AScout@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0AScout@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAScout@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@ABrush@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2ABrush@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1ABrush@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0ABrush@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?OldBuildCoords@ABrush@@UAEMPAVFModelCoords@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?ToLocal@ABrush@@UBE?AVFCoords@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?ToWorld@ABrush@@UBE?AVFCoords@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?BuildCoords@ABrush@@UAEMPAVFModelCoords@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?CopyPosRotScaleFrom@ABrush@@UAEXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GABrush@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@AMover@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2AMover@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1AMover@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?ToLocal@AMover@@UBE?AVFCoords@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?ToWorld@AMover@@UBE?AVFCoords@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?BuildCoords@AMover@@UAEMPAVFModelCoords@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAMover@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@ADoorMover@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2ADoorMover@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1ADoorMover@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GADoorMover@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0ADoorMover@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@AMeshDecal@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2AMeshDecal@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1AMeshDecal@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0AMeshDecal@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAMeshDecal@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@AItem@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2AItem@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1AItem@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0AItem@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAItem@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@ADecoration@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2ADecoration@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1ADecoration@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0ADecoration@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GADecoration@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FSThirdPersonInfo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@ACarcass@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2ACarcass@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1ACarcass@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GACarcass@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0ACarcass@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@ABoneRope@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2ABoneRope@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1ABoneRope@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GABoneRope@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@AParticleCollisionActor@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2AParticleCollisionActor@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1AParticleCollisionActor@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0AParticleCollisionActor@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAParticleCollisionActor@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@ADecal@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2ADecal@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1ADecal@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0ADecal@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GADecal@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@AInventory@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2AInventory@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1AInventory@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0AInventory@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAInventory@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@AWeapon@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2AWeapon@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1AWeapon@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0AWeapon@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAWeapon@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1FWAMEntry@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FWAMEntry@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@AProjectile@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2AProjectile@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1AProjectile@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0AProjectile@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAProjectile@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@AParticleSystem@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2AParticleSystem@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1AParticleSystem@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0AParticleSystem@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAParticleSystem@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@ASoftParticleAffector@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2ASoftParticleAffector@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1ASoftParticleAffector@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0ASoftParticleAffector@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GASoftParticleAffector@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@ASoftParticleSystem@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2ASoftParticleSystem@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1ASoftParticleSystem@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0ASoftParticleSystem@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GASoftParticleSystem@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FAdditionalSpawnStruct@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@ABeamSystem@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2ABeamSystem@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1ABeamSystem@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0ABeamSystem@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GABeamSystem@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FSControlPoint@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@ABreakableGlass@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2ABreakableGlass@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1ABreakableGlass@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GABreakableGlass@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@ULevelSummary@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2ULevelSummary@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1ULevelSummary@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0ULevelSummary@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?PostLoad@ULevelSummary@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GULevelSummary@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1FCollisionHashBase@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GFCollisionHashBase@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@ULevelBase@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1ULevelBase@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0ULevelBase@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1FURL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TTransArray@PAVAActor@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FNetworkNotify@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@ULevel@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2ULevel@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1ULevel@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0ULevel@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?GetLevelInfo@ULevel@@QAEPAVALevelInfo@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GULevel@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TMap@VFString@@V1@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TMap@VFName@@PAVAActor@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TMap@VFString@@V1@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TMap@VFName@@PAVAActor@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??EFStaticBrushIterator@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@UInput@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2UInput@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1UInput@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUInput@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1FAlias@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@UPlayer@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1UPlayer@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@UEngine@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1UEngine@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?vtPad1@UEngine@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?vtPad2@UEngine@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?vtPad3@UEngine@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?edSetClickLocation@UEngine@@UAEXAAVFVector@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?edcamMode@UEngine@@UAEHPAVUViewport@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?vtPad4@UEngine@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?vtPad5@UEngine@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?vtPad6@UEngine@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@UGameEngine@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2UGameEngine@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1UGameEngine@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUGameEngine@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@UCanvas@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2UCanvas@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1UCanvas@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0UCanvas@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUCanvas@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TMap@VFString@@PAVUFont@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TMap@VFString@@PAVUFont@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@UViewport@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1UViewport@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?IsA@HHitProxy@@UBEHPBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?Click@HHitProxy@@UAEXABUFHitCause@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@UClient@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1UClient@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6@YAAAVFArchive@@AAV0@AAVFMeshAnimNotify@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FMeshAnimNotify@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6@YAAAVFArchive@@AAV0@AAUFMeshVertConnect@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FMeshVert@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6@YAAAVFArchive@@AAV0@AAUFMeshVert@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6@YAAAVFArchive@@AAV0@AAUFMeshUV@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6@YAAAVFArchive@@AAV0@AAUFMeshTri@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@UUnrealMesh@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2UUnrealMesh@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1UUnrealMesh@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUUnrealMesh@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@UUnrealLodMesh@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2UUnrealLodMesh@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1UUnrealLodMesh@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0UUnrealLodMesh@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUUnrealLodMesh@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@UDukeMesh@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2UDukeMesh@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1UDukeMesh@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUDukeMesh@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TMap@VFName@@V1@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?IsBrush@AActor@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?IsStaticBrush@AActor@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?GetPlayerPawn@AActor@@QBEPAVAPlayerPawn@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?GetPrimitive@AActor@@UBEPAVUPrimitive@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@UAudioSubsystem@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1UAudioSubsystem@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FSoundData@@QAE@PAVUSound@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@USound@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2USound@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1USound@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0USound@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUSound@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1FSoundData@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@UVoiceSound@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2UVoiceSound@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1UVoiceSound@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUVoiceSound@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0UVoiceSound@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@UMusic@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2UMusic@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1UMusic@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0UMusic@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUMusic@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1FMovingBrushTrackerBase@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GFMovingBrushTrackerBase@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@UScriptedTexture@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2UScriptedTexture@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1UScriptedTexture@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?PostEditChange@UScriptedTexture@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUScriptedTexture@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@URenderIterator@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2URenderIterator@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1URenderIterator@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GURenderIterator@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1FActorNode@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GFActorNode@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsA@HActorVertex@@UBEHPBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0HHitProxy@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CycleCount@@YAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StaticClass@UFractalTexture@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2UFractalTexture@@SAPAXIPAVUObject@@VFName@@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2UFractalTexture@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1UFractalTexture@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PostEditChange@UFractalTexture@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TouchTexture@UFractalTexture@@UAEXHHM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0UFractalTexture@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4UFractalTexture@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUFractalTexture@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_EUFractalTexture@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0UProceduralTexture@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??4UProceduralTexture@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0UTexture@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??4UTexture@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0UBitmap@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??4UBitmap@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6@YAAAVFArchive@@AAV0@AAVFSpark@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4FSpark@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StaticClass@UFireTexture@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2UFireTexture@@SAPAXIPAVUObject@@VFName@@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2UFireTexture@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1UFireTexture@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InternalConstructor@UFireTexture@@SAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0UFireTexture@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4UFireTexture@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUFireTexture@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_EUFireTexture@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4FDrop@@QAEAAU0@ABU0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StaticClass@UWaterTexture@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2UWaterTexture@@SAPAXIPAVUObject@@VFName@@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2UWaterTexture@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1UWaterTexture@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0UWaterTexture@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4UWaterTexture@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUWaterTexture@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_EUWaterTexture@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StaticClass@UWaveTexture@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2UWaveTexture@@SAPAXIPAVUObject@@VFName@@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2UWaveTexture@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1UWaveTexture@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InternalConstructor@UWaveTexture@@SAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0UWaveTexture@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4UWaveTexture@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUWaveTexture@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_EUWaveTexture@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StaticClass@UWetTexture@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2UWetTexture@@SAPAXIPAVUObject@@VFName@@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2UWetTexture@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1UWetTexture@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InternalConstructor@UWetTexture@@SAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Lock@UWetTexture@@UAIXAAUFTextureInfo@@NHPAVURenderDevice@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0UWetTexture@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4UWetTexture@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUWetTexture@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_EUWetTexture@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FTextureInfo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4KeyPoint@@QAEAAU0@ABU0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StaticClass@UIceTexture@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2UIceTexture@@SAPAXIPAVUObject@@VFName@@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2UIceTexture@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1UIceTexture@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InternalConstructor@UIceTexture@@SAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Lock@UIceTexture@@UAIXAAUFTextureInfo@@NHPAVURenderDevice@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0UIceTexture@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4UIceTexture@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUIceTexture@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_EUIceTexture@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_EULinkerLoad@@WKE@AEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_EULinkerSave@@WKE@AEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _DllMain@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SpeedRand@@YAEXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FakeAtan@@YANN@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InitTables@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddSpark@UFireTexture@@AAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CloseSpark@UFireTexture@@AAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DeleteSparks@UFireTexture@@AAEXHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DrawSparkLine@UFireTexture@@AAEXHHHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FirePaint@UFireTexture@@AAEXHHK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MoveSparkXY@UFireTexture@@AAEXPAVFSpark@@CC@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MoveSpark@UFireTexture@@AAEXPAVFSpark@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MoveSparkAngle@UFireTexture@@AAEXPAVFSpark@@E@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MoveSparkTwo@UFireTexture@@AAEXPAVFSpark@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DrawFlashRamp@UFireTexture@@AAEXULineSeg@@EE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RedrawSparks@UFireTexture@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PostDrawSparks@UFireTexture@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CalculateWater@UWaterTexture@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ApplyWetTexture@UWetTexture@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MoveIcePosition@UIceTexture@@AAEXM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BlitTexIce@UIceTexture@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BlitIceTex@UIceTexture@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?WaterRedrawDrops@UWaterTexture@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddDrop@UWaterTexture@@AAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DeleteDrops@UWaterTexture@@AAEXHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TempDrawSpark@UFireTexture@@AAEXHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BlueLagunaPalette@@YAXPAVUPalette@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0UFractalTexture@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0UProceduralTexture@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@UFractalTexture@@UAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PostLoad@UFractalTexture@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E184
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E185
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E187
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E188
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E190
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E191
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0UFireTexture@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@UFireTexture@@UAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Clear@UFireTexture@@UAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PostLoad@UFireTexture@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TouchTexture@UFireTexture@@UAEXHHM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ConstantTimeTick@UFireTexture@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MousePosition@UFireTexture@@UAEXKMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Click@UFireTexture@@UAEXKMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Serialize@UFireTexture@@UAEXAAVFArchive@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E193
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E194
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E196
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E197
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E199
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E200
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0UWaterTexture@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@UWaterTexture@@UAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PostLoad@UWaterTexture@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TouchTexture@UWaterTexture@@UAEXHHM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Destroy@UWaterTexture@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Clear@UWaterTexture@@UAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?WaterPaint@UWaterTexture@@AAEXHHK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MousePosition@UWaterTexture@@UAEXKMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Click@UWaterTexture@@UAEXKMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E202
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E203
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E205
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E206
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E208
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E209
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0UWaveTexture@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@UWaveTexture@@UAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PostLoad@UWaveTexture@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Clear@UWaveTexture@@UAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ConstantTimeTick@UWaveTexture@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetWaveLight@UWaveTexture@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E211
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E212
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E214
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E215
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E217
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E218
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0UWetTexture@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@UWetTexture@@UAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PostLoad@UWetTexture@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Clear@UWetTexture@@UAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ConstantTimeTick@UWetTexture@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetRefractionTable@UWetTexture@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Destroy@UWetTexture@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E220
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E221
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E223
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E224
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E226
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E227
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0UIceTexture@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PostLoad@UIceTexture@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@UIceTexture@@UAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Clear@UIceTexture@@UAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ConstantTimeTick@UIceTexture@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Tick@UIceTexture@@UAIXM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RenderIce@UIceTexture@@AAEXM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MousePosition@UIceTexture@@UAEXKMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Click@UIceTexture@@UAEXKMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Destroy@UIceTexture@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E229
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E230
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E232
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E233
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E235
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E236
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TArray@G@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TArray@G@@QAE@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TArray@G@@QAE@W4ENoInit@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@G@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$TArray@G@@QAEAAGH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$TArray@G@@QBEABGH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Shrink@?$TArray@G@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Add@?$TArray@G@@QAEHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Empty@?$TArray@G@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TArray@E@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@E@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$TArray@E@@QAEAAEH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$TArray@E@@QBEABEH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6@YAAAVFArchive@@AAV0@AAV?$TArray@E@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Add@?$TArray@E@@QAEHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$TArray@PAUFNameEntry@@@@QAEAAPAUFNameEntry@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TArray@H@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@H@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TArray@VFString@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@VFString@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$TArray@PAVUObject@@@@QAEAAPAVUObject@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$TArray@VFFieldNetCache@@@@QAEAAVFFieldNetCache@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FindRef@?$TMapBase@PAVUObject@@PAVFFieldNetCache@@@@QAEPAVFFieldNetCache@@ABQAVUObject@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TArray@VFPackageInfo@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@VFPackageInfo@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TMapBase@PAVUObject@@H@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TMapBase@PAVUObject@@H@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TMapBase@PAVUObject@@PAVFClassNetCache@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TMapBase@PAVUObject@@PAVFClassNetCache@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TArray@VFName@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@VFName@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@UFRepRecord@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@PAVUField@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@VFClassDependency@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$TArray@VFClassDependency@@@@QAEAAVFClassDependency@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TFieldIterator@VUProperty@@@@QAE@PAVUStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$TFieldIterator@VUProperty@@@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??E?$TFieldIterator@VUProperty@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??C?$TFieldIterator@VUProperty@@@@QAEPAVUProperty@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TArray@UFGenerationInfo@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TArray@UFGenerationInfo@@@@QAE@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@UFGenerationInfo@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$TArray@UFGenerationInfo@@@@QAEAAUFGenerationInfo@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Empty@?$TArray@UFGenerationInfo@@@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$TArray@UFGenerationInfo@@@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TArray@UFObjectImport@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@UFObjectImport@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TArray@UFObjectExport@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@UFObjectExport@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TArray@PAVFLazyLoader@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@PAVFLazyLoader@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TTransArray@VFPoly@@@@QAE@PAVUObject@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Empty@?$TTransArray@VFPoly@@@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddZeroed@?$TTransArray@VFPoly@@@@QAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6@YAAAVFArchive@@AAV0@AAV?$TTransArray@VFPoly@@@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@VFPoly@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$TArray@VFPoly@@@@QAEAAVFPoly@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CountBytes@?$TArray@VFPoly@@@@QAEXAAVFArchive@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TTransArray@VFBspNode@@@@QAE@PAVUObject@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@VFBspNode@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TTransArray@VFVert@@@@QAE@PAVUObject@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@VFVert@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TTransArray@VFVector@@@@QAE@PAVUObject@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@VFVector@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TTransArray@VFBspSurf@@@@QAE@PAVUObject@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@VFBspSurf@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$TArray@VFBspSurf@@@@QAEAAVFBspSurf@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TArray@VFLightMapIndex@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@VFLightMapIndex@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$TArray@VFLightMapIndex@@@@QAEAAVFLightMapIndex@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TArray@VFBox@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@VFBox@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TArray@VFLeaf@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@VFLeaf@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TArray@PAVAActor@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@PAVAActor@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$TArray@PAVAActor@@@@QAEAAPAVAActor@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@VFColor@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$TArray@VFColor@@@@QAEAAVFColor@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TLazyArray@E@@QAE@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TLazyArray@E@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Load@?$TLazyArray@E@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Unload@?$TLazyArray@E@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6@YAAAVFArchive@@AAV0@AAV?$TLazyArray@E@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TArray@UFMipmap@@@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@UFMipmap@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$TArray@UFMipmap@@@@QAEAAUFMipmap@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$TArray@UFMipmap@@@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6@YAAAVFArchive@@AAV0@AAV?$TArray@UFFontCharacter@@@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@UFFontPage@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TMapBase@GH@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TArray@M@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@M@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TArray@UFMeshDecalTri@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@UFMeshDecalTri@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TArray@PAVAParticleCollisionActor@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@PAVAParticleCollisionActor@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TTransArray@PAVAActor@@@@QAE@PAVUObject@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TArray@VFReachSpec@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@VFReachSpec@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TMapBase@VFString@@V1@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TMapBase@VFString@@V1@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TMapBase@VFName@@PAVAActor@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TMapBase@VFName@@PAVAActor@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TMapBase@VFString@@PAVUFont@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TMapBase@VFString@@PAVUFont@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@PAVUViewport@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TArray@VFMeshAnimNotify@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@VFMeshAnimNotify@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6@YAAAVFArchive@@AAV0@AAV?$TArray@VFMeshAnimNotify@@@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TLazyArray@UFMeshVert@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Load@?$TLazyArray@UFMeshVert@@@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Unload@?$TLazyArray@UFMeshVert@@@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TLazyArray@UFMeshTri@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Load@?$TLazyArray@UFMeshTri@@@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Unload@?$TLazyArray@UFMeshTri@@@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@VFMeshAnimSeq@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TLazyArray@UFMeshVertConnect@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Load@?$TLazyArray@UFMeshVertConnect@@@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Unload@?$TLazyArray@UFMeshVertConnect@@@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TLazyArray@H@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Load@?$TLazyArray@H@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Unload@?$TLazyArray@H@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@PAVUTexture@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TArray@UFMeshFace@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@UFMeshFace@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TArray@UFMeshWedge@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@UFMeshWedge@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TArray@UFMeshMaterial@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@UFMeshMaterial@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TMapBase@VFName@@V1@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TArray@VFSpark@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TArray@VFSpark@@@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@VFSpark@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$TArray@VFSpark@@@@QAEAAVFSpark@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6@YAAAVFArchive@@AAV0@AAV?$TArray@VFSpark@@@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Add@?$TArray@VFSpark@@@@QAEHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@VFSpark@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$TArray@VFSpark@@@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FMipmap@@QAE@ABU0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??4FMipmap@@QAEAAU0@ABU0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TLazyArray@E@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$TLazyArray@E@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FLazyLoader@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4FLazyLoader@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@G@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TArray@E@@QAE@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TArray@E@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CountBytes@?$TArray@E@@QAEXAAVFArchive@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@E@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Empty@?$TArray@E@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$TArray@E@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6@YAAAVFArchive@@AAV0@AAV?$TArray@H@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@H@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Empty@?$TArray@H@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@VFString@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$TArray@VTPair@?$TMapBase@PAVUObject@@PAVFFieldNetCache@@@@@@QAEAAVTPair@?$TMapBase@PAVUObject@@PAVFFieldNetCache@@@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@VFPackageInfo@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Rehash@?$TMapBase@PAVUObject@@H@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TArray@VTPair@?$TMapBase@PAVUObject@@H@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@VTPair@?$TMapBase@PAVUObject@@H@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Rehash@?$TMapBase@PAVUObject@@PAVFClassNetCache@@@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TArray@VTPair@?$TMapBase@PAVUObject@@PAVFClassNetCache@@@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@VTPair@?$TMapBase@PAVUObject@@PAVFClassNetCache@@@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@VFName@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@UFRepRecord@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@PAVUField@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@VFClassDependency@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IterateToNext@?$TFieldIterator@VUProperty@@@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$TArray@UFGenerationInfo@@@@QBEABUFGenerationInfo@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@UFGenerationInfo@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@UFObjectImport@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@UFObjectExport@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@PAVFLazyLoader@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Add@?$TTransArray@VFPoly@@@@QAEHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SerializeItem@?$TTransArray@VFPoly@@@@KAXAAVFArchive@@PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DestructItem@?$TTransArray@VFPoly@@@@KAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TArray@VFPoly@@@@QAE@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6@YAAAVFArchive@@AAV0@AAV?$TArray@VFPoly@@@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@VFPoly@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Empty@?$TArray@VFPoly@@@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TArray@VFBspNode@@@@QAE@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@VFBspNode@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TArray@VFVert@@@@QAE@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@VFVert@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TArray@VFVector@@@@QAE@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@VFVector@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TArray@VFBspSurf@@@@QAE@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@VFBspSurf@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@VFLightMapIndex@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@VFBox@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@VFLeaf@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TArray@PAVAActor@@@@QAE@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@PAVAActor@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@VFColor@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$TArray@UFMipmap@@@@QBEABUFMipmap@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@UFMipmap@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Empty@?$TArray@UFMipmap@@@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$TArray@UFFontCharacter@@@@QAEAAUFFontCharacter@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CountBytes@?$TArray@UFFontCharacter@@@@QAEXAAVFArchive@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Empty@?$TArray@UFFontCharacter@@@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@UFFontPage@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@VTPair@?$TMapBase@GH@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@M@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@UFMeshDecalTri@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@PAVAParticleCollisionActor@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@VFReachSpec@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Rehash@?$TMapBase@VFString@@V1@@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TArray@VTPair@?$TMapBase@VFString@@V1@@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@VTPair@?$TMapBase@VFString@@V1@@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Rehash@?$TMapBase@VFName@@PAVAActor@@@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TArray@VTPair@?$TMapBase@VFName@@PAVAActor@@@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@VTPair@?$TMapBase@VFName@@PAVAActor@@@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Rehash@?$TMapBase@VFString@@PAVUFont@@@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TArray@VTPair@?$TMapBase@VFString@@PAVUFont@@@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@VTPair@?$TMapBase@VFString@@PAVUFont@@@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@PAVUViewport@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$TArray@VFMeshAnimNotify@@@@QAEAAVFMeshAnimNotify@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CountBytes@?$TArray@VFMeshAnimNotify@@@@QAEXAAVFArchive@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@VFMeshAnimNotify@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Empty@?$TArray@VFMeshAnimNotify@@@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@UFMeshVert@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6@YAAAVFArchive@@AAV0@AAV?$TArray@UFMeshVert@@@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Empty@?$TArray@UFMeshVert@@@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@UFMeshTri@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6@YAAAVFArchive@@AAV0@AAV?$TArray@UFMeshTri@@@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Empty@?$TArray@UFMeshTri@@@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@VFMeshAnimSeq@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@UFMeshVertConnect@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6@YAAAVFArchive@@AAV0@AAV?$TArray@UFMeshVertConnect@@@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Empty@?$TArray@UFMeshVertConnect@@@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@PAVUTexture@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@UFMeshFace@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@UFMeshWedge@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@UFMeshMaterial@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@VTPair@?$TMapBase@VFName@@V1@@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$TArray@VFSpark@@@@QBEABVFSpark@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CountBytes@?$TArray@VFSpark@@@@QAEXAAVFArchive@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Empty@?$TArray@VFSpark@@@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NeedsDestructor@?$TTypeInfoBase@UFGenerationInfo@@@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NeedsDestructor@?$TTypeInfoBase@UFMipmap@@@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NeedsDestructor@?$TTypeInfoBase@VFSpark@@@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GFString@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GFPackageInfo@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FPoly@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GFBspSurf@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GFMipmap@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GFFontPage@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GFMeshAnimSeq@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1FPackageInfo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1FBspSurf@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1FMipmap@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1FFontPage@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1FMeshAnimSeq@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NeedsDestructor@?$TTypeInfoBase@VFString@@@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$TArray@H@@QAEAAHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CountBytes@?$TArray@H@@QAEXAAVFArchive@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$TArray@VFString@@@@QAEAAVFString@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$TArray@VFPackageInfo@@@@QAEAAVFPackageInfo@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$TArray@VTPair@?$TMapBase@PAVUObject@@H@@@@QAEAAVTPair@?$TMapBase@PAVUObject@@H@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@VTPair@?$TMapBase@PAVUObject@@H@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$TArray@VTPair@?$TMapBase@PAVUObject@@PAVFClassNetCache@@@@@@QAEAAVTPair@?$TMapBase@PAVUObject@@PAVFClassNetCache@@@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@VTPair@?$TMapBase@PAVUObject@@PAVFClassNetCache@@@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@VFDecal@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Add@?$TArray@VFPoly@@@@QAEHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@UFFontCharacter@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$TArray@UFFontPage@@@@QAEAAUFFontPage@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@VTPair@?$TMapBase@GH@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$TArray@VTPair@?$TMapBase@VFString@@V1@@@@@QAEAAVTPair@?$TMapBase@VFString@@V1@@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@VTPair@?$TMapBase@VFString@@V1@@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NeedsDestructor@?$TTypeInfoBase@PAVAActor@@@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$TArray@VTPair@?$TMapBase@VFName@@PAVAActor@@@@@@QAEAAVTPair@?$TMapBase@VFName@@PAVAActor@@@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@VTPair@?$TMapBase@VFName@@PAVAActor@@@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$TArray@VTPair@?$TMapBase@VFString@@PAVUFont@@@@@@QAEAAVTPair@?$TMapBase@VFString@@PAVUFont@@@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@VTPair@?$TMapBase@VFString@@PAVUFont@@@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$TArray@UFMeshVert@@@@QAEAAUFMeshVert@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CountBytes@?$TArray@UFMeshVert@@@@QAEXAAVFArchive@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@UFMeshVert@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$TArray@UFMeshTri@@@@QAEAAUFMeshTri@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CountBytes@?$TArray@UFMeshTri@@@@QAEXAAVFArchive@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@UFMeshTri@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$TArray@VFMeshAnimSeq@@@@QAEAAVFMeshAnimSeq@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$TArray@UFMeshVertConnect@@@@QAEAAUFMeshVertConnect@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CountBytes@?$TArray@UFMeshVertConnect@@@@QAEXAAVFArchive@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@UFMeshVertConnect@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@VTPair@?$TMapBase@VFName@@V1@@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NeedsDestructor@?$TTypeInfoBase@VFPackageInfo@@@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NeedsDestructor@?$TTypeInfoBase@UFRepRecord@@@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NeedsDestructor@?$TTypeInfoBase@PAVUField@@@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NeedsDestructor@?$TTypeInfoBase@VFClassDependency@@@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NeedsDestructor@?$TTypeInfoBase@UFObjectImport@@@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NeedsDestructor@?$TTypeInfoBase@UFObjectExport@@@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NeedsDestructor@?$TTypeInfoBase@PAVFLazyLoader@@@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NeedsDestructor@?$TTypeInfoBase@VFPoly@@@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NeedsDestructor@?$TTypeInfoBase@VFBspNode@@@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NeedsDestructor@?$TTypeInfoBase@VFVert@@@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NeedsDestructor@?$TTypeInfoBase@VFVector@@@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NeedsDestructor@?$TTypeInfoBase@VFBspSurf@@@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NeedsDestructor@?$TTypeInfoBase@VFLightMapIndex@@@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NeedsDestructor@?$TTypeInfoBase@VFBox@@@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NeedsDestructor@?$TTypeInfoBase@VFLeaf@@@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NeedsDestructor@?$TTypeInfoBase@VFColor@@@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NeedsDestructor@?$TTypeInfoBase@UFFontCharacter@@@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NeedsDestructor@?$TTypeInfoBase@UFFontPage@@@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NeedsDestructor@?$TTypeInfoBase@M@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NeedsDestructor@?$TTypeInfoBase@UFMeshDecalTri@@@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NeedsDestructor@?$TTypeInfoBase@PAVAParticleCollisionActor@@@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NeedsDestructor@?$TTypeInfoBase@VFReachSpec@@@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NeedsDestructor@?$TTypeInfoBase@PAVUViewport@@@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NeedsDestructor@?$TTypeInfoBase@VFMeshAnimNotify@@@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NeedsDestructor@?$TTypeInfoBase@UFMeshVert@@@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NeedsDestructor@?$TTypeInfoBase@UFMeshTri@@@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NeedsDestructor@?$TTypeInfoBase@VFMeshAnimSeq@@@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NeedsDestructor@?$TTypeInfoBase@UFMeshVertConnect@@@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NeedsDestructor@?$TTypeInfoBase@PAVUTexture@@@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NeedsDestructor@?$TTypeInfoBase@UFMeshFace@@@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NeedsDestructor@?$TTypeInfoBase@UFMeshWedge@@@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NeedsDestructor@?$TTypeInfoBase@UFMeshMaterial@@@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GTPair@?$TMapBase@VFString@@V1@@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GTPair@?$TMapBase@VFString@@PAVUFont@@@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1TPair@?$TMapBase@VFString@@V1@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1TPair@?$TMapBase@VFString@@PAVUFont@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@VFDecal@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@UFFontCharacter@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NeedsDestructor@?$TTypeInfoBase@VTPair@?$TMapBase@PAVUObject@@H@@@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NeedsDestructor@?$TTypeInfoBase@VTPair@?$TMapBase@PAVUObject@@PAVFClassNetCache@@@@@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NeedsDestructor@?$TTypeInfoBase@VTPair@?$TMapBase@GH@@@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NeedsDestructor@?$TTypeInfoBase@VTPair@?$TMapBase@VFString@@V1@@@@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NeedsDestructor@?$TTypeInfoBase@VTPair@?$TMapBase@VFName@@PAVAActor@@@@@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NeedsDestructor@?$TTypeInfoBase@VTPair@?$TMapBase@VFString@@PAVUFont@@@@@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NeedsDestructor@?$TTypeInfoBase@VTPair@?$TMapBase@VFName@@V1@@@@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GFDecal@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1FDecal@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$TArray@VFDecal@@@@QAEAAVFDecal@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NeedsDestructor@?$TTypeInfoBase@VFDecal@@@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Clamp@@YAHHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Clamp@@YAKKKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXIAAV?$TArray@VFClassDependency@@@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXIAAV?$TArray@UFGenerationInfo@@@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Align@@YAPAEQAEH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Abs@@YAMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Clamp@@YAMMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Abs@@YANN@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Clamp@@YANNNN@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Sgn@@YAMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Max@@YAMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Min@@YAMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Square@@YAMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Square@@YANN@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Abs@@YAHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Min@@YAHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FindObjectChecked@@YAPAVUClass@@PAVUObject@@PBGH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXIAAV?$TArray@VFColor@@@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXIAAV?$TArray@E@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXIAAV?$TArray@UFMipmap@@@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXIAAV?$TArray@UFFontCharacter@@@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXIAAV?$TArray@VFMeshAnimNotify@@@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXIAAV?$TArray@VFSpark@@@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXIAAV?$TArray@H@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXIAAV?$TArray@VFPoly@@@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXIAAV?$TArray@UFMeshVert@@@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXIAAV?$TArray@UFMeshTri@@@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXIAAV?$TArray@UFMeshVertConnect@@@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_SULevel@@6BUObject@@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SAInternetLink@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SALight@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SUCanvas@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ULinkerLoad@@6BULinker@@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SAInventory@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ULinkerSave@@6BULinker@@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SAPolyMarker@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SAlocationid@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SARenderActor@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R0PAX@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_SAInfoActor@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$TLazyArray@E@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SUObjectProperty@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SUState@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?Half@?1??appFloor@@YAHM@Z@4MA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT __CT??_R0PAX@84
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_SASpawnNotify@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SUMeshInstance@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SAActorDamageEffect@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7FMovingBrushTrackerBase@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SATcpLink@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SAPawn@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SUUnrealLodMesh@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SAMutator@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SAMapLocations@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7UFireTexture@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SABrush@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SUSystem@@6BUObject@@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SAClipMarker@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SUPrimitive@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SAPlayerPawn@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SAPlayerStart@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7UWaveTexture@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SAWeapon@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SABreakableGlass@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SAPathNode@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SAMover@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SABoneRope@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __CT??_R0PAG@84
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_SAActor@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SULevelSummary@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7FStringOutputDevice@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SUEnum@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ULinkerSave@@6BFArchive@@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R0PAG@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_SACarcass@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SAUdpLink@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SASavedMove@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SUStrProperty@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SADecal@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SANavigationPoint@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SUSound@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SUPackageMap@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SUStructProperty@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SUFunction@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SUMesh@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SAZoneInfo@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SAButtonMarker@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7FBufferArchive@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SAGameInfo@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SATriggers@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$TLazyArray@UFMeshTri@@@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SAPlayerReplicationInfo@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SUFontTrueType@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SASoftParticleAffector@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SUObject@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SUClassProperty@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SABeamSystem@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SUInput@@6BUObject@@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$TLazyArray@H@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SUDukeMesh@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SAInfo@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SAParticleSystem@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SATeleporter@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SAMeshEffect@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SAFocalPoint@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SAScout@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SAInterpolationStation@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$TLazyArray@UFMeshVert@@@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SASkyZoneInfo@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SUFloatProperty@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SUConst@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SUGameEngine@@6BUObject@@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7HActorVertex@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SUNameProperty@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SAParticleCollisionActor@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SAKeypoint@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SUPackage@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SAItem@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SUPalette@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7FLazyLoader@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7UFractalTexture@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SUMusic@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SAHUD@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SUCommandlet@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SAWarpZoneMarker@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SATriggerMarker@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7FBufferWriter@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SUBoolProperty@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SADecoration@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SAInterpolationPoint@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SADamageType@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SUFont@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SAMaterial@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SUPolys@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SUUnrealMesh@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7FConfigCache@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SAReplicationInfo@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SUFixedArrayProperty@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7UIceTexture@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7UWaterTexture@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SADOTAffector@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SADoorMover@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SAFlareLight@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ULinkerLoad@@6BFArchive@@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SATrigger@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SUArrayProperty@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SUVoiceSound@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SAGameReplicationInfo@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SAMeshDecal@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SATriggerLight@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7FCollisionHashBase@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7UWetTexture@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$TLazyArray@UFMeshVertConnect@@@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SUIntProperty@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SUStruct@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SULinker@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SADukeNet@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SASoftParticleSystem@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SAWarpZoneInfo@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SUTexture@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SAInventorySpot@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SUModel@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SUByteProperty@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SALiftCenter@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __CTA2PAG
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_SUScriptedTexture@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SURenderIterator@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SUMapProperty@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SALevelInfo@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __TI2PAG
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_SUTextBuffer@@6BUObject@@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SACamera@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SALiftExit@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SAProjectile@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SUClass@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SAInternetInfo@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
FLAT	GROUP _DATA, CONST, _BSS, CRT$XCA, CRT$XCU, CRT$XCL, CRT$XCC, CRT$XCZ, xdata$x
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	_autoclassUWaterTexture
PUBLIC	_GPackage
PUBLIC	_autoclassUWaveTexture
PUBLIC	?PrivateStaticClass@UWaterTexture@@0VUClass@@A	; UWaterTexture::PrivateStaticClass
PUBLIC	_autoclassUWetTexture
PUBLIC	?PrivateStaticClass@UWaveTexture@@0VUClass@@A	; UWaveTexture::PrivateStaticClass
PUBLIC	_hInstance
PUBLIC	?PrivateStaticClass@UWetTexture@@0VUClass@@A	; UWetTexture::PrivateStaticClass
PUBLIC	_autoclassUIceTexture
PUBLIC	?PrivateStaticClass@UIceTexture@@0VUClass@@A	; UIceTexture::PrivateStaticClass
PUBLIC	_SpeedRindex
PUBLIC	_StaleRindex
PUBLIC	_SpeedRandArr
PUBLIC	_PhaseTable
PUBLIC	_SignedPhaseTable
PUBLIC	_LightPhaseTable
PUBLIC	_autoclassUFractalTexture
PUBLIC	_LTimeTotal1
PUBLIC	_LTimeTotal2
PUBLIC	_LinePixels
PUBLIC	?TotalTime0@@3_JA				; TotalTime0
PUBLIC	?TotalTime1@@3_JA				; TotalTime1
PUBLIC	?TotalTime2@@3_JA				; TotalTime2
PUBLIC	?TotalTime3@@3_JA				; TotalTime3
PUBLIC	?TotalTime4@@3_JA				; TotalTime4
PUBLIC	?TotalPixels@@3_JA				; TotalPixels
PUBLIC	?TotalFrames@@3HA				; TotalFrames
PUBLIC	?PrivateStaticClass@UFractalTexture@@0VUClass@@A ; UFractalTexture::PrivateStaticClass
PUBLIC	_autoclassUFireTexture
PUBLIC	?PrivateStaticClass@UFireTexture@@0VUClass@@A	; UFireTexture::PrivateStaticClass
_BSS	SEGMENT
?LastMouseX@?1??WaterPaint@UWaterTexture@@AAEXHHK@Z@4HA DD 01H DUP (?) ; LastMouseX
?LastMouseY@?1??WaterPaint@UWaterTexture@@AAEXHHK@Z@4HA DD 01H DUP (?) ; LastMouseY
?LastLeftButton@?1??WaterPaint@UWaterTexture@@AAEXHHK@Z@4HA DD 01H DUP (?) ; LastLeftButton
?LastRightButton@?1??WaterPaint@UWaterTexture@@AAEXHHK@Z@4HA DD 01H DUP (?) ; LastRightButton
_autoclassUWaterTexture DD 01H DUP (?)
_autoclassUWaveTexture DD 01H DUP (?)
?PrivateStaticClass@UWaterTexture@@0VUClass@@A DB 0528H DUP (?) ; UWaterTexture::PrivateStaticClass
_autoclassUWetTexture DD 01H DUP (?)
?PrivateStaticClass@UWaveTexture@@0VUClass@@A DB 0528H DUP (?) ; UWaveTexture::PrivateStaticClass
_hInstance DD	01H DUP (?)
?PrivateStaticClass@UWetTexture@@0VUClass@@A DB 0528H DUP (?) ; UWetTexture::PrivateStaticClass
?MouseLastU@?1??MousePosition@UIceTexture@@UAEXKMM@Z@4MA DD 01H DUP (?) ; MouseLastU
?MouseLastV@?1??MousePosition@UIceTexture@@UAEXKMM@Z@4MA DD 01H DUP (?) ; MouseLastV
_autoclassUIceTexture DD 01H DUP (?)
?PrivateStaticClass@UIceTexture@@0VUClass@@A DB 0528H DUP (?) ; UIceTexture::PrivateStaticClass
_SpeedRindex DD	01H DUP (?)
_StaleRindex DD	01H DUP (?)
_SpeedRandArr DB 0200H DUP (?)
_PhaseTable DB	0100H DUP (?)
_SignedPhaseTable DB 0100H DUP (?)
_LightPhaseTable DB 0100H DUP (?)
?Initialized@?1??InitTables@@YAXXZ@4HA DD 01H DUP (?)	; Initialized
_autoclassUFractalTexture DD 01H DUP (?)
?LightPinX@?1??AddSpark@UFireTexture@@AAEXHH@Z@4HA DD 01H DUP (?) ; LightPinX
_LTimeTotal1 DQ	01H DUP (?)
?LightPinY@?1??AddSpark@UFireTexture@@AAEXHH@Z@4HA DD 01H DUP (?) ; LightPinY
	ALIGN	8

_LTimeTotal2 DQ	01H DUP (?)
_LinePixels DQ	01H DUP (?)
?TotalTime0@@3_JA DQ 01H DUP (?)			; TotalTime0
?TotalTime1@@3_JA DQ 01H DUP (?)			; TotalTime1
?TotalTime2@@3_JA DQ 01H DUP (?)			; TotalTime2
?TotalTime3@@3_JA DQ 01H DUP (?)			; TotalTime3
?TotalTime4@@3_JA DQ 01H DUP (?)			; TotalTime4
?TotalPixels@@3_JA DQ 01H DUP (?)			; TotalPixels
?TotalFrames@@3HA DD 01H DUP (?)			; TotalFrames
?PrivateStaticClass@UFractalTexture@@0VUClass@@A DB 0528H DUP (?) ; UFractalTexture::PrivateStaticClass
?LastMouseX@?1??FirePaint@UFireTexture@@AAEXHHK@Z@4HA DD 01H DUP (?) ; LastMouseX
?LastMouseY@?1??FirePaint@UFireTexture@@AAEXHHK@Z@4HA DD 01H DUP (?) ; LastMouseY
?LastLeftButton@?1??FirePaint@UFireTexture@@AAEXHHK@Z@4HA DD 01H DUP (?) ; LastLeftButton
?LastRightButton@?1??FirePaint@UFireTexture@@AAEXHHK@Z@4HA DD 01H DUP (?) ; LastRightButton
_autoclassUFireTexture DD 01H DUP (?)
?PrivateStaticClass@UFireTexture@@0VUClass@@A DB 0528H DUP (?) ; UFireTexture::PrivateStaticClass
_BSS	ENDS
_DATA	SEGMENT
_GPackage DB	'F', 00H, 'i', 00H, 'r', 00H, 'e', 00H, 00H, 00H
_DATA	ENDS
CRT$XCU	SEGMENT
_$S189	DD	FLAT:_$E188
_$S192	DD	FLAT:_$E191
_$S198	DD	FLAT:_$E197
_$S201	DD	FLAT:_$E200
_$S207	DD	FLAT:_$E206
_$S210	DD	FLAT:_$E209
_$S216	DD	FLAT:_$E215
_$S219	DD	FLAT:_$E218
_$S225	DD	FLAT:_$E224
_$S228	DD	FLAT:_$E227
_$S234	DD	FLAT:_$E233
_$S237	DD	FLAT:_$E236
CRT$XCU	ENDS
PUBLIC	_DllMain@12
; Function compile flags: /Ogty
; File C:\duke4\Fire\Src\UnFractal.cpp
;	COMDAT _DllMain@12
_TEXT	SEGMENT
_hInInstance$ = 8
_DllMain@12 PROC NEAR					; COMDAT

; 89   : IMPLEMENT_PACKAGE(Fire);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _hInInstance$[esp-4]
  00004	a3 00 00 00 00	 mov	 DWORD PTR _hInstance, eax
  00009	b8 01 00 00 00	 mov	 eax, 1
  0000e	c2 0c 00	 ret	 12			; 0000000cH
_DllMain@12 ENDP
_TEXT	ENDS
PUBLIC	?FakeAtan@@YANN@Z				; FakeAtan
PUBLIC	__real@00000000
PUBLIC	__real@3ff921cac0000000
PUBLIC	__real@3ff0000000000000
EXTRN	__fltused:NEAR
;	COMDAT __real@00000000
; File ..\..\Core\Inc\UnTemplate.h
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT __real@3ff921cac0000000
CONST	SEGMENT
__real@3ff921cac0000000 DQ 03ff921cac0000000r	; 1.57075
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
; Function compile flags: /Ogty
; File C:\duke4\Fire\Src\UnFractal.cpp
CONST	ENDS
;	COMDAT ?FakeAtan@@YANN@Z
_TEXT	SEGMENT
_X$ = 8
?FakeAtan@@YANN@Z PROC NEAR				; FakeAtan, COMDAT

; 132  :     return 3.1415F * 0.5F * X / (Abs((FLOAT)X) + 1.0);

  00000	dd 44 24 04	 fld	 QWORD PTR _X$[esp-4]
  00004	d8 15 00 00 00
	00		 fcom	 DWORD PTR __real@00000000
  0000a	df e0		 fnstsw	 ax
  0000c	f6 c4 01	 test	 ah, 1
  0000f	74 02		 je	 SHORT $L131807
  00011	d9 e0		 fchs
$L131807:
  00013	dd 44 24 04	 fld	 QWORD PTR _X$[esp-4]
  00017	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@3ff921cac0000000
  0001d	d9 c9		 fxch	 ST(1)
  0001f	dc 05 00 00 00
	00		 fadd	 QWORD PTR __real@3ff0000000000000
  00025	de f9		 fdivp	 ST(1), ST(0)

; 133  : }

  00027	c3		 ret	 0
?FakeAtan@@YANN@Z ENDP					; FakeAtan
_TEXT	ENDS
PUBLIC	?InitTables@@YAXXZ				; InitTables
PUBLIC	__real@3b800000
PUBLIC	__real@40c90fdb
PUBLIC	__real@405fe00000000000
PUBLIC	__real@405fdcccc0000000
EXTRN	__imp__rand:NEAR
;	COMDAT __real@3b800000
; File ..\..\Core\Inc\UnFile.h
CONST	SEGMENT
__real@3b800000 DD 03b800000r			; 0.00390625
CONST	ENDS
;	COMDAT __real@40c90fdb
CONST	SEGMENT
__real@40c90fdb DD 040c90fdbr			; 6.28319
CONST	ENDS
;	COMDAT __real@405fe00000000000
CONST	SEGMENT
__real@405fe00000000000 DQ 0405fe00000000000r	; 127.5
CONST	ENDS
;	COMDAT __real@405fdcccc0000000
CONST	SEGMENT
__real@405fdcccc0000000 DQ 0405fdcccc0000000r	; 127.45
; Function compile flags: /Ogty
; File C:\duke4\Fire\Src\UnFractal.cpp
CONST	ENDS
;	COMDAT ?InitTables@@YAXXZ
_TEXT	SEGMENT
_t$123656 = -8
_I$131824 = -4
$T131826 = -8
?InitTables@@YAXXZ PROC NEAR				; InitTables, COMDAT

; 144  : 	static INT  Initialized=0;
; 145  : 	if( !Initialized )

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?Initialized@?1??InitTables@@YAXXZ@4HA
  00005	83 ec 08	 sub	 esp, 8
  00008	85 c0		 test	 eax, eax
  0000a	0f 85 c1 00 00
	00		 jne	 $L123655

; 146  : 	{
; 147  : 		// Init 8-bit sine table.
; 148  : 		for( INT t=0; t<256; t++ )

  00010	33 c0		 xor	 eax, eax
  00012	89 44 24 00	 mov	 DWORD PTR _t$123656[esp+8], eax
$L123657:

; 149  : 		{
; 150  : 			PhaseTable[t] = appRound(127.45F + 127.5F*appSin( ((FLOAT)t/256.0F) * 6.2831853F ));

  00016	db 44 24 00	 fild	 DWORD PTR _t$123656[esp+8]
  0001a	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3b800000
  00020	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@40c90fdb
  00026	d9 fe		 fsin
  00028	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@405fe00000000000
  0002e	dc 05 00 00 00
	00		 fadd	 QWORD PTR __real@405fdcccc0000000
  00034	d9 5c 24 00	 fstp	 DWORD PTR $T131826[esp+8]
  00038	d9 44 24 00	 fld	 DWORD PTR $T131826[esp+8]
  0003c	db 5c 24 04	 fistp	 DWORD PTR _I$131824[esp+8]
  00040	8a 4c 24 04	 mov	 cl, BYTE PTR _I$131824[esp+8]
  00044	88 88 00 00 00
	00		 mov	 BYTE PTR _PhaseTable[eax], cl
  0004a	40		 inc	 eax
  0004b	3d 00 01 00 00	 cmp	 eax, 256		; 00000100H
  00050	89 44 24 00	 mov	 DWORD PTR _t$123656[esp+8], eax
  00054	7c c0		 jl	 SHORT $L123657

; 151  : 		}
; 152  : 
; 153  : 		for( t=0; t<256; t++ )

  00056	33 c9		 xor	 ecx, ecx
$L123661:

; 154  : 		{
; 155  : 		 	  LightPhaseTable[t] = Clamp (PhaseTable[t] + LIGHTPHASEBIAS, 0, 255);

  00058	33 d2		 xor	 edx, edx
  0005a	8a 91 00 00 00
	00		 mov	 dl, BYTE PTR _PhaseTable[ecx]
  00060	8b c2		 mov	 eax, edx
  00062	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00067	83 c0 20	 add	 eax, 32			; 00000020H
  0006a	79 04		 jns	 SHORT $L131837
  0006c	33 c0		 xor	 eax, eax
  0006e	eb 0c		 jmp	 SHORT $L131836
$L131837:
  00070	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00075	7c 05		 jl	 SHORT $L131836
  00077	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
$L131836:

; 156  : 			 SignedPhaseTable[t] = (BYTE)( -128 + (SBYTE)PhaseTable[t] );

  0007c	80 c2 80	 add	 dl, 128			; 00000080H
  0007f	88 81 00 00 00
	00		 mov	 BYTE PTR _LightPhaseTable[ecx], al
  00085	88 91 00 00 00
	00		 mov	 BYTE PTR _SignedPhaseTable[ecx], dl
  0008b	41		 inc	 ecx
  0008c	81 f9 00 01 00
	00		 cmp	 ecx, 256		; 00000100H
  00092	7c c4		 jl	 SHORT $L123661
  00094	56		 push	 esi
  00095	57		 push	 edi

; 157  : 		}
; 158  : 
; 159  : 		for( t=0 ; t<512 ; t++ )

  00096	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__rand
  0009c	33 f6		 xor	 esi, esi

; 174  : 	}
; 175  : }

  0009e	8b ff		 npad	 2

; 157  : 		}
; 158  : 
; 159  : 		for( t=0 ; t<512 ; t++ )

$L123671:

; 160  : 			SpeedRandArr[t] = (BYTE)(appRand() & 255);

  000a0	ff d7		 call	 edi
  000a2	88 86 00 00 00
	00		 mov	 BYTE PTR _SpeedRandArr[esi], al
  000a8	46		 inc	 esi
  000a9	81 fe 00 02 00
	00		 cmp	 esi, 512		; 00000200H
  000af	7c ef		 jl	 SHORT $L123671
  000b1	5f		 pop	 edi

; 161  : 
; 162  : 		// Speedy random number generator: initialize & align the index.
; 163  : 
; 164  : #if     RANDASM
; 165  : 		//SpeedRindex = ((DWORD)(&SpeedRandArr) +0xFF ) & 0xFFFFFF00;
; 166  : 		SpeedRindex=0;

  000b2	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _SpeedRindex, 0

; 167  : #else
; 168  : 		SpeedRindex=0;
; 169  : #endif
; 170  : 		StaleRindex=0;

  000bc	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _StaleRindex, 0

; 171  : 
; 172  : 		// Now initialized;
; 173  : 		Initialized=1;

  000c6	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?Initialized@?1??InitTables@@YAXXZ@4HA, 1
  000d0	5e		 pop	 esi
$L123655:

; 174  : 	}
; 175  : }

  000d1	83 c4 08	 add	 esp, 8
  000d4	c3		 ret	 0
?InitTables@@YAXXZ ENDP					; InitTables
_TEXT	ENDS
PUBLIC	?AddSpark@UFireTexture@@AAEXHH@Z		; UFireTexture::AddSpark
; Function compile flags: /Ogty
;	COMDAT ?AddSpark@UFireTexture@@AAEXHH@Z
_TEXT	SEGMENT
_MouseX$ = 8
_MouseY$ = 12
_TempSpeed$123741 = 8
_t$123749 = -8
_t$123755 = -8
?AddSpark@UFireTexture@@AAEXHH@Z PROC NEAR		; UFireTexture::AddSpark, COMDAT
; _this$ = ecx

; 464  : 	// Edit-time only.
; 465  : 	static INT  LightPinX=0;
; 466  : 	static INT  LightPinY=0;
; 467  : 
; 468  : 	// Return if out of bounds or out of sparks.
; 469  :     if( MouseX<0 || MouseY<0 || MouseX>=USize || MouseY>=VSize || ActiveSparkNum>=SparksLimit )

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _MouseX$[esp-4]
  00004	83 ec 08	 sub	 esp, 8
  00007	53		 push	 ebx
  00008	55		 push	 ebp
  00009	56		 push	 esi
  0000a	33 d2		 xor	 edx, edx
  0000c	3b c2		 cmp	 eax, edx
  0000e	57		 push	 edi
  0000f	8b f1		 mov	 esi, ecx
  00011	0f 8c f8 07 00
	00		 jl	 $L123787
  00017	8b 5c 24 20	 mov	 ebx, DWORD PTR _MouseY$[esp+20]
  0001b	3b da		 cmp	 ebx, edx
  0001d	0f 8c ec 07 00
	00		 jl	 $L123787
  00023	3b 46 34	 cmp	 eax, DWORD PTR [esi+52]
  00026	0f 8d e3 07 00
	00		 jge	 $L123787
  0002c	3b 5e 38	 cmp	 ebx, DWORD PTR [esi+56]
  0002f	0f 8d da 07 00
	00		 jge	 $L123787
  00035	8b be f8 00 00
	00		 mov	 edi, DWORD PTR [esi+248]
  0003b	3b be f4 00 00
	00		 cmp	 edi, DWORD PTR [esi+244]
  00041	0f 8d c8 07 00
	00		 jge	 $L123787

; 470  :         return;
; 471  : 
; 472  :     // Dynamic spark arrays: ActiveSparkNum/SparksLimit  have the current sparks and the current maximum
; 473  : 	// size; with these, the dynamic array is used as a *static* array in all spark adders/setters.
; 474  : 	
; 475  : 	// Make new spark.
; 476  :     INT  S = ActiveSparkNum++;  // ->Sparks[0] is the first one.

  00047	8d 4f 01	 lea	 ecx, DWORD PTR [edi+1]
  0004a	89 8e f8 00 00
	00		 mov	 DWORD PTR [esi+248], ecx

; 477  : 
; 478  : 	// General new spark initialization.
; 479  :     Sparks(S).Type = SparkType;

  00050	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  00056	89 54 24 1c	 mov	 DWORD PTR 8+[esp+20], edx
  0005a	8a 96 e0 00 00
	00		 mov	 dl, BYTE PTR [esi+224]
  00060	88 14 f9	 mov	 BYTE PTR [ecx+edi*8], dl

; 480  :     Sparks(S).X    = MouseX;

  00063	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  00069	88 44 f9 02	 mov	 BYTE PTR [ecx+edi*8+2], al

; 481  :     Sparks(S).Y    = MouseY;

  0006d	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  00073	88 5c f9 03	 mov	 BYTE PTR [ecx+edi*8+3], bl

; 482  : 	Sparks(S).Heat = FX_Heat; 

  00077	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  0007d	8a 96 e8 00 00
	00		 mov	 dl, BYTE PTR [esi+232]
  00083	88 54 f9 01	 mov	 BYTE PTR [ecx+edi*8+1], dl

; 483  : 
; 484  :     // Spark-type specific assignments.
; 485  :     switch( SparkType )
; 486  :     {

  00087	8b 54 24 1c	 mov	 edx, DWORD PTR 8+[esp+20]
  0008b	33 c9		 xor	 ecx, ecx
  0008d	8a 8e e0 00 00
	00		 mov	 cl, BYTE PTR [esi+224]
  00093	8b e9		 mov	 ebp, ecx
  00095	81 e5 ff 00 00
	00		 and	 ebp, 255		; 000000ffH
  0009b	4d		 dec	 ebp
  0009c	83 fd 1b	 cmp	 ebp, 27			; 0000001bH
  0009f	0f 87 6a 07 00
	00		 ja	 $L123787
  000a5	ff 24 ad 00 00
	00 00		 jmp	 DWORD PTR $L132182[ebp*4]
$L123727:

; 487  : 		case SPARK_Sparkle:
; 488  : 			Sparks(S).ByteA  = FX_Size;

  000ac	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  000b2	8a 86 e9 00 00
	00		 mov	 al, BYTE PTR [esi+233]
  000b8	88 44 fa 04	 mov	 BYTE PTR [edx+edi*8+4], al

; 489  : 			Sparks(S).ByteB  = FX_AuxSize;

  000bc	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  000c2	8a 96 ea 00 00
	00		 mov	 dl, BYTE PTR [esi+234]
  000c8	88 54 f9 05	 mov	 BYTE PTR [ecx+edi*8+5], dl
  000cc	5f		 pop	 edi
  000cd	5e		 pop	 esi
  000ce	5d		 pop	 ebp
  000cf	5b		 pop	 ebx

; 725  :             }
; 726  : 			break;
; 727  : 	}
; 728  : }

  000d0	83 c4 08	 add	 esp, 8
  000d3	c2 08 00	 ret	 8
$L123728:

; 490  : 			break;
; 491  : 
; 492  :         case SPARK_Pulse:
; 493  :             Sparks(S).Heat  = DrawPhase + AuxPhase;  

  000d6	8a 8e dc 00 00
	00		 mov	 cl, BYTE PTR [esi+220]
  000dc	8a 86 dd 00 00
	00		 mov	 al, BYTE PTR [esi+221]
  000e2	02 c1		 add	 al, cl
  000e4	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  000ea	88 44 f9 01	 mov	 BYTE PTR [ecx+edi*8+1], al

; 494  : 			DrawPhase      += FX_Phase;         //

  000ee	8a 86 dc 00 00
	00		 mov	 al, BYTE PTR [esi+220]
  000f4	8a 96 ed 00 00
	00		 mov	 dl, BYTE PTR [esi+237]
  000fa	02 c2		 add	 al, dl
  000fc	88 86 dc 00 00
	00		 mov	 BYTE PTR [esi+220], al

; 495  : 			Sparks(S).ByteD = FX_Frequency;     // Improve useful range.
; 496  :             break;

  00102	e9 9e 05 00 00	 jmp	 $L132181
$L123729:

; 497  : 
; 498  :         case SPARK_Signal:
; 499  :             Sparks(S).Heat  = SpeedRand();      //

  00107	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  0010d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  00113	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00119	83 c2 04	 add	 edx, 4
  0011c	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  00122	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  00128	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  0012e	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  00134	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  0013a	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  00140	88 44 fa 01	 mov	 BYTE PTR [edx+edi*8+1], al

; 500  : 			Sparks(S).ByteD = FX_Frequency;     // Improve useful range.

  00144	8b 86 fc 00 00
	00		 mov	 eax, DWORD PTR [esi+252]
  0014a	8a 8e ec 00 00
	00		 mov	 cl, BYTE PTR [esi+236]
  00150	88 4c f8 07	 mov	 BYTE PTR [eax+edi*8+7], cl

; 501  : 			Sparks(S).ByteC = (255 - FX_Heat);  //

  00154	8a 86 e8 00 00
	00		 mov	 al, BYTE PTR [esi+232]
  0015a	80 ca ff	 or	 dl, 255			; 000000ffH
  0015d	2a d0		 sub	 dl, al
  0015f	8b 86 fc 00 00
	00		 mov	 eax, DWORD PTR [esi+252]
  00165	88 54 f8 06	 mov	 BYTE PTR [eax+edi*8+6], dl
  00169	5f		 pop	 edi
  0016a	5e		 pop	 esi
  0016b	5d		 pop	 ebp
  0016c	5b		 pop	 ebx

; 725  :             }
; 726  : 			break;
; 727  : 	}
; 728  : }

  0016d	83 c4 08	 add	 esp, 8
  00170	c2 08 00	 ret	 8
$L123730:

; 502  :             break;                           
; 503  : 
; 504  :         case SPARK_Stars:    // Stars, FieldA for this type holds (negative) start Intensity.
; 505  :             Sparks(S).ByteA = FX_Heat;

  00173	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  00179	8a 96 e8 00 00
	00		 mov	 dl, BYTE PTR [esi+232]
  0017f	88 54 f9 04	 mov	 BYTE PTR [ecx+edi*8+4], dl
  00183	5f		 pop	 edi

; 506  : 			StarStatus = 1;  // At least one star..

  00184	c6 86 10 05 00
	00 01		 mov	 BYTE PTR [esi+1296], 1
  0018b	5e		 pop	 esi
  0018c	5d		 pop	 ebp
  0018d	5b		 pop	 ebx

; 725  :             }
; 726  : 			break;
; 727  : 	}
; 728  : }

  0018e	83 c4 08	 add	 esp, 8
  00191	c2 08 00	 ret	 8
$L123731:

; 507  :             break;
; 508  : 
; 509  : 		case SPARK_Organic:  // Organic blaze-up.
; 510  : 			Sparks(S).ByteC = FX_Area; 

  00194	8b 86 fc 00 00
	00		 mov	 eax, DWORD PTR [esi+252]
  0019a	8a 8e eb 00 00
	00		 mov	 cl, BYTE PTR [esi+235]
  001a0	88 4c f8 06	 mov	 BYTE PTR [eax+edi*8+6], cl
  001a4	5f		 pop	 edi
  001a5	5e		 pop	 esi
  001a6	5d		 pop	 ebp
  001a7	5b		 pop	 ebx

; 725  :             }
; 726  : 			break;
; 727  : 	}
; 728  : }

  001a8	83 c4 08	 add	 esp, 8
  001ab	c2 08 00	 ret	 8
$L123733:

; 511  : 			break;             
; 512  : 
; 513  : 		case SPARK_Eels: 
; 514  : 			Sparks(S).ByteC = FX_Size;
; 515  : 			break;
; 516  : 
; 517  : 		case SPARK_BlazeLeft:
; 518  : 		case SPARK_BlazeRight:
; 519  : 			Sparks(S).ByteC = FX_Size;

  001ae	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  001b4	8a 96 e9 00 00
	00		 mov	 dl, BYTE PTR [esi+233]
  001ba	88 54 f9 06	 mov	 BYTE PTR [ecx+edi*8+6], dl
  001be	5f		 pop	 edi
  001bf	5e		 pop	 esi
  001c0	5d		 pop	 ebp
  001c1	5b		 pop	 ebx

; 725  :             }
; 726  : 			break;
; 727  : 	}
; 728  : }

  001c2	83 c4 08	 add	 esp, 8
  001c5	c2 08 00	 ret	 8
$L123737:

; 520  : 			break;
; 521  : 
; 522  : 		case SPARK_OzHasSpoken: 
; 523  : 			break;  
; 524  : 
; 525  : 		case SPARK_Emit: // Spawn at angle , lifetime , linear movers.
; 526  : 			Sparks(S).ByteA  = FX_HorizSpeed - 128;
; 527  : 			Sparks(S).ByteB  = 127 ^ FX_VertSpeed;
; 528  : 			Sparks(S).ByteD  = 255/( (INT)FX_Size +1);
; 529  : 			break;
; 530  : 
; 531  : 		case SPARK_Fountain: // As Emit, with gravity.
; 532  : 			Sparks(S).ByteA  = FX_HorizSpeed - 128;

  001c8	8a 86 ee 00 00
	00		 mov	 al, BYTE PTR [esi+238]
  001ce	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  001d4	04 80		 add	 al, 128			; 00000080H
  001d6	88 44 f9 04	 mov	 BYTE PTR [ecx+edi*8+4], al

; 533  : 			Sparks(S).ByteB  = 127 ^ FX_VertSpeed;

  001da	8a 96 ef 00 00
	00		 mov	 dl, BYTE PTR [esi+239]
  001e0	8b 86 fc 00 00
	00		 mov	 eax, DWORD PTR [esi+252]
  001e6	80 f2 7f	 xor	 dl, 127			; 0000007fH
  001e9	88 54 f8 05	 mov	 BYTE PTR [eax+edi*8+5], dl

; 534  : 			Sparks(S).ByteD  = 255/( (INT)FX_Size + 1);

  001ed	33 c9		 xor	 ecx, ecx
  001ef	8a 8e e9 00 00
	00		 mov	 cl, BYTE PTR [esi+233]
  001f5	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
  001fa	99		 cdq
  001fb	41		 inc	 ecx
  001fc	f7 f9		 idiv	 ecx
  001fe	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  00204	88 44 fa 07	 mov	 BYTE PTR [edx+edi*8+7], al
  00208	5f		 pop	 edi
  00209	5e		 pop	 esi
  0020a	5d		 pop	 ebp
  0020b	5b		 pop	 ebx

; 725  :             }
; 726  : 			break;
; 727  : 	}
; 728  : }

  0020c	83 c4 08	 add	 esp, 8
  0020f	c2 08 00	 ret	 8
$L123739:

; 535  : 			break;
; 536  : 	
; 537  : 		case SPARK_Cylinder: // Twister (X=sin()) movement.
; 538  : 		case SPARK_Cylinder3D: // Twister (X=sin()) movement.
; 539  : 			{
; 540  : 				INT TempSize = FX_Size;
; 541  : 				INT TempSpeed = FX_HorizSpeed - 128;

  00212	33 c9		 xor	 ecx, ecx
  00214	8a 8e ee 00 00
	00		 mov	 cl, BYTE PTR [esi+238]
  0021a	33 d2		 xor	 edx, edx
  0021c	8a 96 e9 00 00
	00		 mov	 dl, BYTE PTR [esi+233]
  00222	8b e9		 mov	 ebp, ecx

; 542  : 				INT ThisIdx = S;
; 543  : 				INT Axis2 = PenDownX*2 + FX_Size;

  00224	33 c9		 xor	 ecx, ecx
  00226	8a 8e 11 05 00
	00		 mov	 cl, BYTE PTR [esi+1297]
  0022c	81 ed 80 00 00
	00		 sub	 ebp, 128		; 00000080H
  00232	88 4c 24 10	 mov	 BYTE PTR -8+[esp+24], cl
  00236	89 6c 24 1c	 mov	 DWORD PTR _TempSpeed$123741[esp+20], ebp
  0023a	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00240	8d 2c 4a	 lea	 ebp, DWORD PTR [edx+ecx*2]

; 544  : 
; 545  : 				// Scale to imaginary axis while mousebutton remains down.
; 546  : 				if( (DrawMode > DRAW_Normal) && (PenDownX != 0) )

  00243	8a 8e f0 00 00
	00		 mov	 cl, BYTE PTR [esi+240]
  00249	84 c9		 test	 cl, cl
  0024b	76 30		 jbe	 SHORT $L123745
  0024d	8a 4c 24 10	 mov	 cl, BYTE PTR -8+[esp+24]
  00251	84 c9		 test	 cl, cl
  00253	74 28		 je	 SHORT $L123745

; 547  : 				{
; 548  : 					TempSize = Axis2 - MouseX*2;

  00255	8d 0c 00	 lea	 ecx, DWORD PTR [eax+eax]
  00258	8b d5		 mov	 edx, ebp
  0025a	2b d1		 sub	 edx, ecx

; 549  : 
; 550  : 					// Axis = at PenDownX + 0.5 * FX_Size.
; 551  : 
; 552  : 					if( TempSize<0 )  // Crossed the axis.

  0025c	79 1f		 jns	 SHORT $L123745

; 553  : 					{	
; 554  : 						TempSize = MouseX*2 - Axis2;

  0025e	2b cd		 sub	 ecx, ebp
  00260	8b d1		 mov	 edx, ecx

; 555  : 						Sparks(S).X = MouseX - TempSize;  // Minus total diameter.

  00262	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  00268	2a c2		 sub	 al, dl
  0026a	88 44 f9 02	 mov	 BYTE PTR [ecx+edi*8+2], al

; 556  : 						TempSpeed = (256-TempSpeed) & 255; 

  0026e	8b 44 24 1c	 mov	 eax, DWORD PTR _TempSpeed$123741[esp+20]
  00272	f7 d8		 neg	 eax
  00274	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00279	89 44 24 1c	 mov	 DWORD PTR _TempSpeed$123741[esp+20], eax
$L123745:

; 557  : 					}
; 558  : 				};
; 559  : 				
; 560  : 				Sparks(S).ByteA  = ( GlobalPhase * FX_Frequency + FX_Phase ) & 255;

  0027d	8a 86 ec 00 00
	00		 mov	 al, BYTE PTR [esi+236]
  00283	f6 ae d8 00 00
	00		 imul	 BYTE PTR [esi+216]
  00289	02 86 ed 00 00
	00		 add	 al, BYTE PTR [esi+237]
  0028f	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  00295	88 44 f9 04	 mov	 BYTE PTR [ecx+edi*8+4], al

; 561  : 				Sparks(S).ByteB  = TempSize;  // Size.

  00299	8b 86 fc 00 00
	00		 mov	 eax, DWORD PTR [esi+252]
  0029f	88 54 f8 05	 mov	 BYTE PTR [eax+edi*8+5], dl

; 562  : 				Sparks(S).ByteD  = TempSpeed;

  002a3	8a 44 24 1c	 mov	 al, BYTE PTR _TempSpeed$123741[esp+20]
  002a7	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  002ad	88 44 f9 07	 mov	 BYTE PTR [ecx+edi*8+7], al

; 563  : 				
; 564  : 				// Draw second spark at +0.5 phase
; 565  : 				if( (DrawMode == DRAW_Lathe_2) && (ActiveSparkNum < SparksLimit) ) 

  002b1	80 be f0 00 00
	00 02		 cmp	 BYTE PTR [esi+240], 2
  002b8	0f 85 87 00 00
	00		 jne	 $L123746
  002be	8b 86 f8 00 00
	00		 mov	 eax, DWORD PTR [esi+248]
  002c4	3b 86 f4 00 00
	00		 cmp	 eax, DWORD PTR [esi+244]
  002ca	7d 79		 jge	 SHORT $L123746

; 566  : 				{
; 567  : 					INT  S = ActiveSparkNum++; 
; 568  : 					Sparks(S).Type = SparkType;

  002cc	89 54 24 10	 mov	 DWORD PTR -8+[esp+24], edx
  002d0	8a 96 e0 00 00
	00		 mov	 dl, BYTE PTR [esi+224]
  002d6	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  002d9	89 8e f8 00 00
	00		 mov	 DWORD PTR [esi+248], ecx
  002df	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  002e5	88 14 c1	 mov	 BYTE PTR [ecx+eax*8], dl

; 569  : 					Sparks(S).X    = Sparks(ThisIdx).X;

  002e8	8b ae fc 00 00
	00		 mov	 ebp, DWORD PTR [esi+252]
  002ee	8a 4c fd 02	 mov	 cl, BYTE PTR [ebp+edi*8+2]
  002f2	88 4c c5 02	 mov	 BYTE PTR [ebp+eax*8+2], cl

; 570  : 					Sparks(S).Y    = MouseY;

  002f6	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  002fc	88 5c c1 03	 mov	 BYTE PTR [ecx+eax*8+3], bl

; 571  : 					Sparks(S).Heat = FX_Heat; 

  00300	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  00306	8a 96 e8 00 00
	00		 mov	 dl, BYTE PTR [esi+232]
  0030c	88 54 c1 01	 mov	 BYTE PTR [ecx+eax*8+1], dl

; 572  : 
; 573  : 					Sparks(S).ByteA  = Sparks(ThisIdx).ByteA + 128;

  00310	8b ae fc 00 00
	00		 mov	 ebp, DWORD PTR [esi+252]
  00316	8a 4c fd 04	 mov	 cl, BYTE PTR [ebp+edi*8+4]

; 574  : 					Sparks(S).ByteB  = TempSize;  // size

  0031a	8b 54 24 10	 mov	 edx, DWORD PTR -8+[esp+24]
  0031e	80 c1 80	 add	 cl, 128			; 00000080H
  00321	88 4c c5 04	 mov	 BYTE PTR [ebp+eax*8+4], cl
  00325	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  0032b	88 54 c1 05	 mov	 BYTE PTR [ecx+eax*8+5], dl

; 575  : 					Sparks(S).ByteD  = TempSpeed;

  0032f	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  00335	89 54 24 10	 mov	 DWORD PTR -8+[esp+24], edx
  00339	8a 54 24 1c	 mov	 dl, BYTE PTR _TempSpeed$123741[esp+20]
  0033d	88 54 c1 07	 mov	 BYTE PTR [ecx+eax*8+7], dl
  00341	8b 54 24 10	 mov	 edx, DWORD PTR -8+[esp+24]
$L123746:

; 576  : 				}
; 577  : 				
; 578  : 				// Draw 2 more sparks at   +.33/.67 phases.
; 579  : 				if( ( DrawMode == DRAW_Lathe_3 ) && ( (ActiveSparkNum+2) <= SparksLimit ) )

  00345	80 be f0 00 00
	00 03		 cmp	 BYTE PTR [esi+240], 3
  0034c	0f 85 b3 00 00
	00		 jne	 $L123752
  00352	8b 86 f8 00 00
	00		 mov	 eax, DWORD PTR [esi+248]
  00358	8b 8e f4 00 00
	00		 mov	 ecx, DWORD PTR [esi+244]
  0035e	83 c0 02	 add	 eax, 2
  00361	3b c1		 cmp	 eax, ecx
  00363	0f 8f 9c 00 00
	00		 jg	 $L123752

; 580  : 				{
; 581  : 					for( INT t=1; t<3; t++ )

  00369	c7 44 24 10 01
	00 00 00	 mov	 DWORD PTR _t$123749[esp+24], 1
$L132177:

; 582  : 					{
; 583  : 						INT  S = ActiveSparkNum++; 

  00371	8b 8e f8 00 00
	00		 mov	 ecx, DWORD PTR [esi+248]
  00377	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  0037a	89 86 f8 00 00
	00		 mov	 DWORD PTR [esi+248], eax

; 584  : 						Sparks(S).Type   = SparkType;

  00380	8b 86 fc 00 00
	00		 mov	 eax, DWORD PTR [esi+252]
  00386	89 54 24 14	 mov	 DWORD PTR -4+[esp+24], edx
  0038a	8a 96 e0 00 00
	00		 mov	 dl, BYTE PTR [esi+224]
  00390	88 14 c8	 mov	 BYTE PTR [eax+ecx*8], dl

; 585  : 						Sparks(S).X      = Sparks(ThisIdx).X;

  00393	8b ae fc 00 00
	00		 mov	 ebp, DWORD PTR [esi+252]
  00399	8a 44 fd 02	 mov	 al, BYTE PTR [ebp+edi*8+2]
  0039d	88 44 cd 02	 mov	 BYTE PTR [ebp+ecx*8+2], al

; 586  : 						Sparks(S).Y      = MouseY;

  003a1	8b 86 fc 00 00
	00		 mov	 eax, DWORD PTR [esi+252]
  003a7	88 5c c8 03	 mov	 BYTE PTR [eax+ecx*8+3], bl

; 587  : 						Sparks(S).Heat   = FX_Heat; 

  003ab	8b 86 fc 00 00
	00		 mov	 eax, DWORD PTR [esi+252]
  003b1	8a 9e e8 00 00
	00		 mov	 bl, BYTE PTR [esi+232]

; 588  : 
; 589  : 						Sparks(S).ByteA  = Sparks(ThisIdx).ByteA + (t*(256/3) );
; 590  : 						Sparks(S).ByteB  = TempSize; // Size.

  003b7	8b 54 24 14	 mov	 edx, DWORD PTR -4+[esp+24]
  003bb	88 5c c8 01	 mov	 BYTE PTR [eax+ecx*8+1], bl
  003bf	8a 44 24 10	 mov	 al, BYTE PTR _t$123749[esp+24]
  003c3	8b ae fc 00 00
	00		 mov	 ebp, DWORD PTR [esi+252]
  003c9	b3 55		 mov	 bl, 85			; 00000055H
  003cb	f6 eb		 imul	 bl
  003cd	8a 5c fd 04	 mov	 bl, BYTE PTR [ebp+edi*8+4]
  003d1	02 d8		 add	 bl, al
  003d3	88 5c cd 04	 mov	 BYTE PTR [ebp+ecx*8+4], bl
  003d7	8b 86 fc 00 00
	00		 mov	 eax, DWORD PTR [esi+252]

; 591  : 						Sparks(S).ByteD  = TempSpeed;

  003dd	8a 5c 24 1c	 mov	 bl, BYTE PTR _TempSpeed$123741[esp+20]
  003e1	88 54 c8 05	 mov	 BYTE PTR [eax+ecx*8+5], dl
  003e5	8b 86 fc 00 00
	00		 mov	 eax, DWORD PTR [esi+252]
  003eb	88 5c c8 07	 mov	 BYTE PTR [eax+ecx*8+7], bl
  003ef	8b 44 24 10	 mov	 eax, DWORD PTR _t$123749[esp+24]
  003f3	8b 5c 24 20	 mov	 ebx, DWORD PTR _MouseY$[esp+20]
  003f7	40		 inc	 eax
  003f8	83 f8 03	 cmp	 eax, 3
  003fb	89 44 24 10	 mov	 DWORD PTR _t$123749[esp+24], eax
  003ff	0f 8c 6c ff ff
	ff		 jl	 $L132177
$L123752:

; 592  : 					}
; 593  : 				}			
; 594  : 
; 595  : 				// Draw 2 more sparks at   +.33/.67 phases.
; 596  : 				if( ( DrawMode == DRAW_Lathe_4 ) && ( (ActiveSparkNum+3) <= SparksLimit ) )

  00405	80 be f0 00 00
	00 04		 cmp	 BYTE PTR [esi+240], 4
  0040c	0f 85 fd 03 00
	00		 jne	 $L123787
  00412	8b 8e f8 00 00
	00		 mov	 ecx, DWORD PTR [esi+248]
  00418	8b 86 f4 00 00
	00		 mov	 eax, DWORD PTR [esi+244]
  0041e	83 c1 03	 add	 ecx, 3
  00421	3b c8		 cmp	 ecx, eax
  00423	0f 8f e6 03 00
	00		 jg	 $L123787

; 597  : 				{
; 598  : 					for( INT t=1; t<4; t++ )

  00429	c7 44 24 10 01
	00 00 00	 mov	 DWORD PTR _t$123755[esp+24], 1
  00431	eb 04		 jmp	 SHORT $L123756
$L132178:
  00433	8b 5c 24 20	 mov	 ebx, DWORD PTR _MouseY$[esp+20]
$L123756:

; 599  : 					{
; 600  : 						INT  S = ActiveSparkNum++; 

  00437	8b 86 f8 00 00
	00		 mov	 eax, DWORD PTR [esi+248]
  0043d	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  00440	89 8e f8 00 00
	00		 mov	 DWORD PTR [esi+248], ecx

; 601  : 						Sparks(S).Type   = SparkType;

  00446	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  0044c	89 54 24 14	 mov	 DWORD PTR -4+[esp+24], edx
  00450	8a 96 e0 00 00
	00		 mov	 dl, BYTE PTR [esi+224]
  00456	88 14 c1	 mov	 BYTE PTR [ecx+eax*8], dl

; 602  : 						Sparks(S).X      = Sparks(ThisIdx).X;

  00459	8b ae fc 00 00
	00		 mov	 ebp, DWORD PTR [esi+252]
  0045f	8a 4c fd 02	 mov	 cl, BYTE PTR [ebp+edi*8+2]

; 603  : 						Sparks(S).Y      = MouseY;
; 604  : 						Sparks(S).Heat   = FX_Heat; 
; 605  : 
; 606  : 						Sparks(S).ByteA  = Sparks(ThisIdx).ByteA +( t * 64 );
; 607  : 						Sparks(S).ByteB  = TempSize; // Size.

  00463	8b 54 24 14	 mov	 edx, DWORD PTR -4+[esp+24]
  00467	88 4c c5 02	 mov	 BYTE PTR [ebp+eax*8+2], cl
  0046b	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  00471	88 5c c1 03	 mov	 BYTE PTR [ecx+eax*8+3], bl
  00475	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  0047b	8a 9e e8 00 00
	00		 mov	 bl, BYTE PTR [esi+232]
  00481	88 5c c1 01	 mov	 BYTE PTR [ecx+eax*8+1], bl
  00485	8b ae fc 00 00
	00		 mov	 ebp, DWORD PTR [esi+252]
  0048b	8a 4c 24 10	 mov	 cl, BYTE PTR _t$123755[esp+24]
  0048f	8a 5c fd 04	 mov	 bl, BYTE PTR [ebp+edi*8+4]
  00493	c0 e1 06	 shl	 cl, 6
  00496	02 d9		 add	 bl, cl
  00498	88 5c c5 04	 mov	 BYTE PTR [ebp+eax*8+4], bl
  0049c	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]

; 608  : 						Sparks(S).ByteD  = TempSpeed;

  004a2	8a 5c 24 1c	 mov	 bl, BYTE PTR _TempSpeed$123741[esp+20]
  004a6	88 54 c1 05	 mov	 BYTE PTR [ecx+eax*8+5], dl
  004aa	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  004b0	88 5c c1 07	 mov	 BYTE PTR [ecx+eax*8+7], bl
  004b4	8b 44 24 10	 mov	 eax, DWORD PTR _t$123755[esp+24]
  004b8	40		 inc	 eax
  004b9	83 f8 04	 cmp	 eax, 4
  004bc	89 44 24 10	 mov	 DWORD PTR _t$123755[esp+24], eax
  004c0	0f 8c 6d ff ff
	ff		 jl	 $L132178
  004c6	5f		 pop	 edi
  004c7	5e		 pop	 esi
  004c8	5d		 pop	 ebp
  004c9	5b		 pop	 ebx

; 725  :             }
; 726  : 			break;
; 727  : 	}
; 728  : }

  004ca	83 c4 08	 add	 esp, 8
  004cd	c2 08 00	 ret	 8
$L123760:

; 609  : 					}
; 610  : 				}			
; 611  : 			}
; 612  : 			break;
; 613  : 
; 614  : 		case SPARK_Jugglers: // Twister (X=sin()) movement.
; 615  : 			Sparks(S).ByteA  = ( GlobalPhase * FX_Frequency + FX_Phase ) & 255;

  004d0	8a 86 ec 00 00
	00		 mov	 al, BYTE PTR [esi+236]
  004d6	f6 ae d8 00 00
	00		 imul	 BYTE PTR [esi+216]
  004dc	8a 8e ed 00 00
	00		 mov	 cl, BYTE PTR [esi+237]
  004e2	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  004e8	02 c1		 add	 al, cl
  004ea	88 44 fa 04	 mov	 BYTE PTR [edx+edi*8+4], al

; 616  : 			Sparks(S).ByteB  = FX_Size;  // size

  004ee	8b 86 fc 00 00
	00		 mov	 eax, DWORD PTR [esi+252]
  004f4	8a 8e e9 00 00
	00		 mov	 cl, BYTE PTR [esi+233]
  004fa	88 4c f8 05	 mov	 BYTE PTR [eax+edi*8+5], cl

; 617  : 			Sparks(S).ByteD  = FX_HorizSpeed - 128;

  004fe	8a 96 ee 00 00
	00		 mov	 dl, BYTE PTR [esi+238]
  00504	8b 86 fc 00 00
	00		 mov	 eax, DWORD PTR [esi+252]
  0050a	80 c2 80	 add	 dl, 128			; 00000080H
  0050d	88 54 f8 07	 mov	 BYTE PTR [eax+edi*8+7], dl
  00511	5f		 pop	 edi
  00512	5e		 pop	 esi
  00513	5d		 pop	 ebp
  00514	5b		 pop	 ebx

; 725  :             }
; 726  : 			break;
; 727  : 	}
; 728  : }

  00515	83 c4 08	 add	 esp, 8
  00518	c2 08 00	 ret	 8
$L123761:

; 618  : 			break;
; 619  : 
; 620  : 		case SPARK_Lissajous:
; 621  : 			Sparks(S).Heat  = FX_Size;       // size

  0051b	8a 86 e9 00 00
	00		 mov	 al, BYTE PTR [esi+233]
  00521	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  00527	88 44 f9 01	 mov	 BYTE PTR [ecx+edi*8+1], al

; 622  : 			Sparks(S).ByteA = FX_Phase;      // phase u

  0052b	8a 86 ed 00 00
	00		 mov	 al, BYTE PTR [esi+237]
  00531	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  00537	88 44 f9 04	 mov	 BYTE PTR [ecx+edi*8+4], al

; 623  : 			Sparks(S).ByteB = FX_Frequency;  // phase v

  0053b	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  00541	8a 86 ec 00 00
	00		 mov	 al, BYTE PTR [esi+236]
  00547	88 44 f9 05	 mov	 BYTE PTR [ecx+edi*8+5], al

; 624  : 			Sparks(S).ByteC = FX_HorizSpeed - 128;

  0054b	8a 8e ee 00 00
	00		 mov	 cl, BYTE PTR [esi+238]
  00551	8b 86 fc 00 00
	00		 mov	 eax, DWORD PTR [esi+252]
  00557	80 c1 80	 add	 cl, 128			; 00000080H
  0055a	88 4c f8 06	 mov	 BYTE PTR [eax+edi*8+6], cl

; 625  : 			Sparks(S).ByteD = FX_VertSpeed  - 128;

  0055e	8a 8e ef 00 00
	00		 mov	 cl, BYTE PTR [esi+239]
  00564	8b 86 fc 00 00
	00		 mov	 eax, DWORD PTR [esi+252]
  0056a	80 c1 80	 add	 cl, 128			; 00000080H
  0056d	88 4c f8 07	 mov	 BYTE PTR [eax+edi*8+7], cl

; 626  : 			// Special-cases redirected to more efficient setters.
; 627  : 			if( Sparks(S).ByteC == 0 ) Sparks(S).Type = SPARK_LissajY;

  00571	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  00577	8d 04 f9	 lea	 eax, DWORD PTR [ecx+edi*8]
  0057a	38 50 06	 cmp	 BYTE PTR [eax+6], dl
  0057d	75 03		 jne	 SHORT $L123762
  0057f	c6 00 1e	 mov	 BYTE PTR [eax], 30	; 0000001eH
$L123762:

; 628  : 			if( Sparks(S).ByteD == 0 ) Sparks(S).Type = SPARK_LissajX;

  00582	8b 86 fc 00 00
	00		 mov	 eax, DWORD PTR [esi+252]
  00588	8d 3c f8	 lea	 edi, DWORD PTR [eax+edi*8]
  0058b	38 57 07	 cmp	 BYTE PTR [edi+7], dl
  0058e	0f 85 7b 02 00
	00		 jne	 $L123787
  00594	c6 07 1d	 mov	 BYTE PTR [edi], 29	; 0000001dH
  00597	5f		 pop	 edi
  00598	5e		 pop	 esi
  00599	5d		 pop	 ebp
  0059a	5b		 pop	 ebx

; 725  :             }
; 726  : 			break;
; 727  : 	}
; 728  : }

  0059b	83 c4 08	 add	 esp, 8
  0059e	c2 08 00	 ret	 8
$L123764:

; 629  : 			break;
; 630  : 
; 631  :         case SPARK_SphereLightning: // Spherical lightning.
; 632  :             Sparks(S).Heat   = FX_Heat;  // heat

  005a1	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  005a7	8a 96 e8 00 00
	00		 mov	 dl, BYTE PTR [esi+232]
  005ad	88 54 f9 01	 mov	 BYTE PTR [ecx+edi*8+1], dl

; 633  :             Sparks(S).ByteC  = FX_Size;  // radius

  005b1	8b 86 fc 00 00
	00		 mov	 eax, DWORD PTR [esi+252]
  005b7	8a 8e e9 00 00
	00		 mov	 cl, BYTE PTR [esi+233]
  005bd	88 4c f8 06	 mov	 BYTE PTR [eax+edi*8+6], cl

; 634  :             // minimal 8 (=radius 4)
; 635  :             if( Sparks(S).ByteC <8 ) Sparks(S).ByteC = 8;

  005c1	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  005c7	8a 4c fa 06	 mov	 cl, BYTE PTR [edx+edi*8+6]
  005cb	80 f9 08	 cmp	 cl, 8
  005ce	8d 44 fa 06	 lea	 eax, DWORD PTR [edx+edi*8+6]
  005d2	73 03		 jae	 SHORT $L123765
  005d4	c6 00 08	 mov	 BYTE PTR [eax], 8
$L123765:

; 636  : 			Sparks(S).ByteD  = 96;  // Hardcoded chance.

  005d7	8b 86 fc 00 00
	00		 mov	 eax, DWORD PTR [esi+252]
  005dd	c6 44 f8 07 60	 mov	 BYTE PTR [eax+edi*8+7], 96 ; 00000060H
  005e2	5f		 pop	 edi
  005e3	5e		 pop	 esi
  005e4	5d		 pop	 ebp
  005e5	5b		 pop	 ebx

; 725  :             }
; 726  : 			break;
; 727  : 	}
; 728  : }

  005e6	83 c4 08	 add	 esp, 8
  005e9	c2 08 00	 ret	 8
$L123766:

; 637  :             break;
; 638  : 
; 639  : 		case SPARK_Flocks:
; 640  : 			Sparks(S).ByteA  = 128;

  005ec	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  005f2	b0 80		 mov	 al, 128			; 00000080H
  005f4	88 44 f9 04	 mov	 BYTE PTR [ecx+edi*8+4], al

; 641  : 			Sparks(S).ByteB  = FX_Size;   // Lifetime

  005f8	8a 8e e9 00 00
	00		 mov	 cl, BYTE PTR [esi+233]
  005fe	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  00604	88 4c fa 05	 mov	 BYTE PTR [edx+edi*8+5], cl

; 642  : 			Sparks(S).ByteC  = 128;

  00608	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  0060e	88 44 fa 06	 mov	 BYTE PTR [edx+edi*8+6], al

; 643  : 			Sparks(S).ByteD  = (255-FX_Area);   // spawn direction delta

  00612	8a 8e eb 00 00
	00		 mov	 cl, BYTE PTR [esi+235]
  00618	0c ff		 or	 al, 255			; 000000ffH
  0061a	2a c1		 sub	 al, cl
  0061c	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  00622	88 44 f9 07	 mov	 BYTE PTR [ecx+edi*8+7], al
  00626	5f		 pop	 edi
  00627	5e		 pop	 esi
  00628	5d		 pop	 ebp
  00629	5b		 pop	 ebx

; 725  :             }
; 726  : 			break;
; 727  : 	}
; 728  : }

  0062a	83 c4 08	 add	 esp, 8
  0062d	c2 08 00	 ret	 8
$L123767:

; 644  : 			break;
; 645  : 
; 646  : 		case SPARK_Wheel:  // Swirly emitter.
; 647  : 			Sparks(S).ByteA  = FX_Phase;  // Initial spawn dir.

  00630	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  00636	8a 86 ed 00 00
	00		 mov	 al, BYTE PTR [esi+237]
  0063c	88 44 fa 04	 mov	 BYTE PTR [edx+edi*8+4], al

; 648  : 			Sparks(S).ByteB  = FX_Size;   // Lifetime

  00640	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  00646	8a 96 e9 00 00
	00		 mov	 dl, BYTE PTR [esi+233]
  0064c	88 54 f9 05	 mov	 BYTE PTR [ecx+edi*8+5], dl

; 649  : 			Sparks(S).ByteC  = FX_Frequency; 

  00650	8b 86 fc 00 00
	00		 mov	 eax, DWORD PTR [esi+252]
  00656	8a 8e ec 00 00
	00		 mov	 cl, BYTE PTR [esi+236]
  0065c	88 4c f8 06	 mov	 BYTE PTR [eax+edi*8+6], cl

; 650  : 			Sparks(S).ByteD  = (255-FX_Area);   // spawn direction delta

  00660	8a 86 eb 00 00
	00		 mov	 al, BYTE PTR [esi+235]
  00666	80 ca ff	 or	 dl, 255			; 000000ffH
  00669	2a d0		 sub	 dl, al
  0066b	8b 86 fc 00 00
	00		 mov	 eax, DWORD PTR [esi+252]
  00671	88 54 f8 07	 mov	 BYTE PTR [eax+edi*8+7], dl
  00675	5f		 pop	 edi
  00676	5e		 pop	 esi
  00677	5d		 pop	 ebp
  00678	5b		 pop	 ebx

; 725  :             }
; 726  : 			break;
; 727  : 	}
; 728  : }

  00679	83 c4 08	 add	 esp, 8
  0067c	c2 08 00	 ret	 8
$L123768:

; 651  : 			break;
; 652  : 	
; 653  : 		case SPARK_Sprinkler: 
; 654  : 			Sparks(S).ByteA  = FX_Phase;  // Initial spawn dir.

  0067f	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  00685	8a 96 ed 00 00
	00		 mov	 dl, BYTE PTR [esi+237]
  0068b	88 54 f9 04	 mov	 BYTE PTR [ecx+edi*8+4], dl

; 655  : 			Sparks(S).ByteB  = - 128;

  0068f	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  00695	b0 80		 mov	 al, 128			; 00000080H
  00697	88 44 f9 05	 mov	 BYTE PTR [ecx+edi*8+5], al

; 656  : 			Sparks(S).ByteC  = 128;       // lifetime

  0069b	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  006a1	88 44 fa 06	 mov	 BYTE PTR [edx+edi*8+6], al
$L132181:

; 657  : 			Sparks(S).ByteD  = FX_Frequency;

  006a5	8b 86 fc 00 00
	00		 mov	 eax, DWORD PTR [esi+252]
  006ab	8a 8e ec 00 00
	00		 mov	 cl, BYTE PTR [esi+236]
  006b1	88 4c f8 07	 mov	 BYTE PTR [eax+edi*8+7], cl
  006b5	5f		 pop	 edi
  006b6	5e		 pop	 esi
  006b7	5d		 pop	 ebp
  006b8	5b		 pop	 ebx

; 725  :             }
; 726  : 			break;
; 727  : 	}
; 728  : }

  006b9	83 c4 08	 add	 esp, 8
  006bc	c2 08 00	 ret	 8
$L123769:

; 658  : 			break;
; 659  : 
; 660  : 		case SPARK_Gametes: 
; 661  : 			Sparks(S).ByteC  = FX_Size;    // Lifetime of spawned spermatozoids.

  006bf	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  006c5	8a 86 e9 00 00
	00		 mov	 al, BYTE PTR [esi+233]
  006cb	88 44 fa 06	 mov	 BYTE PTR [edx+edi*8+6], al
  006cf	5f		 pop	 edi
  006d0	5e		 pop	 esi
  006d1	5d		 pop	 ebp
  006d2	5b		 pop	 ebx

; 725  :             }
; 726  : 			break;
; 727  : 	}
; 728  : }

  006d3	83 c4 08	 add	 esp, 8
  006d6	c2 08 00	 ret	 8
$L123770:

; 662  : 			break;
; 663  : 
; 664  : 		case SPARK_LocalCloud:
; 665  : 			Sparks(S).ByteC  = FX_Area;

  006d9	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  006df	8a 96 eb 00 00
	00		 mov	 dl, BYTE PTR [esi+235]
  006e5	88 54 f9 06	 mov	 BYTE PTR [ecx+edi*8+6], dl
$L123771:

; 666  : 			Sparks(S).ByteA  = FX_HorizSpeed - 128;         

  006e9	8a 86 ee 00 00
	00		 mov	 al, BYTE PTR [esi+238]
  006ef	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  006f5	04 80		 add	 al, 128			; 00000080H
  006f7	88 44 f9 04	 mov	 BYTE PTR [ecx+edi*8+4], al

; 667  :             Sparks(S).ByteB  = (255 ^ FX_VertSpeed) - 128;  

  006fb	8a 96 ef 00 00
	00		 mov	 dl, BYTE PTR [esi+239]
  00701	8b 86 fc 00 00
	00		 mov	 eax, DWORD PTR [esi+252]
  00707	f6 d2		 not	 dl
  00709	80 c2 80	 add	 dl, 128			; 00000080H
  0070c	88 54 f8 05	 mov	 BYTE PTR [eax+edi*8+5], dl

; 668  : 			Sparks(S).ByteD  = 255-FX_Size;

  00710	8a 86 e9 00 00
	00		 mov	 al, BYTE PTR [esi+233]
  00716	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  0071c	80 c9 ff	 or	 cl, 255			; 000000ffH
  0071f	2a c8		 sub	 cl, al
  00721	88 4c fa 07	 mov	 BYTE PTR [edx+edi*8+7], cl
  00725	5f		 pop	 edi
  00726	5e		 pop	 esi
  00727	5d		 pop	 ebp
  00728	5b		 pop	 ebx

; 725  :             }
; 726  : 			break;
; 727  : 	}
; 728  : }

  00729	83 c4 08	 add	 esp, 8
  0072c	c2 08 00	 ret	 8
  0072f	90		 npad	 1
$L123773:

; 669  : 			break;
; 670  : 
; 671  : 		case SPARK_CustomCloud:
; 672  : 			Sparks(S).ByteA  = FX_HorizSpeed - 128;         
; 673  :             Sparks(S).ByteB  = (255 ^ FX_VertSpeed) - 128;  
; 674  : 			Sparks(S).ByteD  = 255-FX_Size;
; 675  : 			break;
; 676  : 
; 677  :         case SPARK_LineLightning: // 2-point lightning bolts.
; 678  :         case SPARK_RampLightning: 
; 679  :             // We have a new spark if no other was an 'open' one.
; 680  : 			// Not always the last one since short-lived sparks may shuffle the spark
; 681  : 			// order at any moment.
; 682  :             do { S--; }

  00730	4f		 dec	 edi

; 683  : 			while( (S>=0) && !( (Sparks(S).Type == SparkType) && (Sparks(S).ByteD == 0))  );

  00731	0f 88 b2 00 00
	00		 js	 $L123777
  00737	8b ae fc 00 00
	00		 mov	 ebp, DWORD PTR [esi+252]
  0073d	38 4c fd 00	 cmp	 BYTE PTR [ebp+edi*8], cl
  00741	8d 6c fd 00	 lea	 ebp, DWORD PTR [ebp+edi*8]
  00745	75 e9		 jne	 SHORT $L123773
  00747	38 55 07	 cmp	 BYTE PTR [ebp+7], dl
  0074a	75 e4		 jne	 SHORT $L123773

; 684  : 
; 685  :             if( S>=0 )
; 686  :             // Open point found, draw it while being stretched.
; 687  :             {
; 688  :                 ActiveSparkNum--; // so don't allocate 'current' spark

  0074c	ff 8e f8 00 00
	00		 dec	 DWORD PTR [esi+248]

; 689  : 
; 690  : 				// Refresh to 'starting' point
; 691  : 				Sparks(S).X  = LightPinX;

  00752	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  00758	89 54 24 20	 mov	 DWORD PTR 12+[esp+20], edx
  0075c	8a 15 00 00 00
	00		 mov	 dl, BYTE PTR ?LightPinX@?1??AddSpark@UFireTexture@@AAEXHH@Z@4HA
  00762	88 54 f9 02	 mov	 BYTE PTR [ecx+edi*8+2], dl

; 692  : 				Sparks(S).Y  = LightPinY;

  00766	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  0076c	8a 15 00 00 00
	00		 mov	 dl, BYTE PTR ?LightPinY@?1??AddSpark@UFireTexture@@AAEXHH@Z@4HA
  00772	88 54 f9 03	 mov	 BYTE PTR [ecx+edi*8+3], dl

; 693  : 
; 694  :                 // Dragging the lightning: Must have a heat value.
; 695  :                 // Close it by setting ByteD = heat ?
; 696  :                 // To nonzero, eventually.
; 697  : 
; 698  :                 Sparks(S).Heat = 3 | (FX_Heat); // Brightness.

  00776	8a 8e e8 00 00
	00		 mov	 cl, BYTE PTR [esi+232]
  0077c	8b ae fc 00 00
	00		 mov	 ebp, DWORD PTR [esi+252]
  00782	80 c9 03	 or	 cl, 3

; 699  : 
; 700  :                 INT  LenX = MouseX - (INT)Sparks(S).X;
; 701  :                 INT  LenY = MouseY - (INT)Sparks(S).Y;

  00785	8b 54 24 20	 mov	 edx, DWORD PTR 12+[esp+20]
  00789	88 4c fd 01	 mov	 BYTE PTR [ebp+edi*8+1], cl
  0078d	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  00793	8d 2c f9	 lea	 ebp, DWORD PTR [ecx+edi*8]
  00796	33 c9		 xor	 ecx, ecx
  00798	8a 4d 02	 mov	 cl, BYTE PTR [ebp+2]
  0079b	2b c1		 sub	 eax, ecx
  0079d	33 c9		 xor	 ecx, ecx
  0079f	8a 4d 03	 mov	 cl, BYTE PTR [ebp+3]
  007a2	2b d9		 sub	 ebx, ecx

; 702  : 
; 703  : 				if( LenX<0 )	LenX  = (- LenX) | 1;

  007a4	3b c2		 cmp	 eax, edx
  007a6	7d 07		 jge	 SHORT $L123782
  007a8	f7 d8		 neg	 eax
  007aa	83 c8 01	 or	 eax, 1

; 704  :                 else			LenX &= 0xFFFFFFFE;

  007ad	eb 03		 jmp	 SHORT $L123783
$L123782:
  007af	83 e0 fe	 and	 eax, -2			; fffffffeH
$L123783:

; 705  : 				if( LenY<0 )	LenY  = (- LenY) | 1;

  007b2	3b da		 cmp	 ebx, edx
  007b4	7d 07		 jge	 SHORT $L123784
  007b6	f7 db		 neg	 ebx
  007b8	83 cb 01	 or	 ebx, 1

; 706  :                 else			LenY &= 0xFFFFFFFE;

  007bb	eb 03		 jmp	 SHORT $L123785
$L123784:
  007bd	83 e3 fe	 and	 ebx, -2			; fffffffeH
$L123785:

; 707  : 
; 708  :                 if( (LenX == 0) && (LenY == 0) )

  007c0	3b c2		 cmp	 eax, edx
  007c2	75 07		 jne	 SHORT $L123786
  007c4	3b da		 cmp	 ebx, edx
  007c6	75 03		 jne	 SHORT $L123786

; 709  :                     Sparks(S).Heat=0;  // too short!

  007c8	88 55 01	 mov	 BYTE PTR [ebp+1], dl
$L123786:

; 710  : 
; 711  :                 Sparks(S).ByteA = LenX;

  007cb	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  007d1	88 44 fa 04	 mov	 BYTE PTR [edx+edi*8+4], al

; 712  :                 Sparks(S).ByteB = LenY;

  007d5	8b 86 fc 00 00
	00		 mov	 eax, DWORD PTR [esi+252]
  007db	88 5c f8 05	 mov	 BYTE PTR [eax+edi*8+5], bl
  007df	5f		 pop	 edi
  007e0	5e		 pop	 esi
  007e1	5d		 pop	 ebp
  007e2	5b		 pop	 ebx

; 725  :             }
; 726  : 			break;
; 727  : 	}
; 728  : }

  007e3	83 c4 08	 add	 esp, 8
  007e6	c2 08 00	 ret	 8
$L123777:

; 713  :                 // ByteD Stays 0 while drawing to indicate open bolt.
; 714  : 
; 715  :             } // Open point found.
; 716  : 
; 717  :             else
; 718  : 
; 719  :             { // No open point found: new lightning thing.
; 720  :                 S = ActiveSparkNum - 1;

  007e9	8b 8e f8 00 00
	00		 mov	 ecx, DWORD PTR [esi+248]

; 721  :                 Sparks(S).ByteD=0; // Signify open bolt.

  007ef	8b be fc 00 00
	00		 mov	 edi, DWORD PTR [esi+252]
  007f5	49		 dec	 ecx
  007f6	88 54 cf 07	 mov	 BYTE PTR [edi+ecx*8+7], dl

; 722  : 				Sparks(S).Heat =0; //

  007fa	8b b6 fc 00 00
	00		 mov	 esi, DWORD PTR [esi+252]
  00800	88 54 ce 01	 mov	 BYTE PTR [esi+ecx*8+1], dl

; 723  : 				LightPinX = MouseX;

  00804	a3 00 00 00 00	 mov	 DWORD PTR ?LightPinX@?1??AddSpark@UFireTexture@@AAEXHH@Z@4HA, eax

; 724  : 				LightPinY = MouseY;

  00809	89 1d 00 00 00
	00		 mov	 DWORD PTR ?LightPinY@?1??AddSpark@UFireTexture@@AAEXHH@Z@4HA, ebx
$L123787:
  0080f	5f		 pop	 edi
  00810	5e		 pop	 esi
  00811	5d		 pop	 ebp
  00812	5b		 pop	 ebx

; 725  :             }
; 726  : 			break;
; 727  : 	}
; 728  : }

  00813	83 c4 08	 add	 esp, 8
  00816	c2 08 00	 ret	 8
  00819	8d 49 00	 npad	 3
$L132182:
  0081c	00 00 00 00	 DD	 $L123727
  00820	00 00 00 00	 DD	 $L123728
  00824	00 00 00 00	 DD	 $L123729
  00828	00 00 00 00	 DD	 $L123787
  0082c	00 00 00 00	 DD	 $L123787
  00830	00 00 00 00	 DD	 $L123787
  00834	00 00 00 00	 DD	 $L123733
  00838	00 00 00 00	 DD	 $L123733
  0083c	00 00 00 00	 DD	 $L123739
  00840	00 00 00 00	 DD	 $L123739
  00844	00 00 00 00	 DD	 $L123761
  00848	00 00 00 00	 DD	 $L123760
  0084c	00 00 00 00	 DD	 $L123737
  00850	00 00 00 00	 DD	 $L123737
  00854	00 00 00 00	 DD	 $L123766
  00858	00 00 00 00	 DD	 $L123769
  0085c	00 00 00 00	 DD	 $L123731
  00860	00 00 00 00	 DD	 $L123787
  00864	00 00 00 00	 DD	 $L123787
  00868	00 00 00 00	 DD	 $L123771
  0086c	00 00 00 00	 DD	 $L123770
  00870	00 00 00 00	 DD	 $L123730
  00874	00 00 00 00	 DD	 $L123773
  00878	00 00 00 00	 DD	 $L123773
  0087c	00 00 00 00	 DD	 $L123764
  00880	00 00 00 00	 DD	 $L123767
  00884	00 00 00 00	 DD	 $L123769
  00888	00 00 00 00	 DD	 $L123768
?AddSpark@UFireTexture@@AAEXHH@Z ENDP			; UFireTexture::AddSpark
_TEXT	ENDS
PUBLIC	?CloseSpark@UFireTexture@@AAEXHH@Z		; UFireTexture::CloseSpark
; Function compile flags: /Ogty
;	COMDAT ?CloseSpark@UFireTexture@@AAEXHH@Z
_TEXT	SEGMENT
?CloseSpark@UFireTexture@@AAEXHH@Z PROC NEAR		; UFireTexture::CloseSpark, COMDAT
; _this$ = ecx

; 732  : {

  00000	56		 push	 esi

; 733  :     INT  S = ActiveSparkNum; // Sparks[S=0] is only one if ActiveSparkNum = 1.

  00001	8b b1 f8 00 00
	00		 mov	 esi, DWORD PTR [ecx+248]
$L123794:

; 734  : 
; 735  : 	        // Warning: extremely kludgy.
; 736  :             // Find ANY old spark of type 17/18 which has an 'open' end.
; 737  :             do { S--; } while( (S>=0) && !(	(

  00007	4e		 dec	 esi

; 738  : 				                   (Sparks(S).Type == SPARK_LineLightning)
; 739  : 							    || (Sparks(S).Type == SPARK_RampLightning)
; 740  : 								)
; 741  : 								&& (Sparks(S).ByteD == 0))  );

  00008	78 3c		 js	 SHORT $L123800
  0000a	8b 81 fc 00 00
	00		 mov	 eax, DWORD PTR [ecx+252]
  00010	8d 14 f0	 lea	 edx, DWORD PTR [eax+esi*8]
  00013	8a 02		 mov	 al, BYTE PTR [edx]
  00015	3c 17		 cmp	 al, 23			; 00000017H
  00017	74 04		 je	 SHORT $L123798
  00019	3c 18		 cmp	 al, 24			; 00000018H
  0001b	75 ea		 jne	 SHORT $L123794
$L123798:
  0001d	8a 42 07	 mov	 al, BYTE PTR [edx+7]
  00020	84 c0		 test	 al, al
  00022	75 e3		 jne	 SHORT $L123794

; 742  :             if( S>=0 )
; 743  :             // Open point found, closin' it.
; 744  :             {
; 745  :                 // ByteD, minimally 1...
; 746  : 				Sparks(S).ByteD  = FX_Frequency;

  00024	8a 81 ec 00 00
	00		 mov	 al, BYTE PTR [ecx+236]
  0002a	8b 91 fc 00 00
	00		 mov	 edx, DWORD PTR [ecx+252]
  00030	88 44 f2 07	 mov	 BYTE PTR [edx+esi*8+7], al

; 747  : 				if( Sparks(S).ByteD == 0 ) Sparks(S).ByteD = 1; // Ensure != 0.

  00034	8b 89 fc 00 00
	00		 mov	 ecx, DWORD PTR [ecx+252]
  0003a	8d 44 f1 07	 lea	 eax, DWORD PTR [ecx+esi*8+7]
  0003e	80 38 00	 cmp	 BYTE PTR [eax], 0
  00041	75 03		 jne	 SHORT $L123800
  00043	c6 00 01	 mov	 BYTE PTR [eax], 1
$L123800:
  00046	5e		 pop	 esi

; 748  : 			}
; 749  : }

  00047	c2 08 00	 ret	 8
?CloseSpark@UFireTexture@@AAEXHH@Z ENDP			; UFireTexture::CloseSpark
_TEXT	ENDS
PUBLIC	?DeleteSparks@UFireTexture@@AAEXHHH@Z		; UFireTexture::DeleteSparks
; Function compile flags: /Ogty
;	COMDAT ?DeleteSparks@UFireTexture@@AAEXHHH@Z
_TEXT	SEGMENT
_SparkX$ = 8
_SparkY$ = 12
_AreaWidth$ = 16
?DeleteSparks@UFireTexture@@AAEXHHH@Z PROC NEAR		; UFireTexture::DeleteSparks, COMDAT
; _this$ = ecx

; 758  : {

  00000	55		 push	 ebp

; 759  :     if( ActiveSparkNum > 0 )

  00001	8b a9 f8 00 00
	00		 mov	 ebp, DWORD PTR [ecx+248]
  00007	85 ed		 test	 ebp, ebp
  00009	56		 push	 esi
  0000a	7e 5c		 jle	 SHORT $L123811

; 760  : 	{
; 761  : 		for( INT S=0; S<ActiveSparkNum; S++ )

  0000c	33 f6		 xor	 esi, esi
  0000e	85 ed		 test	 ebp, ebp
  00010	7e 56		 jle	 SHORT $L123811
  00012	53		 push	 ebx
  00013	57		 push	 edi
$L123809:

; 762  : 		{
; 763  : 			// Diamond-shaped eraser.
; 764  : 			if( AreaWidth >= Abs(SparkX - Sparks(S).X) + Abs(SparkY - Sparks(S).Y ) )

  00014	8b 81 fc 00 00
	00		 mov	 eax, DWORD PTR [ecx+252]
  0001a	33 d2		 xor	 edx, edx
  0001c	8a 54 f0 02	 mov	 dl, BYTE PTR [eax+esi*8+2]
  00020	8b fa		 mov	 edi, edx
  00022	8b 54 24 14	 mov	 edx, DWORD PTR _SparkX$[esp+12]
  00026	2b d7		 sub	 edx, edi
  00028	79 02		 jns	 SHORT $L132216
  0002a	f7 da		 neg	 edx
$L132216:
  0002c	8b 7c 24 18	 mov	 edi, DWORD PTR _SparkY$[esp+12]
  00030	33 db		 xor	 ebx, ebx
  00032	8a 5c f0 03	 mov	 bl, BYTE PTR [eax+esi*8+3]
  00036	2b fb		 sub	 edi, ebx
  00038	79 02		 jns	 SHORT $L132227
  0003a	f7 df		 neg	 edi
$L132227:
  0003c	03 fa		 add	 edi, edx
  0003e	39 7c 24 1c	 cmp	 DWORD PTR _AreaWidth$[esp+12], edi
  00042	7c 17		 jl	 SHORT $L123810

; 765  : 			{
; 766  : 				// Delete spark by replacing it with last one (+ delete last one).
; 767  : 				INT LastSpark = --ActiveSparkNum;

  00044	8d 55 ff	 lea	 edx, DWORD PTR [ebp-1]
  00047	89 91 f8 00 00
	00		 mov	 DWORD PTR [ecx+248], edx

; 768  : 				Sparks(S) =   Sparks(LastSpark);

  0004d	8b 3c d0	 mov	 edi, DWORD PTR [eax+edx*8]
  00050	89 3c f0	 mov	 DWORD PTR [eax+esi*8], edi
  00053	8b 54 d0 04	 mov	 edx, DWORD PTR [eax+edx*8+4]
  00057	89 54 f0 04	 mov	 DWORD PTR [eax+esi*8+4], edx
$L123810:
  0005b	8b a9 f8 00 00
	00		 mov	 ebp, DWORD PTR [ecx+248]
  00061	46		 inc	 esi
  00062	3b f5		 cmp	 esi, ebp
  00064	7c ae		 jl	 SHORT $L123809
  00066	5f		 pop	 edi
  00067	5b		 pop	 ebx
$L123811:
  00068	5e		 pop	 esi
  00069	5d		 pop	 ebp

; 769  : 			}
; 770  : 		}
; 771  : 	}
; 772  : }

  0006a	c2 0c 00	 ret	 12			; 0000000cH
?DeleteSparks@UFireTexture@@AAEXHHH@Z ENDP		; UFireTexture::DeleteSparks
_TEXT	ENDS
PUBLIC	?DrawSparkLine@UFireTexture@@AAEXHHHHH@Z	; UFireTexture::DrawSparkLine
; Function compile flags: /Ogty
;	COMDAT ?DrawSparkLine@UFireTexture@@AAEXHHHHH@Z
_TEXT	SEGMENT
_StartX$ = 8
_StartY$ = 12
_DestX$ = 16
_DestY$ = 20
_this$ = -4
_Xinc$ = 16
_Yinc$ = 8
_DivY2$123851 = 12
_DivX2$123861 = 12
?DrawSparkLine@UFireTexture@@AAEXHHHHH@Z PROC NEAR	; UFireTexture::DrawSparkLine, COMDAT
; _this$ = ecx

; 780  : {

  00000	51		 push	 ecx

; 781  :     INT  Xinc, Yinc;
; 782  : 
; 783  :     INT  DivX = DestX - StartX;

  00001	8b 44 24 10	 mov	 eax, DWORD PTR _DestX$[esp]
  00005	53		 push	 ebx
  00006	55		 push	 ebp
  00007	56		 push	 esi
  00008	8b 74 24 14	 mov	 esi, DWORD PTR _StartX$[esp+12]
  0000c	89 4c 24 0c	 mov	 DWORD PTR _this$[esp+16], ecx

; 784  :     INT  DivY = DestY - StartY;

  00010	8b 4c 24 20	 mov	 ecx, DWORD PTR _DestY$[esp+12]
  00014	57		 push	 edi
  00015	8b 7c 24 1c	 mov	 edi, DWORD PTR _StartY$[esp+16]
  00019	2b c6		 sub	 eax, esi
  0001b	2b cf		 sub	 ecx, edi

; 785  : 
; 786  :     if( (DivX == 0) && (DivY == 0) )

  0001d	83 ca ff	 or	 edx, -1
  00020	85 c0		 test	 eax, eax
  00022	75 0a		 jne	 SHORT $L132262
  00024	85 c9		 test	 ecx, ecx
  00026	0f 84 e2 00 00
	00		 je	 $L123867

; 787  :         return;
; 788  : 
; 789  :     if( DivX<0 )

  0002c	eb 14		 jmp	 SHORT $L123836
$L132262:
  0002e	7d 06		 jge	 SHORT $L123834

; 790  :         Xinc = -1;

  00030	89 54 24 20	 mov	 DWORD PTR _Xinc$[esp+16], edx

; 791  :     else

  00034	eb 14		 jmp	 SHORT $L123837
$L123834:

; 792  :     {
; 793  :         if( DivX>0 )

  00036	85 c0		 test	 eax, eax

; 794  :             Xinc = 1;

  00038	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR _Xinc$[esp+16], 1
  00040	7f 08		 jg	 SHORT $L123837
$L123836:

; 795  :         else
; 796  :             Xinc=0;

  00042	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR _Xinc$[esp+16], 0
$L123837:

; 797  :     }
; 798  : 
; 799  :     if( DivY<0 )

  0004a	85 c9		 test	 ecx, ecx

; 800  :         Yinc = -1;
; 801  :     else

  0004c	7c 07		 jl	 SHORT $L132263

; 802  :     {
; 803  :         if( DivY>0 )

  0004e	33 d2		 xor	 edx, edx
  00050	85 c9		 test	 ecx, ecx
  00052	0f 9f c2	 setg	 dl
$L132263:

; 804  :             Yinc = 1;
; 805  :         else
; 806  :             Yinc=0;
; 807  :     }
; 808  : 
; 809  :     DivX = Abs(DivX);

  00055	85 c0		 test	 eax, eax
  00057	89 54 24 18	 mov	 DWORD PTR _Yinc$[esp+16], edx
  0005b	7d 02		 jge	 SHORT $L132247
  0005d	f7 d8		 neg	 eax
$L132247:

; 810  :     DivY = Abs(DivY);

  0005f	85 c9		 test	 ecx, ecx
  00061	7d 02		 jge	 SHORT $L132254
  00063	f7 d9		 neg	 ecx
$L132254:

; 811  : 
; 812  :     INT  Xpoint = StartX;
; 813  :     INT  Ypoint = StartY;
; 814  : 
; 815  :     if( DivX>=DivY )   // Draw line based on X loop.

  00065	3b c1		 cmp	 eax, ecx
  00067	8b de		 mov	 ebx, esi
  00069	7c 5b		 jl	 SHORT $L123850

; 816  :     {
; 817  :         INT  DivY2  = DivY + DivY;

  0006b	03 c9		 add	 ecx, ecx

; 818  :         INT  Diff   = DivY2 - DivX;

  0006d	8b f1		 mov	 esi, ecx

; 819  :         INT  DivXY2 = DivY2 - DivX - DivX;

  0006f	8d 14 00	 lea	 edx, DWORD PTR [eax+eax]
  00072	8b e9		 mov	 ebp, ecx
  00074	2b f0		 sub	 esi, eax
  00076	2b ea		 sub	 ebp, edx

; 820  : 
; 821  :         for( INT LCount = 1; LCount<=DivX; LCount++ )

  00078	83 f8 01	 cmp	 eax, 1
  0007b	89 4c 24 1c	 mov	 DWORD PTR _DivY2$123851[esp+16], ecx
  0007f	0f 8c 89 00 00
	00		 jl	 $L123867

; 816  :     {
; 817  :         INT  DivY2  = DivY + DivY;

  00085	89 44 24 24	 mov	 DWORD PTR 20+[esp+16], eax

; 853  :         }
; 854  :     }
; 855  : }

  00089	8d a4 24 00 00
	00 00		 npad	 7
$L123855:

; 822  :         {
; 823  :             AddSpark(Xpoint,Ypoint);

  00090	8b 4c 24 10	 mov	 ecx, DWORD PTR _this$[esp+20]
  00094	57		 push	 edi
  00095	53		 push	 ebx
  00096	e8 00 00 00 00	 call	 ?AddSpark@UFireTexture@@AAEXHH@Z ; UFireTexture::AddSpark

; 824  : 
; 825  :             if( Diff<0 )

  0009b	85 f6		 test	 esi, esi
  0009d	7d 06		 jge	 SHORT $L123858

; 826  :                 Diff += DivY2;

  0009f	03 74 24 1c	 add	 esi, DWORD PTR _DivY2$123851[esp+16]

; 827  :             else

  000a3	eb 08		 jmp	 SHORT $L123859
$L123858:

; 828  :             {
; 829  :                 Diff   += DivXY2;
; 830  :                 Ypoint += Yinc;

  000a5	8b 44 24 18	 mov	 eax, DWORD PTR _Yinc$[esp+16]
  000a9	03 f5		 add	 esi, ebp
  000ab	03 f8		 add	 edi, eax
$L123859:

; 831  :             }
; 832  :         Xpoint += Xinc;

  000ad	8b 4c 24 20	 mov	 ecx, DWORD PTR _Xinc$[esp+16]
  000b1	8b 44 24 24	 mov	 eax, DWORD PTR 20+[esp+16]
  000b5	03 d9		 add	 ebx, ecx
  000b7	48		 dec	 eax
  000b8	89 44 24 24	 mov	 DWORD PTR 20+[esp+16], eax
  000bc	75 d2		 jne	 SHORT $L123855
  000be	5f		 pop	 edi
  000bf	5e		 pop	 esi
  000c0	5d		 pop	 ebp
  000c1	5b		 pop	 ebx

; 853  :         }
; 854  :     }
; 855  : }

  000c2	59		 pop	 ecx
  000c3	c2 14 00	 ret	 20			; 00000014H
$L123850:

; 833  :         }
; 834  :     }
; 835  :     else    // Draw line based on Y loop.
; 836  :     {
; 837  :         INT  DivX2  = DivX  + DivX;

  000c6	03 c0		 add	 eax, eax

; 838  :         INT  Diff   = DivX2 - DivY;

  000c8	8b f0		 mov	 esi, eax

; 839  :         INT  DivXY2 = DivX2 - DivY - DivY;

  000ca	8d 14 09	 lea	 edx, DWORD PTR [ecx+ecx]
  000cd	8b e8		 mov	 ebp, eax
  000cf	2b f1		 sub	 esi, ecx
  000d1	2b ea		 sub	 ebp, edx

; 840  : 
; 841  :         for( INT LCount = 1; LCount<=DivY; LCount++ )

  000d3	83 f9 01	 cmp	 ecx, 1
  000d6	89 44 24 1c	 mov	 DWORD PTR _DivX2$123861[esp+16], eax
  000da	7c 32		 jl	 SHORT $L123867

; 833  :         }
; 834  :     }
; 835  :     else    // Draw line based on Y loop.
; 836  :     {
; 837  :         INT  DivX2  = DivX  + DivX;

  000dc	89 4c 24 24	 mov	 DWORD PTR 20+[esp+16], ecx
$L123865:

; 842  :         {
; 843  :             AddSpark(Xpoint,Ypoint);

  000e0	8b 4c 24 10	 mov	 ecx, DWORD PTR _this$[esp+20]
  000e4	57		 push	 edi
  000e5	53		 push	 ebx
  000e6	e8 00 00 00 00	 call	 ?AddSpark@UFireTexture@@AAEXHH@Z ; UFireTexture::AddSpark

; 844  : 
; 845  :             if( Diff<0 )

  000eb	85 f6		 test	 esi, esi
  000ed	7d 06		 jge	 SHORT $L123868

; 846  :                 Diff += DivX2;

  000ef	03 74 24 1c	 add	 esi, DWORD PTR _DivX2$123861[esp+16]

; 847  :             else

  000f3	eb 08		 jmp	 SHORT $L123869
$L123868:

; 848  :             {
; 849  :                 Diff   += DivXY2;
; 850  :                 Xpoint += Xinc;

  000f5	8b 44 24 20	 mov	 eax, DWORD PTR _Xinc$[esp+16]
  000f9	03 f5		 add	 esi, ebp
  000fb	03 d8		 add	 ebx, eax
$L123869:

; 851  :             }
; 852  :             Ypoint += Yinc;

  000fd	8b 4c 24 18	 mov	 ecx, DWORD PTR _Yinc$[esp+16]
  00101	8b 44 24 24	 mov	 eax, DWORD PTR 20+[esp+16]
  00105	03 f9		 add	 edi, ecx
  00107	48		 dec	 eax
  00108	89 44 24 24	 mov	 DWORD PTR 20+[esp+16], eax
  0010c	75 d2		 jne	 SHORT $L123865
$L123867:
  0010e	5f		 pop	 edi
  0010f	5e		 pop	 esi
  00110	5d		 pop	 ebp
  00111	5b		 pop	 ebx

; 853  :         }
; 854  :     }
; 855  : }

  00112	59		 pop	 ecx
  00113	c2 14 00	 ret	 20			; 00000014H
?DrawSparkLine@UFireTexture@@AAEXHHHHH@Z ENDP		; UFireTexture::DrawSparkLine
_TEXT	ENDS
PUBLIC	?FirePaint@UFireTexture@@AAEXHHK@Z		; UFireTexture::FirePaint
; Function compile flags: /Ogty
;	COMDAT ?FirePaint@UFireTexture@@AAEXHHK@Z
_TEXT	SEGMENT
_MouseX$ = 8
_MouseY$ = 12
_Buttons$ = 16
_RightButton$ = -4
_LeftButton$ = -16
_PosChanged$ = 16
_RightChanged$ = -8
_LeftChanged$ = -12
?FirePaint@UFireTexture@@AAEXHHK@Z PROC NEAR		; UFireTexture::FirePaint, COMDAT
; _this$ = ecx

; 865  : {

  00000	83 ec 10	 sub	 esp, 16			; 00000010H

; 866  : 	UBOOL RightButton = (Buttons & MOUSE_Right);

  00003	8b 44 24 1c	 mov	 eax, DWORD PTR _Buttons$[esp+12]

; 867  : 	UBOOL  LeftButton = (Buttons & MOUSE_Left);
; 868  : 
; 869  : 	// Perform painting.
; 870  :     static INT  LastMouseX=0, LastMouseY=0, LastLeftButton=0, LastRightButton=0;
; 871  : 
; 872  :     UBOOL  PosChanged   = ((LastMouseX != MouseX) || (LastMouseY != MouseY));

  00007	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?LastMouseY@?1??FirePaint@UFireTexture@@AAEXHHK@Z@4HA
  0000d	53		 push	 ebx
  0000e	8b 5c 24 18	 mov	 ebx, DWORD PTR _MouseX$[esp+16]
  00012	55		 push	 ebp
  00013	56		 push	 esi
  00014	8b f0		 mov	 esi, eax
  00016	83 e0 01	 and	 eax, 1
  00019	8b e8		 mov	 ebp, eax
  0001b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?LastMouseX@?1??FirePaint@UFireTexture@@AAEXHHK@Z@4HA
  00020	83 e6 02	 and	 esi, 2
  00023	3b c3		 cmp	 eax, ebx
  00025	57		 push	 edi
  00026	8b f9		 mov	 edi, ecx
  00028	89 74 24 1c	 mov	 DWORD PTR _RightButton$[esp+32], esi
  0002c	89 6c 24 10	 mov	 DWORD PTR _LeftButton$[esp+32], ebp
  00030	75 0e		 jne	 SHORT $L132267
  00032	3b 54 24 28	 cmp	 edx, DWORD PTR _MouseY$[esp+28]
  00036	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR _PosChanged$[esp+28], 0
  0003e	74 08		 je	 SHORT $L132268
$L132267:
  00040	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR _PosChanged$[esp+28], 1
$L132268:

; 873  :     UBOOL  RightChanged =  (LastRightButton != RightButton);

  00048	33 c9		 xor	 ecx, ecx
  0004a	39 35 00 00 00
	00		 cmp	 DWORD PTR ?LastRightButton@?1??FirePaint@UFireTexture@@AAEXHHK@Z@4HA, esi
  00050	0f 95 c1	 setne	 cl
  00053	89 4c 24 18	 mov	 DWORD PTR _RightChanged$[esp+32], ecx

; 874  :     UBOOL  LeftChanged  =  (LastLeftButton  != LeftButton);

  00057	33 c9		 xor	 ecx, ecx
  00059	39 2d 00 00 00
	00		 cmp	 DWORD PTR ?LastLeftButton@?1??FirePaint@UFireTexture@@AAEXHHK@Z@4HA, ebp
  0005f	0f 95 c1	 setne	 cl

; 875  : 
; 876  : 
; 877  : 	
; 878  : 	if( LeftChanged && LeftButton )

  00062	85 c9		 test	 ecx, ecx
  00064	89 4c 24 14	 mov	 DWORD PTR _LeftChanged$[esp+32], ecx
  00068	74 33		 je	 SHORT $L123890
  0006a	85 ed		 test	 ebp, ebp
  0006c	74 1f		 je	 SHORT $L132329

; 879  : 	{
; 880  : 		PenDownX = MouseX;
; 881  : 		PenDownY = MouseY;

  0006e	8a 54 24 28	 mov	 dl, BYTE PTR _MouseY$[esp+28]
  00072	88 97 12 05 00
	00		 mov	 BYTE PTR [edi+1298], dl

; 896  : 			{	
; 897  :             AddSpark( MouseX, MouseY);

  00078	8b 54 24 28	 mov	 edx, DWORD PTR _MouseY$[esp+28]
  0007c	52		 push	 edx
  0007d	53		 push	 ebx
  0007e	8b cf		 mov	 ecx, edi
  00080	88 9f 11 05 00
	00		 mov	 BYTE PTR [edi+1297], bl
  00086	e8 00 00 00 00	 call	 ?AddSpark@UFireTexture@@AAEXHH@Z ; UFireTexture::AddSpark

; 898  : 			}
; 899  :     }
; 900  :     else // LeftButton == 0

  0008b	eb 63		 jmp	 SHORT $L123896
$L132329:

; 882  : 	}
; 883  : 	if( LeftChanged && (!LeftButton) )
; 884  : 	{
; 885  : 		PenDownX=0;

  0008d	c6 87 11 05 00
	00 00		 mov	 BYTE PTR [edi+1297], 0

; 886  : 		PenDownY=0;

  00094	c6 87 12 05 00
	00 00		 mov	 BYTE PTR [edi+1298], 0

; 887  : 	}
; 888  :     
; 889  :     // Draws the kind of spark/linetype currently selected.
; 890  :     if( LeftButton )

  0009b	eb 46		 jmp	 SHORT $L123897
$L123890:
  0009d	85 ed		 test	 ebp, ebp
  0009f	74 3a		 je	 SHORT $L132330

; 891  :     {
; 892  :         if( !LeftChanged && PosChanged && ( SparkType<4 ))

  000a1	8b 4c 24 2c	 mov	 ecx, DWORD PTR _PosChanged$[esp+28]
  000a5	85 c9		 test	 ecx, ecx
  000a7	74 57		 je	 SHORT $L132328
  000a9	80 bf e0 00 00
	00 04		 cmp	 BYTE PTR [edi+224], 4
  000b0	73 11		 jae	 SHORT $L132326

; 893  :             DrawSparkLine( LastMouseX, LastMouseY, MouseX, MouseY, 1);

  000b2	8b 4c 24 28	 mov	 ecx, DWORD PTR _MouseY$[esp+28]
  000b6	6a 01		 push	 1
  000b8	51		 push	 ecx
  000b9	53		 push	 ebx
  000ba	52		 push	 edx
  000bb	50		 push	 eax
  000bc	8b cf		 mov	 ecx, edi
  000be	e8 00 00 00 00	 call	 ?DrawSparkLine@UFireTexture@@AAEXHHHHH@Z ; UFireTexture::DrawSparkLine
$L132326:

; 894  : 
; 895  :         if( LeftChanged || ( PosChanged && ( SparkType>=4 )  )  )

  000c3	80 bf e0 00 00
	00 04		 cmp	 BYTE PTR [edi+224], 4
  000ca	72 2c		 jb	 SHORT $L132327

; 896  : 			{	
; 897  :             AddSpark( MouseX, MouseY);

  000cc	8b 54 24 28	 mov	 edx, DWORD PTR _MouseY$[esp+28]
  000d0	52		 push	 edx
  000d1	53		 push	 ebx
  000d2	8b cf		 mov	 ecx, edi
  000d4	e8 00 00 00 00	 call	 ?AddSpark@UFireTexture@@AAEXHH@Z ; UFireTexture::AddSpark

; 898  : 			}
; 899  :     }
; 900  :     else // LeftButton == 0

  000d9	eb 15		 jmp	 SHORT $L123896
$L132330:

; 901  : 	{
; 902  : 		// Lightning bolt close on release + movement.
; 903  : 		if( LeftChanged || PosChanged )

  000db	8b 44 24 2c	 mov	 eax, DWORD PTR _PosChanged$[esp+28]
  000df	85 c0		 test	 eax, eax
  000e1	74 2e		 je	 SHORT $L123898
$L123897:

; 904  : 		{
; 905  : 			CloseSpark( MouseX, MouseY );

  000e3	8b 44 24 28	 mov	 eax, DWORD PTR _MouseY$[esp+28]
  000e7	50		 push	 eax
  000e8	53		 push	 ebx
  000e9	8b cf		 mov	 ecx, edi
  000eb	e8 00 00 00 00	 call	 ?CloseSpark@UFireTexture@@AAEXHH@Z ; UFireTexture::CloseSpark
$L123896:

; 906  : 		}
; 907  : 	}
; 908  : 
; 909  :     // Lightning bolt close on non-moving re-clicking.
; 910  : 	if( (!LeftChanged) && (! PosChanged) && LeftButton )

  000f0	8b 44 24 14	 mov	 eax, DWORD PTR _LeftChanged$[esp+32]
  000f4	85 c0		 test	 eax, eax
  000f6	75 19		 jne	 SHORT $L123898
$L132327:
  000f8	8b 44 24 2c	 mov	 eax, DWORD PTR _PosChanged$[esp+28]
  000fc	85 c0		 test	 eax, eax
  000fe	75 11		 jne	 SHORT $L123898
$L132328:
  00100	85 ed		 test	 ebp, ebp
  00102	74 0d		 je	 SHORT $L123898

; 911  : 	{
; 912  : 		CloseSpark( MouseX, MouseY );

  00104	8b 4c 24 28	 mov	 ecx, DWORD PTR _MouseY$[esp+28]
  00108	51		 push	 ecx
  00109	53		 push	 ebx
  0010a	8b cf		 mov	 ecx, edi
  0010c	e8 00 00 00 00	 call	 ?CloseSpark@UFireTexture@@AAEXHH@Z ; UFireTexture::CloseSpark
$L123898:

; 913  : 	}
; 914  : 
; 915  : 	// Delete any sparks within certain range of mouse cursor.
; 916  :     if( RightButton && (PosChanged || RightChanged) )

  00111	85 f6		 test	 esi, esi
  00113	74 7b		 je	 SHORT $L132320
  00115	8b 44 24 2c	 mov	 eax, DWORD PTR _PosChanged$[esp+28]
  00119	85 c0		 test	 eax, eax
  0011b	75 08		 jne	 SHORT $L123900
  0011d	8b 44 24 18	 mov	 eax, DWORD PTR _RightChanged$[esp+32]
  00121	85 c0		 test	 eax, eax
  00123	74 6b		 je	 SHORT $L132320
$L123900:

; 917  : 	{
; 918  :         DeleteSparks( MouseX, MouseY, DEL_RANGE );

  00125	8b af f8 00 00
	00		 mov	 ebp, DWORD PTR [edi+248]
  0012b	85 ed		 test	 ebp, ebp
  0012d	7e 5d		 jle	 SHORT $L132335
  0012f	33 d2		 xor	 edx, edx
  00131	85 ed		 test	 ebp, ebp
  00133	7e 57		 jle	 SHORT $L132335
$L132318:
  00135	8b 87 fc 00 00
	00		 mov	 eax, DWORD PTR [edi+252]
  0013b	33 c9		 xor	 ecx, ecx
  0013d	8a 4c d0 02	 mov	 cl, BYTE PTR [eax+edx*8+2]
  00141	8b f1		 mov	 esi, ecx
  00143	8b cb		 mov	 ecx, ebx
  00145	2b ce		 sub	 ecx, esi
  00147	79 02		 jns	 SHORT $L132303
  00149	f7 d9		 neg	 ecx
$L132303:
  0014b	8b 74 24 28	 mov	 esi, DWORD PTR _MouseY$[esp+28]
  0014f	33 db		 xor	 ebx, ebx
  00151	8a 5c d0 03	 mov	 bl, BYTE PTR [eax+edx*8+3]
  00155	2b f3		 sub	 esi, ebx
  00157	79 02		 jns	 SHORT $L132309
  00159	f7 de		 neg	 esi
$L132309:
  0015b	03 f1		 add	 esi, ecx
  0015d	83 fe 0c	 cmp	 esi, 12			; 0000000cH
  00160	7f 17		 jg	 SHORT $L132319
  00162	8d 4d ff	 lea	 ecx, DWORD PTR [ebp-1]
  00165	89 8f f8 00 00
	00		 mov	 DWORD PTR [edi+248], ecx
  0016b	8b 34 c8	 mov	 esi, DWORD PTR [eax+ecx*8]
  0016e	89 34 d0	 mov	 DWORD PTR [eax+edx*8], esi
  00171	8b 4c c8 04	 mov	 ecx, DWORD PTR [eax+ecx*8+4]
  00175	89 4c d0 04	 mov	 DWORD PTR [eax+edx*8+4], ecx
$L132319:
  00179	8b af f8 00 00
	00		 mov	 ebp, DWORD PTR [edi+248]
  0017f	8b 5c 24 24	 mov	 ebx, DWORD PTR _MouseX$[esp+28]
  00183	42		 inc	 edx
  00184	3b d5		 cmp	 edx, ebp
  00186	7c ad		 jl	 SHORT $L132318
  00188	8b 74 24 1c	 mov	 esi, DWORD PTR _RightButton$[esp+32]
$L132335:
  0018c	8b 6c 24 10	 mov	 ebp, DWORD PTR _LeftButton$[esp+32]
$L132320:

; 919  : 	}
; 920  : 
; 921  : 	// Remember.
; 922  :     LastMouseX      = MouseX;
; 923  :     LastMouseY      = MouseY;

  00190	8b 54 24 28	 mov	 edx, DWORD PTR _MouseY$[esp+28]
  00194	5f		 pop	 edi

; 924  :     LastLeftButton  = LeftButton;
; 925  :     LastRightButton = RightButton;

  00195	89 35 00 00 00
	00		 mov	 DWORD PTR ?LastRightButton@?1??FirePaint@UFireTexture@@AAEXHHK@Z@4HA, esi
  0019b	5e		 pop	 esi
  0019c	89 2d 00 00 00
	00		 mov	 DWORD PTR ?LastLeftButton@?1??FirePaint@UFireTexture@@AAEXHHK@Z@4HA, ebp
  001a2	5d		 pop	 ebp
  001a3	89 1d 00 00 00
	00		 mov	 DWORD PTR ?LastMouseX@?1??FirePaint@UFireTexture@@AAEXHHK@Z@4HA, ebx
  001a9	89 15 00 00 00
	00		 mov	 DWORD PTR ?LastMouseY@?1??FirePaint@UFireTexture@@AAEXHHK@Z@4HA, edx
  001af	5b		 pop	 ebx

; 926  : }

  001b0	83 c4 10	 add	 esp, 16			; 00000010H
  001b3	c2 0c 00	 ret	 12			; 0000000cH
?FirePaint@UFireTexture@@AAEXHHK@Z ENDP			; UFireTexture::FirePaint
_TEXT	ENDS
PUBLIC	?MoveSparkXY@UFireTexture@@AAEXPAVFSpark@@CC@Z	; UFireTexture::MoveSparkXY
; Function compile flags: /Ogty
;	COMDAT ?MoveSparkXY@UFireTexture@@AAEXPAVFSpark@@CC@Z
_TEXT	SEGMENT
_Spark$ = 8
_Xspeed$ = 12
_Yspeed$ = 16
?MoveSparkXY@UFireTexture@@AAEXPAVFSpark@@CC@Z PROC NEAR ; UFireTexture::MoveSparkXY, COMDAT
; _this$ = ecx

; 1018 : {

  00000	53		 push	 ebx

; 1019 :     if( Xspeed<0 ) // move left

  00001	8a 5c 24 0c	 mov	 bl, BYTE PTR _Xspeed$[esp]
  00005	84 db		 test	 bl, bl
  00007	56		 push	 esi
  00008	8b 74 24 0c	 mov	 esi, DWORD PTR _Spark$[esp+4]
  0000c	57		 push	 edi
  0000d	8b f9		 mov	 edi, ecx
  0000f	7d 51		 jge	 SHORT $L123907

; 1020 :     {
; 1021 :         if( (SpeedRand()&127) < -Xspeed )

  00011	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  00017	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  0001d	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00023	83 c2 04	 add	 edx, 4
  00026	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  0002c	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  00032	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  00038	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  0003e	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  00044	0f be cb	 movsx	 ecx, bl
  00047	f7 d9		 neg	 ecx
  00049	83 e0 7f	 and	 eax, 127		; 0000007fH
  0004c	3b c1		 cmp	 eax, ecx
  0004e	7d 5c		 jge	 SHORT $L123910

; 1022 :             Spark->X = UMask & (Spark->X-1);

  00050	8a 56 02	 mov	 dl, BYTE PTR [esi+2]
  00053	8a 87 c8 00 00
	00		 mov	 al, BYTE PTR [edi+200]
  00059	fe ca		 dec	 dl
  0005b	22 d0		 and	 dl, al
  0005d	88 56 02	 mov	 BYTE PTR [esi+2], dl

; 1023 :     }
; 1024 :     else // move right

  00060	eb 4a		 jmp	 SHORT $L123910
$L123907:

; 1025 :     {
; 1026 :         if( (SpeedRand()&127) <  Xspeed )

  00062	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  00068	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  0006e	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00074	83 c2 04	 add	 edx, 4
  00077	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  0007d	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  00083	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  00089	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  0008f	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  00095	83 e0 7f	 and	 eax, 127		; 0000007fH
  00098	3a c3		 cmp	 al, bl
  0009a	7d 10		 jge	 SHORT $L123910

; 1027 :             Spark->X = UMask & (Spark->X+1);

  0009c	8a 46 02	 mov	 al, BYTE PTR [esi+2]
  0009f	8a 8f c8 00 00
	00		 mov	 cl, BYTE PTR [edi+200]
  000a5	fe c0		 inc	 al
  000a7	22 c1		 and	 al, cl
  000a9	88 46 02	 mov	 BYTE PTR [esi+2], al
$L123910:

; 1028 :     }
; 1029 : 
; 1030 :     if( Yspeed<0 ) // move up

  000ac	8a 5c 24 18	 mov	 bl, BYTE PTR _Yspeed$[esp+8]
  000b0	84 db		 test	 bl, bl
  000b2	7d 55		 jge	 SHORT $L123911

; 1031 :     {
; 1032 :         if( (SpeedRand()&127) < -Yspeed )

  000b4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  000ba	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  000c0	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  000c6	83 c2 04	 add	 edx, 4
  000c9	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  000cf	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  000d5	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  000db	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  000e1	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  000e7	0f be cb	 movsx	 ecx, bl
  000ea	f7 d9		 neg	 ecx
  000ec	83 e0 7f	 and	 eax, 127		; 0000007fH
  000ef	3b c1		 cmp	 eax, ecx
  000f1	7d 60		 jge	 SHORT $L123914

; 1033 :             Spark->Y = VMask &(Spark->Y-1);

  000f3	8a 56 03	 mov	 dl, BYTE PTR [esi+3]
  000f6	8a 87 cc 00 00
	00		 mov	 al, BYTE PTR [edi+204]
  000fc	fe ca		 dec	 dl
  000fe	22 d0		 and	 dl, al
  00100	5f		 pop	 edi
  00101	88 56 03	 mov	 BYTE PTR [esi+3], dl
  00104	5e		 pop	 esi
  00105	5b		 pop	 ebx

; 1039 :     }
; 1040 : }

  00106	c2 0c 00	 ret	 12			; 0000000cH
$L123911:

; 1034 :     }
; 1035 :     else // move down
; 1036 :     {
; 1037 :         if( (SpeedRand()&127) <  Yspeed )

  00109	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  0010f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  00115	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  0011b	83 c2 04	 add	 edx, 4
  0011e	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  00124	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  0012a	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  00130	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  00136	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  0013c	83 e0 7f	 and	 eax, 127		; 0000007fH
  0013f	3a c3		 cmp	 al, bl
  00141	7d 10		 jge	 SHORT $L123914

; 1038 : 			Spark->Y = VMask &(Spark->Y+1);

  00143	8a 46 03	 mov	 al, BYTE PTR [esi+3]
  00146	8a 8f cc 00 00
	00		 mov	 cl, BYTE PTR [edi+204]
  0014c	fe c0		 inc	 al
  0014e	22 c1		 and	 al, cl
  00150	88 46 03	 mov	 BYTE PTR [esi+3], al
$L123914:
  00153	5f		 pop	 edi
  00154	5e		 pop	 esi
  00155	5b		 pop	 ebx

; 1039 :     }
; 1040 : }

  00156	c2 0c 00	 ret	 12			; 0000000cH
?MoveSparkXY@UFireTexture@@AAEXPAVFSpark@@CC@Z ENDP	; UFireTexture::MoveSparkXY
_TEXT	ENDS
PUBLIC	?MoveSpark@UFireTexture@@AAEXPAVFSpark@@@Z	; UFireTexture::MoveSpark
; Function compile flags: /Ogty
;	COMDAT ?MoveSpark@UFireTexture@@AAEXPAVFSpark@@@Z
_TEXT	SEGMENT
_Spark$ = 8
?MoveSpark@UFireTexture@@AAEXPAVFSpark@@@Z PROC NEAR	; UFireTexture::MoveSpark, COMDAT
; _this$ = ecx

; 1128 : {

  00000	56		 push	 esi

; 1129 :     if( (SBYTE)Spark->ByteA<0 ) // move left

  00001	8b 74 24 08	 mov	 esi, DWORD PTR _Spark$[esp]
  00005	8a 46 04	 mov	 al, BYTE PTR [esi+4]
  00008	84 c0		 test	 al, al
  0000a	57		 push	 edi
  0000b	8b f9		 mov	 edi, ecx
  0000d	7d 52		 jge	 SHORT $L123920

; 1130 :     {
; 1131 :         if( (SpeedRand()&127) < -(SBYTE)Spark->ByteA )

  0000f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  00015	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  0001b	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00021	83 c2 04	 add	 edx, 4
  00024	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  0002a	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  00030	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  00036	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  0003c	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  00042	0f be 4e 04	 movsx	 ecx, BYTE PTR [esi+4]
  00046	f7 d9		 neg	 ecx
  00048	83 e0 7f	 and	 eax, 127		; 0000007fH
  0004b	3b c1		 cmp	 eax, ecx
  0004d	7d 5f		 jge	 SHORT $L123925

; 1132 :             Spark->X = UMask & (Spark->X-1);

  0004f	8a 56 02	 mov	 dl, BYTE PTR [esi+2]
  00052	8a 87 c8 00 00
	00		 mov	 al, BYTE PTR [edi+200]
  00058	fe ca		 dec	 dl
  0005a	22 d0		 and	 dl, al
  0005c	88 56 02	 mov	 BYTE PTR [esi+2], dl

; 1133 :     }
; 1134 :     else // move right

  0005f	eb 4d		 jmp	 SHORT $L123925
$L123920:

; 1135 :     {
; 1136 :         if( (SpeedRand()&127) <  (SBYTE)Spark->ByteA )

  00061	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  00067	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  0006d	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00073	83 c2 04	 add	 edx, 4
  00076	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  0007c	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  00082	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  00088	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  0008e	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  00094	8a 4e 04	 mov	 cl, BYTE PTR [esi+4]
  00097	83 e0 7f	 and	 eax, 127		; 0000007fH
  0009a	3a c1		 cmp	 al, cl
  0009c	7d 10		 jge	 SHORT $L123925

; 1137 :             Spark->X = UMask & (Spark->X+1);

  0009e	8a 46 02	 mov	 al, BYTE PTR [esi+2]
  000a1	8a 8f c8 00 00
	00		 mov	 cl, BYTE PTR [edi+200]
  000a7	fe c0		 inc	 al
  000a9	22 c1		 and	 al, cl
  000ab	88 46 02	 mov	 BYTE PTR [esi+2], al
$L123925:

; 1138 :     }
; 1139 : 
; 1140 :     if( (SBYTE)Spark->ByteB<0 ) // move up

  000ae	8a 46 05	 mov	 al, BYTE PTR [esi+5]
  000b1	84 c0		 test	 al, al
  000b3	7d 55		 jge	 SHORT $L123927

; 1141 :     {
; 1142 :         if( (SpeedRand()&127) < -(SBYTE)Spark->ByteB )

  000b5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  000bb	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  000c1	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  000c7	83 c2 04	 add	 edx, 4
  000ca	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  000d0	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  000d6	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  000dc	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  000e2	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  000e8	0f be 4e 05	 movsx	 ecx, BYTE PTR [esi+5]
  000ec	f7 d9		 neg	 ecx
  000ee	83 e0 7f	 and	 eax, 127		; 0000007fH
  000f1	3b c1		 cmp	 eax, ecx
  000f3	7d 62		 jge	 SHORT $L123932

; 1143 :             Spark->Y = VMask &(Spark->Y-1);

  000f5	8a 56 03	 mov	 dl, BYTE PTR [esi+3]
  000f8	8a 87 cc 00 00
	00		 mov	 al, BYTE PTR [edi+204]
  000fe	fe ca		 dec	 dl
  00100	22 d0		 and	 dl, al
  00102	5f		 pop	 edi
  00103	88 56 03	 mov	 BYTE PTR [esi+3], dl
  00106	5e		 pop	 esi

; 1149 :     }
; 1150 : }

  00107	c2 04 00	 ret	 4
$L123927:

; 1144 :     }
; 1145 :     else // move down
; 1146 :     {
; 1147 :         if( (SpeedRand()&127) <  (SBYTE)Spark->ByteB )

  0010a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  00110	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  00116	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  0011c	83 c2 04	 add	 edx, 4
  0011f	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  00125	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  0012b	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  00131	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  00137	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  0013d	8a 4e 05	 mov	 cl, BYTE PTR [esi+5]
  00140	83 e0 7f	 and	 eax, 127		; 0000007fH
  00143	3a c1		 cmp	 al, cl
  00145	7d 10		 jge	 SHORT $L123932

; 1148 : 			Spark->Y = VMask &(Spark->Y+1);

  00147	8a 46 03	 mov	 al, BYTE PTR [esi+3]
  0014a	8a 8f cc 00 00
	00		 mov	 cl, BYTE PTR [edi+204]
  00150	fe c0		 inc	 al
  00152	22 c1		 and	 al, cl
  00154	88 46 03	 mov	 BYTE PTR [esi+3], al
$L123932:
  00157	5f		 pop	 edi
  00158	5e		 pop	 esi

; 1149 :     }
; 1150 : }

  00159	c2 04 00	 ret	 4
?MoveSpark@UFireTexture@@AAEXPAVFSpark@@@Z ENDP		; UFireTexture::MoveSpark
_TEXT	ENDS
PUBLIC	?MoveSparkAngle@UFireTexture@@AAEXPAVFSpark@@E@Z ; UFireTexture::MoveSparkAngle
; Function compile flags: /Ogty
;	COMDAT ?MoveSparkAngle@UFireTexture@@AAEXPAVFSpark@@E@Z
_TEXT	SEGMENT
_Spark$ = 8
_Angle$ = 12
_Ydir$ = 12
?MoveSparkAngle@UFireTexture@@AAEXPAVFSpark@@E@Z PROC NEAR ; UFireTexture::MoveSparkAngle, COMDAT
; _this$ = ecx

; 1157 : 
; 1158 : 	SBYTE Xdir = -127 + (SBYTE)PhaseTable[ Angle ];

  00000	8b 44 24 08	 mov	 eax, DWORD PTR _Angle$[esp-4]
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	8b f1		 mov	 esi, ecx
  00008	8b c8		 mov	 ecx, eax

; 1159 :     SBYTE Ydir = -127 + (SBYTE)PhaseTable[ BYTE(Angle+64 ) ];

  0000a	04 40		 add	 al, 64			; 00000040H
  0000c	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00012	8a 99 00 00 00
	00		 mov	 bl, BYTE PTR _PhaseTable[ecx]
  00018	80 eb 7f	 sub	 bl, 127			; 0000007fH
  0001b	57		 push	 edi

; 1160 : 
; 1161 :     if( (SBYTE)Xdir<0 ) 

  0001c	8b 7c 24 10	 mov	 edi, DWORD PTR _Spark$[esp+8]
  00020	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00025	8a 80 00 00 00
	00		 mov	 al, BYTE PTR _PhaseTable[eax]
  0002b	2c 7f		 sub	 al, 127			; 0000007fH
  0002d	84 db		 test	 bl, bl
  0002f	88 44 24 14	 mov	 BYTE PTR _Ydir$[esp+8], al
  00033	7d 51		 jge	 SHORT $L123943

; 1162 :     {
; 1163 : 		// Move left.
; 1164 :         if( (SpeedRand()&127) < -(SBYTE)Xdir )

  00035	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  0003b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  00041	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00047	83 c2 04	 add	 edx, 4
  0004a	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  00050	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  00056	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  0005c	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  00062	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  00068	0f be d3	 movsx	 edx, bl
  0006b	f7 da		 neg	 edx
  0006d	83 e0 7f	 and	 eax, 127		; 0000007fH
  00070	3b c2		 cmp	 eax, edx
  00072	7d 5c		 jge	 SHORT $L123948

; 1165 :              Spark->X = UMask & ( Spark->X-1);

  00074	8a 47 02	 mov	 al, BYTE PTR [edi+2]
  00077	8a 8e c8 00 00
	00		 mov	 cl, BYTE PTR [esi+200]
  0007d	fe c8		 dec	 al
  0007f	22 c1		 and	 al, cl
  00081	88 47 02	 mov	 BYTE PTR [edi+2], al

; 1166 :     }
; 1167 :     else 

  00084	eb 4a		 jmp	 SHORT $L123948
$L123943:

; 1168 :     {
; 1169 : 		// Move right.
; 1170 :         if( (SpeedRand()&127) <  (SBYTE)Xdir )

  00086	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  0008c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  00092	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00098	83 c2 04	 add	 edx, 4
  0009b	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  000a1	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  000a7	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  000ad	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  000b3	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  000b9	83 e0 7f	 and	 eax, 127		; 0000007fH
  000bc	3a c3		 cmp	 al, bl
  000be	7d 10		 jge	 SHORT $L123948

; 1171 :              Spark->X = UMask & ( Spark->X+1);

  000c0	8a 4f 02	 mov	 cl, BYTE PTR [edi+2]
  000c3	8a 86 c8 00 00
	00		 mov	 al, BYTE PTR [esi+200]
  000c9	fe c1		 inc	 cl
  000cb	22 c8		 and	 cl, al
  000cd	88 4f 02	 mov	 BYTE PTR [edi+2], cl
$L123948:

; 1172 :     }
; 1173 : 
; 1174 :     if( (SBYTE)Ydir<0 ) 

  000d0	8a 5c 24 14	 mov	 bl, BYTE PTR _Ydir$[esp+8]
  000d4	84 db		 test	 bl, bl
  000d6	7d 55		 jge	 SHORT $L123950

; 1175 :     {
; 1176 : 		// Move up.
; 1177 :         if( (SpeedRand()&127) < -(SBYTE)Ydir )

  000d8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  000de	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  000e4	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  000ea	83 c2 04	 add	 edx, 4
  000ed	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  000f3	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  000f9	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  000ff	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  00105	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  0010b	0f be d3	 movsx	 edx, bl
  0010e	f7 da		 neg	 edx
  00110	83 e0 7f	 and	 eax, 127		; 0000007fH
  00113	3b c2		 cmp	 eax, edx
  00115	7d 60		 jge	 SHORT $L123955

; 1178 :              Spark->Y = VMask &( Spark->Y-1);

  00117	8a 47 03	 mov	 al, BYTE PTR [edi+3]
  0011a	8a 8e cc 00 00
	00		 mov	 cl, BYTE PTR [esi+204]
  00120	fe c8		 dec	 al
  00122	22 c8		 and	 cl, al
  00124	88 4f 03	 mov	 BYTE PTR [edi+3], cl
  00127	5f		 pop	 edi
  00128	5e		 pop	 esi
  00129	5b		 pop	 ebx

; 1185 :     }
; 1186 : }

  0012a	c2 08 00	 ret	 8
$L123950:

; 1179 :     }
; 1180 :     else 
; 1181 :     {
; 1182 : 		// Move down.
; 1183 :         if( (SpeedRand()&127) <  (SBYTE)Ydir )

  0012d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  00133	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  00139	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  0013f	83 c2 04	 add	 edx, 4
  00142	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  00148	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  0014e	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  00154	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  0015a	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  00160	83 e0 7f	 and	 eax, 127		; 0000007fH
  00163	3a c3		 cmp	 al, bl
  00165	7d 10		 jge	 SHORT $L123955

; 1184 : 			 Spark->Y = VMask &( Spark->Y+1);

  00167	8a 57 03	 mov	 dl, BYTE PTR [edi+3]
  0016a	8a 86 cc 00 00
	00		 mov	 al, BYTE PTR [esi+204]
  00170	fe c2		 inc	 dl
  00172	22 c2		 and	 al, dl
  00174	88 47 03	 mov	 BYTE PTR [edi+3], al
$L123955:
  00177	5f		 pop	 edi
  00178	5e		 pop	 esi
  00179	5b		 pop	 ebx

; 1185 :     }
; 1186 : }

  0017a	c2 08 00	 ret	 8
?MoveSparkAngle@UFireTexture@@AAEXPAVFSpark@@E@Z ENDP	; UFireTexture::MoveSparkAngle
_TEXT	ENDS
PUBLIC	?MoveSparkTwo@UFireTexture@@AAEXPAVFSpark@@@Z	; UFireTexture::MoveSparkTwo
; Function compile flags: /Ogty
;	COMDAT ?MoveSparkTwo@UFireTexture@@AAEXPAVFSpark@@@Z
_TEXT	SEGMENT
_Spark$ = 8
?MoveSparkTwo@UFireTexture@@AAEXPAVFSpark@@@Z PROC NEAR	; UFireTexture::MoveSparkTwo, COMDAT
; _this$ = ecx

; 1190 : {    

  00000	56		 push	 esi

; 1191 :     if( (SBYTE)Spark->ByteA<0 ) 

  00001	8b 74 24 08	 mov	 esi, DWORD PTR _Spark$[esp]
  00005	8a 46 04	 mov	 al, BYTE PTR [esi+4]
  00008	84 c0		 test	 al, al
  0000a	57		 push	 edi
  0000b	8b f9		 mov	 edi, ecx
  0000d	7d 52		 jge	 SHORT $L123961

; 1192 :     {
; 1193 : 		// Negative update.
; 1194 :         if( (SpeedRand()&127) < -(SBYTE)Spark->ByteA )

  0000f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  00015	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  0001b	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00021	83 c2 04	 add	 edx, 4
  00024	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  0002a	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  00030	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  00036	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  0003c	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  00042	0f be 4e 04	 movsx	 ecx, BYTE PTR [esi+4]
  00046	f7 d9		 neg	 ecx
  00048	83 e0 7f	 and	 eax, 127		; 0000007fH
  0004b	3b c1		 cmp	 eax, ecx
  0004d	7d 5f		 jge	 SHORT $L123966

; 1195 :             Spark->X = UMask & (Spark->X-1);

  0004f	8a 56 02	 mov	 dl, BYTE PTR [esi+2]
  00052	8a 87 c8 00 00
	00		 mov	 al, BYTE PTR [edi+200]
  00058	fe ca		 dec	 dl
  0005a	22 d0		 and	 dl, al
  0005c	88 56 02	 mov	 BYTE PTR [esi+2], dl

; 1196 :     }
; 1197 :     else    

  0005f	eb 4d		 jmp	 SHORT $L123966
$L123961:

; 1198 :     {
; 1199 : 		// Positive update.
; 1200 :         if( (SpeedRand()&127) <  (SBYTE)Spark->ByteA )

  00061	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  00067	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  0006d	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00073	83 c2 04	 add	 edx, 4
  00076	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  0007c	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  00082	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  00088	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  0008e	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  00094	8a 4e 04	 mov	 cl, BYTE PTR [esi+4]
  00097	83 e0 7f	 and	 eax, 127		; 0000007fH
  0009a	3a c1		 cmp	 al, cl
  0009c	7d 10		 jge	 SHORT $L123966

; 1201 :             Spark->X = UMask & (Spark->X+1);

  0009e	8a 46 02	 mov	 al, BYTE PTR [esi+2]
  000a1	8a 8f c8 00 00
	00		 mov	 cl, BYTE PTR [edi+200]
  000a7	fe c0		 inc	 al
  000a9	22 c1		 and	 al, cl
  000ab	88 46 02	 mov	 BYTE PTR [esi+2], al
$L123966:

; 1202 :     }
; 1203 :     Spark->Y = VMask &(Spark->Y-2);

  000ae	8a 4e 03	 mov	 cl, BYTE PTR [esi+3]
  000b1	8a 87 cc 00 00
	00		 mov	 al, BYTE PTR [edi+204]
  000b7	80 e9 02	 sub	 cl, 2
  000ba	22 c8		 and	 cl, al
  000bc	5f		 pop	 edi
  000bd	88 4e 03	 mov	 BYTE PTR [esi+3], cl
  000c0	5e		 pop	 esi

; 1204 : }

  000c1	c2 04 00	 ret	 4
?MoveSparkTwo@UFireTexture@@AAEXPAVFSpark@@@Z ENDP	; UFireTexture::MoveSparkTwo
_TEXT	ENDS
PUBLIC	?DrawFlashRamp@UFireTexture@@AAEXULineSeg@@EE@Z	; UFireTexture::DrawFlashRamp
; Function compile flags: /Ogty
;	COMDAT ?DrawFlashRamp@UFireTexture@@AAEXULineSeg@@EE@Z
_TEXT	SEGMENT
_LL$ = 8
_Color1$ = 12
_Color2$ = 16
_FlashArray$ = -256
_Xstep$ = -268
_Ystep$ = -276
_RealYlen$ = -260
_RealXlen$ = -280
_MajorLen$ = -288
_FlashPos$ = -284
_ColorSlope$ = -272
_FlashBias$123997 = -292
_FlashBias$124004 = -288
$T132421 = -292
?DrawFlashRamp@UFireTexture@@AAEXULineSeg@@EE@Z PROC NEAR ; UFireTexture::DrawFlashRamp, COMDAT
; _this$ = ecx

; 1209 : {

  00000	81 ec 24 01 00
	00		 sub	 esp, 292		; 00000124H
  00006	53		 push	 ebx

; 1210 :     DWORD	SparkDest;
; 1211 :     BYTE	FlashArray[256];
; 1212 : 	INT  Xstep,Ystep,RealYlen,RealXlen;
; 1213 : 
; 1214 : 	// Make writing cache-friendlier by drawing approximately to the right or downwards.
; 1215 : 
; 1216 : 	if( ( ( LL.Ylen & 1 ) && ((LL.Ylen*2) >= LL.Xlen ) ) || 
; 1217 : 	     ( ( LL.Xlen & 1 ) && ((LL.Ylen*2) <  LL.Xlen ) ) )

  00007	8a 9c 24 2f 01
	00 00		 mov	 bl, BYTE PTR _LL$[esp+295]
  0000e	80 e3 01	 and	 bl, 1
  00011	55		 push	 ebp
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	8b f1		 mov	 esi, ecx
  00016	74 20		 je	 SHORT $L123981
  00018	8b 8c 24 3b 01
	00 00		 mov	 ecx, DWORD PTR _LL$[esp+307]
  0001f	8b 84 24 3a 01
	00 00		 mov	 eax, DWORD PTR _LL$[esp+306]
  00026	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0002c	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00031	8d 14 09	 lea	 edx, DWORD PTR [ecx+ecx]
  00034	3b d0		 cmp	 edx, eax
  00036	7d 32		 jge	 SHORT $L132444
$L123981:
  00038	8a 94 24 3a 01
	00 00		 mov	 dl, BYTE PTR _LL$[esp+306]
  0003f	f6 c2 01	 test	 dl, 1
  00042	0f 84 93 00 00
	00		 je	 $L123979
  00048	8b 8c 24 3b 01
	00 00		 mov	 ecx, DWORD PTR _LL$[esp+307]
  0004f	8b 84 24 3a 01
	00 00		 mov	 eax, DWORD PTR _LL$[esp+306]
  00056	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0005c	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00061	8d 3c 09	 lea	 edi, DWORD PTR [ecx+ecx]
  00064	3b f8		 cmp	 edi, eax
  00066	7d 73		 jge	 SHORT $L123979
  00068	eb 07		 jmp	 SHORT $L123980
$L132444:
  0006a	8a 94 24 3a 01
	00 00		 mov	 dl, BYTE PTR _LL$[esp+306]
$L123980:

; 1218 :     {
; 1219 : 		LL.Xpos = LL.Xpos + ((LL.Xlen & 1)? -LL.Xlen:LL.Xlen );

  00071	f6 c2 01	 test	 dl, 1
  00074	74 02		 je	 SHORT $L132413
  00076	f7 d8		 neg	 eax
$L132413:
  00078	8a 94 24 38 01
	00 00		 mov	 dl, BYTE PTR _LL$[esp+304]
  0007f	02 d0		 add	 dl, al

; 1220 : 		LL.Ypos = LL.Ypos + ((LL.Ylen & 1)? -LL.Ylen:LL.Ylen );

  00081	84 db		 test	 bl, bl
  00083	88 94 24 38 01
	00 00		 mov	 BYTE PTR _LL$[esp+304], dl
  0008a	74 02		 je	 SHORT $L132415
  0008c	f7 d9		 neg	 ecx
$L132415:
  0008e	8a 94 24 39 01
	00 00		 mov	 dl, BYTE PTR _LL$[esp+305]

; 1221 : 		LL.Xlen ^=1;
; 1222 : 		LL.Ylen ^=1;	

  00095	8a 84 24 3b 01
	00 00		 mov	 al, BYTE PTR _LL$[esp+307]
  0009c	02 d1		 add	 dl, cl

; 1223 : 		BYTE Tcol = Color1;
; 1224 : 		Color1 = Color2;

  0009e	8a 8c 24 40 01
	00 00		 mov	 cl, BYTE PTR _Color2$[esp+304]
  000a5	88 94 24 39 01
	00 00		 mov	 BYTE PTR _LL$[esp+305], dl
  000ac	8a 94 24 3a 01
	00 00		 mov	 dl, BYTE PTR _LL$[esp+306]
  000b3	80 f2 01	 xor	 dl, 1
  000b6	34 01		 xor	 al, 1
  000b8	88 84 24 3b 01
	00 00		 mov	 BYTE PTR _LL$[esp+307], al
  000bf	8a 84 24 3c 01
	00 00		 mov	 al, BYTE PTR _Color1$[esp+304]
  000c6	88 94 24 3a 01
	00 00		 mov	 BYTE PTR _LL$[esp+306], dl
  000cd	88 8c 24 3c 01
	00 00		 mov	 BYTE PTR _Color1$[esp+304], cl

; 1225 : 		Color2 = Tcol;

  000d4	88 84 24 40 01
	00 00		 mov	 BYTE PTR _Color2$[esp+304], al
$L123979:

; 1226 :     }
; 1227 : 
; 1228 : 	INT MajorLen = 1 | ( (LL.Xlen >= LL.Ylen) ?  LL.Xlen : LL.Ylen );

  000db	8a 84 24 3b 01
	00 00		 mov	 al, BYTE PTR _LL$[esp+307]
  000e2	3a d0		 cmp	 dl, al
  000e4	72 02		 jb	 SHORT $L132417
  000e6	8a c2		 mov	 al, dl
$L132417:
  000e8	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000ed	83 c8 01	 or	 eax, 1

; 1229 : 
; 1230 :     // Fill array for the specific length.
; 1231 :     INT  FlashPos=0;

  000f0	bb 00 00 00 00	 mov	 ebx, 0
  000f5	8b e8		 mov	 ebp, eax
  000f7	89 6c 24 14	 mov	 DWORD PTR _MajorLen$[esp+308], ebp
  000fb	89 5c 24 18	 mov	 DWORD PTR _FlashPos$[esp+308], ebx

; 1232 :     for( INT Flash=0; Flash<MajorLen; Flash++ )

  000ff	8b fb		 mov	 edi, ebx
  00101	7e 50		 jle	 SHORT $L123988
$L123986:

; 1233 :     {
; 1234 :         FlashPos += ( FlashArray[Flash] = SpeedRand() );

  00103	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  00109	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  0010f	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00115	83 c2 04	 add	 edx, 4
  00118	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  0011e	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  00124	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  0012a	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  00130	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  00136	88 44 24 10	 mov	 BYTE PTR $T132421[esp+308], al
  0013a	8b 54 24 10	 mov	 edx, DWORD PTR $T132421[esp+308]
  0013e	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00144	03 da		 add	 ebx, edx
  00146	88 44 3c 34	 mov	 BYTE PTR _FlashArray$[esp+edi+308], al
  0014a	47		 inc	 edi
  0014b	3b fd		 cmp	 edi, ebp
  0014d	7c b4		 jl	 SHORT $L123986
  0014f	89 5c 24 18	 mov	 DWORD PTR _FlashPos$[esp+308], ebx
$L123988:

; 1235 :     }
; 1236 : 
; 1237 : 	if( LL.Ylen & 1 )
; 1238 : 	{
; 1239 : 		Ystep = -1;
; 1240 : 		RealYlen = -LL.Ylen;

  00153	8b 9c 24 3b 01
	00 00		 mov	 ebx, DWORD PTR _LL$[esp+307]
  0015a	8a 84 24 3b 01
	00 00		 mov	 al, BYTE PTR _LL$[esp+307]
  00161	81 e3 ff 00 00
	00		 and	 ebx, 255		; 000000ffH
  00167	83 c9 ff	 or	 ecx, -1
  0016a	a8 01		 test	 al, 1
  0016c	89 5c 24 10	 mov	 DWORD PTR -292+[esp+308], ebx
  00170	74 0e		 je	 SHORT $L123989
  00172	8b c3		 mov	 eax, ebx
  00174	f7 d8		 neg	 eax
  00176	89 4c 24 20	 mov	 DWORD PTR _Ystep$[esp+308], ecx
  0017a	89 44 24 30	 mov	 DWORD PTR _RealYlen$[esp+308], eax

; 1241 : 	}
; 1242 : 	else

  0017e	eb 0c		 jmp	 SHORT $L123990
$L123989:

; 1243 : 	{
; 1244 : 		Ystep = 1;

  00180	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR _Ystep$[esp+308], 1

; 1245 : 		RealYlen =  LL.Ylen;

  00188	89 5c 24 30	 mov	 DWORD PTR _RealYlen$[esp+308], ebx
$L123990:

; 1246 : 	}
; 1247 : 
; 1248 : 
; 1249 : 	if( LL.Xlen & 1 )

  0018c	f6 84 24 3a 01
	00 00 01	 test	 BYTE PTR _LL$[esp+306], 1
  00194	74 1b		 je	 SHORT $L123991

; 1250 : 	{
; 1251 : 		Xstep = -1;

  00196	89 4c 24 28	 mov	 DWORD PTR _Xstep$[esp+308], ecx

; 1252 : 		RealXlen = -LL.Xlen;

  0019a	8b 8c 24 3a 01
	00 00		 mov	 ecx, DWORD PTR _LL$[esp+306]
  001a1	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  001a7	8b c1		 mov	 eax, ecx
  001a9	f7 d8		 neg	 eax
  001ab	89 44 24 1c	 mov	 DWORD PTR _RealXlen$[esp+308], eax

; 1253 : 	}
; 1254 : 	else

  001af	eb 19		 jmp	 SHORT $L132446
$L123991:

; 1255 : 	{
; 1256 : 		Xstep = 1;
; 1257 : 		RealXlen =  LL.Xlen;

  001b1	8b 8c 24 3a 01
	00 00		 mov	 ecx, DWORD PTR _LL$[esp+306]
  001b8	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  001be	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR _Xstep$[esp+308], 1
  001c6	89 4c 24 1c	 mov	 DWORD PTR _RealXlen$[esp+308], ecx
$L132446:

; 1258 : 	}
; 1259 : 
; 1260 : 
; 1261 : 	//  Setup color ramp.
; 1262 : 	INT RampColor  =  Color1 << 23 ;

  001ca	8b 94 24 3c 01
	00 00		 mov	 edx, DWORD PTR _Color1$[esp+304]

; 1263 : 	INT ColorSlope =  ((Color2 - Color1 ) << 23 ) / MajorLen;

  001d1	8b 84 24 40 01
	00 00		 mov	 eax, DWORD PTR _Color2$[esp+304]
  001d8	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  001de	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  001e3	2b c2		 sub	 eax, edx
  001e5	c1 e0 17	 shl	 eax, 23			; 00000017H
  001e8	8b fa		 mov	 edi, edx
  001ea	99		 cdq
  001eb	f7 fd		 idiv	 ebp

; 1264 :     
; 1265 : 
; 1266 :     if( LL.Xlen>=LL.Ylen )

  001ed	8a 94 24 3a 01
	00 00		 mov	 dl, BYTE PTR _LL$[esp+306]
  001f4	c1 e7 17	 shl	 edi, 23			; 00000017H
  001f7	89 4c 24 2c	 mov	 DWORD PTR -264+[esp+308], ecx
  001fb	89 44 24 24	 mov	 DWORD PTR _ColorSlope$[esp+308], eax
  001ff	8a 84 24 3b 01
	00 00		 mov	 al, BYTE PTR _LL$[esp+307]
  00206	3a d0		 cmp	 dl, al
  00208	0f 82 a8 00 00
	00		 jb	 $L123995

; 1267 :     {
; 1268 :         // X major axis.
; 1269 :         // calculate BIAS:
; 1270 :         // Bias = (Ylen << 6) - FlashPos;
; 1271 : 
; 1272 :         INT  Ypoz = (LL.Ypos << 6);
; 1273 :         INT  FlashBias = (( (INT)RealYlen << 6) - FlashPos) / MajorLen;  

  0020e	8b 44 24 30	 mov	 eax, DWORD PTR _RealYlen$[esp+308]
  00212	8b 5c 24 18	 mov	 ebx, DWORD PTR _FlashPos$[esp+308]
  00216	c1 e0 06	 shl	 eax, 6
  00219	2b c3		 sub	 eax, ebx
  0021b	99		 cdq
  0021c	f7 7c 24 14	 idiv	 DWORD PTR _MajorLen$[esp+308]
  00220	8b ac 24 39 01
	00 00		 mov	 ebp, DWORD PTR _LL$[esp+305]
  00227	81 e5 ff 00 00
	00		 and	 ebp, 255		; 000000ffH
  0022d	c1 e5 06	 shl	 ebp, 6
  00230	89 44 24 10	 mov	 DWORD PTR _FlashBias$123997[esp+308], eax

; 1274 : 
; 1275 :         //
; 1276 :         for( Flash=0; Flash<LL.Xlen; Flash++ )

  00234	33 c0		 xor	 eax, eax
  00236	85 c9		 test	 ecx, ecx
  00238	0f 8e 0d 01 00
	00		 jle	 $L124008

; 1301 : 		}
; 1302 :     }
; 1303 : }

  0023e	8b ff		 npad	 2
$L123999:

; 1277 :         {
; 1278 : 			Ypoz += FlashArray[Flash] + FlashBias;

  00240	8b 5c 24 10	 mov	 ebx, DWORD PTR _FlashBias$123997[esp+308]
  00244	33 c9		 xor	 ecx, ecx
  00246	8a 4c 04 34	 mov	 cl, BYTE PTR _FlashArray$[esp+eax+308]
  0024a	03 cb		 add	 ecx, ebx

; 1279 : 			SparkDest = (((Ypoz >> 6) & VMask) << UBits) + (LL.Xpos & UMask);

  0024c	8b 9e c8 00 00
	00		 mov	 ebx, DWORD PTR [esi+200]
  00252	03 e9		 add	 ebp, ecx
  00254	8b 8e cc 00 00
	00		 mov	 ecx, DWORD PTR [esi+204]
  0025a	8b d5		 mov	 edx, ebp
  0025c	c1 fa 06	 sar	 edx, 6
  0025f	23 d1		 and	 edx, ecx
  00261	8a 4e 30	 mov	 cl, BYTE PTR [esi+48]
  00264	d3 e2		 shl	 edx, cl
  00266	8b 8c 24 38 01
	00 00		 mov	 ecx, DWORD PTR _LL$[esp+304]
  0026d	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00273	23 cb		 and	 ecx, ebx

; 1280 : 			LL.Xpos += Xstep;   // increase X

  00275	8a 9c 24 38 01
	00 00		 mov	 bl, BYTE PTR _LL$[esp+304]
  0027c	03 d1		 add	 edx, ecx
  0027e	8a 4c 24 28	 mov	 cl, BYTE PTR _Xstep$[esp+308]
  00282	02 d9		 add	 bl, cl

; 1281 : 			Mips(0).DataArray(SparkDest) = ( (RampColor += ColorSlope) >> 23 );

  00284	03 7c 24 24	 add	 edi, DWORD PTR _ColorSlope$[esp+308]
  00288	88 9c 24 38 01
	00 00		 mov	 BYTE PTR _LL$[esp+304], bl
  0028f	8b 9e a8 00 00
	00		 mov	 ebx, DWORD PTR [esi+168]
  00295	8b 5b 1c	 mov	 ebx, DWORD PTR [ebx+28]
  00298	8b cf		 mov	 ecx, edi
  0029a	c1 f9 17	 sar	 ecx, 23			; 00000017H
  0029d	88 0c 1a	 mov	 BYTE PTR [edx+ebx], cl
  002a0	8b 4c 24 2c	 mov	 ecx, DWORD PTR -264+[esp+308]
  002a4	40		 inc	 eax
  002a5	3b c1		 cmp	 eax, ecx
  002a7	7c 97		 jl	 SHORT $L123999
  002a9	5f		 pop	 edi
  002aa	5e		 pop	 esi
  002ab	5d		 pop	 ebp
  002ac	5b		 pop	 ebx

; 1301 : 		}
; 1302 :     }
; 1303 : }

  002ad	81 c4 24 01 00
	00		 add	 esp, 292		; 00000124H
  002b3	c2 0c 00	 ret	 12			; 0000000cH
$L123995:

; 1282 :         }
; 1283 : 
; 1284 :     }
; 1285 :     else
; 1286 :     {
; 1287 :         //  Y major axis.
; 1288 :         //  calculate BIAS:
; 1289 :         //  Bias = (Xlen << 6) - FlashPos;
; 1290 : 
; 1291 :         INT  Xpoz = (LL.Xpos << 6);
; 1292 :         INT  FlashBias = (( (INT)RealXlen << 6) - FlashPos) / MajorLen;   

  002b6	8b 44 24 1c	 mov	 eax, DWORD PTR _RealXlen$[esp+308]
  002ba	8b 54 24 18	 mov	 edx, DWORD PTR _FlashPos$[esp+308]
  002be	c1 e0 06	 shl	 eax, 6
  002c1	2b c2		 sub	 eax, edx
  002c3	99		 cdq
  002c4	f7 7c 24 14	 idiv	 DWORD PTR _MajorLen$[esp+308]
  002c8	8b ac 24 38 01
	00 00		 mov	 ebp, DWORD PTR _LL$[esp+304]
  002cf	81 e5 ff 00 00
	00		 and	 ebp, 255		; 000000ffH
  002d5	c1 e5 06	 shl	 ebp, 6
  002d8	89 44 24 14	 mov	 DWORD PTR _FlashBias$124004[esp+308], eax

; 1293 : 
; 1294 :         //
; 1295 :         for( Flash=0; Flash<LL.Ylen; Flash++ )

  002dc	33 c0		 xor	 eax, eax
  002de	85 db		 test	 ebx, ebx
  002e0	7e 69		 jle	 SHORT $L124008
$L124006:

; 1296 :         {
; 1297 : 			Xpoz += FlashArray[Flash] + FlashBias;

  002e2	8b 5c 24 14	 mov	 ebx, DWORD PTR _FlashBias$124004[esp+308]

; 1298 : 			SparkDest = ( (LL.Ypos & VMask) << UBits) + ((Xpoz >> 6) & UMask);

  002e6	8b 8e cc 00 00
	00		 mov	 ecx, DWORD PTR [esi+204]
  002ec	33 d2		 xor	 edx, edx
  002ee	8a 54 04 34	 mov	 dl, BYTE PTR _FlashArray$[esp+eax+308]
  002f2	03 d3		 add	 edx, ebx
  002f4	8b 9e c8 00 00
	00		 mov	 ebx, DWORD PTR [esi+200]
  002fa	03 ea		 add	 ebp, edx
  002fc	8b 94 24 39 01
	00 00		 mov	 edx, DWORD PTR _LL$[esp+305]
  00303	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00309	23 d1		 and	 edx, ecx
  0030b	8a 4e 30	 mov	 cl, BYTE PTR [esi+48]
  0030e	d3 e2		 shl	 edx, cl
  00310	8b cd		 mov	 ecx, ebp
  00312	c1 f9 06	 sar	 ecx, 6
  00315	23 cb		 and	 ecx, ebx

; 1299 : 			LL.Ypos += Ystep;   // increase Y

  00317	8a 9c 24 39 01
	00 00		 mov	 bl, BYTE PTR _LL$[esp+305]
  0031e	03 d1		 add	 edx, ecx
  00320	8a 4c 24 20	 mov	 cl, BYTE PTR _Ystep$[esp+308]
  00324	02 d9		 add	 bl, cl

; 1300 : 			Mips(0).DataArray(SparkDest) = ((RampColor += ColorSlope) >> 23);

  00326	03 7c 24 24	 add	 edi, DWORD PTR _ColorSlope$[esp+308]
  0032a	88 9c 24 39 01
	00 00		 mov	 BYTE PTR _LL$[esp+305], bl
  00331	8b 9e a8 00 00
	00		 mov	 ebx, DWORD PTR [esi+168]
  00337	8b 5b 1c	 mov	 ebx, DWORD PTR [ebx+28]
  0033a	8b cf		 mov	 ecx, edi
  0033c	c1 f9 17	 sar	 ecx, 23			; 00000017H
  0033f	88 0c 1a	 mov	 BYTE PTR [edx+ebx], cl
  00342	8b 4c 24 10	 mov	 ecx, DWORD PTR -292+[esp+308]
  00346	40		 inc	 eax
  00347	3b c1		 cmp	 eax, ecx
  00349	7c 97		 jl	 SHORT $L124006
$L124008:
  0034b	5f		 pop	 edi
  0034c	5e		 pop	 esi
  0034d	5d		 pop	 ebp
  0034e	5b		 pop	 ebx

; 1301 : 		}
; 1302 :     }
; 1303 : }

  0034f	81 c4 24 01 00
	00		 add	 esp, 292		; 00000124H
  00355	c2 0c 00	 ret	 12			; 0000000cH
?DrawFlashRamp@UFireTexture@@AAEXULineSeg@@EE@Z ENDP	; UFireTexture::DrawFlashRamp
_TEXT	ENDS
PUBLIC	?RedrawSparks@UFireTexture@@AAEXXZ		; UFireTexture::RedrawSparks
; Function compile flags: /Ogty
;	COMDAT ?RedrawSparks@UFireTexture@@AAEXXZ
_TEXT	SEGMENT
$T133188 = -16
_Htemp$124051 = -73
_LL$124155 = -64
_HeatA$124156 = -24
_LL$124162 = -60
_HeatA$124163 = -20
_Radius$124170 = -68
_Col1$124171 = -8
_Col2$124172 = -12
_LL$124177 = -56
_TempSpeedY$124251 = -73
_TempSpeedY$124261 = -73
$T132466 = -52
$T132470 = -48
_Ydir$133590 = -73
$T133596 = -4
$T132765 = -40
$T132772 = -36
$T133043 = -32
$T133050 = -28
?RedrawSparks@UFireTexture@@AAEXXZ PROC NEAR		; UFireTexture::RedrawSparks, COMDAT
; _this$ = ecx

; 1315 : {

  00000	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00003	53		 push	 ebx
  00004	55		 push	 ebp
  00005	56		 push	 esi
  00006	8b f1		 mov	 esi, ecx

; 1316 : 	AuxPhase += FX_Frequency;  

  00008	8a 96 dd 00 00
	00		 mov	 dl, BYTE PTR [esi+221]
  0000e	8a 86 ec 00 00
	00		 mov	 al, BYTE PTR [esi+236]

; 1317 : 	GlobalPhase++;

  00014	8b 8e d8 00 00
	00		 mov	 ecx, DWORD PTR [esi+216]

; 1318 : 
; 1319 : 	// Warning: On any movement or new creation, the integrity of a spark's coordinates
; 1320 :     // must be assured by using UMask and VMask.
; 1321 :     
; 1322 :     for( INT S=0; S<ActiveSparkNum; S++ )

  0001a	8b 9e f8 00 00
	00		 mov	 ebx, DWORD PTR [esi+248]
  00020	02 d0		 add	 dl, al
  00022	41		 inc	 ecx
  00023	33 ed		 xor	 ebp, ebp
  00025	85 db		 test	 ebx, ebx
  00027	88 96 dd 00 00
	00		 mov	 BYTE PTR [esi+221], dl
  0002d	89 8e d8 00 00
	00		 mov	 DWORD PTR [esi+216], ecx
  00033	0f 8e 28 31 00
	00		 jle	 $L124015
  00039	57		 push	 edi

; 2031 : 			break;
; 2032 : 
; 2033 :         } //Switch.
; 2034 : 	}
; 2035 : }

  0003a	8d 9b 00 00 00
	00		 npad	 6
$L124013:

; 1323 : 	{
; 1324 :         FSpark* ThisSpark = &(Sparks(S));

  00040	8b be fc 00 00
	00		 mov	 edi, DWORD PTR [esi+252]

; 1325 : 
; 1326 :         switch( ThisSpark->Type )
; 1327 :         {

  00046	33 c0		 xor	 eax, eax
  00048	8a 04 ef	 mov	 al, BYTE PTR [edi+ebp*8]
  0004b	83 f8 2b	 cmp	 eax, 43			; 0000002bH
  0004e	0f 87 fd 30 00
	00		 ja	 $L124014
  00054	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $L133704[eax*4]
$L124021:

; 1328 :         
; 1329 :         case SPARK_Burn:
; 1330 : 			{
; 1331 : 				DWORD SparkDest = (DWORD)(ThisSpark->X + (ThisSpark->Y << UBits) );

  0005b	8a 4e 30	 mov	 cl, BYTE PTR [esi+48]
  0005e	33 db		 xor	 ebx, ebx
  00060	8a 5c ef 03	 mov	 bl, BYTE PTR [edi+ebp*8+3]
  00064	d3 e3		 shl	 ebx, cl
  00066	33 c9		 xor	 ecx, ecx
  00068	8a 4c ef 02	 mov	 cl, BYTE PTR [edi+ebp*8+2]
  0006c	03 d9		 add	 ebx, ecx

; 1332 : 				Mips(0).DataArray(SparkDest) = SpeedRand();  

  0006e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  00074	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  0007a	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00080	83 c2 04	 add	 edx, 4
  00083	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  00089	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  0008f	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  00095	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  0009b	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  000a1	8b 96 a8 00 00
	00		 mov	 edx, DWORD PTR [esi+168]
  000a7	8b 4a 1c	 mov	 ecx, DWORD PTR [edx+28]
  000aa	88 04 0b	 mov	 BYTE PTR [ebx+ecx], al

; 1333 : 				break;

  000ad	e9 9f 30 00 00	 jmp	 $L124014
$L124024:

; 1334 : 			}
; 1335 : 
; 1336 :         case SPARK_Sparkle: // Normal spark with positional jitter.
; 1337 : 			{
; 1338 : 				DWORD NewSparkX = ( ThisSpark->X + (( SpeedRand() * ThisSpark->ByteA ) >> 8 ) );

  000b2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  000b8	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  000be	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  000c4	83 c2 04	 add	 edx, 4
  000c7	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  000cd	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  000d3	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  000d9	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  000df	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  000e5	33 db		 xor	 ebx, ebx
  000e7	8a 5c ef 04	 mov	 bl, BYTE PTR [edi+ebp*8+4]
  000eb	88 44 24 28	 mov	 BYTE PTR $T132466[esp+92], al
  000ef	8b 54 24 28	 mov	 edx, DWORD PTR $T132466[esp+92]
  000f3	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  000f9	33 c0		 xor	 eax, eax
  000fb	8a 44 ef 02	 mov	 al, BYTE PTR [edi+ebp*8+2]
  000ff	0f af da	 imul	 ebx, edx
  00102	c1 fb 08	 sar	 ebx, 8
  00105	03 d8		 add	 ebx, eax

; 1339 : 				DWORD NewSparkY = ( ThisSpark->Y + (( SpeedRand() * ThisSpark->ByteB ) >> 8 ) );

  00107	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  0010d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  00113	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00119	83 c2 04	 add	 edx, 4
  0011c	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  00122	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  00128	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  0012e	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  00134	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax

; 1340 : 				DWORD SparkDest = (DWORD)( (UMask & NewSparkX) + ( (VMask & NewSparkY) << UBits  ) );
; 1341 : 				Mips(0).DataArray(SparkDest) = ThisSpark->Heat;

  0013a	33 c9		 xor	 ecx, ecx
  0013c	8a 4c ef 05	 mov	 cl, BYTE PTR [edi+ebp*8+5]
  00140	88 44 24 2c	 mov	 BYTE PTR $T132470[esp+92], al
  00144	8b 44 24 2c	 mov	 eax, DWORD PTR $T132470[esp+92]
  00148	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0014d	8b d1		 mov	 edx, ecx
  0014f	0f af d0	 imul	 edx, eax
  00152	8b 86 c8 00 00
	00		 mov	 eax, DWORD PTR [esi+200]
  00158	33 c9		 xor	 ecx, ecx
  0015a	8a 4c ef 03	 mov	 cl, BYTE PTR [edi+ebp*8+3]
  0015e	c1 fa 08	 sar	 edx, 8
  00161	23 c3		 and	 eax, ebx
  00163	03 d1		 add	 edx, ecx
  00165	23 96 cc 00 00
	00		 and	 edx, DWORD PTR [esi+204]
  0016b	8a 4e 30	 mov	 cl, BYTE PTR [esi+48]
  0016e	d3 e2		 shl	 edx, cl
  00170	8b 8e a8 00 00
	00		 mov	 ecx, DWORD PTR [esi+168]
  00176	03 d0		 add	 edx, eax
  00178	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  0017b	8a 4c ef 01	 mov	 cl, BYTE PTR [edi+ebp*8+1]
  0017f	88 0c 02	 mov	 BYTE PTR [edx+eax], cl

; 1342 : 				break;

  00182	e9 ca 2f 00 00	 jmp	 $L124014
$L124029:

; 1343 : 			}
; 1344 : 
; 1345 :         case SPARK_Pulse: // Phased sparks.
; 1346 : 			{
; 1347 : 				DWORD SparkDest = (DWORD)( ThisSpark->X + ( ThisSpark->Y << UBits ));

  00187	8a 4e 30	 mov	 cl, BYTE PTR [esi+48]

; 1348 : 				Mips(0).DataArray(SparkDest) = (BYTE) ThisSpark->Heat;

  0018a	33 d2		 xor	 edx, edx
  0018c	8a 54 ef 03	 mov	 dl, BYTE PTR [edi+ebp*8+3]
  00190	8d 44 ef 01	 lea	 eax, DWORD PTR [edi+ebp*8+1]
  00194	d3 e2		 shl	 edx, cl
  00196	8b 8e a8 00 00
	00		 mov	 ecx, DWORD PTR [esi+168]
  0019c	8b 59 1c	 mov	 ebx, DWORD PTR [ecx+28]
  0019f	33 c9		 xor	 ecx, ecx
  001a1	8a 4c ef 02	 mov	 cl, BYTE PTR [edi+ebp*8+2]
  001a5	03 d3		 add	 edx, ebx
  001a7	8a 18		 mov	 bl, BYTE PTR [eax]
  001a9	88 1c 0a	 mov	 BYTE PTR [edx+ecx], bl

; 1349 : 				ThisSpark->Heat +=ThisSpark->ByteD;

  001ac	8a 08		 mov	 cl, BYTE PTR [eax]
  001ae	8a 54 ef 07	 mov	 dl, BYTE PTR [edi+ebp*8+7]
  001b2	02 ca		 add	 cl, dl

; 2005 : 
; 2006 : 				// Advance position.
; 2007 :                 MoveSparkXY( ThisSpark, TempSpeedX, TempSpeedY ); 

  001b4	88 08		 mov	 BYTE PTR [eax], cl

; 2008 :             }
; 2009 :             else // Delete the spark.

  001b6	e9 96 2f 00 00	 jmp	 $L124014
$L124033:

; 1350 : 				break;
; 1351 : 			}
; 1352 : 
; 1353 :         case SPARK_Signal: // Pulse-phased sparks.
; 1354 : 			{
; 1355 : 				DWORD SparkDest = (DWORD)(ThisSpark->X + ( ThisSpark->Y << UBits ));
; 1356 : 
; 1357 : 				if( ThisSpark->Heat > ThisSpark->ByteC )

  001bb	8a 44 ef 01	 mov	 al, BYTE PTR [edi+ebp*8+1]
  001bf	3a 44 ef 06	 cmp	 al, BYTE PTR [edi+ebp*8+6]
  001c3	8d 5c ef 01	 lea	 ebx, DWORD PTR [edi+ebp*8+1]
  001c7	76 1f		 jbe	 SHORT $L124036

; 1358 : 					Mips(0).DataArray(SparkDest) = (BYTE) ThisSpark->Heat;

  001c9	33 c9		 xor	 ecx, ecx
  001cb	8a 4c ef 03	 mov	 cl, BYTE PTR [edi+ebp*8+3]
  001cf	8b d1		 mov	 edx, ecx
  001d1	8a 4e 30	 mov	 cl, BYTE PTR [esi+48]
  001d4	d3 e2		 shl	 edx, cl
  001d6	8b 8e a8 00 00
	00		 mov	 ecx, DWORD PTR [esi+168]
  001dc	03 51 1c	 add	 edx, DWORD PTR [ecx+28]
  001df	33 c9		 xor	 ecx, ecx
  001e1	8a 4c ef 02	 mov	 cl, BYTE PTR [edi+ebp*8+2]
  001e5	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
$L124036:

; 1359 : 
; 1360 : 				if( (ThisSpark->Heat +=ThisSpark->ByteD) < ThisSpark->ByteD ) 

  001e8	8a 44 ef 07	 mov	 al, BYTE PTR [edi+ebp*8+7]
  001ec	8a 13		 mov	 dl, BYTE PTR [ebx]
  001ee	02 d0		 add	 dl, al
  001f0	8a ca		 mov	 cl, dl
  001f2	3a c8		 cmp	 cl, al
  001f4	88 13		 mov	 BYTE PTR [ebx], dl
  001f6	0f 83 55 2f 00
	00		 jae	 $L124014

; 1361 : 					ThisSpark->Heat = SpeedRand(); // Renew phase...

  001fc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  00202	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  00208	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  0020e	83 c2 04	 add	 edx, 4
  00211	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  00217	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  0021d	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  00223	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  00229	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax

; 1827 :                 // Advance position.
; 1828 :                 MoveSpark( ThisSpark );

  0022f	88 03		 mov	 BYTE PTR [ebx], al

; 1829 :                 // No gravity.
; 1830 :             }
; 1831 :             else  // Delete the spark.
; 1832 : 				*ThisSpark = Sparks(--ActiveSparkNum);
; 1833 :             break;

  00231	e9 1b 2f 00 00	 jmp	 $L124014
$L124039:

; 1362 : 				break;
; 1363 : 			}
; 1364 : 	
; 1365 : 		case SPARK_Cylinder: // Draw [Phase>>?] nr of sparks in a SIZE twister, speed FREQ
; 1366 :             {  
; 1367 : 				// Draw harmonic-motion spark based on size, phase, speed (freq).
; 1368 : 				// 'Z' distance suggested by brightness.
; 1369 : 				// DWORD SparkDest = (DWORD)( ThisSpark->X + ( ThisSpark->Y << UBits ));
; 1370 : 
; 1371 : 				BYTE Htemp = Min( PhaseTable[ (ThisSpark->ByteA+64) & 255 ] +  ThisSpark->Heat, 255);

  00236	33 c9		 xor	 ecx, ecx
  00238	8a 4c ef 04	 mov	 cl, BYTE PTR [edi+ebp*8+4]
  0023c	8d 54 ef 04	 lea	 edx, DWORD PTR [edi+ebp*8+4]
  00240	8d 41 40	 lea	 eax, DWORD PTR [ecx+64]
  00243	25 ff 00 00 00	 and	 eax, 255		; 000000ffH

; 1372 : 				BYTE XTemp = ThisSpark->X + (( (PhaseTable[ ThisSpark->ByteA ]) * ThisSpark->ByteB ) >> 8);
; 1373 : 				DWORD SparkDest = (DWORD)( (XTemp & UMask) + ( ThisSpark->Y << UBits ) );
; 1374 : 				Mips(0).DataArray(SparkDest) = Htemp;			
; 1375 : 
; 1376 : 				ThisSpark->ByteA += ThisSpark->ByteD; // Angle increment/decrement
; 1377 :             }
; 1378 :             break;

  00248	eb 19		 jmp	 SHORT $L133702
$L124049:

; 1379 : 
; 1380 : 		case SPARK_Cylinder3D: // Draw [Phase>>?] nr of sparks in a SIZE twister, speed FREQ
; 1381 :             {  
; 1382 : 				// Draw harmonic-motion spark based on size, phase, speed (freq).
; 1383 : 				// 'Z' distance suggested by brightness.
; 1384 : 				// DWORD SparkDest = (DWORD)( ThisSpark->X + ( ThisSpark->Y << UBits ));
; 1385 : 
; 1386 : 				if( ((ThisSpark->ByteA+64)&255) < 128 )

  0024a	33 c9		 xor	 ecx, ecx
  0024c	8a 4c ef 04	 mov	 cl, BYTE PTR [edi+ebp*8+4]
  00250	8d 54 ef 04	 lea	 edx, DWORD PTR [edi+ebp*8+4]
  00254	8d 41 40	 lea	 eax, DWORD PTR [ecx+64]
  00257	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0025c	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  00261	7d 68		 jge	 SHORT $L124050
$L133702:

; 1387 : 				{
; 1388 : 					BYTE Htemp = Min( PhaseTable[ (ThisSpark->ByteA+64) & 255 ] +  ThisSpark->Heat, 255);

  00263	33 db		 xor	 ebx, ebx
  00265	8a 98 00 00 00
	00		 mov	 bl, BYTE PTR _PhaseTable[eax]
  0026b	8b c3		 mov	 eax, ebx
  0026d	33 db		 xor	 ebx, ebx
  0026f	8a 5c ef 01	 mov	 bl, BYTE PTR [edi+ebp*8+1]
  00273	03 c3		 add	 eax, ebx
  00275	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  0027a	88 44 24 13	 mov	 BYTE PTR _Htemp$124051[esp+92], al
  0027e	7e 05		 jle	 SHORT $L132513
  00280	c6 44 24 13 ff	 mov	 BYTE PTR _Htemp$124051[esp+92], 255 ; 000000ffH
$L132513:

; 1389 : 					BYTE XTemp = ThisSpark->X + (( (PhaseTable[ ThisSpark->ByteA ]) * ThisSpark->ByteB ) >> 8);

  00285	8a 5c ef 02	 mov	 bl, BYTE PTR [edi+ebp*8+2]

; 1390 : 					DWORD SparkDest = (DWORD)( (XTemp & UMask) + ( ThisSpark->Y << UBits ) );
; 1391 : 					Mips(0).DataArray(SparkDest) = Htemp;			

  00289	33 c0		 xor	 eax, eax
  0028b	8a 81 00 00 00
	00		 mov	 al, BYTE PTR _PhaseTable[ecx]
  00291	33 c9		 xor	 ecx, ecx
  00293	8a 4c ef 05	 mov	 cl, BYTE PTR [edi+ebp*8+5]
  00297	0f af c1	 imul	 eax, ecx
  0029a	c1 f8 08	 sar	 eax, 8
  0029d	02 c3		 add	 al, bl
  0029f	8b 9e c8 00 00
	00		 mov	 ebx, DWORD PTR [esi+200]
  002a5	33 c9		 xor	 ecx, ecx
  002a7	8a 4c ef 03	 mov	 cl, BYTE PTR [edi+ebp*8+3]
  002ab	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  002b0	23 c3		 and	 eax, ebx
  002b2	8b d9		 mov	 ebx, ecx
  002b4	8a 4e 30	 mov	 cl, BYTE PTR [esi+48]
  002b7	d3 e3		 shl	 ebx, cl
  002b9	8b 8e a8 00 00
	00		 mov	 ecx, DWORD PTR [esi+168]
  002bf	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]
  002c2	03 c3		 add	 eax, ebx
  002c4	8a 5c 24 13	 mov	 bl, BYTE PTR _Htemp$124051[esp+92]
  002c8	88 1c 08	 mov	 BYTE PTR [eax+ecx], bl
$L124050:

; 1392 : 				}
; 1393 : 
; 1394 : 				ThisSpark->ByteA += ThisSpark->ByteD; // Angle increment/decrement

  002cb	8a 0a		 mov	 cl, BYTE PTR [edx]
  002cd	8a 44 ef 07	 mov	 al, BYTE PTR [edi+ebp*8+7]
  002d1	02 c8		 add	 cl, al
  002d3	88 0a		 mov	 BYTE PTR [edx], cl

; 1395 :             }
; 1396 :             break;

  002d5	e9 77 2e 00 00	 jmp	 $L124014
$L124059:

; 1397 : 
; 1398 : 		case SPARK_Jugglers: // Draw [Phase>>?] nr of sparks in a SIZE twister, speed FREQ
; 1399 :             {  
; 1400 : 				// Draw harmonic-motion spark based on size, phase, speed (freq).
; 1401 : 				// 'Z' distance suggested by brightness.
; 1402 : 				// DWORD SparkDest = (DWORD)( ThisSpark->X + ( ThisSpark->Y << UBits ));
; 1403 : 
; 1404 : 				BYTE Htemp = Min( PhaseTable[ (ThisSpark->ByteA+64) & 255 ] +  ThisSpark->Heat, 255 );

  002da	33 c9		 xor	 ecx, ecx
  002dc	8a 4c ef 04	 mov	 cl, BYTE PTR [edi+ebp*8+4]
  002e0	8d 54 ef 04	 lea	 edx, DWORD PTR [edi+ebp*8+4]
  002e4	33 db		 xor	 ebx, ebx
  002e6	8d 41 40	 lea	 eax, DWORD PTR [ecx+64]
  002e9	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  002ee	8a 98 00 00 00
	00		 mov	 bl, BYTE PTR _PhaseTable[eax]
  002f4	8b c3		 mov	 eax, ebx
  002f6	33 db		 xor	 ebx, ebx
  002f8	8a 5c ef 01	 mov	 bl, BYTE PTR [edi+ebp*8+1]
  002fc	03 c3		 add	 eax, ebx
  002fe	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00303	7e 02		 jle	 SHORT $L132527
  00305	0c ff		 or	 al, 255			; 000000ffH
$L132527:

; 1405 : 				BYTE YTemp = ThisSpark->Y + (( (PhaseTable[ ThisSpark->ByteA ]) * ThisSpark->ByteB ) >> 8);
; 1406 : 				DWORD SparkDest = (DWORD)( ThisSpark->X + ( (YTemp & VMask) << UBits )  );
; 1407 : 				Mips(0).DataArray(SparkDest) = Htemp;

  00307	33 db		 xor	 ebx, ebx
  00309	8a 99 00 00 00
	00		 mov	 bl, BYTE PTR _PhaseTable[ecx]
  0030f	33 c9		 xor	 ecx, ecx
  00311	8a 4c ef 05	 mov	 cl, BYTE PTR [edi+ebp*8+5]
  00315	0f af d9	 imul	 ebx, ecx
  00318	8a 4c ef 03	 mov	 cl, BYTE PTR [edi+ebp*8+3]
  0031c	c1 fb 08	 sar	 ebx, 8
  0031f	02 d9		 add	 bl, cl
  00321	8b 8e cc 00 00
	00		 mov	 ecx, DWORD PTR [esi+204]
  00327	81 e3 ff 00 00
	00		 and	 ebx, 255		; 000000ffH
  0032d	23 d9		 and	 ebx, ecx
  0032f	8a 4e 30	 mov	 cl, BYTE PTR [esi+48]
  00332	d3 e3		 shl	 ebx, cl
  00334	8b 8e a8 00 00
	00		 mov	 ecx, DWORD PTR [esi+168]
  0033a	03 59 1c	 add	 ebx, DWORD PTR [ecx+28]
  0033d	33 c9		 xor	 ecx, ecx
  0033f	8a 4c ef 02	 mov	 cl, BYTE PTR [edi+ebp*8+2]
  00343	88 04 0b	 mov	 BYTE PTR [ebx+ecx], al

; 1408 : 				ThisSpark->ByteA += ThisSpark->ByteD; //

  00346	8a 0a		 mov	 cl, BYTE PTR [edx]
  00348	8a 44 ef 07	 mov	 al, BYTE PTR [edi+ebp*8+7]
  0034c	02 c8		 add	 cl, al
  0034e	88 0a		 mov	 BYTE PTR [edx], cl

; 1409 :             }
; 1410 :             break;

  00350	e9 fc 2d 00 00	 jmp	 $L124014
$L124068:

; 1411 : 
; 1412 : 		case SPARK_Lissajous: // Draw [Phase>>?] nr of sparks in a SIZE twister, speed FREQ
; 1413 :             {  
; 1414 : 				// Draw harmonic-motion spark based on size, phase, speed (freq).
; 1415 : 				// 'Z' distance suggested by brightness.
; 1416 : 				// DWORD SparkDest = (DWORD)( ThisSpark->X + ( ThisSpark->Y << UBits ));
; 1417 : 
; 1418 : 				BYTE Htemp = LightPhaseTable[ (BYTE) (ThisSpark->ByteA+64) ]; // Light phase == A
; 1419 : 				BYTE XTemp = ThisSpark->X + (( PhaseTable[ ThisSpark->ByteA ] * ThisSpark->Heat ) >> 8);
; 1420 : 				BYTE YTemp = ThisSpark->Y + (( PhaseTable[ ThisSpark->ByteB ] * ThisSpark->Heat ) >> 8);
; 1421 : 
; 1422 : 				DWORD SparkDest = (DWORD)( (XTemp & UMask) + ( (YTemp & VMask) << UBits )  );
; 1423 : 				Mips(0).DataArray(SparkDest) = Htemp;			

  00355	33 db		 xor	 ebx, ebx
  00357	8a 5c ef 05	 mov	 bl, BYTE PTR [edi+ebp*8+5]
  0035b	33 c9		 xor	 ecx, ecx
  0035d	8a 4c ef 01	 mov	 cl, BYTE PTR [edi+ebp*8+1]
  00361	8d 44 ef 05	 lea	 eax, DWORD PTR [edi+ebp*8+5]
  00365	89 44 24 14	 mov	 DWORD PTR -72+[esp+92], eax
  00369	33 c0		 xor	 eax, eax
  0036b	33 d2		 xor	 edx, edx
  0036d	8a 83 00 00 00
	00		 mov	 al, BYTE PTR _PhaseTable[ebx]
  00373	8a 54 ef 04	 mov	 dl, BYTE PTR [edi+ebp*8+4]
  00377	89 4c 24 18	 mov	 DWORD PTR -68+[esp+92], ecx
  0037b	88 54 24 30	 mov	 BYTE PTR -44+[esp+92], dl
  0037f	80 c2 40	 add	 dl, 64			; 00000040H
  00382	8b d8		 mov	 ebx, eax
  00384	0f af d9	 imul	 ebx, ecx
  00387	8a 4c ef 03	 mov	 cl, BYTE PTR [edi+ebp*8+3]
  0038b	8b 44 24 30	 mov	 eax, DWORD PTR -44+[esp+92]
  0038f	c1 fb 08	 sar	 ebx, 8
  00392	02 d9		 add	 bl, cl
  00394	8b 8e cc 00 00
	00		 mov	 ecx, DWORD PTR [esi+204]
  0039a	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0039f	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  003a5	8a 92 00 00 00
	00		 mov	 dl, BYTE PTR _LightPhaseTable[edx]
  003ab	81 e3 ff 00 00
	00		 and	 ebx, 255		; 000000ffH
  003b1	23 d9		 and	 ebx, ecx
  003b3	8a 4e 30	 mov	 cl, BYTE PTR [esi+48]
  003b6	d3 e3		 shl	 ebx, cl
  003b8	33 c9		 xor	 ecx, ecx
  003ba	8a 88 00 00 00
	00		 mov	 cl, BYTE PTR _PhaseTable[eax]
  003c0	8a 44 ef 02	 mov	 al, BYTE PTR [edi+ebp*8+2]
  003c4	0f af 4c 24 18	 imul	 ecx, DWORD PTR -68+[esp+92]
  003c9	c1 f9 08	 sar	 ecx, 8
  003cc	02 c8		 add	 cl, al
  003ce	8b 86 c8 00 00
	00		 mov	 eax, DWORD PTR [esi+200]
  003d4	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  003da	23 c8		 and	 ecx, eax
  003dc	8b 86 a8 00 00
	00		 mov	 eax, DWORD PTR [esi+168]
  003e2	03 d9		 add	 ebx, ecx
  003e4	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  003e7	88 14 0b	 mov	 BYTE PTR [ebx+ecx], dl

; 1424 : 
; 1425 : 				ThisSpark->ByteA += ThisSpark->ByteC;

  003ea	8a 44 ef 06	 mov	 al, BYTE PTR [edi+ebp*8+6]
  003ee	8a 5c ef 04	 mov	 bl, BYTE PTR [edi+ebp*8+4]

; 1426 : 				ThisSpark->ByteB += ThisSpark->ByteD;

  003f2	8a 4c ef 07	 mov	 cl, BYTE PTR [edi+ebp*8+7]
  003f6	02 d8		 add	 bl, al
  003f8	8b 44 24 14	 mov	 eax, DWORD PTR -72+[esp+92]
  003fc	8a 10		 mov	 dl, BYTE PTR [eax]
  003fe	02 d1		 add	 dl, cl
  00400	88 5c ef 04	 mov	 BYTE PTR [edi+ebp*8+4], bl
  00404	88 10		 mov	 BYTE PTR [eax], dl

; 1427 :             }
; 1428 :             break;

  00406	e9 46 2d 00 00	 jmp	 $L124014
$L124075:

; 1429 : 
; 1430 : 		
; 1431 : 		case SPARK_LissajX: // Special case: Lissajous without Y-movement.
; 1432 : 			{  
; 1433 : 				BYTE XTemp = ThisSpark->X + (( PhaseTable[ ThisSpark->ByteA ] * ThisSpark->Heat ) >> 8);
; 1434 : 				BYTE Htemp = LightPhaseTable[ (BYTE)(ThisSpark->ByteA+64) ]; // Light phase == B

  0040b	8d 44 ef 04	 lea	 eax, DWORD PTR [edi+ebp*8+4]
  0040f	89 44 24 18	 mov	 DWORD PTR -68+[esp+92], eax
  00413	0f b6 00	 movzx	 eax, BYTE PTR [eax]

; 1435 : 
; 1436 : 				DWORD SparkDest = (DWORD)( (XTemp & UMask) + ( ThisSpark->Y << UBits )  );
; 1437 : 				Mips(0).DataArray(SparkDest) = Htemp;			

  00416	33 c9		 xor	 ecx, ecx
  00418	33 d2		 xor	 edx, edx
  0041a	8a d0		 mov	 dl, al
  0041c	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00421	8a 88 00 00 00
	00		 mov	 cl, BYTE PTR _PhaseTable[eax]
  00427	8a 5c ef 02	 mov	 bl, BYTE PTR [edi+ebp*8+2]
  0042b	80 c2 40	 add	 dl, 64			; 00000040H
  0042e	8b c1		 mov	 eax, ecx
  00430	33 c9		 xor	 ecx, ecx
  00432	8a 4c ef 01	 mov	 cl, BYTE PTR [edi+ebp*8+1]
  00436	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  0043c	8a 92 00 00 00
	00		 mov	 dl, BYTE PTR _LightPhaseTable[edx]
  00442	0f af c1	 imul	 eax, ecx
  00445	c1 f8 08	 sar	 eax, 8
  00448	02 c3		 add	 al, bl
  0044a	8b 9e c8 00 00
	00		 mov	 ebx, DWORD PTR [esi+200]
  00450	33 c9		 xor	 ecx, ecx
  00452	8a 4c ef 03	 mov	 cl, BYTE PTR [edi+ebp*8+3]
  00456	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0045b	23 c3		 and	 eax, ebx
  0045d	8b d9		 mov	 ebx, ecx
  0045f	8a 4e 30	 mov	 cl, BYTE PTR [esi+48]
  00462	d3 e3		 shl	 ebx, cl
  00464	8b 8e a8 00 00
	00		 mov	 ecx, DWORD PTR [esi+168]
  0046a	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]
  0046d	03 c3		 add	 eax, ebx
  0046f	88 14 08	 mov	 BYTE PTR [eax+ecx], dl

; 1438 : 
; 1439 : 				ThisSpark->ByteA += ThisSpark->ByteC;

  00472	8b 44 24 18	 mov	 eax, DWORD PTR -68+[esp+92]
  00476	8a 10		 mov	 dl, BYTE PTR [eax]
  00478	8a 4c ef 06	 mov	 cl, BYTE PTR [edi+ebp*8+6]
  0047c	02 d1		 add	 dl, cl
  0047e	88 10		 mov	 BYTE PTR [eax], dl

; 1440 :             }
; 1441 :             break;

  00480	e9 cc 2c 00 00	 jmp	 $L124014
$L124081:

; 1442 : 
; 1443 : 		case SPARK_LissajY: // Special case: Lissajous without X-movement.
; 1444 : 			{  
; 1445 : 				BYTE YTemp = ThisSpark->Y + (( PhaseTable[ ThisSpark->ByteB ] * ThisSpark->Heat ) >> 8);
; 1446 : 				BYTE Htemp = LightPhaseTable[ (BYTE)(ThisSpark->ByteB+64) ]; // Light phase == B
; 1447 : 
; 1448 : 				DWORD SparkDest = (DWORD)( ThisSpark->X + ( (YTemp & VMask) << UBits )  );
; 1449 : 				Mips(0).DataArray(SparkDest) = Htemp;

  00485	33 c0		 xor	 eax, eax
  00487	8a 44 ef 05	 mov	 al, BYTE PTR [edi+ebp*8+5]
  0048b	8d 54 ef 05	 lea	 edx, DWORD PTR [edi+ebp*8+5]
  0048f	33 c9		 xor	 ecx, ecx
  00491	33 db		 xor	 ebx, ebx
  00493	8a d8		 mov	 bl, al
  00495	80 c3 40	 add	 bl, 64			; 00000040H
  00498	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0049d	8a 88 00 00 00
	00		 mov	 cl, BYTE PTR _PhaseTable[eax]
  004a3	81 e3 ff 00 00
	00		 and	 ebx, 255		; 000000ffH
  004a9	8a 9b 00 00 00
	00		 mov	 bl, BYTE PTR _LightPhaseTable[ebx]
  004af	8b c1		 mov	 eax, ecx
  004b1	33 c9		 xor	 ecx, ecx
  004b3	8a 4c ef 01	 mov	 cl, BYTE PTR [edi+ebp*8+1]
  004b7	0f af c1	 imul	 eax, ecx
  004ba	8a 4c ef 03	 mov	 cl, BYTE PTR [edi+ebp*8+3]
  004be	c1 f8 08	 sar	 eax, 8
  004c1	02 c1		 add	 al, cl
  004c3	8b 8e cc 00 00
	00		 mov	 ecx, DWORD PTR [esi+204]
  004c9	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  004ce	23 c1		 and	 eax, ecx
  004d0	8a 4e 30	 mov	 cl, BYTE PTR [esi+48]
  004d3	d3 e0		 shl	 eax, cl
  004d5	8b 8e a8 00 00
	00		 mov	 ecx, DWORD PTR [esi+168]
  004db	03 41 1c	 add	 eax, DWORD PTR [ecx+28]
  004de	33 c9		 xor	 ecx, ecx
  004e0	8a 4c ef 02	 mov	 cl, BYTE PTR [edi+ebp*8+2]
  004e4	88 1c 08	 mov	 BYTE PTR [eax+ecx], bl

; 1450 : 
; 1451 : 				ThisSpark->ByteB += ThisSpark->ByteD;

  004e7	8a 0a		 mov	 cl, BYTE PTR [edx]
  004e9	8a 44 ef 07	 mov	 al, BYTE PTR [edi+ebp*8+7]
  004ed	02 c8		 add	 cl, al
  004ef	88 0a		 mov	 BYTE PTR [edx], cl

; 1452 :             }
; 1453 :             break;

  004f1	e9 5b 2c 00 00	 jmp	 $L124014
$L124087:

; 1454 : 
; 1455 :         case SPARK_Blaze: // Emit sparks pseudo-radially.
; 1456 :             if( (ActiveSparkNum < (SparksLimit)) && ( 128 > SpeedRand() ) )

  004f6	3b 9e f4 00 00
	00		 cmp	 ebx, DWORD PTR [esi+244]
  004fc	0f 8d 4f 2c 00
	00		 jge	 $L124014
  00502	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  00508	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  0050e	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00514	83 c2 04	 add	 edx, 4
  00517	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  0051d	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  00523	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  00529	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  0052f	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  00535	3c 80		 cmp	 al, 128			; 00000080H
  00537	0f 83 14 2c 00
	00		 jae	 $L124014

; 1457 :             {   // create it..
; 1458 :                 INT  NS = ActiveSparkNum++;

  0053d	8b 9e f8 00 00
	00		 mov	 ebx, DWORD PTR [esi+248]

; 1459 : 	            Sparks(NS).Type = ISPARK_Drifter;  // Dynamic type.

  00543	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  00549	8d 4b 01	 lea	 ecx, DWORD PTR [ebx+1]
  0054c	89 8e f8 00 00
	00		 mov	 DWORD PTR [esi+248], ecx
  00552	c6 04 da 20	 mov	 BYTE PTR [edx+ebx*8], 32 ; 00000020H

; 1460 : 				Sparks(NS).Heat = ThisSpark->Heat; // Start heat 

  00556	8b 86 fc 00 00
	00		 mov	 eax, DWORD PTR [esi+252]
  0055c	8a 4c ef 01	 mov	 cl, BYTE PTR [edi+ebp*8+1]
  00560	88 4c d8 01	 mov	 BYTE PTR [eax+ebx*8+1], cl

; 1461 :                 Sparks(NS).X = ThisSpark->X;

  00564	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  0056a	8a 44 ef 02	 mov	 al, BYTE PTR [edi+ebp*8+2]
  0056e	88 44 da 02	 mov	 BYTE PTR [edx+ebx*8+2], al

; 1462 : 				Sparks(NS).Y = ThisSpark->Y;             

  00572	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  00578	8a 54 ef 03	 mov	 dl, BYTE PTR [edi+ebp*8+3]
  0057c	88 54 d9 03	 mov	 BYTE PTR [ecx+ebx*8+3], dl

; 1463 :                 Sparks(NS).ByteA = SpeedRand();  // Speed

  00580	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  00586	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  0058c	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00592	83 c2 04	 add	 edx, 4
  00595	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  0059b	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  005a1	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  005a7	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  005ad	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  005b3	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  005b9	88 44 d9 04	 mov	 BYTE PTR [ecx+ebx*8+4], al

; 1464 :                 Sparks(NS).ByteB = SpeedRand();  // Speed

  005bd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  005c3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  005c9	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  005cf	83 c2 04	 add	 edx, 4
  005d2	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  005d8	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  005de	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  005e4	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  005ea	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  005f0	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  005f6	88 44 da 05	 mov	 BYTE PTR [edx+ebx*8+5], al

; 1465 : 				Sparks(NS).ByteC = ThisSpark->ByteC;

  005fa	8b 86 fc 00 00
	00		 mov	 eax, DWORD PTR [esi+252]
  00600	8a 4c ef 06	 mov	 cl, BYTE PTR [edi+ebp*8+6]
  00604	88 4c d8 06	 mov	 BYTE PTR [eax+ebx*8+6], cl

; 1466 : 				Sparks(NS).ByteD = ThisSpark->ByteD;

  00608	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  0060e	8a 44 ef 07	 mov	 al, BYTE PTR [edi+ebp*8+7]
  00612	88 44 da 07	 mov	 BYTE PTR [edx+ebx*8+7], al

; 1467 :             }
; 1468 :             break;

  00616	e9 36 2b 00 00	 jmp	 $L124014
$L124090:

; 1469 : 
; 1470 :         case SPARK_OzHasSpoken: // V-shaped output.
; 1471 :             if( (ActiveSparkNum < (SparksLimit)) && ( 128 > SpeedRand() ) )

  0061b	3b 9e f4 00 00
	00		 cmp	 ebx, DWORD PTR [esi+244]
  00621	0f 8d 2a 2b 00
	00		 jge	 $L124014
  00627	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  0062d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  00633	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00639	83 c2 04	 add	 edx, 4
  0063c	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  00642	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  00648	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  0064e	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  00654	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  0065a	3c 80		 cmp	 al, 128			; 00000080H
  0065c	0f 83 ef 2a 00
	00		 jae	 $L124014

; 1472 :             {   // create it..
; 1473 :                 INT  NS = ActiveSparkNum++;

  00662	8b 9e f8 00 00
	00		 mov	 ebx, DWORD PTR [esi+248]

; 1474 :                 Sparks(NS).Type  = ISPARK_DriftSlow;

  00668	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  0066e	8d 4b 01	 lea	 ecx, DWORD PTR [ebx+1]
  00671	89 8e f8 00 00
	00		 mov	 DWORD PTR [esi+248], ecx
  00677	c6 04 da 21	 mov	 BYTE PTR [edx+ebx*8], 33 ; 00000021H

; 1475 :                 Sparks(NS).Heat  = ThisSpark->Heat;        // Start heat.

  0067b	8b 86 fc 00 00
	00		 mov	 eax, DWORD PTR [esi+252]
  00681	8a 4c ef 01	 mov	 cl, BYTE PTR [edi+ebp*8+1]
  00685	88 4c d8 01	 mov	 BYTE PTR [eax+ebx*8+1], cl

; 1476 :                 Sparks(NS).X     = ThisSpark->X;

  00689	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  0068f	8a 44 ef 02	 mov	 al, BYTE PTR [edi+ebp*8+2]
  00693	88 44 da 02	 mov	 BYTE PTR [edx+ebx*8+2], al

; 1477 :                 Sparks(NS).Y     = ThisSpark->Y;

  00697	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  0069d	8a 54 ef 03	 mov	 dl, BYTE PTR [edi+ebp*8+3]
  006a1	88 54 d9 03	 mov	 BYTE PTR [ecx+ebx*8+3], dl

; 1478 : 				Sparks(NS).ByteA = (SpeedRand()&127) - 63; // X speed arbit.

  006a5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  006ab	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  006b1	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  006b7	83 c2 04	 add	 edx, 4
  006ba	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  006c0	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  006c6	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  006cc	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  006d2	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  006d8	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  006de	24 7f		 and	 al, 127			; 0000007fH
  006e0	2c 3f		 sub	 al, 63			; 0000003fH
  006e2	88 44 d9 04	 mov	 BYTE PTR [ecx+ebx*8+4], al

; 1479 :                 Sparks(NS).ByteB = (BYTE)-127;             // Y speed UP..

  006e6	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  006ec	c6 44 da 05 81	 mov	 BYTE PTR [edx+ebx*8+5], 129 ; 00000081H

; 1480 : 				Sparks(NS).ByteD = 2;  // Life decrement.

  006f1	8b 86 fc 00 00
	00		 mov	 eax, DWORD PTR [esi+252]
  006f7	c6 44 d8 07 02	 mov	 BYTE PTR [eax+ebx*8+7], 2

; 1481 :             }
; 1482 :             break;

  006fc	e9 50 2a 00 00	 jmp	 $L124014
$L124094:

; 1483 : 
; 1484 :         case SPARK_Cone: // Symmetric gravity-emitting - sparks of type 130.
; 1485 :             if( (ActiveSparkNum < (SparksLimit)) && ( 64 > SpeedRand() ) )

  00701	3b 9e f4 00 00
	00		 cmp	 ebx, DWORD PTR [esi+244]
  00707	0f 8d 44 2a 00
	00		 jge	 $L124014
  0070d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  00713	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  00719	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  0071f	83 c2 04	 add	 edx, 4
  00722	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  00728	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  0072e	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  00734	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  0073a	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  00740	3c 40		 cmp	 al, 64			; 00000040H
  00742	0f 83 09 2a 00
	00		 jae	 $L124014

; 1486 :             {   // create it..
; 1487 :                 INT  NS = ActiveSparkNum++;

  00748	8b 9e f8 00 00
	00		 mov	 ebx, DWORD PTR [esi+248]

; 1488 :                 Sparks(NS).Type = ISPARK_Faller;

  0074e	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  00754	8d 4b 01	 lea	 ecx, DWORD PTR [ebx+1]
  00757	89 8e f8 00 00
	00		 mov	 DWORD PTR [esi+248], ecx
  0075d	c6 04 da 22	 mov	 BYTE PTR [edx+ebx*8], 34 ; 00000022H

; 1489 : 				Sparks(NS).Heat = ThisSpark->Heat;   // Heat.

  00761	8b 86 fc 00 00
	00		 mov	 eax, DWORD PTR [esi+252]
  00767	8a 4c ef 01	 mov	 cl, BYTE PTR [edi+ebp*8+1]
  0076b	88 4c d8 01	 mov	 BYTE PTR [eax+ebx*8+1], cl

; 1490 :                 Sparks(NS).X = ThisSpark->X;

  0076f	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  00775	8a 44 ef 02	 mov	 al, BYTE PTR [edi+ebp*8+2]
  00779	88 44 da 02	 mov	 BYTE PTR [edx+ebx*8+2], al

; 1491 :                 Sparks(NS).Y = ThisSpark->Y;

  0077d	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  00783	8a 54 ef 03	 mov	 dl, BYTE PTR [edi+ebp*8+3]
  00787	88 54 d9 03	 mov	 BYTE PTR [ecx+ebx*8+3], dl

; 1492 : 
; 1493 :                 Sparks(NS).ByteA = (SpeedRand()&127) - 63; // X speed arbit.

  0078b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  00791	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  00797	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  0079d	83 c2 04	 add	 edx, 4
  007a0	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  007a6	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  007ac	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  007b2	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  007b8	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  007be	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  007c4	24 7f		 and	 al, 127			; 0000007fH
  007c6	2c 3f		 sub	 al, 63			; 0000003fH
  007c8	88 44 d9 04	 mov	 BYTE PTR [ecx+ebx*8+4], al

; 1494 :                 Sparks(NS).ByteB =  0;  // Y speed UP

  007cc	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  007d2	c6 44 da 05 00	 mov	 BYTE PTR [edx+ebx*8+5], 0

; 1495 :                 Sparks(NS).ByteC =  50; // Timer.

  007d7	8b 86 fc 00 00
	00		 mov	 eax, DWORD PTR [esi+252]
  007dd	c6 44 d8 06 32	 mov	 BYTE PTR [eax+ebx*8+6], 50 ; 00000032H

; 1496 :             }
; 1497 :             break;

  007e2	e9 6a 29 00 00	 jmp	 $L124014
$L124097:

; 1498 : 
; 1499 :         case SPARK_BlazeRight: // Erupt to the right.
; 1500 :             if( (ActiveSparkNum < (SparksLimit)) && ( 64 > SpeedRand() ) )

  007e7	3b 9e f4 00 00
	00		 cmp	 ebx, DWORD PTR [esi+244]
  007ed	0f 8d 5e 29 00
	00		 jge	 $L124014
  007f3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  007f9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  007ff	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00805	83 c2 04	 add	 edx, 4
  00808	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  0080e	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  00814	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  0081a	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  00820	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  00826	3c 40		 cmp	 al, 64			; 00000040H
  00828	0f 83 23 29 00
	00		 jae	 $L124014

; 1501 :             {   // Create it.
; 1502 :                 INT  NS = ActiveSparkNum++;

  0082e	8b 9e f8 00 00
	00		 mov	 ebx, DWORD PTR [esi+248]

; 1503 :                 Sparks(NS).Type = ISPARK_Faller; //

  00834	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  0083a	8d 4b 01	 lea	 ecx, DWORD PTR [ebx+1]
  0083d	89 8e f8 00 00
	00		 mov	 DWORD PTR [esi+248], ecx
  00843	c6 04 da 22	 mov	 BYTE PTR [edx+ebx*8], 34 ; 00000022H

; 1504 : 				Sparks(NS).Heat = ThisSpark->Heat;  // Heat.

  00847	8b 86 fc 00 00
	00		 mov	 eax, DWORD PTR [esi+252]
  0084d	8a 4c ef 01	 mov	 cl, BYTE PTR [edi+ebp*8+1]
  00851	88 4c d8 01	 mov	 BYTE PTR [eax+ebx*8+1], cl

; 1505 : 				Sparks(NS).X = ThisSpark->X;

  00855	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  0085b	8a 44 ef 02	 mov	 al, BYTE PTR [edi+ebp*8+2]
  0085f	88 44 da 02	 mov	 BYTE PTR [edx+ebx*8+2], al

; 1506 :                 Sparks(NS).Y = ThisSpark->Y;

  00863	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  00869	8a 54 ef 03	 mov	 dl, BYTE PTR [edi+ebp*8+3]
  0086d	88 54 d9 03	 mov	 BYTE PTR [ecx+ebx*8+3], dl

; 1507 :                 Sparks(NS).ByteA = (SpeedRand()&63) + 63; // X Speed.

  00871	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  00877	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  0087d	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00883	83 c2 04	 add	 edx, 4
  00886	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  0088c	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  00892	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  00898	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  0089e	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  008a4	24 3f		 and	 al, 63			; 0000003fH
  008a6	04 3f		 add	 al, 63			; 0000003fH

; 1508 :                 Sparks(NS).ByteB = (BYTE) -29; // Y speed UP.
; 1509 :                 Sparks(NS).ByteC =  ThisSpark->ByteC; // Timer.
; 1510 :             }
; 1511 :             break;

  008a8	e9 c1 00 00 00	 jmp	 $L133701
$L124101:

; 1512 : 
; 1513 :         case SPARK_BlazeLeft: // Erupt to the left.
; 1514 :             if( (ActiveSparkNum < (SparksLimit)) && ( 64 > SpeedRand() ) )

  008ad	3b 9e f4 00 00
	00		 cmp	 ebx, DWORD PTR [esi+244]
  008b3	0f 8d 98 28 00
	00		 jge	 $L124014
  008b9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  008bf	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  008c5	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  008cb	83 c2 04	 add	 edx, 4
  008ce	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  008d4	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  008da	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  008e0	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  008e6	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  008ec	3c 40		 cmp	 al, 64			; 00000040H
  008ee	0f 83 5d 28 00
	00		 jae	 $L124014

; 1515 :             {   // Create it.
; 1516 :                 INT  NS = ActiveSparkNum++;

  008f4	8b 9e f8 00 00
	00		 mov	 ebx, DWORD PTR [esi+248]

; 1517 :                 Sparks(NS).Type = ISPARK_Faller;

  008fa	8b 86 fc 00 00
	00		 mov	 eax, DWORD PTR [esi+252]
  00900	8d 53 01	 lea	 edx, DWORD PTR [ebx+1]
  00903	89 96 f8 00 00
	00		 mov	 DWORD PTR [esi+248], edx
  00909	c6 04 d8 22	 mov	 BYTE PTR [eax+ebx*8], 34 ; 00000022H

; 1518 : 				Sparks(NS).Heat = ThisSpark->Heat;	  // Heat.

  0090d	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  00913	8a 54 ef 01	 mov	 dl, BYTE PTR [edi+ebp*8+1]
  00917	88 54 d9 01	 mov	 BYTE PTR [ecx+ebx*8+1], dl

; 1519 : 				Sparks(NS).X = ThisSpark->X;

  0091b	8b 86 fc 00 00
	00		 mov	 eax, DWORD PTR [esi+252]
  00921	8a 4c ef 02	 mov	 cl, BYTE PTR [edi+ebp*8+2]
  00925	88 4c d8 02	 mov	 BYTE PTR [eax+ebx*8+2], cl

; 1520 :                 Sparks(NS).Y = ThisSpark->Y;

  00929	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  0092f	8a 44 ef 03	 mov	 al, BYTE PTR [edi+ebp*8+3]
  00933	88 44 da 03	 mov	 BYTE PTR [edx+ebx*8+3], al

; 1521 :                 Sparks(NS).ByteA = (SpeedRand()&63) -128; // X speed 

  00937	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  0093d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  00943	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00949	83 c2 04	 add	 edx, 4
  0094c	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  00952	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  00958	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  0095e	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  00964	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  0096a	24 3f		 and	 al, 63			; 0000003fH
  0096c	04 80		 add	 al, 128			; 00000080H
$L133701:
  0096e	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  00974	88 44 d9 04	 mov	 BYTE PTR [ecx+ebx*8+4], al

; 1522 :                 Sparks(NS).ByteB = (BYTE) -29;  // Y speed UP

  00978	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  0097e	c6 44 da 05 e3	 mov	 BYTE PTR [edx+ebx*8+5], 227 ; 000000e3H

; 1523 :                 Sparks(NS).ByteC =  ThisSpark->ByteC; // Timer.

  00983	8b 86 fc 00 00
	00		 mov	 eax, DWORD PTR [esi+252]
  00989	8a 4c ef 06	 mov	 cl, BYTE PTR [edi+ebp*8+6]
  0098d	88 4c d8 06	 mov	 BYTE PTR [eax+ebx*8+6], cl

; 1524 :             }
; 1525 :             break;

  00991	e9 bb 27 00 00	 jmp	 $L124014
$L124105:

; 1526 : 
; 1527 :         case SPARK_Emit: // Erupt to a preset speed & direction.
; 1528 :             if( (ActiveSparkNum < (SparksLimit)) && ( 64 > SpeedRand() ) )

  00996	3b 9e f4 00 00
	00		 cmp	 ebx, DWORD PTR [esi+244]
  0099c	0f 8d af 27 00
	00		 jge	 $L124014
  009a2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  009a8	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  009ae	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  009b4	83 c2 04	 add	 edx, 4
  009b7	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  009bd	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  009c3	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  009c9	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  009cf	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  009d5	3c 40		 cmp	 al, 64			; 00000040H
  009d7	0f 83 74 27 00
	00		 jae	 $L124014

; 1529 :             {   // Create it..
; 1530 :                 INT  NS = ActiveSparkNum++;

  009dd	8b 86 f8 00 00
	00		 mov	 eax, DWORD PTR [esi+248]

; 1531 :                 Sparks(NS).Type = ISPARK_DriftSlow;

  009e3	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  009e9	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  009ec	89 96 f8 00 00
	00		 mov	 DWORD PTR [esi+248], edx
  009f2	c6 04 c1 21	 mov	 BYTE PTR [ecx+eax*8], 33 ; 00000021H

; 1532 : 				Sparks(NS).Heat = ThisSpark->Heat; // heat

  009f6	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  009fc	8a 4c ef 01	 mov	 cl, BYTE PTR [edi+ebp*8+1]
  00a00	88 4c c2 01	 mov	 BYTE PTR [edx+eax*8+1], cl

; 1533 :                 Sparks(NS).X = ThisSpark->X;

  00a04	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  00a0a	8a 4c ef 02	 mov	 cl, BYTE PTR [edi+ebp*8+2]
  00a0e	88 4c c2 02	 mov	 BYTE PTR [edx+eax*8+2], cl

; 1534 :                 Sparks(NS).Y = ThisSpark->Y;

  00a12	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  00a18	8a 4c ef 03	 mov	 cl, BYTE PTR [edi+ebp*8+3]
  00a1c	88 4c c2 03	 mov	 BYTE PTR [edx+eax*8+3], cl

; 1535 :                 Sparks(NS).ByteA = ThisSpark->ByteA; // X speed

  00a20	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  00a26	8a 4c ef 04	 mov	 cl, BYTE PTR [edi+ebp*8+4]
  00a2a	88 4c c2 04	 mov	 BYTE PTR [edx+eax*8+4], cl

; 1536 :                 Sparks(NS).ByteB = ThisSpark->ByteB; // Y speed

  00a2e	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  00a34	8a 4c ef 05	 mov	 cl, BYTE PTR [edi+ebp*8+5]
  00a38	88 4c c2 05	 mov	 BYTE PTR [edx+eax*8+5], cl

; 1537 : 				Sparks(NS).ByteD = ThisSpark->ByteD; // Decrement

  00a3c	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  00a42	8a 4c ef 07	 mov	 cl, BYTE PTR [edi+ebp*8+7]
  00a46	88 4c c2 07	 mov	 BYTE PTR [edx+eax*8+7], cl

; 1538 :             }
; 1539 :             break;

  00a4a	e9 02 27 00 00	 jmp	 $L124014
$L124108:

; 1540 : 
; 1541 : 		case SPARK_Fountain: // Erupt to a preset speed & direction.
; 1542 :             if( (ActiveSparkNum < (SparksLimit)) && ( 64 > SpeedRand() ) )

  00a4f	3b 9e f4 00 00
	00		 cmp	 ebx, DWORD PTR [esi+244]
  00a55	0f 8d f6 26 00
	00		 jge	 $L124014
  00a5b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  00a61	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  00a67	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00a6d	83 c2 04	 add	 edx, 4
  00a70	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  00a76	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  00a7c	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  00a82	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  00a88	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  00a8e	3c 40		 cmp	 al, 64			; 00000040H
  00a90	0f 83 bb 26 00
	00		 jae	 $L124014

; 1543 :             {   // Create it..
; 1544 :                 INT  NS = ActiveSparkNum++;

  00a96	8b 86 f8 00 00
	00		 mov	 eax, DWORD PTR [esi+248]

; 1545 :                 Sparks(NS).Type  = ISPARK_Graviton;

  00a9c	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  00aa2	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  00aa5	89 96 f8 00 00
	00		 mov	 DWORD PTR [esi+248], edx
  00aab	c6 04 c1 2a	 mov	 BYTE PTR [ecx+eax*8], 42 ; 0000002aH

; 1546 : 				Sparks(NS).Heat  = ThisSpark->Heat; // heat

  00aaf	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  00ab5	8a 4c ef 01	 mov	 cl, BYTE PTR [edi+ebp*8+1]
  00ab9	88 4c c2 01	 mov	 BYTE PTR [edx+eax*8+1], cl

; 1547 :                 Sparks(NS).X     = ThisSpark->X;

  00abd	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  00ac3	8a 4c ef 02	 mov	 cl, BYTE PTR [edi+ebp*8+2]
  00ac7	88 4c c2 02	 mov	 BYTE PTR [edx+eax*8+2], cl

; 1548 :                 Sparks(NS).Y     = ThisSpark->Y;

  00acb	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  00ad1	8a 4c ef 03	 mov	 cl, BYTE PTR [edi+ebp*8+3]
  00ad5	88 4c c2 03	 mov	 BYTE PTR [edx+eax*8+3], cl

; 1549 :                 Sparks(NS).ByteA = ThisSpark->ByteA; // X speed

  00ad9	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  00adf	8a 4c ef 04	 mov	 cl, BYTE PTR [edi+ebp*8+4]
  00ae3	88 4c c2 04	 mov	 BYTE PTR [edx+eax*8+4], cl

; 1550 :                 Sparks(NS).ByteB = ThisSpark->ByteB; // Y speed

  00ae7	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  00aed	8a 4c ef 05	 mov	 cl, BYTE PTR [edi+ebp*8+5]
  00af1	88 4c c2 05	 mov	 BYTE PTR [edx+eax*8+5], cl

; 1551 : 				Sparks(NS).ByteD = ThisSpark->ByteD; // Decrement

  00af5	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  00afb	8a 4c ef 07	 mov	 cl, BYTE PTR [edi+ebp*8+7]
  00aff	88 4c c2 07	 mov	 BYTE PTR [edx+eax*8+7], cl

; 1552 :             }
; 1553 :         	break;

  00b03	e9 49 26 00 00	 jmp	 $L124014
$L124111:

; 1554 : 
; 1555 : 
; 1556 : 		case SPARK_Organic: // Emitting - sparks of type SPARK_VShooter.
; 1557 :      						// Whirly-floaty fire sparks, go up & glow out.
; 1558 :             if( (ActiveSparkNum < (SparksLimit)) && ( 128 > SpeedRand() ) )

  00b08	3b 9e f4 00 00
	00		 cmp	 ebx, DWORD PTR [esi+244]
  00b0e	0f 8d 3d 26 00
	00		 jge	 $L124014
  00b14	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  00b1a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  00b20	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00b26	83 c2 04	 add	 edx, 4
  00b29	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  00b2f	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  00b35	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  00b3b	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  00b41	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  00b47	3c 80		 cmp	 al, 128			; 00000080H
  00b49	0f 83 02 26 00
	00		 jae	 $L124014

; 1559 :             {   // create it..
; 1560 :                 INT  NS = ActiveSparkNum++;

  00b4f	8b 9e f8 00 00
	00		 mov	 ebx, DWORD PTR [esi+248]

; 1561 :                 Sparks(NS).Type = ISPARK_VShooter; //

  00b55	8b 86 fc 00 00
	00		 mov	 eax, DWORD PTR [esi+252]
  00b5b	8d 53 01	 lea	 edx, DWORD PTR [ebx+1]
  00b5e	89 96 f8 00 00
	00		 mov	 DWORD PTR [esi+248], edx
  00b64	c6 04 d8 23	 mov	 BYTE PTR [eax+ebx*8], 35 ; 00000023H

; 1562 : 				Sparks(NS).X = UMask & (ThisSpark->X + ((SpeedRand() * ThisSpark->ByteC) >> 8));

  00b68	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  00b6e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  00b74	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00b7a	83 c2 04	 add	 edx, 4
  00b7d	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  00b83	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  00b89	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  00b8f	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  00b95	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  00b9b	33 d2		 xor	 edx, edx
  00b9d	8a 54 ef 06	 mov	 dl, BYTE PTR [edi+ebp*8+6]
  00ba1	88 44 24 34	 mov	 BYTE PTR $T132765[esp+92], al
  00ba5	8b 4c 24 34	 mov	 ecx, DWORD PTR $T132765[esp+92]
  00ba9	8a 44 ef 02	 mov	 al, BYTE PTR [edi+ebp*8+2]
  00bad	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00bb3	0f af ca	 imul	 ecx, edx
  00bb6	8a 96 c8 00 00
	00		 mov	 dl, BYTE PTR [esi+200]
  00bbc	c1 f9 08	 sar	 ecx, 8
  00bbf	02 c8		 add	 cl, al
  00bc1	8b 86 fc 00 00
	00		 mov	 eax, DWORD PTR [esi+252]
  00bc7	22 ca		 and	 cl, dl
  00bc9	88 4c d8 02	 mov	 BYTE PTR [eax+ebx*8+2], cl

; 1563 : 				Sparks(NS).Y = VMask & (ThisSpark->Y + ((SpeedRand() * ThisSpark->ByteC) >> 8));

  00bcd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  00bd3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  00bd9	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00bdf	83 c2 04	 add	 edx, 4
  00be2	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  00be8	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  00bee	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  00bf4	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  00bfa	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  00c00	33 d2		 xor	 edx, edx
  00c02	8a 54 ef 06	 mov	 dl, BYTE PTR [edi+ebp*8+6]
  00c06	88 44 24 38	 mov	 BYTE PTR $T132772[esp+92], al
  00c0a	8b 4c 24 38	 mov	 ecx, DWORD PTR $T132772[esp+92]
  00c0e	8a 44 ef 03	 mov	 al, BYTE PTR [edi+ebp*8+3]
  00c12	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00c18	0f af ca	 imul	 ecx, edx
  00c1b	8a 96 cc 00 00
	00		 mov	 dl, BYTE PTR [esi+204]
  00c21	c1 f9 08	 sar	 ecx, 8
  00c24	02 c8		 add	 cl, al
  00c26	8b 86 fc 00 00
	00		 mov	 eax, DWORD PTR [esi+252]
  00c2c	22 ca		 and	 cl, dl
  00c2e	88 4c d8 03	 mov	 BYTE PTR [eax+ebx*8+3], cl

; 1564 :                 Sparks(NS).ByteA = SpeedRand() - 127; // X speed arbit.

  00c32	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  00c38	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  00c3e	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00c44	83 c2 04	 add	 edx, 4
  00c47	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  00c4d	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  00c53	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  00c59	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  00c5f	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  00c65	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  00c6b	2c 7f		 sub	 al, 127			; 0000007fH
  00c6d	88 44 d9 04	 mov	 BYTE PTR [ecx+ebx*8+4], al

; 1565 :                 Sparks(NS).ByteB = 256-127;           // Y speed UP

  00c71	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  00c77	c6 44 da 05 81	 mov	 BYTE PTR [edx+ebx*8+5], 129 ; 00000081H

; 1566 :                 Sparks(NS).ByteC = 255;				  // Timer==heat - steps --2, to 128

  00c7c	8b 86 fc 00 00
	00		 mov	 eax, DWORD PTR [esi+252]
  00c82	c6 44 d8 06 ff	 mov	 BYTE PTR [eax+ebx*8+6], 255 ; 000000ffH

; 1567 :             }
; 1568 :             break;

  00c87	e9 c5 24 00 00	 jmp	 $L124014
$L124114:

; 1569 : 
; 1570 :         case SPARK_WanderOrganic: // Emitting VShooters but randomly moves itself.
; 1571 :             if( (ActiveSparkNum < (SparksLimit)) )

  00c8c	3b 9e f4 00 00
	00		 cmp	 ebx, DWORD PTR [esi+244]
  00c92	0f 8d fc 00 00
	00		 jge	 $L124115

; 1572 :             {   // create it..
; 1573 :                 INT  NS = ActiveSparkNum++;

  00c98	8d 4b 01	 lea	 ecx, DWORD PTR [ebx+1]
  00c9b	89 8e f8 00 00
	00		 mov	 DWORD PTR [esi+248], ecx

; 1574 :                 Sparks(NS).Type = ISPARK_VShooter;

  00ca1	c6 04 df 23	 mov	 BYTE PTR [edi+ebx*8], 35 ; 00000023H

; 1575 :                 Sparks(NS).X = UMask & (ThisSpark->X + (SpeedRand()&31));

  00ca5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  00cab	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  00cb1	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00cb7	83 c2 04	 add	 edx, 4
  00cba	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  00cc0	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  00cc6	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  00ccc	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  00cd2	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  00cd8	8a 54 ef 02	 mov	 dl, BYTE PTR [edi+ebp*8+2]
  00cdc	8a 8e c8 00 00
	00		 mov	 cl, BYTE PTR [esi+200]
  00ce2	24 1f		 and	 al, 31			; 0000001fH
  00ce4	02 c2		 add	 al, dl
  00ce6	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  00cec	22 c1		 and	 al, cl
  00cee	88 44 da 02	 mov	 BYTE PTR [edx+ebx*8+2], al

; 1576 :                 Sparks(NS).Y = VMask & (ThisSpark->Y + (SpeedRand()&31));

  00cf2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  00cf8	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  00cfe	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00d04	83 c2 04	 add	 edx, 4
  00d07	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  00d0d	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  00d13	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  00d19	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  00d1f	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  00d25	8a 4c ef 03	 mov	 cl, BYTE PTR [edi+ebp*8+3]
  00d29	8a 96 cc 00 00
	00		 mov	 dl, BYTE PTR [esi+204]
  00d2f	24 1f		 and	 al, 31			; 0000001fH
  00d31	02 c1		 add	 al, cl
  00d33	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  00d39	22 c2		 and	 al, dl
  00d3b	88 44 d9 03	 mov	 BYTE PTR [ecx+ebx*8+3], al

; 1577 : 
; 1578 :                 Sparks(NS).ByteA = SpeedRand() - 127; // X speed

  00d3f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  00d45	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  00d4b	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00d51	83 c2 04	 add	 edx, 4
  00d54	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  00d5a	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  00d60	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  00d66	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  00d6c	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  00d72	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  00d78	2c 7f		 sub	 al, 127			; 0000007fH
  00d7a	88 44 da 04	 mov	 BYTE PTR [edx+ebx*8+4], al

; 1579 :                 Sparks(NS).ByteB = 256-127;           // Y speed UP

  00d7e	8b 86 fc 00 00
	00		 mov	 eax, DWORD PTR [esi+252]
  00d84	c6 44 d8 05 81	 mov	 BYTE PTR [eax+ebx*8+5], 129 ; 00000081H

; 1580 :                 Sparks(NS).ByteC = 255;               // timer - steps --2, to 128

  00d89	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  00d8f	c6 44 d9 06 ff	 mov	 BYTE PTR [ecx+ebx*8+6], 255 ; 000000ffH
$L124115:

; 1581 :             }
; 1582 :             // move around a bit
; 1583 :             if( SpeedRand() & 15 == 15 ) ThisSpark->X = UMask & (ThisSpark->X+(SpeedRand()&15)-7);

  00d94	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  00d9a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  00da0	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00da6	83 c2 04	 add	 edx, 4
  00da9	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  00daf	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  00db5	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  00dbb	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  00dc1	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  00dc7	a8 01		 test	 al, 1
  00dc9	74 49		 je	 SHORT $L124117
  00dcb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  00dd1	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  00dd7	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00ddd	83 c2 04	 add	 edx, 4
  00de0	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  00de6	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  00dec	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  00df2	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  00df8	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  00dfe	8a 5c ef 02	 mov	 bl, BYTE PTR [edi+ebp*8+2]
  00e02	8a 8e c8 00 00
	00		 mov	 cl, BYTE PTR [esi+200]
  00e08	24 0f		 and	 al, 15			; 0000000fH
  00e0a	02 c3		 add	 al, bl
  00e0c	2c 07		 sub	 al, 7
  00e0e	22 c1		 and	 al, cl
  00e10	88 44 ef 02	 mov	 BYTE PTR [edi+ebp*8+2], al
$L124117:

; 1584 :             if( SpeedRand() & 15 == 15 ) ThisSpark->Y = VMask & (ThisSpark->Y+(SpeedRand()&15)-7);

  00e14	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  00e1a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  00e20	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00e26	83 c2 04	 add	 edx, 4
  00e29	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  00e2f	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  00e35	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  00e3b	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  00e41	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  00e47	a8 01		 test	 al, 1
  00e49	0f 84 02 23 00
	00		 je	 $L124014
  00e4f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  00e55	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  00e5b	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00e61	83 c2 04	 add	 edx, 4
  00e64	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  00e6a	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  00e70	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  00e76	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  00e7c	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  00e82	8a 5c ef 03	 mov	 bl, BYTE PTR [edi+ebp*8+3]
  00e86	8a 8e cc 00 00
	00		 mov	 cl, BYTE PTR [esi+204]
  00e8c	8d 7c ef 03	 lea	 edi, DWORD PTR [edi+ebp*8+3]
  00e90	24 0f		 and	 al, 15			; 0000000fH
  00e92	02 c3		 add	 al, bl
  00e94	2c 07		 sub	 al, 7
  00e96	22 c1		 and	 al, cl
  00e98	88 07		 mov	 BYTE PTR [edi], al

; 1585 :             break;

  00e9a	e9 b2 22 00 00	 jmp	 $L124014
$L124119:

; 1586 : 
; 1587 :         case SPARK_RandomCloud: // Emitting Drop but randomly moves itself eratically.
; 1588 :             if( (ActiveSparkNum < (SparksLimit)) )

  00e9f	3b 9e f4 00 00
	00		 cmp	 ebx, DWORD PTR [esi+244]
  00ea5	0f 8d fe 00 00
	00		 jge	 $L124120

; 1589 :             {   // create it..
; 1590 :                 INT  NS = ActiveSparkNum++;

  00eab	8d 53 01	 lea	 edx, DWORD PTR [ebx+1]
  00eae	89 96 f8 00 00
	00		 mov	 DWORD PTR [esi+248], edx

; 1591 :                 Sparks(NS).Type =  ISPARK_Drop;

  00eb4	c6 04 df 24	 mov	 BYTE PTR [edi+ebx*8], 36 ; 00000024H

; 1592 :                 Sparks(NS).X = UMask & (ThisSpark->X + (SpeedRand()&31));

  00eb8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  00ebe	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  00ec4	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00eca	83 c2 04	 add	 edx, 4
  00ecd	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  00ed3	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  00ed9	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  00edf	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  00ee5	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  00eeb	8a 4c ef 02	 mov	 cl, BYTE PTR [edi+ebp*8+2]
  00eef	8a 96 c8 00 00
	00		 mov	 dl, BYTE PTR [esi+200]
  00ef5	24 1f		 and	 al, 31			; 0000001fH
  00ef7	02 c1		 add	 al, cl
  00ef9	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  00eff	22 c2		 and	 al, dl
  00f01	88 44 d9 02	 mov	 BYTE PTR [ecx+ebx*8+2], al

; 1593 :                 Sparks(NS).Y = VMask & (ThisSpark->Y + (SpeedRand()&31));

  00f05	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  00f0b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  00f11	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00f17	83 c2 04	 add	 edx, 4
  00f1a	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  00f20	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  00f26	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  00f2c	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  00f32	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  00f38	8a 54 ef 03	 mov	 dl, BYTE PTR [edi+ebp*8+3]
  00f3c	8a 8e cc 00 00
	00		 mov	 cl, BYTE PTR [esi+204]
  00f42	24 1f		 and	 al, 31			; 0000001fH
  00f44	02 c2		 add	 al, dl
  00f46	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  00f4c	22 c1		 and	 al, cl
  00f4e	88 44 da 03	 mov	 BYTE PTR [edx+ebx*8+3], al

; 1594 :                 Sparks(NS).ByteA = (SpeedRand()&31) - 15; // X speed

  00f52	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  00f58	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  00f5e	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00f64	83 c2 04	 add	 edx, 4
  00f67	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  00f6d	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  00f73	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  00f79	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  00f7f	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  00f85	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  00f8b	24 1f		 and	 al, 31			; 0000001fH
  00f8d	2c 0f		 sub	 al, 15			; 0000000fH
  00f8f	88 44 d9 04	 mov	 BYTE PTR [ecx+ebx*8+4], al

; 1595 :                 Sparks(NS).ByteB =  256-127;              // Y speed UP

  00f93	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  00f99	c6 44 da 05 81	 mov	 BYTE PTR [edx+ebx*8+5], 129 ; 00000081H

; 1596 :                 Sparks(NS).ByteC =  0;                    // timer=HEAT

  00f9e	8b 86 fc 00 00
	00		 mov	 eax, DWORD PTR [esi+252]
  00fa4	c6 44 d8 06 00	 mov	 BYTE PTR [eax+ebx*8+6], 0
$L124120:

; 1597 :             }
; 1598 :             // move around a bit
; 1599 :             if( SpeedRand() & 15 == 15 ) ThisSpark->X = UMask & (ThisSpark->X+(SpeedRand()&15)-7);

  00fa9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  00faf	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  00fb5	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00fbb	83 c2 04	 add	 edx, 4
  00fbe	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  00fc4	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  00fca	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  00fd0	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  00fd6	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  00fdc	a8 01		 test	 al, 1
  00fde	74 49		 je	 SHORT $L124122
  00fe0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  00fe6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  00fec	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00ff2	83 c2 04	 add	 edx, 4
  00ff5	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  00ffb	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  01001	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  01007	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  0100d	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  01013	8a 5c ef 02	 mov	 bl, BYTE PTR [edi+ebp*8+2]
  01017	8a 8e c8 00 00
	00		 mov	 cl, BYTE PTR [esi+200]
  0101d	24 0f		 and	 al, 15			; 0000000fH
  0101f	02 c3		 add	 al, bl
  01021	2c 07		 sub	 al, 7
  01023	22 c1		 and	 al, cl
  01025	88 44 ef 02	 mov	 BYTE PTR [edi+ebp*8+2], al
$L124122:

; 1600 :             if( SpeedRand() & 15 == 15 ) ThisSpark->Y = VMask & (ThisSpark->Y+(SpeedRand()&15)-7);

  01029	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  0102f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  01035	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  0103b	83 c2 04	 add	 edx, 4
  0103e	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  01044	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  0104a	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  01050	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  01056	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  0105c	a8 01		 test	 al, 1
  0105e	0f 84 ed 20 00
	00		 je	 $L124014
  01064	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  0106a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  01070	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  01076	83 c2 04	 add	 edx, 4
  01079	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  0107f	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  01085	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  0108b	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  01091	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  01097	8a 5c ef 03	 mov	 bl, BYTE PTR [edi+ebp*8+3]
  0109b	8a 8e cc 00 00
	00		 mov	 cl, BYTE PTR [esi+204]
  010a1	8d 7c ef 03	 lea	 edi, DWORD PTR [edi+ebp*8+3]
  010a5	24 0f		 and	 al, 15			; 0000000fH
  010a7	02 c3		 add	 al, bl
  010a9	2c 07		 sub	 al, 7
  010ab	22 c1		 and	 al, cl
  010ad	88 07		 mov	 BYTE PTR [edi], al

; 1601 :             break;

  010af	e9 9d 20 00 00	 jmp	 $L124014
$L124124:

; 1602 : 
; 1603 :         case SPARK_Eels: // Spawns some Eels.
; 1604 :             if  ( (SpeedRand()<20) &&  ( (ActiveSparkNum < (SparksLimit)) ) )

  010b4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  010ba	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  010c0	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  010c6	83 c2 04	 add	 edx, 4
  010c9	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  010cf	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  010d5	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  010db	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  010e1	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  010e7	3c 14		 cmp	 al, 20			; 00000014H
  010e9	0f 83 55 01 00
	00		 jae	 $L124125
  010ef	8b 9e f8 00 00
	00		 mov	 ebx, DWORD PTR [esi+248]
  010f5	3b 9e f4 00 00
	00		 cmp	 ebx, DWORD PTR [esi+244]
  010fb	0f 8d 43 01 00
	00		 jge	 $L124125

; 1605 :             {
; 1606 :                 // create it..
; 1607 :                 INT  NS = ActiveSparkNum++;
; 1608 : 				Sparks(NS).Heat  = ThisSpark->Heat;

  01101	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  01107	8d 4b 01	 lea	 ecx, DWORD PTR [ebx+1]
  0110a	89 8e f8 00 00
	00		 mov	 DWORD PTR [esi+248], ecx
  01110	8a 44 ef 01	 mov	 al, BYTE PTR [edi+ebp*8+1]
  01114	88 44 da 01	 mov	 BYTE PTR [edx+ebx*8+1], al

; 1609 :                 Sparks(NS).Type = ISPARK_SpawnedEel; //

  01118	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  0111e	c6 04 d9 26	 mov	 BYTE PTR [ecx+ebx*8], 38 ; 00000026H

; 1610 :                 Sparks(NS).X = UMask & (ThisSpark->X + (SpeedRand()&31));

  01122	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  01128	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  0112e	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  01134	83 c2 04	 add	 edx, 4
  01137	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  0113d	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  01143	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  01149	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  0114f	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  01155	8a 4c ef 02	 mov	 cl, BYTE PTR [edi+ebp*8+2]
  01159	8a 96 c8 00 00
	00		 mov	 dl, BYTE PTR [esi+200]
  0115f	24 1f		 and	 al, 31			; 0000001fH
  01161	02 c1		 add	 al, cl
  01163	22 c2		 and	 al, dl
  01165	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  0116b	88 44 da 02	 mov	 BYTE PTR [edx+ebx*8+2], al

; 1611 :                 Sparks(NS).Y = VMask & (ThisSpark->Y + (SpeedRand()&31));

  0116f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  01175	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  0117b	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  01181	83 c2 04	 add	 edx, 4
  01184	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  0118a	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  01190	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  01196	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  0119c	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  011a2	8a 54 ef 03	 mov	 dl, BYTE PTR [edi+ebp*8+3]
  011a6	8a 8e cc 00 00
	00		 mov	 cl, BYTE PTR [esi+204]
  011ac	24 1f		 and	 al, 31			; 0000001fH
  011ae	02 c2		 add	 al, dl
  011b0	22 c1		 and	 al, cl
  011b2	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  011b8	88 44 d9 03	 mov	 BYTE PTR [ecx+ebx*8+3], al

; 1612 :                 Sparks(NS).ByteA = SpeedRand();

  011bc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  011c2	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  011c8	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  011ce	83 c2 04	 add	 edx, 4
  011d1	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  011d7	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  011dd	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  011e3	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  011e9	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  011ef	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  011f5	88 44 da 04	 mov	 BYTE PTR [edx+ebx*8+4], al

; 1613 :                 Sparks(NS).ByteB = SpeedRand();

  011f9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  011ff	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  01205	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  0120b	83 c2 04	 add	 edx, 4
  0120e	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  01214	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  0121a	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  01220	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  01226	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  0122c	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  01232	88 44 d9 05	 mov	 BYTE PTR [ecx+ebx*8+5], al

; 1614 :                 Sparks(NS).ByteC = ThisSpark->ByteC;  // Timer.

  01236	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  0123c	8a 44 ef 06	 mov	 al, BYTE PTR [edi+ebp*8+6]
  01240	88 44 da 06	 mov	 BYTE PTR [edx+ebx*8+6], al
$L124125:

; 1615 :             }
; 1616 :             // move around a bit
; 1617 :             if( SpeedRand() & 15 == 15 ) ThisSpark->X = UMask & (ThisSpark->X+(SpeedRand()&15)-7);

  01244	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  0124a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  01250	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  01256	83 c2 04	 add	 edx, 4
  01259	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  0125f	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  01265	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  0126b	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  01271	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  01277	a8 01		 test	 al, 1
  01279	74 49		 je	 SHORT $L124127
  0127b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  01281	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  01287	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  0128d	83 c2 04	 add	 edx, 4
  01290	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  01296	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  0129c	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  012a2	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  012a8	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  012ae	8a 5c ef 02	 mov	 bl, BYTE PTR [edi+ebp*8+2]
  012b2	8a 8e c8 00 00
	00		 mov	 cl, BYTE PTR [esi+200]
  012b8	24 0f		 and	 al, 15			; 0000000fH
  012ba	02 c3		 add	 al, bl
  012bc	2c 07		 sub	 al, 7
  012be	22 c1		 and	 al, cl
  012c0	88 44 ef 02	 mov	 BYTE PTR [edi+ebp*8+2], al
$L124127:

; 1618 :             if( SpeedRand() & 15 == 15 ) ThisSpark->Y = VMask & (ThisSpark->Y+(SpeedRand()&15)-7);

  012c4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  012ca	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  012d0	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  012d6	83 c2 04	 add	 edx, 4
  012d9	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  012df	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  012e5	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  012eb	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  012f1	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  012f7	a8 01		 test	 al, 1
  012f9	0f 84 52 1e 00
	00		 je	 $L124014
  012ff	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  01305	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  0130b	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  01311	83 c2 04	 add	 edx, 4
  01314	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  0131a	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  01320	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  01326	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  0132c	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  01332	8a 5c ef 03	 mov	 bl, BYTE PTR [edi+ebp*8+3]
  01336	8a 8e cc 00 00
	00		 mov	 cl, BYTE PTR [esi+204]
  0133c	8d 7c ef 03	 lea	 edi, DWORD PTR [edi+ebp*8+3]
  01340	24 0f		 and	 al, 15			; 0000000fH
  01342	02 c3		 add	 al, bl
  01344	2c 07		 sub	 al, 7
  01346	22 c1		 and	 al, cl
  01348	88 07		 mov	 BYTE PTR [edi], al

; 1619 :             break;

  0134a	e9 02 1e 00 00	 jmp	 $L124014
$L124129:

; 1620 : 
; 1621 : 		case SPARK_Gametes: // Spawns a spermatozoid.
; 1622 :             if  ( (SpeedRand()<20) &&  ( (ActiveSparkNum < (SparksLimit)) ) )

  0134f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  01355	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  0135b	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  01361	83 c2 04	 add	 edx, 4
  01364	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  0136a	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  01370	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  01376	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  0137c	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  01382	3c 14		 cmp	 al, 20			; 00000014H
  01384	0f 83 55 01 00
	00		 jae	 $L124130
  0138a	8b 9e f8 00 00
	00		 mov	 ebx, DWORD PTR [esi+248]
  01390	3b 9e f4 00 00
	00		 cmp	 ebx, DWORD PTR [esi+244]
  01396	0f 8d 43 01 00
	00		 jge	 $L124130

; 1623 :             {
; 1624 : 				// Create it.
; 1625 :                 INT  NS = ActiveSparkNum++;
; 1626 :                 Sparks(NS).Type = ISPARK_SpawnedSperm; //

  0139c	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  013a2	8d 4b 01	 lea	 ecx, DWORD PTR [ebx+1]
  013a5	89 8e f8 00 00
	00		 mov	 DWORD PTR [esi+248], ecx
  013ab	c6 04 da 2b	 mov	 BYTE PTR [edx+ebx*8], 43 ; 0000002bH

; 1627 : 				Sparks(NS).Heat = ThisSpark->Heat;

  013af	8b 86 fc 00 00
	00		 mov	 eax, DWORD PTR [esi+252]
  013b5	8a 4c ef 01	 mov	 cl, BYTE PTR [edi+ebp*8+1]
  013b9	88 4c d8 01	 mov	 BYTE PTR [eax+ebx*8+1], cl

; 1628 :                 Sparks(NS).X = UMask & (ThisSpark->X + (SpeedRand()&31));

  013bd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  013c3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  013c9	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  013cf	83 c2 04	 add	 edx, 4
  013d2	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  013d8	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  013de	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  013e4	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  013ea	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  013f0	8a 4c ef 02	 mov	 cl, BYTE PTR [edi+ebp*8+2]
  013f4	8a 96 c8 00 00
	00		 mov	 dl, BYTE PTR [esi+200]
  013fa	24 1f		 and	 al, 31			; 0000001fH
  013fc	02 c1		 add	 al, cl
  013fe	22 c2		 and	 al, dl
  01400	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  01406	88 44 da 02	 mov	 BYTE PTR [edx+ebx*8+2], al

; 1629 :                 Sparks(NS).Y = VMask & (ThisSpark->Y + (SpeedRand()&31));

  0140a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  01410	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  01416	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  0141c	83 c2 04	 add	 edx, 4
  0141f	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  01425	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  0142b	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  01431	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  01437	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  0143d	8a 54 ef 03	 mov	 dl, BYTE PTR [edi+ebp*8+3]
  01441	8a 8e cc 00 00
	00		 mov	 cl, BYTE PTR [esi+204]
  01447	24 1f		 and	 al, 31			; 0000001fH
  01449	02 c2		 add	 al, dl
  0144b	22 c1		 and	 al, cl
  0144d	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  01453	88 44 d9 03	 mov	 BYTE PTR [ecx+ebx*8+3], al

; 1630 :                 Sparks(NS).ByteA = SpeedRand(); // wriggle counter

  01457	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  0145d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  01463	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  01469	83 c2 04	 add	 edx, 4
  0146c	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  01472	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  01478	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  0147e	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  01484	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  0148a	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  01490	88 44 da 04	 mov	 BYTE PTR [edx+ebx*8+4], al

; 1631 :                 Sparks(NS).ByteC = ThisSpark->ByteC;  // Timer.

  01494	8b 86 fc 00 00
	00		 mov	 eax, DWORD PTR [esi+252]
  0149a	8a 4c ef 06	 mov	 cl, BYTE PTR [edi+ebp*8+6]
  0149e	88 4c d8 06	 mov	 BYTE PTR [eax+ebx*8+6], cl

; 1632 : 				Sparks(NS).ByteD = SpeedRand(); // Direction

  014a2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  014a8	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  014ae	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  014b4	83 c2 04	 add	 edx, 4
  014b7	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  014bd	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  014c3	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  014c9	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  014cf	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  014d5	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  014db	88 44 da 07	 mov	 BYTE PTR [edx+ebx*8+7], al
$L124130:

; 1633 :             }
; 1634 :             // Move around a bit.
; 1635 :             if( SpeedRand() & 15 == 15 ) ThisSpark->X = UMask & (ThisSpark->X+(SpeedRand()&15)-7);

  014df	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  014e5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  014eb	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  014f1	83 c2 04	 add	 edx, 4
  014f4	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  014fa	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  01500	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  01506	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  0150c	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  01512	a8 01		 test	 al, 1
  01514	74 49		 je	 SHORT $L124132
  01516	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  0151c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  01522	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  01528	83 c2 04	 add	 edx, 4
  0152b	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  01531	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  01537	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  0153d	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  01543	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  01549	8a 5c ef 02	 mov	 bl, BYTE PTR [edi+ebp*8+2]
  0154d	8a 8e c8 00 00
	00		 mov	 cl, BYTE PTR [esi+200]
  01553	24 0f		 and	 al, 15			; 0000000fH
  01555	02 c3		 add	 al, bl
  01557	2c 07		 sub	 al, 7
  01559	22 c1		 and	 al, cl
  0155b	88 44 ef 02	 mov	 BYTE PTR [edi+ebp*8+2], al
$L124132:

; 1636 :             if( SpeedRand() & 15 == 15 ) ThisSpark->Y = VMask & (ThisSpark->Y+(SpeedRand()&15)-7);

  0155f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  01565	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  0156b	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  01571	83 c2 04	 add	 edx, 4
  01574	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  0157a	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  01580	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  01586	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  0158c	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  01592	a8 01		 test	 al, 1
  01594	0f 84 b7 1b 00
	00		 je	 $L124014
  0159a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  015a0	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  015a6	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  015ac	83 c2 04	 add	 edx, 4
  015af	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  015b5	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  015bb	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  015c1	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  015c7	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  015cd	8a 5c ef 03	 mov	 bl, BYTE PTR [edi+ebp*8+3]
  015d1	8a 8e cc 00 00
	00		 mov	 cl, BYTE PTR [esi+204]
  015d7	8d 7c ef 03	 lea	 edi, DWORD PTR [edi+ebp*8+3]
  015db	24 0f		 and	 al, 15			; 0000000fH
  015dd	02 c3		 add	 al, bl
  015df	2c 07		 sub	 al, 7
  015e1	22 c1		 and	 al, cl
  015e3	88 07		 mov	 BYTE PTR [edi], al

; 1637 :             break;

  015e5	e9 67 1b 00 00	 jmp	 $L124014
$L124134:

; 1638 : 
; 1639 :         case SPARK_CustomCloud:  // Custom CLOUDS that move at DrawByteA's speed.
; 1640 :             if( (ActiveSparkNum < (SparksLimit)) )

  015ea	3b 9e f4 00 00
	00		 cmp	 ebx, DWORD PTR [esi+244]
  015f0	0f 8d d1 00 00
	00		 jge	 $L124135

; 1641 :             {
; 1642 :                 // Create it.
; 1643 :                 INT  NS = ActiveSparkNum++;

  015f6	8d 43 01	 lea	 eax, DWORD PTR [ebx+1]
  015f9	89 86 f8 00 00
	00		 mov	 DWORD PTR [esi+248], eax

; 1644 :                 Sparks(NS).Type = ISPARK_Move; //

  015ff	c6 04 df 25	 mov	 BYTE PTR [edi+ebx*8], 37 ; 00000025H

; 1645 :                 Sparks(NS).X = UMask & (ThisSpark->X + (SpeedRand()&31));

  01603	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  01609	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  0160f	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  01615	83 c2 04	 add	 edx, 4
  01618	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  0161e	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  01624	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  0162a	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  01630	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  01636	8a 4c ef 02	 mov	 cl, BYTE PTR [edi+ebp*8+2]
  0163a	8a 96 c8 00 00
	00		 mov	 dl, BYTE PTR [esi+200]
  01640	24 1f		 and	 al, 31			; 0000001fH
  01642	02 c1		 add	 al, cl
  01644	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  0164a	22 c2		 and	 al, dl
  0164c	88 44 d9 02	 mov	 BYTE PTR [ecx+ebx*8+2], al

; 1646 :                 Sparks(NS).Y = VMask & (ThisSpark->Y + (SpeedRand()&31));

  01650	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  01656	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  0165c	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  01662	83 c2 04	 add	 edx, 4
  01665	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  0166b	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  01671	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  01677	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  0167d	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  01683	8a 54 ef 03	 mov	 dl, BYTE PTR [edi+ebp*8+3]
  01687	8a 8e cc 00 00
	00		 mov	 cl, BYTE PTR [esi+204]
  0168d	24 1f		 and	 al, 31			; 0000001fH
  0168f	02 c2		 add	 al, dl
  01691	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  01697	22 c1		 and	 al, cl
  01699	88 44 da 03	 mov	 BYTE PTR [edx+ebx*8+3], al

; 1647 :                 Sparks(NS).ByteA = ThisSpark->ByteA; // X speed

  0169d	8b 86 fc 00 00
	00		 mov	 eax, DWORD PTR [esi+252]
  016a3	8a 4c ef 04	 mov	 cl, BYTE PTR [edi+ebp*8+4]
  016a7	88 4c d8 04	 mov	 BYTE PTR [eax+ebx*8+4], cl

; 1648 :                 Sparks(NS).ByteB = ThisSpark->ByteB; // Y speed

  016ab	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  016b1	8a 44 ef 05	 mov	 al, BYTE PTR [edi+ebp*8+5]
  016b5	88 44 da 05	 mov	 BYTE PTR [edx+ebx*8+5], al

; 1649 :                 Sparks(NS).ByteC = ThisSpark->ByteD; // timer==heat

  016b9	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  016bf	8a 54 ef 07	 mov	 dl, BYTE PTR [edi+ebp*8+7]
  016c3	88 54 d9 06	 mov	 BYTE PTR [ecx+ebx*8+6], dl
$L124135:

; 1650 :             }
; 1651 : 
; 1652 :             // Move around a bit.
; 1653 :             ThisSpark->X = UMask & (ThisSpark->X+(SpeedRand()&7)-(SpeedRand()&7));

  016c7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  016cd	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  016d3	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  016d9	83 c2 04	 add	 edx, 4
  016dc	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  016e2	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  016e8	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  016ee	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  016f4	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  016fa	8a d8		 mov	 bl, al
  016fc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  01702	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  01708	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  0170e	83 c2 04	 add	 edx, 4
  01711	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  01717	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  0171d	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  01723	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  01729	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  0172f	8a 4c ef 02	 mov	 cl, BYTE PTR [edi+ebp*8+2]
  01733	24 07		 and	 al, 7
  01735	80 e3 07	 and	 bl, 7
  01738	2a d8		 sub	 bl, al
  0173a	8a 86 c8 00 00
	00		 mov	 al, BYTE PTR [esi+200]
  01740	02 d9		 add	 bl, cl
  01742	22 d8		 and	 bl, al
  01744	88 5c ef 02	 mov	 BYTE PTR [edi+ebp*8+2], bl

; 1654 :             ThisSpark->Y = VMask & (ThisSpark->Y+(SpeedRand()&7)-(SpeedRand()&7));

  01748	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  0174e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  01754	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  0175a	83 c2 04	 add	 edx, 4
  0175d	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  01763	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  01769	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  0176f	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  01775	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  0177b	8a d8		 mov	 bl, al
  0177d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  01783	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  01789	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  0178f	83 c2 04	 add	 edx, 4
  01792	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  01798	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  0179e	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  017a4	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  017aa	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax

; 1655 :             break;

  017b0	e9 ff 02 00 00	 jmp	 $L133700
$L124137:

; 1656 : 
; 1657 : 		case SPARK_LocalCloud: // Custom clouds that move at DrawByteA's speed.
; 1658 :             if( (ActiveSparkNum < (SparksLimit)) )

  017b5	3b 9e f4 00 00
	00		 cmp	 ebx, DWORD PTR [esi+244]
  017bb	0f 8d 90 19 00
	00		 jge	 $L124014

; 1659 :             {
; 1660 :                 // create it..
; 1661 :                 INT  NS = ActiveSparkNum++;

  017c1	8d 43 01	 lea	 eax, DWORD PTR [ebx+1]
  017c4	89 86 f8 00 00
	00		 mov	 DWORD PTR [esi+248], eax

; 1662 :                 Sparks(NS).Type = ISPARK_Move; //

  017ca	c6 04 df 25	 mov	 BYTE PTR [edi+ebx*8], 37 ; 00000025H

; 1663 : 				Sparks(NS).X = UMask & (ThisSpark->X + ((SpeedRand() * ThisSpark->ByteC) >> 8));

  017ce	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  017d4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  017da	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  017e0	83 c2 04	 add	 edx, 4
  017e3	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  017e9	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  017ef	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  017f5	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  017fb	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  01801	33 d2		 xor	 edx, edx
  01803	8a 54 ef 06	 mov	 dl, BYTE PTR [edi+ebp*8+6]
  01807	88 44 24 3c	 mov	 BYTE PTR $T133043[esp+92], al
  0180b	8b 4c 24 3c	 mov	 ecx, DWORD PTR $T133043[esp+92]
  0180f	8a 86 c8 00 00
	00		 mov	 al, BYTE PTR [esi+200]
  01815	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0181b	0f af ca	 imul	 ecx, edx
  0181e	8a 54 ef 02	 mov	 dl, BYTE PTR [edi+ebp*8+2]
  01822	c1 f9 08	 sar	 ecx, 8
  01825	02 ca		 add	 cl, dl
  01827	22 c8		 and	 cl, al
  01829	8b 86 fc 00 00
	00		 mov	 eax, DWORD PTR [esi+252]
  0182f	88 4c d8 02	 mov	 BYTE PTR [eax+ebx*8+2], cl

; 1664 : 				Sparks(NS).Y = VMask & (ThisSpark->Y + ((SpeedRand() * ThisSpark->ByteC) >> 8));

  01833	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  01839	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  0183f	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  01845	83 c2 04	 add	 edx, 4
  01848	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  0184e	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  01854	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  0185a	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  01860	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  01866	33 d2		 xor	 edx, edx
  01868	8a 54 ef 06	 mov	 dl, BYTE PTR [edi+ebp*8+6]
  0186c	88 44 24 40	 mov	 BYTE PTR $T133050[esp+92], al
  01870	8b 4c 24 40	 mov	 ecx, DWORD PTR $T133050[esp+92]
  01874	8a 86 cc 00 00
	00		 mov	 al, BYTE PTR [esi+204]
  0187a	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  01880	0f af ca	 imul	 ecx, edx
  01883	8a 54 ef 03	 mov	 dl, BYTE PTR [edi+ebp*8+3]
  01887	c1 f9 08	 sar	 ecx, 8
  0188a	02 ca		 add	 cl, dl
  0188c	22 c8		 and	 cl, al
  0188e	8b 86 fc 00 00
	00		 mov	 eax, DWORD PTR [esi+252]
  01894	88 4c d8 03	 mov	 BYTE PTR [eax+ebx*8+3], cl

; 1665 :                 Sparks(NS).ByteA = ThisSpark->ByteA;  

  01898	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  0189e	8a 54 ef 04	 mov	 dl, BYTE PTR [edi+ebp*8+4]
  018a2	88 54 d9 04	 mov	 BYTE PTR [ecx+ebx*8+4], dl

; 1666 :                 Sparks(NS).ByteB = ThisSpark->ByteB; 

  018a6	8b 86 fc 00 00
	00		 mov	 eax, DWORD PTR [esi+252]
  018ac	8a 4c ef 05	 mov	 cl, BYTE PTR [edi+ebp*8+5]
  018b0	88 4c d8 05	 mov	 BYTE PTR [eax+ebx*8+5], cl

; 1667 :                 Sparks(NS).ByteC = ThisSpark->ByteD; // timer==heat

  018b4	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  018ba	8a 44 ef 07	 mov	 al, BYTE PTR [edi+ebp*8+7]
  018be	88 44 da 06	 mov	 BYTE PTR [edx+ebx*8+6], al

; 1668 :             }
; 1669 :             break;

  018c2	e9 8a 18 00 00	 jmp	 $L124014
$L124140:

; 1670 : 
; 1671 :         case SPARK_Flocks: // CLOUDS that move at DrawByteA's speed...
; 1672 :             if( (ActiveSparkNum < (SparksLimit)) )

  018c7	3b 9e f4 00 00
	00		 cmp	 ebx, DWORD PTR [esi+244]
  018cd	0f 8d f8 00 00
	00		 jge	 $L124141

; 1673 :             {
; 1674 :                 // Create it..
; 1675 :                 INT  NS = ActiveSparkNum++;

  018d3	8d 4b 01	 lea	 ecx, DWORD PTR [ebx+1]
  018d6	89 8e f8 00 00
	00		 mov	 DWORD PTR [esi+248], ecx

; 1676 :                 Sparks(NS).Type  = ISPARK_SpawnedTwirl;

  018dc	c6 04 df 27	 mov	 BYTE PTR [edi+ebx*8], 39 ; 00000027H

; 1677 :                 Sparks(NS).X     = UMask & (ThisSpark->X + (SpeedRand()&31));

  018e0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  018e6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  018ec	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  018f2	83 c2 04	 add	 edx, 4
  018f5	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  018fb	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  01901	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  01907	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  0190d	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  01913	8a 4c ef 02	 mov	 cl, BYTE PTR [edi+ebp*8+2]
  01917	8a 96 c8 00 00
	00		 mov	 dl, BYTE PTR [esi+200]
  0191d	24 1f		 and	 al, 31			; 0000001fH
  0191f	02 c1		 add	 al, cl
  01921	22 c2		 and	 al, dl
  01923	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  01929	88 44 da 02	 mov	 BYTE PTR [edx+ebx*8+2], al

; 1678 :                 Sparks(NS).Y     = VMask & (ThisSpark->Y + (SpeedRand()&31));

  0192d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  01933	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  01939	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  0193f	83 c2 04	 add	 edx, 4
  01942	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  01948	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  0194e	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  01954	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  0195a	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  01960	8a 54 ef 03	 mov	 dl, BYTE PTR [edi+ebp*8+3]
  01964	8a 8e cc 00 00
	00		 mov	 cl, BYTE PTR [esi+204]
  0196a	24 1f		 and	 al, 31			; 0000001fH
  0196c	02 c2		 add	 al, dl
  0196e	22 c1		 and	 al, cl
  01970	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  01976	88 44 d9 03	 mov	 BYTE PTR [ecx+ebx*8+3], al

; 1679 : 				Sparks(NS).ByteB = ThisSpark->ByteA;  // Initial direction.

  0197a	8a 44 ef 04	 mov	 al, BYTE PTR [edi+ebp*8+4]
  0197e	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  01984	88 44 da 05	 mov	 BYTE PTR [edx+ebx*8+5], al

; 1680 : 				Sparks(NS).ByteA=0;                 // low byte

  01988	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  0198e	c6 44 d9 04 00	 mov	 BYTE PTR [ecx+ebx*8+4], 0

; 1681 :                 Sparks(NS).ByteC = ThisSpark->ByteB;  // Timer / Size 

  01993	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  01999	8a 44 ef 05	 mov	 al, BYTE PTR [edi+ebp*8+5]
  0199d	88 44 da 06	 mov	 BYTE PTR [edx+ebx*8+6], al

; 1682 : 				Sparks(NS).ByteD = ThisSpark->ByteD;  // Angle delta

  019a1	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  019a7	8a 54 ef 07	 mov	 dl, BYTE PTR [edi+ebp*8+7]
  019ab	88 54 d9 07	 mov	 BYTE PTR [ecx+ebx*8+7], dl

; 1683 : 				Sparks(NS).Heat  = ThisSpark->Heat;

  019af	8b 86 fc 00 00
	00		 mov	 eax, DWORD PTR [esi+252]
  019b5	8a 4c ef 01	 mov	 cl, BYTE PTR [edi+ebp*8+1]
  019b9	88 4c d8 01	 mov	 BYTE PTR [eax+ebx*8+1], cl

; 1684 : 
; 1685 : 				//if( SpeedRand()<1 ) 
; 1686 : 				//	ThisSpark->ByteA = SpeedRand(); // change about every XX sparks
; 1687 : 				//else
; 1688 : 				ThisSpark->ByteA += ThisSpark->ByteC; // Turn spawn direction.

  019bd	8a 44 ef 04	 mov	 al, BYTE PTR [edi+ebp*8+4]
  019c1	8a 54 ef 06	 mov	 dl, BYTE PTR [edi+ebp*8+6]
  019c5	02 c2		 add	 al, dl
  019c7	88 44 ef 04	 mov	 BYTE PTR [edi+ebp*8+4], al
$L124141:

; 1689 :             }
; 1690 :             // move around a bit
; 1691 :             ThisSpark->X = UMask & ( ThisSpark->X + (SpeedRand()&7) - (SpeedRand()&7) );

  019cb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  019d1	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  019d7	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  019dd	83 c2 04	 add	 edx, 4
  019e0	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  019e6	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  019ec	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  019f2	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  019f8	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  019fe	8a d8		 mov	 bl, al
  01a00	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  01a06	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  01a0c	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  01a12	83 c2 04	 add	 edx, 4
  01a15	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  01a1b	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  01a21	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  01a27	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  01a2d	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  01a33	8a 4c ef 02	 mov	 cl, BYTE PTR [edi+ebp*8+2]
  01a37	24 07		 and	 al, 7
  01a39	80 e3 07	 and	 bl, 7
  01a3c	2a d8		 sub	 bl, al
  01a3e	8a 86 c8 00 00
	00		 mov	 al, BYTE PTR [esi+200]
  01a44	02 d9		 add	 bl, cl
  01a46	22 d8		 and	 bl, al
  01a48	88 5c ef 02	 mov	 BYTE PTR [edi+ebp*8+2], bl

; 1692 :             ThisSpark->Y = VMask & ( ThisSpark->Y + (SpeedRand()&7) - (SpeedRand()&7) );

  01a4c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  01a52	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  01a58	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  01a5e	83 c2 04	 add	 edx, 4
  01a61	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  01a67	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  01a6d	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  01a73	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  01a79	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  01a7f	8a d8		 mov	 bl, al
  01a81	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  01a87	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  01a8d	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  01a93	83 c2 04	 add	 edx, 4
  01a96	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  01a9c	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  01aa2	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  01aa8	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  01aae	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
$L133700:
  01ab4	8a 4c ef 03	 mov	 cl, BYTE PTR [edi+ebp*8+3]
  01ab8	24 07		 and	 al, 7
  01aba	80 e3 07	 and	 bl, 7
  01abd	8d 7c ef 03	 lea	 edi, DWORD PTR [edi+ebp*8+3]
  01ac1	2a d8		 sub	 bl, al
  01ac3	8a 86 cc 00 00
	00		 mov	 al, BYTE PTR [esi+204]
  01ac9	02 d9		 add	 bl, cl
  01acb	22 d8		 and	 bl, al
  01acd	88 1f		 mov	 BYTE PTR [edi], bl

; 1693 :             break;

  01acf	e9 7d 16 00 00	 jmp	 $L124014
$L124143:

; 1694 : 
; 1695 : 		case SPARK_Wheel:  // CLOUDS that move at DrawByteA's speed.
; 1696 :             if( (ActiveSparkNum < (SparksLimit)) )

  01ad4	3b 9e f4 00 00
	00		 cmp	 ebx, DWORD PTR [esi+244]
  01ada	7d 6c		 jge	 SHORT $L124144

; 1697 :             {   // Create it..
; 1698 :                 INT  NS = ActiveSparkNum++;

  01adc	8d 43 01	 lea	 eax, DWORD PTR [ebx+1]
  01adf	89 86 f8 00 00
	00		 mov	 DWORD PTR [esi+248], eax

; 1699 :                 Sparks(NS).Type = ISPARK_SpawnedTwirl;

  01ae5	c6 04 df 27	 mov	 BYTE PTR [edi+ebx*8], 39 ; 00000027H

; 1700 :                 Sparks(NS).X = ThisSpark->X ;

  01ae9	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  01aef	8a 54 ef 02	 mov	 dl, BYTE PTR [edi+ebp*8+2]
  01af3	88 54 d9 02	 mov	 BYTE PTR [ecx+ebx*8+2], dl

; 1701 :                 Sparks(NS).Y = ThisSpark->Y ;

  01af7	8b 86 fc 00 00
	00		 mov	 eax, DWORD PTR [esi+252]
  01afd	8a 4c ef 03	 mov	 cl, BYTE PTR [edi+ebp*8+3]
  01b01	88 4c d8 03	 mov	 BYTE PTR [eax+ebx*8+3], cl

; 1702 :                 Sparks(NS).ByteB  = ThisSpark->ByteA;      // Initial Direction.

  01b05	8a 44 ef 04	 mov	 al, BYTE PTR [edi+ebp*8+4]
  01b09	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  01b0f	88 44 da 05	 mov	 BYTE PTR [edx+ebx*8+5], al

; 1703 : 				Sparks(NS).ByteA =0;                     // low byte

  01b13	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  01b19	c6 44 d9 04 00	 mov	 BYTE PTR [ecx+ebx*8+4], 0

; 1704 :                 Sparks(NS).ByteC  = ThisSpark->ByteB;      // Timer/ Size

  01b1e	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  01b24	8a 44 ef 05	 mov	 al, BYTE PTR [edi+ebp*8+5]
  01b28	88 44 da 06	 mov	 BYTE PTR [edx+ebx*8+6], al

; 1705 : 				Sparks(NS).ByteD  = ThisSpark->ByteD;      // 2 << 3 ; //ThisSpark->ByteD;      // Angle delta.

  01b2c	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  01b32	8a 54 ef 07	 mov	 dl, BYTE PTR [edi+ebp*8+7]
  01b36	88 54 d9 07	 mov	 BYTE PTR [ecx+ebx*8+7], dl

; 1706 : 				Sparks(NS).Heat   = ThisSpark->Heat;

  01b3a	8b 86 fc 00 00
	00		 mov	 eax, DWORD PTR [esi+252]
  01b40	8a 4c ef 01	 mov	 cl, BYTE PTR [edi+ebp*8+1]
  01b44	88 4c d8 01	 mov	 BYTE PTR [eax+ebx*8+1], cl
$L124144:

; 1707 :             }
; 1708 : 			ThisSpark->ByteA += ThisSpark->ByteC;      // Turn spawn direction.

  01b48	8a 4c ef 04	 mov	 cl, BYTE PTR [edi+ebp*8+4]
  01b4c	8a 54 ef 06	 mov	 dl, BYTE PTR [edi+ebp*8+6]
  01b50	8d 44 ef 04	 lea	 eax, DWORD PTR [edi+ebp*8+4]
  01b54	02 ca		 add	 cl, dl

; 2005 : 
; 2006 : 				// Advance position.
; 2007 :                 MoveSparkXY( ThisSpark, TempSpeedX, TempSpeedY ); 

  01b56	88 08		 mov	 BYTE PTR [eax], cl

; 2008 :             }
; 2009 :             else // Delete the spark.

  01b58	e9 f4 15 00 00	 jmp	 $L124014
$L124146:

; 1709 :             break;
; 1710 : 
; 1711 : 		case SPARK_Sprinkler:  
; 1712 :             if( (ActiveSparkNum < (SparksLimit)) )

  01b5d	3b 9e f4 00 00
	00		 cmp	 ebx, DWORD PTR [esi+244]
  01b63	7d 6c		 jge	 SHORT $L124147

; 1713 :             {   // Create it..
; 1714 :                 INT  NS = ActiveSparkNum++;

  01b65	8d 43 01	 lea	 eax, DWORD PTR [ebx+1]
  01b68	89 86 f8 00 00
	00		 mov	 DWORD PTR [esi+248], eax

; 1715 :                 Sparks(NS).Type = ISPARK_SprinklerTwirl;

  01b6e	c6 04 df 28	 mov	 BYTE PTR [edi+ebx*8], 40 ; 00000028H

; 1716 :                 Sparks(NS).X = ThisSpark->X ;

  01b72	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  01b78	8a 54 ef 02	 mov	 dl, BYTE PTR [edi+ebp*8+2]
  01b7c	88 54 d9 02	 mov	 BYTE PTR [ecx+ebx*8+2], dl

; 1717 :                 Sparks(NS).Y = ThisSpark->Y ;

  01b80	8b 86 fc 00 00
	00		 mov	 eax, DWORD PTR [esi+252]
  01b86	8a 4c ef 03	 mov	 cl, BYTE PTR [edi+ebp*8+3]
  01b8a	88 4c d8 03	 mov	 BYTE PTR [eax+ebx*8+3], cl

; 1718 : 				Sparks(NS).Heat = ThisSpark->Heat;

  01b8e	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  01b94	8a 44 ef 01	 mov	 al, BYTE PTR [edi+ebp*8+1]
  01b98	88 44 da 01	 mov	 BYTE PTR [edx+ebx*8+1], al

; 1719 :                 Sparks(NS).ByteA  = ThisSpark->ByteA;      // Initial Direction.

  01b9c	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  01ba2	8a 54 ef 04	 mov	 dl, BYTE PTR [edi+ebp*8+4]
  01ba6	88 54 d9 04	 mov	 BYTE PTR [ecx+ebx*8+4], dl

; 1720 :                 Sparks(NS).ByteB  = ThisSpark->ByteB;      // 

  01baa	8b 86 fc 00 00
	00		 mov	 eax, DWORD PTR [esi+252]
  01bb0	8a 4c ef 05	 mov	 cl, BYTE PTR [edi+ebp*8+5]
  01bb4	88 4c d8 05	 mov	 BYTE PTR [eax+ebx*8+5], cl

; 1721 : 				Sparks(NS).ByteC  = ThisSpark->ByteC;

  01bb8	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  01bbe	8a 44 ef 06	 mov	 al, BYTE PTR [edi+ebp*8+6]
  01bc2	88 44 da 06	 mov	 BYTE PTR [edx+ebx*8+6], al

; 1722 : 				Sparks(NS).ByteD  = 2; //ThisSpark->ByteD;      // Angle delta.

  01bc6	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  01bcc	c6 44 d9 07 02	 mov	 BYTE PTR [ecx+ebx*8+7], 2
$L124147:

; 1723 :             }
; 1724 : 			ThisSpark->ByteA += ThisSpark->ByteD;      // Turn spawn direction.

  01bd1	8a 4c ef 04	 mov	 cl, BYTE PTR [edi+ebp*8+4]
  01bd5	8a 54 ef 07	 mov	 dl, BYTE PTR [edi+ebp*8+7]
  01bd9	8d 44 ef 04	 lea	 eax, DWORD PTR [edi+ebp*8+4]
  01bdd	02 ca		 add	 cl, dl

; 2005 : 
; 2006 : 				// Advance position.
; 2007 :                 MoveSparkXY( ThisSpark, TempSpeedX, TempSpeedY ); 

  01bdf	88 08		 mov	 BYTE PTR [eax], cl

; 2008 :             }
; 2009 :             else // Delete the spark.

  01be1	e9 6b 15 00 00	 jmp	 $L124014
$L124149:

; 1725 :             break;
; 1726 : 
; 1727 :         case SPARK_Stars: // FIXED STARS ! dim according to fire Intensity..
; 1728 : 			{
; 1729 :             // called here just BEFORE update: so RESTORE original pixel.
; 1730 :             // ByteA has the star itself, ByteB the saved bckgrnd
; 1731 : 				DWORD SparkDest = (DWORD)(ThisSpark->X + (ThisSpark->Y << UBits ));

  01be6	8a 4e 30	 mov	 cl, BYTE PTR [esi+48]

; 1732 : 				Mips(0).DataArray(SparkDest) = ThisSpark->ByteB;

  01be9	33 c0		 xor	 eax, eax
  01beb	8a 44 ef 03	 mov	 al, BYTE PTR [edi+ebp*8+3]
  01bef	d3 e0		 shl	 eax, cl
  01bf1	8b 8e a8 00 00
	00		 mov	 ecx, DWORD PTR [esi+168]
  01bf7	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  01bfa	8a 4c ef 05	 mov	 cl, BYTE PTR [edi+ebp*8+5]
  01bfe	03 c2		 add	 eax, edx
  01c00	33 d2		 xor	 edx, edx
  01c02	8a 54 ef 02	 mov	 dl, BYTE PTR [edi+ebp*8+2]
  01c06	88 0c 10	 mov	 BYTE PTR [eax+edx], cl

; 1733 : 			}
; 1734 :             break;

  01c09	e9 43 15 00 00	 jmp	 $L124014
$L124152:

; 1735 : 
; 1736 :         case SPARK_LineLightning:     // Emitting lightning - random bursts, FIXED locations.
; 1737 :             if( ThisSpark->Heat == 0 ) // Too-small bolts have Heat 0

  01c0e	8a 44 ef 01	 mov	 al, BYTE PTR [edi+ebp*8+1]
  01c12	84 c0		 test	 al, al
  01c14	8d 4c ef 01	 lea	 ecx, DWORD PTR [edi+ebp*8+1]
  01c18	0f 84 33 15 00
	00		 je	 $L124014

; 1738 :                 break;
; 1739 :             // Flash in progress ?
; 1740 :             if( ThisSpark->ByteC  > 0 )

  01c1e	8a 44 ef 06	 mov	 al, BYTE PTR [edi+ebp*8+6]
  01c22	84 c0		 test	 al, al
  01c24	8d 5c ef 06	 lea	 ebx, DWORD PTR [edi+ebp*8+6]
  01c28	76 41		 jbe	 SHORT $L124154

; 1741 :             {
; 1742 :                 ThisSpark->ByteC--;  // Countdown effect
; 1743 :                 LineSeg LL;
; 1744 :                 LL.Xlen = ThisSpark->ByteA;
; 1745 :                 LL.Ylen = ThisSpark->ByteB;
; 1746 :                 LL.Xpos = ThisSpark->X;
; 1747 :                 LL.Ypos = ThisSpark->Y;
; 1748 : 				BYTE HeatA = ThisSpark->Heat;

  01c2a	8a 09		 mov	 cl, BYTE PTR [ecx]
  01c2c	8a 54 ef 04	 mov	 dl, BYTE PTR [edi+ebp*8+4]
  01c30	fe c8		 dec	 al
  01c32	88 03		 mov	 BYTE PTR [ebx], al
  01c34	8a 44 ef 05	 mov	 al, BYTE PTR [edi+ebp*8+5]
  01c38	88 44 24 1f	 mov	 BYTE PTR _LL$124155[esp+95], al
  01c3c	8a 44 ef 03	 mov	 al, BYTE PTR [edi+ebp*8+3]
  01c40	88 4c 24 44	 mov	 BYTE PTR _HeatA$124156[esp+92], cl
  01c44	88 44 24 1d	 mov	 BYTE PTR _LL$124155[esp+93], al

; 1749 : 				DrawFlashRamp(LL, HeatA, HeatA);

  01c48	8b 44 24 44	 mov	 eax, DWORD PTR _HeatA$124156[esp+92]
  01c4c	88 54 24 1e	 mov	 BYTE PTR _LL$124155[esp+94], dl
  01c50	8a 54 ef 02	 mov	 dl, BYTE PTR [edi+ebp*8+2]
  01c54	50		 push	 eax
  01c55	88 54 24 20	 mov	 BYTE PTR _LL$124155[esp+96], dl
  01c59	8b 54 24 20	 mov	 edx, DWORD PTR _LL$124155[esp+96]
  01c5d	50		 push	 eax
  01c5e	52		 push	 edx
  01c5f	8b ce		 mov	 ecx, esi
  01c61	e8 00 00 00 00	 call	 ?DrawFlashRamp@UFireTexture@@AAEXULineSeg@@EE@Z ; UFireTexture::DrawFlashRamp

; 1750 :             }
; 1751 :             else

  01c66	e9 e6 14 00 00	 jmp	 $L124014
$L124154:

; 1752 :             if( SpeedRand() >= ThisSpark->ByteD )

  01c6b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  01c71	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  01c77	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  01c7d	83 c2 04	 add	 edx, 4
  01c80	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  01c86	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  01c8c	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  01c92	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  01c98	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  01c9e	3a 44 ef 07	 cmp	 al, BYTE PTR [edi+ebp*8+7]
  01ca2	0f 82 a9 14 00
	00		 jb	 $L124014

; 1753 :             // Initiate new flash ?
; 1754 :             {
; 1755 :                 ThisSpark->ByteC = 1+ SpeedRand() & 5;

  01ca8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  01cae	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  01cb4	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  01cba	83 c2 04	 add	 edx, 4
  01cbd	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  01cc3	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  01cc9	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  01ccf	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  01cd5	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  01cdb	fe c0		 inc	 al
  01cdd	24 05		 and	 al, 5

; 1827 :                 // Advance position.
; 1828 :                 MoveSpark( ThisSpark );

  01cdf	88 03		 mov	 BYTE PTR [ebx], al

; 1829 :                 // No gravity.
; 1830 :             }
; 1831 :             else  // Delete the spark.
; 1832 : 				*ThisSpark = Sparks(--ActiveSparkNum);
; 1833 :             break;

  01ce1	e9 6b 14 00 00	 jmp	 $L124014
$L124159:

; 1756 :             }
; 1757 :             break;
; 1758 : 
; 1759 :         case SPARK_RampLightning:     // Emitting lightning - random bursts, FIXED locations.
; 1760 :             if( ThisSpark->Heat == 0 ) // Too-small bolts have heat 0

  01ce6	8a 44 ef 01	 mov	 al, BYTE PTR [edi+ebp*8+1]
  01cea	84 c0		 test	 al, al
  01cec	8d 4c ef 01	 lea	 ecx, DWORD PTR [edi+ebp*8+1]
  01cf0	0f 84 5b 14 00
	00		 je	 $L124014

; 1761 :                 break;
; 1762 :             // Flash in progress ?
; 1763 :             if( ThisSpark->ByteC  > 0 )

  01cf6	8a 44 ef 06	 mov	 al, BYTE PTR [edi+ebp*8+6]
  01cfa	84 c0		 test	 al, al
  01cfc	8d 5c ef 06	 lea	 ebx, DWORD PTR [edi+ebp*8+6]
  01d00	76 46		 jbe	 SHORT $L124161

; 1764 :             {
; 1765 :                 ThisSpark->ByteC--; // Countdown.
; 1766 :                 LineSeg LL;
; 1767 :                 LL.Xlen = ThisSpark->ByteA;
; 1768 :                 LL.Ylen = ThisSpark->ByteB;

  01d02	8a 54 ef 05	 mov	 dl, BYTE PTR [edi+ebp*8+5]
  01d06	fe c8		 dec	 al
  01d08	88 03		 mov	 BYTE PTR [ebx], al
  01d0a	8a 44 ef 04	 mov	 al, BYTE PTR [edi+ebp*8+4]
  01d0e	88 44 24 22	 mov	 BYTE PTR _LL$124162[esp+94], al

; 1769 :                 LL.Xpos = ThisSpark->X;

  01d12	8a 44 ef 02	 mov	 al, BYTE PTR [edi+ebp*8+2]
  01d16	88 44 24 20	 mov	 BYTE PTR _LL$124162[esp+92], al

; 1770 :                 LL.Ypos = ThisSpark->Y;
; 1771 : 				BYTE HeatA = ThisSpark->Heat;
; 1772 : 				BYTE HeatB = HeatA >> 3;
; 1773 :                 DrawFlashRamp( LL, HeatA, HeatB);

  01d1a	33 c0		 xor	 eax, eax
  01d1c	8a 01		 mov	 al, BYTE PTR [ecx]
  01d1e	88 44 24 48	 mov	 BYTE PTR _HeatA$124163[esp+92], al
  01d22	c0 e8 03	 shr	 al, 3
  01d25	88 54 24 23	 mov	 BYTE PTR _LL$124162[esp+95], dl
  01d29	8a 54 ef 03	 mov	 dl, BYTE PTR [edi+ebp*8+3]
  01d2d	88 54 24 21	 mov	 BYTE PTR _LL$124162[esp+93], dl
  01d31	8b 4c 24 20	 mov	 ecx, DWORD PTR _LL$124162[esp+92]
  01d35	50		 push	 eax
  01d36	8b 44 24 4c	 mov	 eax, DWORD PTR _HeatA$124163[esp+96]
  01d3a	50		 push	 eax
  01d3b	51		 push	 ecx
  01d3c	8b ce		 mov	 ecx, esi
  01d3e	e8 00 00 00 00	 call	 ?DrawFlashRamp@UFireTexture@@AAEXULineSeg@@EE@Z ; UFireTexture::DrawFlashRamp

; 1774 :             }
; 1775 :             else

  01d43	e9 09 14 00 00	 jmp	 $L124014
$L124161:

; 1776 :             if( SpeedRand() >= ThisSpark->ByteD )

  01d48	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  01d4e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  01d54	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  01d5a	83 c2 04	 add	 edx, 4
  01d5d	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  01d63	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  01d69	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  01d6f	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  01d75	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  01d7b	3a 44 ef 07	 cmp	 al, BYTE PTR [edi+ebp*8+7]
  01d7f	0f 82 cc 13 00
	00		 jb	 $L124014

; 1777 :             // Initiate new flash ?
; 1778 :             {
; 1779 :                 ThisSpark->ByteC = 1 + SpeedRand() & 5;

  01d85	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  01d8b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  01d91	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  01d97	83 c2 04	 add	 edx, 4
  01d9a	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  01da0	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  01da6	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  01dac	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  01db2	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  01db8	fe c0		 inc	 al
  01dba	24 05		 and	 al, 5

; 1827 :                 // Advance position.
; 1828 :                 MoveSpark( ThisSpark );

  01dbc	88 03		 mov	 BYTE PTR [ebx], al

; 1829 :                 // No gravity.
; 1830 :             }
; 1831 :             else  // Delete the spark.
; 1832 : 				*ThisSpark = Sparks(--ActiveSparkNum);
; 1833 :             break;

  01dbe	e9 8e 13 00 00	 jmp	 $L124014
$L124167:

; 1780 :             }
; 1781 :             break;
; 1782 : 
; 1783 :         case SPARK_SphereLightning: // Radial lightning from source point.
; 1784 :             if( SpeedRand() >= ThisSpark->ByteD ) // Frequency.

  01dc3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  01dc9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  01dcf	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  01dd5	83 c2 04	 add	 edx, 4
  01dd8	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  01dde	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  01de4	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  01dea	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  01df0	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  01df6	3a 44 ef 07	 cmp	 al, BYTE PTR [edi+ebp*8+7]
  01dfa	0f 82 51 13 00
	00		 jb	 $L124014

; 1785 :             {
; 1786 :                 INT  SparkAngle = SpeedRand();

  01e00	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  01e06	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  01e0c	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  01e12	83 c2 04	 add	 edx, 4
  01e15	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  01e1b	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  01e21	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  01e27	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  01e2d	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax

; 1787 :                 INT  Radius = ThisSpark->ByteC;
; 1788 : 
; 1789 : 				BYTE  Col1 = ThisSpark->Heat;

  01e33	8a 4c ef 01	 mov	 cl, BYTE PTR [edi+ebp*8+1]
  01e37	88 44 24 4c	 mov	 BYTE PTR $T133188[esp+92], al
  01e3b	8b 5c 24 4c	 mov	 ebx, DWORD PTR $T133188[esp+92]
  01e3f	33 c0		 xor	 eax, eax
  01e41	8a 44 ef 06	 mov	 al, BYTE PTR [edi+ebp*8+6]
  01e45	88 4c 24 54	 mov	 BYTE PTR _Col1$124171[esp+92], cl

; 1790 : 				BYTE  Col2 = ThisSpark->Heat >> 2; // Taper off to (relative) darkness.

  01e49	c0 e9 02	 shr	 cl, 2
  01e4c	88 4c 24 50	 mov	 BYTE PTR _Col2$124172[esp+92], cl

; 1791 : 
; 1792 :                 INT  SdispX = ( Radius * ( (INT)PhaseTable[SparkAngle] ) ) >> 8;
; 1793 :                 INT  SdispY = ( Radius * ( (INT)PhaseTable[(SparkAngle+64) & 255] ) ) >> 8;
; 1794 : 
; 1795 :   				LineSeg LL;
; 1796 : 
; 1797 :                 INT  Xlen =  (INT)SdispX - (INT)(Radius/2);

  01e50	33 c9		 xor	 ecx, ecx
  01e52	81 e3 ff 00 00
	00		 and	 ebx, 255		; 000000ffH
  01e58	8a 8b 00 00 00
	00		 mov	 cl, BYTE PTR _PhaseTable[ebx]
  01e5e	89 44 24 18	 mov	 DWORD PTR _Radius$124170[esp+92], eax
  01e62	99		 cdq
  01e63	2b c2		 sub	 eax, edx

; 1798 :                 INT  Ylen =  (INT)SdispY - (INT)(Radius/2);

  01e65	33 d2		 xor	 edx, edx
  01e67	83 c3 40	 add	 ebx, 64			; 00000040H
  01e6a	0f af 4c 24 18	 imul	 ecx, DWORD PTR _Radius$124170[esp+92]
  01e6f	81 e3 ff 00 00
	00		 and	 ebx, 255		; 000000ffH
  01e75	8a 93 00 00 00
	00		 mov	 dl, BYTE PTR _PhaseTable[ebx]
  01e7b	d1 f8		 sar	 eax, 1
  01e7d	c1 f9 08	 sar	 ecx, 8
  01e80	2b c8		 sub	 ecx, eax
  01e82	0f af 54 24 18	 imul	 edx, DWORD PTR _Radius$124170[esp+92]
  01e87	c1 fa 08	 sar	 edx, 8
  01e8a	2b d0		 sub	 edx, eax

; 1799 : 
; 1800 : 				LL.Xpos = ThisSpark->X;
; 1801 : 				LL.Ypos = ThisSpark->Y;
; 1802 : 
; 1803 :                 // Cram the sign bit into the lsbit.
; 1804 : 				if( Xlen<=0 )   Xlen  = (- Xlen) | 1;

  01e8c	85 c9		 test	 ecx, ecx
  01e8e	8a 44 ef 02	 mov	 al, BYTE PTR [edi+ebp*8+2]
  01e92	88 44 24 24	 mov	 BYTE PTR _LL$124177[esp+92], al
  01e96	8a 44 ef 03	 mov	 al, BYTE PTR [edi+ebp*8+3]
  01e9a	88 44 24 25	 mov	 BYTE PTR _LL$124177[esp+93], al
  01e9e	7f 07		 jg	 SHORT $L124184
  01ea0	f7 d9		 neg	 ecx
  01ea2	83 c9 01	 or	 ecx, 1

; 1805 :                     else		Xlen &= 0xFFFFFFFE;

  01ea5	eb 03		 jmp	 SHORT $L124185
$L124184:
  01ea7	83 e1 fe	 and	 ecx, -2			; fffffffeH
$L124185:

; 1806 : 				if( Ylen<=0 )   Ylen  = (- Ylen) | 1;

  01eaa	85 d2		 test	 edx, edx
  01eac	7f 07		 jg	 SHORT $L124186
  01eae	f7 da		 neg	 edx
  01eb0	83 ca 01	 or	 edx, 1

; 1807 :                     else		Ylen &= 0xFFFFFFFE;

  01eb3	eb 03		 jmp	 SHORT $L124187
$L124186:
  01eb5	83 e2 fe	 and	 edx, -2			; fffffffeH
$L124187:

; 1808 : 
; 1809 : 				LL.Xlen = Xlen;

  01eb8	88 4c 24 26	 mov	 BYTE PTR _LL$124177[esp+94], cl

; 1810 : 				LL.Ylen = Ylen;
; 1811 : 
; 1812 :                 DrawFlashRamp( LL, Col1,Col2);

  01ebc	8b 4c 24 50	 mov	 ecx, DWORD PTR _Col2$124172[esp+92]
  01ec0	88 54 24 27	 mov	 BYTE PTR _LL$124177[esp+95], dl
  01ec4	8b 54 24 54	 mov	 edx, DWORD PTR _Col1$124171[esp+92]
  01ec8	8b 44 24 24	 mov	 eax, DWORD PTR _LL$124177[esp+92]
  01ecc	51		 push	 ecx
  01ecd	52		 push	 edx
  01ece	50		 push	 eax
  01ecf	8b ce		 mov	 ecx, esi
  01ed1	e8 00 00 00 00	 call	 ?DrawFlashRamp@UFireTexture@@AAEXULineSeg@@EE@Z ; UFireTexture::DrawFlashRamp

; 1813 :             }
; 1814 :             break;

  01ed6	e9 76 12 00 00	 jmp	 $L124014
$L124188:

; 1815 : 
; 1816 :         //
; 1817 :         //  Transient /spawned sparks, emitted by lower spark types.
; 1818 :         //
; 1819 : 
; 1820 :         //  Dynamic emitted sparks. General linear 'drifter', limited lifetime.
; 1821 :         case ISPARK_Drifter:
; 1822 :             if( (( ThisSpark->Heat -= 5 ) < 251 )  )  // Glow out fast.

  01edb	8a 54 ef 01	 mov	 dl, BYTE PTR [edi+ebp*8+1]
  01edf	80 c2 fb	 add	 dl, 251			; 000000fbH
  01ee2	8a c2		 mov	 al, dl
  01ee4	3c fb		 cmp	 al, 251			; 000000fbH
  01ee6	88 54 ef 01	 mov	 BYTE PTR [edi+ebp*8+1], dl
  01eea	0f 83 40 12 00
	00		 jae	 $L124256

; 1823 :             {
; 1824 :                 DWORD SparkDest = (DWORD) (ThisSpark->X + ( ThisSpark->Y << UBits ));
; 1825 :                 // Set spark.
; 1826 :                 Mips(0).DataArray(SparkDest) = ThisSpark->Heat;

  01ef0	33 c9		 xor	 ecx, ecx
  01ef2	8a 4c ef 03	 mov	 cl, BYTE PTR [edi+ebp*8+3]
  01ef6	8d 5c ef 03	 lea	 ebx, DWORD PTR [edi+ebp*8+3]
  01efa	8b d1		 mov	 edx, ecx
  01efc	8a 4e 30	 mov	 cl, BYTE PTR [esi+48]
  01eff	d3 e2		 shl	 edx, cl
  01f01	8b 8e a8 00 00
	00		 mov	 ecx, DWORD PTR [esi+168]
  01f07	03 51 1c	 add	 edx, DWORD PTR [ecx+28]
  01f0a	33 c9		 xor	 ecx, ecx
  01f0c	8a 4c ef 02	 mov	 cl, BYTE PTR [edi+ebp*8+2]
  01f10	88 04 0a	 mov	 BYTE PTR [edx+ecx], al

; 1827 :                 // Advance position.
; 1828 :                 MoveSpark( ThisSpark );

  01f13	8a 44 ef 04	 mov	 al, BYTE PTR [edi+ebp*8+4]
  01f17	84 c0		 test	 al, al
  01f19	7d 55		 jge	 SHORT $L133222
  01f1b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  01f21	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  01f27	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  01f2d	83 c2 04	 add	 edx, 4
  01f30	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  01f36	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  01f3c	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  01f42	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  01f48	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  01f4e	0f be 54 ef 04	 movsx	 edx, BYTE PTR [edi+ebp*8+4]
  01f53	f7 da		 neg	 edx
  01f55	83 e0 7f	 and	 eax, 127		; 0000007fH
  01f58	3b c2		 cmp	 eax, edx
  01f5a	7d 64		 jge	 SHORT $L133225
  01f5c	8a 44 ef 02	 mov	 al, BYTE PTR [edi+ebp*8+2]
  01f60	8a 8e c8 00 00
	00		 mov	 cl, BYTE PTR [esi+200]
  01f66	fe c8		 dec	 al
  01f68	22 c1		 and	 al, cl
  01f6a	88 44 ef 02	 mov	 BYTE PTR [edi+ebp*8+2], al
  01f6e	eb 50		 jmp	 SHORT $L133225
$L133222:
  01f70	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  01f76	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  01f7c	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  01f82	83 c2 04	 add	 edx, 4
  01f85	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  01f8b	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  01f91	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  01f97	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  01f9d	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  01fa3	8a 4c ef 04	 mov	 cl, BYTE PTR [edi+ebp*8+4]
  01fa7	83 e0 7f	 and	 eax, 127		; 0000007fH
  01faa	3a c1		 cmp	 al, cl
  01fac	7d 12		 jge	 SHORT $L133225
  01fae	8a 4c ef 02	 mov	 cl, BYTE PTR [edi+ebp*8+2]
  01fb2	8a 86 c8 00 00
	00		 mov	 al, BYTE PTR [esi+200]
  01fb8	fe c1		 inc	 cl
  01fba	22 c8		 and	 cl, al
  01fbc	88 4c ef 02	 mov	 BYTE PTR [edi+ebp*8+2], cl
$L133225:
  01fc0	8a 44 ef 05	 mov	 al, BYTE PTR [edi+ebp*8+5]
  01fc4	84 c0		 test	 al, al
  01fc6	8d 7c ef 05	 lea	 edi, DWORD PTR [edi+ebp*8+5]
  01fca	7d 56		 jge	 SHORT $L133226
  01fcc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  01fd2	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  01fd8	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  01fde	83 c2 04	 add	 edx, 4
  01fe1	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  01fe7	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  01fed	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  01ff3	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  01ff9	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  01fff	0f be 17	 movsx	 edx, BYTE PTR [edi]
  02002	f7 da		 neg	 edx
  02004	83 e0 7f	 and	 eax, 127		; 0000007fH
  02007	3b c2		 cmp	 eax, edx
  02009	0f 8d 42 11 00
	00		 jge	 $L124014
  0200f	8a 03		 mov	 al, BYTE PTR [ebx]
  02011	8a 8e cc 00 00
	00		 mov	 cl, BYTE PTR [esi+204]
  02017	fe c8		 dec	 al
  02019	22 c8		 and	 cl, al
  0201b	88 0b		 mov	 BYTE PTR [ebx], cl
  0201d	e9 2f 11 00 00	 jmp	 $L124014
$L133226:
  02022	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  02028	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  0202e	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  02034	83 c2 04	 add	 edx, 4
  02037	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  0203d	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  02043	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  02049	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  0204f	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
$L133694:
  02055	8a 0f		 mov	 cl, BYTE PTR [edi]
  02057	83 e0 7f	 and	 eax, 127		; 0000007fH
  0205a	3a c1		 cmp	 al, cl
  0205c	0f 8d ef 10 00
	00		 jge	 $L124014
  02062	8a 13		 mov	 dl, BYTE PTR [ebx]
  02064	8a 86 cc 00 00
	00		 mov	 al, BYTE PTR [esi+204]
  0206a	fe c2		 inc	 dl
  0206c	22 c2		 and	 al, dl
  0206e	88 03		 mov	 BYTE PTR [ebx], al

; 1829 :                 // No gravity.
; 1830 :             }
; 1831 :             else  // Delete the spark.
; 1832 : 				*ThisSpark = Sparks(--ActiveSparkNum);
; 1833 :             break;

  02070	e9 dc 10 00 00	 jmp	 $L124014
$L124193:

; 1834 : 
; 1835 : 
; 1836 :         // Dynamic emitted sparks. Linear movement, longer lifetime.
; 1837 :         case ISPARK_DriftSlow:
; 1838 :             if( ( ThisSpark->Heat -= ThisSpark->ByteD ) > ThisSpark->ByteD ) // Glow out.

  02075	8a 4c ef 07	 mov	 cl, BYTE PTR [edi+ebp*8+7]
  02079	8a 5c ef 01	 mov	 bl, BYTE PTR [edi+ebp*8+1]
  0207d	2a d9		 sub	 bl, cl
  0207f	8a c3		 mov	 al, bl
  02081	3a c1		 cmp	 al, cl
  02083	88 5c ef 01	 mov	 BYTE PTR [edi+ebp*8+1], bl
  02087	0f 86 a3 10 00
	00		 jbe	 $L124256

; 1839 :             {
; 1840 :                 DWORD SparkDest = (DWORD)( ThisSpark->X + ( ThisSpark->Y << UBits ) );
; 1841 :                 // Set spark.
; 1842 :                 Mips(0).DataArray( SparkDest ) = ThisSpark->Heat;

  0208d	33 c9		 xor	 ecx, ecx
  0208f	8a 4c ef 03	 mov	 cl, BYTE PTR [edi+ebp*8+3]
  02093	8d 5c ef 03	 lea	 ebx, DWORD PTR [edi+ebp*8+3]
  02097	8b d1		 mov	 edx, ecx
  02099	8a 4e 30	 mov	 cl, BYTE PTR [esi+48]
  0209c	d3 e2		 shl	 edx, cl
  0209e	8b 8e a8 00 00
	00		 mov	 ecx, DWORD PTR [esi+168]
  020a4	03 51 1c	 add	 edx, DWORD PTR [ecx+28]
  020a7	33 c9		 xor	 ecx, ecx
  020a9	8a 4c ef 02	 mov	 cl, BYTE PTR [edi+ebp*8+2]
  020ad	88 04 0a	 mov	 BYTE PTR [edx+ecx], al

; 1843 :                 // Advance position.
; 1844 :                 MoveSpark( ThisSpark );

  020b0	8a 44 ef 04	 mov	 al, BYTE PTR [edi+ebp*8+4]
  020b4	84 c0		 test	 al, al
  020b6	7d 55		 jge	 SHORT $L133266
  020b8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  020be	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  020c4	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  020ca	83 c2 04	 add	 edx, 4
  020cd	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  020d3	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  020d9	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  020df	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  020e5	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  020eb	0f be 54 ef 04	 movsx	 edx, BYTE PTR [edi+ebp*8+4]
  020f0	f7 da		 neg	 edx
  020f2	83 e0 7f	 and	 eax, 127		; 0000007fH
  020f5	3b c2		 cmp	 eax, edx
  020f7	7d 64		 jge	 SHORT $L133269
  020f9	8a 44 ef 02	 mov	 al, BYTE PTR [edi+ebp*8+2]
  020fd	8a 8e c8 00 00
	00		 mov	 cl, BYTE PTR [esi+200]
  02103	fe c8		 dec	 al
  02105	22 c1		 and	 al, cl
  02107	88 44 ef 02	 mov	 BYTE PTR [edi+ebp*8+2], al
  0210b	eb 50		 jmp	 SHORT $L133269
$L133266:
  0210d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  02113	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  02119	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  0211f	83 c2 04	 add	 edx, 4
  02122	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  02128	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  0212e	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  02134	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  0213a	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  02140	8a 4c ef 04	 mov	 cl, BYTE PTR [edi+ebp*8+4]
  02144	83 e0 7f	 and	 eax, 127		; 0000007fH
  02147	3a c1		 cmp	 al, cl
  02149	7d 12		 jge	 SHORT $L133269
  0214b	8a 4c ef 02	 mov	 cl, BYTE PTR [edi+ebp*8+2]
  0214f	8a 86 c8 00 00
	00		 mov	 al, BYTE PTR [esi+200]
  02155	fe c1		 inc	 cl
  02157	22 c8		 and	 cl, al
  02159	88 4c ef 02	 mov	 BYTE PTR [edi+ebp*8+2], cl
$L133269:
  0215d	8a 44 ef 05	 mov	 al, BYTE PTR [edi+ebp*8+5]
  02161	84 c0		 test	 al, al
  02163	8d 7c ef 05	 lea	 edi, DWORD PTR [edi+ebp*8+5]
  02167	7d 56		 jge	 SHORT $L133270
  02169	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  0216f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  02175	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  0217b	83 c2 04	 add	 edx, 4
  0217e	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  02184	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  0218a	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  02190	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  02196	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  0219c	0f be 17	 movsx	 edx, BYTE PTR [edi]
  0219f	f7 da		 neg	 edx
  021a1	83 e0 7f	 and	 eax, 127		; 0000007fH
  021a4	3b c2		 cmp	 eax, edx
  021a6	0f 8d a5 0f 00
	00		 jge	 $L124014
  021ac	8a 03		 mov	 al, BYTE PTR [ebx]
  021ae	8a 8e cc 00 00
	00		 mov	 cl, BYTE PTR [esi+204]
  021b4	fe c8		 dec	 al
  021b6	22 c8		 and	 cl, al
  021b8	88 0b		 mov	 BYTE PTR [ebx], cl
  021ba	e9 92 0f 00 00	 jmp	 $L124014
$L133270:
  021bf	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  021c5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  021cb	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  021d1	83 c2 04	 add	 edx, 4
  021d4	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  021da	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  021e0	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  021e6	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  021ec	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax

; 1845 :                 // No gravity.
; 1846 :             }
; 1847 :             else // Delete the spark.
; 1848 : 				*ThisSpark = Sparks( --ActiveSparkNum );
; 1849 :             break;

  021f2	e9 5e fe ff ff	 jmp	 $L133694
$L124198:

; 1850 : 
; 1851 : 
; 1852 :         //  Dynamic emitted sparks. General: adjustable lifetime and speed.
; 1853 :         case ISPARK_Custom:
; 1854 :             if   ( (( ThisSpark->Heat -= ThisSpark->ByteC ) < 250 )  )  // Glow out slower.

  021f7	8a 54 ef 01	 mov	 dl, BYTE PTR [edi+ebp*8+1]
  021fb	8a 4c ef 06	 mov	 cl, BYTE PTR [edi+ebp*8+6]
  021ff	2a d1		 sub	 dl, cl
  02201	8a c2		 mov	 al, dl
  02203	3c fa		 cmp	 al, 250			; 000000faH
  02205	88 54 ef 01	 mov	 BYTE PTR [edi+ebp*8+1], dl
  02209	0f 83 21 0f 00
	00		 jae	 $L124256

; 1855 :             {
; 1856 :                 DWORD SparkDest = (DWORD)( ThisSpark->X + ( ThisSpark->Y << UBits ));

  0220f	8a 4e 30	 mov	 cl, BYTE PTR [esi+48]

; 1857 :                 // Set spark.
; 1858 :                 Mips(0).DataArray(SparkDest) = ThisSpark->Heat;

  02212	33 d2		 xor	 edx, edx
  02214	8a 54 ef 03	 mov	 dl, BYTE PTR [edi+ebp*8+3]
  02218	8d 5c ef 03	 lea	 ebx, DWORD PTR [edi+ebp*8+3]
  0221c	d3 e2		 shl	 edx, cl
  0221e	8b 8e a8 00 00
	00		 mov	 ecx, DWORD PTR [esi+168]
  02224	03 51 1c	 add	 edx, DWORD PTR [ecx+28]
  02227	33 c9		 xor	 ecx, ecx
  02229	8a 4c ef 02	 mov	 cl, BYTE PTR [edi+ebp*8+2]
  0222d	88 04 0a	 mov	 BYTE PTR [edx+ecx], al

; 1859 :                 // Advance position.
; 1860 :                 MoveSpark( ThisSpark );

  02230	8a 44 ef 04	 mov	 al, BYTE PTR [edi+ebp*8+4]
  02234	84 c0		 test	 al, al
  02236	7d 55		 jge	 SHORT $L133310
  02238	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  0223e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  02244	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  0224a	83 c2 04	 add	 edx, 4
  0224d	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  02253	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  02259	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  0225f	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  02265	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  0226b	0f be 54 ef 04	 movsx	 edx, BYTE PTR [edi+ebp*8+4]
  02270	f7 da		 neg	 edx
  02272	83 e0 7f	 and	 eax, 127		; 0000007fH
  02275	3b c2		 cmp	 eax, edx
  02277	7d 64		 jge	 SHORT $L133313
  02279	8a 44 ef 02	 mov	 al, BYTE PTR [edi+ebp*8+2]
  0227d	8a 8e c8 00 00
	00		 mov	 cl, BYTE PTR [esi+200]
  02283	fe c8		 dec	 al
  02285	22 c1		 and	 al, cl
  02287	88 44 ef 02	 mov	 BYTE PTR [edi+ebp*8+2], al
  0228b	eb 50		 jmp	 SHORT $L133313
$L133310:
  0228d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  02293	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  02299	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  0229f	83 c2 04	 add	 edx, 4
  022a2	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  022a8	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  022ae	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  022b4	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  022ba	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  022c0	8a 4c ef 04	 mov	 cl, BYTE PTR [edi+ebp*8+4]
  022c4	83 e0 7f	 and	 eax, 127		; 0000007fH
  022c7	3a c1		 cmp	 al, cl
  022c9	7d 12		 jge	 SHORT $L133313
  022cb	8a 4c ef 02	 mov	 cl, BYTE PTR [edi+ebp*8+2]
  022cf	8a 86 c8 00 00
	00		 mov	 al, BYTE PTR [esi+200]
  022d5	fe c1		 inc	 cl
  022d7	22 c8		 and	 cl, al
  022d9	88 4c ef 02	 mov	 BYTE PTR [edi+ebp*8+2], cl
$L133313:
  022dd	8a 44 ef 05	 mov	 al, BYTE PTR [edi+ebp*8+5]
  022e1	84 c0		 test	 al, al
  022e3	8d 7c ef 05	 lea	 edi, DWORD PTR [edi+ebp*8+5]
  022e7	7d 56		 jge	 SHORT $L133314
  022e9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  022ef	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  022f5	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  022fb	83 c2 04	 add	 edx, 4
  022fe	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  02304	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  0230a	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  02310	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  02316	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  0231c	0f be 17	 movsx	 edx, BYTE PTR [edi]
  0231f	f7 da		 neg	 edx
  02321	83 e0 7f	 and	 eax, 127		; 0000007fH
  02324	3b c2		 cmp	 eax, edx
  02326	0f 8d 25 0e 00
	00		 jge	 $L124014
  0232c	8a 03		 mov	 al, BYTE PTR [ebx]
  0232e	8a 8e cc 00 00
	00		 mov	 cl, BYTE PTR [esi+204]
  02334	fe c8		 dec	 al
  02336	22 c8		 and	 cl, al
  02338	88 0b		 mov	 BYTE PTR [ebx], cl
  0233a	e9 12 0e 00 00	 jmp	 $L124014
$L133314:
  0233f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  02345	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  0234b	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  02351	83 c2 04	 add	 edx, 4
  02354	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  0235a	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  02360	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  02366	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  0236c	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax

; 1861 :                 // No gravity.
; 1862 :             }
; 1863 :             else  // Delete the spark.
; 1864 : 				*ThisSpark = Sparks(--ActiveSparkNum);
; 1865 :             break;

  02372	e9 de fc ff ff	 jmp	 $L133694
$L124203:

; 1866 : 
; 1867 : 
; 1868 :         //  Dynamic falling ones: GRAVITY. if out of range, delete.
; 1869 :         case ISPARK_Faller:
; 1870 :             if( (( ThisSpark->ByteC -= 1 ) > 0 )  )  // Timeout.

  02377	fe 4c ef 06	 dec	 BYTE PTR [edi+ebp*8+6]
  0237b	0f 84 af 0d 00
	00		 je	 $L124256
  02381	8b 86 a8 00 00
	00		 mov	 eax, DWORD PTR [esi+168]

; 1871 :             {
; 1872 :                 DWORD SparkDest = (DWORD)( ThisSpark->X + ( ThisSpark->Y << UBits ));
; 1873 :                 // Set spark.
; 1874 :                 Mips(0).DataArray(SparkDest) = ThisSpark->Heat;

  02387	33 c9		 xor	 ecx, ecx
  02389	8a 4c ef 03	 mov	 cl, BYTE PTR [edi+ebp*8+3]
  0238d	8d 5c ef 03	 lea	 ebx, DWORD PTR [edi+ebp*8+3]
  02391	8b d1		 mov	 edx, ecx
  02393	8a 4e 30	 mov	 cl, BYTE PTR [esi+48]
  02396	d3 e2		 shl	 edx, cl
  02398	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  0239b	8a 44 ef 01	 mov	 al, BYTE PTR [edi+ebp*8+1]
  0239f	03 d1		 add	 edx, ecx
  023a1	33 c9		 xor	 ecx, ecx
  023a3	8a 4c ef 02	 mov	 cl, BYTE PTR [edi+ebp*8+2]
  023a7	88 04 0a	 mov	 BYTE PTR [edx+ecx], al

; 1875 :                 // Advance position.
; 1876 :                 MoveSpark( ThisSpark );

  023aa	8a 44 ef 04	 mov	 al, BYTE PTR [edi+ebp*8+4]
  023ae	84 c0		 test	 al, al
  023b0	7d 55		 jge	 SHORT $L133354
  023b2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  023b8	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  023be	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  023c4	83 c2 04	 add	 edx, 4
  023c7	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  023cd	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  023d3	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  023d9	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  023df	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  023e5	0f be 4c ef 04	 movsx	 ecx, BYTE PTR [edi+ebp*8+4]
  023ea	f7 d9		 neg	 ecx
  023ec	83 e0 7f	 and	 eax, 127		; 0000007fH
  023ef	3b c1		 cmp	 eax, ecx
  023f1	7d 64		 jge	 SHORT $L133357
  023f3	8a 54 ef 02	 mov	 dl, BYTE PTR [edi+ebp*8+2]
  023f7	8a 86 c8 00 00
	00		 mov	 al, BYTE PTR [esi+200]
  023fd	fe ca		 dec	 dl
  023ff	22 d0		 and	 dl, al
  02401	88 54 ef 02	 mov	 BYTE PTR [edi+ebp*8+2], dl
  02405	eb 50		 jmp	 SHORT $L133357
$L133354:
  02407	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  0240d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  02413	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  02419	83 c2 04	 add	 edx, 4
  0241c	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  02422	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  02428	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  0242e	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  02434	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  0243a	8a 4c ef 04	 mov	 cl, BYTE PTR [edi+ebp*8+4]
  0243e	83 e0 7f	 and	 eax, 127		; 0000007fH
  02441	3a c1		 cmp	 al, cl
  02443	7d 12		 jge	 SHORT $L133357
  02445	8a 44 ef 02	 mov	 al, BYTE PTR [edi+ebp*8+2]
  02449	8a 8e c8 00 00
	00		 mov	 cl, BYTE PTR [esi+200]
  0244f	fe c0		 inc	 al
  02451	22 c1		 and	 al, cl
  02453	88 44 ef 02	 mov	 BYTE PTR [edi+ebp*8+2], al
$L133357:
  02457	8a 44 ef 05	 mov	 al, BYTE PTR [edi+ebp*8+5]
  0245b	84 c0		 test	 al, al
  0245d	8d 7c ef 05	 lea	 edi, DWORD PTR [edi+ebp*8+5]
  02461	7d 47		 jge	 SHORT $L133358
  02463	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  02469	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  0246f	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  02475	83 c2 04	 add	 edx, 4
  02478	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  0247e	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  02484	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  0248a	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  02490	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  02496	8a 0f		 mov	 cl, BYTE PTR [edi]
  02498	0f be d1	 movsx	 edx, cl
  0249b	f7 da		 neg	 edx
  0249d	83 e0 7f	 and	 eax, 127		; 0000007fH
  024a0	3b c2		 cmp	 eax, edx
  024a2	7d 50		 jge	 SHORT $L133361
  024a4	8a 03		 mov	 al, BYTE PTR [ebx]
  024a6	fe c8		 dec	 al
  024a8	eb 40		 jmp	 SHORT $L133692
$L133358:
  024aa	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  024b0	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  024b6	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  024bc	83 c2 04	 add	 edx, 4
  024bf	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  024c5	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  024cb	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  024d1	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  024d7	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  024dd	8a 0f		 mov	 cl, BYTE PTR [edi]
  024df	83 e0 7f	 and	 eax, 127		; 0000007fH
  024e2	3a c1		 cmp	 al, cl
  024e4	7d 0e		 jge	 SHORT $L133361
  024e6	8a 03		 mov	 al, BYTE PTR [ebx]
  024e8	fe c0		 inc	 al
$L133692:
  024ea	8a 96 cc 00 00
	00		 mov	 dl, BYTE PTR [esi+204]
  024f0	22 d0		 and	 dl, al
  024f2	88 13		 mov	 BYTE PTR [ebx], dl
$L133361:

; 1877 :                 // Gravity:
; 1878 :                 if( (SBYTE)ThisSpark->ByteB < 122 )

  024f4	80 f9 7a	 cmp	 cl, 122			; 0000007aH
  024f7	0f 8d 54 0c 00
	00		 jge	 $L124014

; 1879 :                     ThisSpark->ByteB +=3;

  024fd	80 c1 03	 add	 cl, 3
  02500	88 0f		 mov	 BYTE PTR [edi], cl

; 1880 :             }
; 1881 :             else  // Delete the spark.
; 1882 :                 *ThisSpark = Sparks(--ActiveSparkNum);
; 1883 :             break;

  02502	e9 4a 0c 00 00	 jmp	 $L124014
$L124210:

; 1884 : 
; 1885 : 		//  Dynamic falling ones for _Fountain.
; 1886 : 		case ISPARK_Graviton:
; 1887 : 			if    (( ThisSpark->Heat -= ThisSpark->ByteD ) > LOWESTGLOW )  // Glow out 

  02507	8a 54 ef 01	 mov	 dl, BYTE PTR [edi+ebp*8+1]
  0250b	8a 4c ef 07	 mov	 cl, BYTE PTR [edi+ebp*8+7]
  0250f	2a d1		 sub	 dl, cl
  02511	8a c2		 mov	 al, dl
  02513	3c 32		 cmp	 al, 50			; 00000032H
  02515	88 54 ef 01	 mov	 BYTE PTR [edi+ebp*8+1], dl
  02519	0f 86 11 0c 00
	00		 jbe	 $L124256

; 1888 :             {
; 1889 :                 DWORD SparkDest = (DWORD)( ThisSpark->X + ( ThisSpark->Y << UBits ));

  0251f	8a 4e 30	 mov	 cl, BYTE PTR [esi+48]

; 1890 : 
; 1891 :                 // Set spark.
; 1892 :                 Mips(0).DataArray(SparkDest ) = ThisSpark->Heat;

  02522	33 d2		 xor	 edx, edx
  02524	8a 54 ef 03	 mov	 dl, BYTE PTR [edi+ebp*8+3]
  02528	8d 5c ef 03	 lea	 ebx, DWORD PTR [edi+ebp*8+3]
  0252c	d3 e2		 shl	 edx, cl
  0252e	8b 8e a8 00 00
	00		 mov	 ecx, DWORD PTR [esi+168]
  02534	03 51 1c	 add	 edx, DWORD PTR [ecx+28]
  02537	33 c9		 xor	 ecx, ecx
  02539	8a 4c ef 02	 mov	 cl, BYTE PTR [edi+ebp*8+2]
  0253d	88 04 0a	 mov	 BYTE PTR [edx+ecx], al

; 1893 : 
; 1894 :                 // Advance position.
; 1895 :                 MoveSpark( ThisSpark ); 

  02540	8a 44 ef 04	 mov	 al, BYTE PTR [edi+ebp*8+4]
  02544	84 c0		 test	 al, al
  02546	7d 55		 jge	 SHORT $L133398
  02548	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  0254e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  02554	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  0255a	83 c2 04	 add	 edx, 4
  0255d	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  02563	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  02569	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  0256f	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  02575	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  0257b	0f be 54 ef 04	 movsx	 edx, BYTE PTR [edi+ebp*8+4]
  02580	f7 da		 neg	 edx
  02582	83 e0 7f	 and	 eax, 127		; 0000007fH
  02585	3b c2		 cmp	 eax, edx
  02587	7d 64		 jge	 SHORT $L133401
  02589	8a 44 ef 02	 mov	 al, BYTE PTR [edi+ebp*8+2]
  0258d	8a 8e c8 00 00
	00		 mov	 cl, BYTE PTR [esi+200]
  02593	fe c8		 dec	 al
  02595	22 c1		 and	 al, cl
  02597	88 44 ef 02	 mov	 BYTE PTR [edi+ebp*8+2], al
  0259b	eb 50		 jmp	 SHORT $L133401
$L133398:
  0259d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  025a3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  025a9	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  025af	83 c2 04	 add	 edx, 4
  025b2	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  025b8	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  025be	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  025c4	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  025ca	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  025d0	8a 4c ef 04	 mov	 cl, BYTE PTR [edi+ebp*8+4]
  025d4	83 e0 7f	 and	 eax, 127		; 0000007fH
  025d7	3a c1		 cmp	 al, cl
  025d9	7d 12		 jge	 SHORT $L133401
  025db	8a 4c ef 02	 mov	 cl, BYTE PTR [edi+ebp*8+2]
  025df	8a 86 c8 00 00
	00		 mov	 al, BYTE PTR [esi+200]
  025e5	fe c1		 inc	 cl
  025e7	22 c8		 and	 cl, al
  025e9	88 4c ef 02	 mov	 BYTE PTR [edi+ebp*8+2], cl
$L133401:
  025ed	8a 44 ef 05	 mov	 al, BYTE PTR [edi+ebp*8+5]
  025f1	84 c0		 test	 al, al
  025f3	8d 7c ef 05	 lea	 edi, DWORD PTR [edi+ebp*8+5]
  025f7	7d 47		 jge	 SHORT $L133402
  025f9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  025ff	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  02605	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  0260b	83 c2 04	 add	 edx, 4
  0260e	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  02614	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  0261a	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  02620	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  02626	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  0262c	8a 0f		 mov	 cl, BYTE PTR [edi]
  0262e	0f be d1	 movsx	 edx, cl
  02631	f7 da		 neg	 edx
  02633	83 e0 7f	 and	 eax, 127		; 0000007fH
  02636	3b c2		 cmp	 eax, edx
  02638	7d 50		 jge	 SHORT $L133405
  0263a	8a 03		 mov	 al, BYTE PTR [ebx]
  0263c	fe c8		 dec	 al
  0263e	eb 40		 jmp	 SHORT $L133693
$L133402:
  02640	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  02646	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  0264c	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  02652	83 c2 04	 add	 edx, 4
  02655	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  0265b	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  02661	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  02667	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  0266d	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  02673	8a 0f		 mov	 cl, BYTE PTR [edi]
  02675	83 e0 7f	 and	 eax, 127		; 0000007fH
  02678	3a c1		 cmp	 al, cl
  0267a	7d 0e		 jge	 SHORT $L133405
  0267c	8a 03		 mov	 al, BYTE PTR [ebx]
  0267e	fe c0		 inc	 al
$L133693:
  02680	8a 96 cc 00 00
	00		 mov	 dl, BYTE PTR [esi+204]
  02686	22 d0		 and	 dl, al
  02688	88 13		 mov	 BYTE PTR [ebx], dl
$L133405:

; 1896 : 
; 1897 :                 // 1/2 Gravity.
; 1898 : 				if( GlobalPhase & 1 )

  0268a	f6 86 d8 00 00
	00 01		 test	 BYTE PTR [esi+216], 1
  02691	0f 84 ba 0a 00
	00		 je	 $L124014

; 1899 : 				{					
; 1900 : 					if( (SBYTE)ThisSpark->ByteB < 124 )

  02697	80 f9 7c	 cmp	 cl, 124			; 0000007cH
  0269a	0f 8d b1 0a 00
	00		 jge	 $L124014

; 1901 : 						ThisSpark->ByteB +=3;

  026a0	80 c1 03	 add	 cl, 3
  026a3	88 0f		 mov	 BYTE PTR [edi], cl

; 1902 : 				}
; 1903 :             }
; 1904 :             else  // Delete the spark.
; 1905 : 				*ThisSpark = Sparks(--ActiveSparkNum);
; 1906 :             break;

  026a5	e9 a7 0a 00 00	 jmp	 $L124014
$L124218:

; 1907 : 
; 1908 : 
; 1909 :         //  Whirly-floaty fire sparks, go up & glow out.
; 1910 :         case ISPARK_VShooter:
; 1911 :             if   ((( ThisSpark->ByteC -= 3 ) > 190 )  )  // Timeout.

  026aa	8a 54 ef 06	 mov	 dl, BYTE PTR [edi+ebp*8+6]
  026ae	80 c2 fd	 add	 dl, 253			; 000000fdH
  026b1	8a c2		 mov	 al, dl
  026b3	3c be		 cmp	 al, 190			; 000000beH
  026b5	88 54 ef 06	 mov	 BYTE PTR [edi+ebp*8+6], dl
  026b9	0f 86 86 08 00
	00		 jbe	 $L124247

; 1912 :             {
; 1913 :                 DWORD SparkDest = (DWORD)( ThisSpark->X + ( ThisSpark->Y << UBits ));

  026bf	8d 4c ef 03	 lea	 ecx, DWORD PTR [edi+ebp*8+3]

; 1914 :                 // Set spark.
; 1915 :                 Mips(0).DataArray(SparkDest) = (BYTE) (ThisSpark->ByteC);

  026c3	33 d2		 xor	 edx, edx
  026c5	8a 11		 mov	 dl, BYTE PTR [ecx]
  026c7	89 4c 24 14	 mov	 DWORD PTR -72+[esp+92], ecx
  026cb	8a 4e 30	 mov	 cl, BYTE PTR [esi+48]
  026ce	8d 5c ef 02	 lea	 ebx, DWORD PTR [edi+ebp*8+2]

; 1916 :                 // Advance position.
; 1917 :                 MoveSparkTwo( ThisSpark );

  026d2	8d 7c ef 04	 lea	 edi, DWORD PTR [edi+ebp*8+4]
  026d6	d3 e2		 shl	 edx, cl
  026d8	8b 8e a8 00 00
	00		 mov	 ecx, DWORD PTR [esi+168]
  026de	03 51 1c	 add	 edx, DWORD PTR [ecx+28]
  026e1	33 c9		 xor	 ecx, ecx
  026e3	8a 0b		 mov	 cl, BYTE PTR [ebx]
  026e5	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
  026e8	80 3f 00	 cmp	 BYTE PTR [edi], 0
  026eb	7d 65		 jge	 SHORT $L133425
  026ed	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  026f3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  026f9	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  026ff	83 c2 04	 add	 edx, 4
  02702	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  02708	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  0270e	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  02714	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  0271a	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  02720	0f be 17	 movsx	 edx, BYTE PTR [edi]
  02723	f7 da		 neg	 edx
  02725	83 e0 7f	 and	 eax, 127		; 0000007fH
  02728	3b c2		 cmp	 eax, edx
  0272a	7d 70		 jge	 SHORT $L133428
  0272c	8a 03		 mov	 al, BYTE PTR [ebx]
  0272e	8a 8e c8 00 00
	00		 mov	 cl, BYTE PTR [esi+200]
  02734	fe c8		 dec	 al
  02736	22 c1		 and	 al, cl
  02738	88 03		 mov	 BYTE PTR [ebx], al
  0273a	8b 44 24 14	 mov	 eax, DWORD PTR -72+[esp+92]
  0273e	8a 10		 mov	 dl, BYTE PTR [eax]

; 2005 : 
; 2006 : 				// Advance position.
; 2007 :                 MoveSparkXY( ThisSpark, TempSpeedX, TempSpeedY ); 

  02740	8a 8e cc 00 00
	00		 mov	 cl, BYTE PTR [esi+204]
  02746	80 ea 02	 sub	 dl, 2
  02749	22 ca		 and	 cl, dl
  0274b	88 08		 mov	 BYTE PTR [eax], cl

; 2008 :             }
; 2009 :             else // Delete the spark.

  0274d	e9 ff 09 00 00	 jmp	 $L124014

; 1916 :                 // Advance position.
; 1917 :                 MoveSparkTwo( ThisSpark );

$L133425:
  02752	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  02758	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  0275e	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  02764	83 c2 04	 add	 edx, 4
  02767	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  0276d	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  02773	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  02779	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  0277f	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
$L133703:
  02785	8a 0f		 mov	 cl, BYTE PTR [edi]
  02787	83 e0 7f	 and	 eax, 127		; 0000007fH
  0278a	3a c1		 cmp	 al, cl
  0278c	7d 0e		 jge	 SHORT $L133428
  0278e	8a 0b		 mov	 cl, BYTE PTR [ebx]
  02790	8a 86 c8 00 00
	00		 mov	 al, BYTE PTR [esi+200]
  02796	fe c1		 inc	 cl
  02798	22 c8		 and	 cl, al
  0279a	88 0b		 mov	 BYTE PTR [ebx], cl
$L133428:
  0279c	8b 44 24 14	 mov	 eax, DWORD PTR -72+[esp+92]
  027a0	8a 10		 mov	 dl, BYTE PTR [eax]

; 2005 : 
; 2006 : 				// Advance position.
; 2007 :                 MoveSparkXY( ThisSpark, TempSpeedX, TempSpeedY ); 

  027a2	8a 8e cc 00 00
	00		 mov	 cl, BYTE PTR [esi+204]
  027a8	80 ea 02	 sub	 dl, 2
  027ab	22 ca		 and	 cl, dl
  027ad	88 08		 mov	 BYTE PTR [eax], cl

; 2008 :             }
; 2009 :             else // Delete the spark.

  027af	e9 9d 09 00 00	 jmp	 $L124014
$L124224:

; 1918 :             }
; 1919 :             else  // Delete the spark.
; 1920 :                 *ThisSpark = Sparks(--ActiveSparkNum);
; 1921 :             break;
; 1922 : 
; 1923 : 
; 1924 :         //  Whirly-floaty fire sparks, go up & glow out.
; 1925 :         case ISPARK_Drop:
; 1926 :             if( (( ThisSpark->ByteC += 4 ) < 250 )  )  // Timeout.

  027b4	8a 54 ef 06	 mov	 dl, BYTE PTR [edi+ebp*8+6]
  027b8	80 c2 04	 add	 dl, 4
  027bb	8a c2		 mov	 al, dl
  027bd	3c fa		 cmp	 al, 250			; 000000faH
  027bf	88 54 ef 06	 mov	 BYTE PTR [edi+ebp*8+6], dl
  027c3	0f 83 7c 07 00
	00		 jae	 $L124247

; 1927 :             {
; 1928 :                 DWORD SparkDest = (DWORD)( ThisSpark->X + ( ThisSpark->Y << UBits ));

  027c9	8d 4c ef 03	 lea	 ecx, DWORD PTR [edi+ebp*8+3]

; 1929 :                 // Set spark.
; 1930 :                 Mips(0).DataArray(SparkDest) = ThisSpark->ByteC;

  027cd	33 d2		 xor	 edx, edx
  027cf	8a 11		 mov	 dl, BYTE PTR [ecx]
  027d1	89 4c 24 14	 mov	 DWORD PTR -72+[esp+92], ecx
  027d5	8a 4e 30	 mov	 cl, BYTE PTR [esi+48]
  027d8	8d 5c ef 02	 lea	 ebx, DWORD PTR [edi+ebp*8+2]

; 1931 :                 // Advance position.
; 1932 :                 MoveSparkTwo( ThisSpark );

  027dc	8d 7c ef 04	 lea	 edi, DWORD PTR [edi+ebp*8+4]
  027e0	d3 e2		 shl	 edx, cl
  027e2	8b 8e a8 00 00
	00		 mov	 ecx, DWORD PTR [esi+168]
  027e8	03 51 1c	 add	 edx, DWORD PTR [ecx+28]
  027eb	33 c9		 xor	 ecx, ecx
  027ed	8a 0b		 mov	 cl, BYTE PTR [ebx]
  027ef	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
  027f2	80 3f 00	 cmp	 BYTE PTR [edi], 0
  027f5	7d 56		 jge	 SHORT $L133453
  027f7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  027fd	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  02803	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  02809	83 c2 04	 add	 edx, 4
  0280c	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  02812	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  02818	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  0281e	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  02824	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  0282a	0f be 17	 movsx	 edx, BYTE PTR [edi]
  0282d	f7 da		 neg	 edx
  0282f	83 e0 7f	 and	 eax, 127		; 0000007fH
  02832	3b c2		 cmp	 eax, edx
  02834	0f 8d 62 ff ff
	ff		 jge	 $L133428
  0283a	8a 03		 mov	 al, BYTE PTR [ebx]
  0283c	8a 8e c8 00 00
	00		 mov	 cl, BYTE PTR [esi+200]
  02842	fe c8		 dec	 al
  02844	22 c1		 and	 al, cl
  02846	88 03		 mov	 BYTE PTR [ebx], al
  02848	e9 4f ff ff ff	 jmp	 $L133428
$L133453:
  0284d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  02853	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  02859	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  0285f	83 c2 04	 add	 edx, 4
  02862	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  02868	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  0286e	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  02874	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  0287a	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax

; 1933 :             }
; 1934 :             else // Delete the spark.

  02880	e9 00 ff ff ff	 jmp	 $L133703
$L124229:

; 1935 :                 *ThisSpark = Sparks(--ActiveSparkNum);
; 1936 :             break;
; 1937 : 
; 1938 : 
; 1939 :         //  Whirly-floaty fire sparks, go down & glow out.
; 1940 :         case ISPARK_Move:
; 1941 :             if   ((( ThisSpark->ByteC += 4 ) < 250 )  )  // Timeout

  02885	8a 54 ef 06	 mov	 dl, BYTE PTR [edi+ebp*8+6]
  02889	80 c2 04	 add	 dl, 4
  0288c	8a c2		 mov	 al, dl
  0288e	3c fa		 cmp	 al, 250			; 000000faH
  02890	88 54 ef 06	 mov	 BYTE PTR [edi+ebp*8+6], dl
  02894	0f 83 96 08 00
	00		 jae	 $L124256

; 1942 :             {
; 1943 :                 DWORD SparkDest = (DWORD)( ThisSpark->X + ( ThisSpark->Y << UBits ));
; 1944 :                 // Set spark.
; 1945 :                 Mips(0).DataArray(SparkDest) = ThisSpark->ByteC;

  0289a	33 c9		 xor	 ecx, ecx
  0289c	8a 4c ef 03	 mov	 cl, BYTE PTR [edi+ebp*8+3]
  028a0	8d 5c ef 03	 lea	 ebx, DWORD PTR [edi+ebp*8+3]
  028a4	8b d1		 mov	 edx, ecx
  028a6	8a 4e 30	 mov	 cl, BYTE PTR [esi+48]
  028a9	d3 e2		 shl	 edx, cl
  028ab	8b 8e a8 00 00
	00		 mov	 ecx, DWORD PTR [esi+168]
  028b1	03 51 1c	 add	 edx, DWORD PTR [ecx+28]
  028b4	33 c9		 xor	 ecx, ecx
  028b6	8a 4c ef 02	 mov	 cl, BYTE PTR [edi+ebp*8+2]
  028ba	88 04 0a	 mov	 BYTE PTR [edx+ecx], al

; 1946 :                 // Advance position.
; 1947 :                 MoveSpark( ThisSpark );

  028bd	8a 44 ef 04	 mov	 al, BYTE PTR [edi+ebp*8+4]
  028c1	84 c0		 test	 al, al
  028c3	7d 55		 jge	 SHORT $L133498
  028c5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  028cb	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  028d1	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  028d7	83 c2 04	 add	 edx, 4
  028da	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  028e0	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  028e6	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  028ec	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  028f2	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  028f8	0f be 54 ef 04	 movsx	 edx, BYTE PTR [edi+ebp*8+4]
  028fd	f7 da		 neg	 edx
  028ff	83 e0 7f	 and	 eax, 127		; 0000007fH
  02902	3b c2		 cmp	 eax, edx
  02904	7d 64		 jge	 SHORT $L133501
  02906	8a 44 ef 02	 mov	 al, BYTE PTR [edi+ebp*8+2]
  0290a	8a 8e c8 00 00
	00		 mov	 cl, BYTE PTR [esi+200]
  02910	fe c8		 dec	 al
  02912	22 c1		 and	 al, cl
  02914	88 44 ef 02	 mov	 BYTE PTR [edi+ebp*8+2], al
  02918	eb 50		 jmp	 SHORT $L133501
$L133498:
  0291a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  02920	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  02926	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  0292c	83 c2 04	 add	 edx, 4
  0292f	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  02935	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  0293b	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  02941	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  02947	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  0294d	8a 4c ef 04	 mov	 cl, BYTE PTR [edi+ebp*8+4]
  02951	83 e0 7f	 and	 eax, 127		; 0000007fH
  02954	3a c1		 cmp	 al, cl
  02956	7d 12		 jge	 SHORT $L133501
  02958	8a 4c ef 02	 mov	 cl, BYTE PTR [edi+ebp*8+2]
  0295c	8a 86 c8 00 00
	00		 mov	 al, BYTE PTR [esi+200]
  02962	fe c1		 inc	 cl
  02964	22 c8		 and	 cl, al
  02966	88 4c ef 02	 mov	 BYTE PTR [edi+ebp*8+2], cl
$L133501:
  0296a	8a 44 ef 05	 mov	 al, BYTE PTR [edi+ebp*8+5]
  0296e	84 c0		 test	 al, al
  02970	8d 7c ef 05	 lea	 edi, DWORD PTR [edi+ebp*8+5]
  02974	7d 56		 jge	 SHORT $L133502
  02976	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  0297c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  02982	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  02988	83 c2 04	 add	 edx, 4
  0298b	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  02991	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  02997	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  0299d	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  029a3	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  029a9	0f be 17	 movsx	 edx, BYTE PTR [edi]
  029ac	f7 da		 neg	 edx
  029ae	83 e0 7f	 and	 eax, 127		; 0000007fH
  029b1	3b c2		 cmp	 eax, edx
  029b3	0f 8d 98 07 00
	00		 jge	 $L124014
  029b9	8a 03		 mov	 al, BYTE PTR [ebx]
  029bb	8a 8e cc 00 00
	00		 mov	 cl, BYTE PTR [esi+204]
  029c1	fe c8		 dec	 al
  029c3	22 c8		 and	 cl, al
  029c5	88 0b		 mov	 BYTE PTR [ebx], cl
  029c7	e9 85 07 00 00	 jmp	 $L124014
$L133502:
  029cc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  029d2	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  029d8	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  029de	83 c2 04	 add	 edx, 4
  029e1	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  029e7	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  029ed	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  029f3	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  029f9	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax

; 1948 :             }
; 1949 :             else  // Delete the spark.
; 1950 :                 *ThisSpark = Sparks(--ActiveSparkNum);
; 1951 :             break;

  029ff	e9 51 f6 ff ff	 jmp	 $L133694
$L124234:

; 1952 : 
; 1953 : 
; 1954 :         //  'Wormy' sparks, long-lived and sparse.
; 1955 :         case ISPARK_SpawnedEel:
; 1956 : 			if   ((( ThisSpark->ByteC -= 1 ) < 255 )  )  // Timeout

  02a04	8a 4c ef 06	 mov	 cl, BYTE PTR [edi+ebp*8+6]
  02a08	fe c9		 dec	 cl
  02a0a	8a c1		 mov	 al, cl
  02a0c	3c ff		 cmp	 al, 255			; 000000ffH
  02a0e	88 4c ef 06	 mov	 BYTE PTR [edi+ebp*8+6], cl
  02a12	0f 83 18 07 00
	00		 jae	 $L124256
  02a18	8b 86 a8 00 00
	00		 mov	 eax, DWORD PTR [esi+168]

; 1957 :             {
; 1958 : 	            DWORD SparkDest = (DWORD)( ThisSpark->X + ( ThisSpark->Y << UBits ) );
; 1959 :                 // Set spark.
; 1960 :                 Mips(0).DataArray(SparkDest) = ThisSpark->Heat;

  02a1e	33 c9		 xor	 ecx, ecx
  02a20	8a 4c ef 03	 mov	 cl, BYTE PTR [edi+ebp*8+3]
  02a24	8d 5c ef 03	 lea	 ebx, DWORD PTR [edi+ebp*8+3]
  02a28	8b d1		 mov	 edx, ecx
  02a2a	8a 4e 30	 mov	 cl, BYTE PTR [esi+48]
  02a2d	d3 e2		 shl	 edx, cl
  02a2f	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  02a32	8a 44 ef 01	 mov	 al, BYTE PTR [edi+ebp*8+1]
  02a36	03 d1		 add	 edx, ecx
  02a38	33 c9		 xor	 ecx, ecx
  02a3a	8a 4c ef 02	 mov	 cl, BYTE PTR [edi+ebp*8+2]
  02a3e	88 04 0a	 mov	 BYTE PTR [edx+ecx], al

; 1961 :                 // (BYTE) (ThisSpark->ByteC);
; 1962 :                 // Advance position.
; 1963 :                 MoveSpark( ThisSpark );

  02a41	8a 44 ef 04	 mov	 al, BYTE PTR [edi+ebp*8+4]
  02a45	84 c0		 test	 al, al
  02a47	7d 55		 jge	 SHORT $L133542
  02a49	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  02a4f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  02a55	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  02a5b	83 c2 04	 add	 edx, 4
  02a5e	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  02a64	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  02a6a	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  02a70	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  02a76	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  02a7c	0f be 4c ef 04	 movsx	 ecx, BYTE PTR [edi+ebp*8+4]
  02a81	f7 d9		 neg	 ecx
  02a83	83 e0 7f	 and	 eax, 127		; 0000007fH
  02a86	3b c1		 cmp	 eax, ecx
  02a88	7d 64		 jge	 SHORT $L133545
  02a8a	8a 54 ef 02	 mov	 dl, BYTE PTR [edi+ebp*8+2]
  02a8e	8a 86 c8 00 00
	00		 mov	 al, BYTE PTR [esi+200]
  02a94	fe ca		 dec	 dl
  02a96	22 d0		 and	 dl, al
  02a98	88 54 ef 02	 mov	 BYTE PTR [edi+ebp*8+2], dl
  02a9c	eb 50		 jmp	 SHORT $L133545
$L133542:
  02a9e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  02aa4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  02aaa	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  02ab0	83 c2 04	 add	 edx, 4
  02ab3	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  02ab9	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  02abf	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  02ac5	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  02acb	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  02ad1	8a 4c ef 04	 mov	 cl, BYTE PTR [edi+ebp*8+4]
  02ad5	83 e0 7f	 and	 eax, 127		; 0000007fH
  02ad8	3a c1		 cmp	 al, cl
  02ada	7d 12		 jge	 SHORT $L133545
  02adc	8a 44 ef 02	 mov	 al, BYTE PTR [edi+ebp*8+2]
  02ae0	8a 8e c8 00 00
	00		 mov	 cl, BYTE PTR [esi+200]
  02ae6	fe c0		 inc	 al
  02ae8	22 c1		 and	 al, cl
  02aea	88 44 ef 02	 mov	 BYTE PTR [edi+ebp*8+2], al
$L133545:
  02aee	8a 44 ef 05	 mov	 al, BYTE PTR [edi+ebp*8+5]
  02af2	84 c0		 test	 al, al
  02af4	8d 7c ef 05	 lea	 edi, DWORD PTR [edi+ebp*8+5]
  02af8	7d 56		 jge	 SHORT $L133546
  02afa	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  02b00	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  02b06	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  02b0c	83 c2 04	 add	 edx, 4
  02b0f	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  02b15	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  02b1b	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  02b21	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  02b27	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  02b2d	0f be 0f	 movsx	 ecx, BYTE PTR [edi]
  02b30	f7 d9		 neg	 ecx
  02b32	83 e0 7f	 and	 eax, 127		; 0000007fH
  02b35	3b c1		 cmp	 eax, ecx
  02b37	0f 8d 14 06 00
	00		 jge	 $L124014
  02b3d	8a 13		 mov	 dl, BYTE PTR [ebx]
  02b3f	8a 86 cc 00 00
	00		 mov	 al, BYTE PTR [esi+204]
  02b45	fe ca		 dec	 dl
  02b47	22 c2		 and	 al, dl
  02b49	88 03		 mov	 BYTE PTR [ebx], al
  02b4b	e9 01 06 00 00	 jmp	 $L124014
$L133546:
  02b50	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  02b56	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  02b5c	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  02b62	83 c2 04	 add	 edx, 4
  02b65	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  02b6b	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  02b71	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  02b77	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  02b7d	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  02b83	8a 0f		 mov	 cl, BYTE PTR [edi]
  02b85	83 e0 7f	 and	 eax, 127		; 0000007fH
  02b88	3a c1		 cmp	 al, cl
  02b8a	0f 8d c1 05 00
	00		 jge	 $L124014
  02b90	8a 0b		 mov	 cl, BYTE PTR [ebx]
  02b92	8a 96 cc 00 00
	00		 mov	 dl, BYTE PTR [esi+204]
  02b98	fe c1		 inc	 cl
  02b9a	22 d1		 and	 dl, cl
  02b9c	88 13		 mov	 BYTE PTR [ebx], dl

; 1964 :             }
; 1965 :             else  // Delete the spark.
; 1966 :                 *ThisSpark = Sparks(--ActiveSparkNum);
; 1967 : 			break;

  02b9e	e9 ae 05 00 00	 jmp	 $L124014
$L124239:

; 1968 : 
; 1969 : 
; 1970 : 		//  Cruising sparks, long-lived and sparse.
; 1971 :         case ISPARK_SpawnedSperm:
; 1972 : 			if( ( ( ThisSpark->ByteC -= 1 ) < 255 )  )  // Timeout

  02ba3	8a 4c ef 06	 mov	 cl, BYTE PTR [edi+ebp*8+6]
  02ba7	fe c9		 dec	 cl
  02ba9	8a c1		 mov	 al, cl
  02bab	3c ff		 cmp	 al, 255			; 000000ffH
  02bad	88 4c ef 06	 mov	 BYTE PTR [edi+ebp*8+6], cl
  02bb1	0f 83 8e 03 00
	00		 jae	 $L124247

; 1973 :             {
; 1974 : 	            DWORD SparkDest = (DWORD)( ThisSpark->X + ( ThisSpark->Y << UBits ) );
; 1975 :                 // Set spark.
; 1976 :                 Mips(0).DataArray(SparkDest) = ThisSpark->Heat;

  02bb7	33 c9		 xor	 ecx, ecx
  02bb9	8a 4c ef 03	 mov	 cl, BYTE PTR [edi+ebp*8+3]
  02bbd	8d 44 ef 03	 lea	 eax, DWORD PTR [edi+ebp*8+3]
  02bc1	89 44 24 14	 mov	 DWORD PTR -72+[esp+92], eax
  02bc5	8d 54 ef 02	 lea	 edx, DWORD PTR [edi+ebp*8+2]
  02bc9	89 54 24 18	 mov	 DWORD PTR -68+[esp+92], edx
  02bcd	8b c1		 mov	 eax, ecx
  02bcf	8a 4e 30	 mov	 cl, BYTE PTR [esi+48]
  02bd2	d3 e0		 shl	 eax, cl
  02bd4	8b 8e a8 00 00
	00		 mov	 ecx, DWORD PTR [esi+168]
  02bda	8b 59 1c	 mov	 ebx, DWORD PTR [ecx+28]
  02bdd	33 c9		 xor	 ecx, ecx
  02bdf	8a 0a		 mov	 cl, BYTE PTR [edx]
  02be1	8a 54 ef 01	 mov	 dl, BYTE PTR [edi+ebp*8+1]
  02be5	03 c3		 add	 eax, ebx
  02be7	88 14 08	 mov	 BYTE PTR [eax+ecx], dl

; 1977 : 
; 1978 : 				// Jiggle direction = ByteD using a zigzaggy ByteA.
; 1979 : 				BYTE SawTooth = 127 & (ThisSpark->ByteA += 7);

  02bea	8a 54 ef 04	 mov	 dl, BYTE PTR [edi+ebp*8+4]
  02bee	80 c2 07	 add	 dl, 7
  02bf1	8a c2		 mov	 al, dl
  02bf3	24 7f		 and	 al, 127			; 0000007fH
  02bf5	8a c8		 mov	 cl, al

; 1980 : 				if( SawTooth>63 ) SawTooth = 127-SawTooth;

  02bf7	80 f9 3f	 cmp	 cl, 63			; 0000003fH
  02bfa	88 54 ef 04	 mov	 BYTE PTR [edi+ebp*8+4], dl
  02bfe	76 06		 jbe	 SHORT $L124244
  02c00	b0 7f		 mov	 al, 127			; 0000007fH
  02c02	2a c1		 sub	 al, cl
  02c04	8a c8		 mov	 cl, al
$L124244:

; 1981 : 
; 1982 :                 // Advance position, in direction of angle SawTooth+ByteD.
; 1983 : 				MoveSparkAngle(ThisSpark, 255& (SawTooth + ThisSpark->ByteD) );

  02c06	33 c0		 xor	 eax, eax
  02c08	8a 44 ef 07	 mov	 al, BYTE PTR [edi+ebp*8+7]
  02c0c	02 c1		 add	 al, cl
  02c0e	88 44 24 58	 mov	 BYTE PTR $T133596[esp+92], al
  02c12	8b 4c 24 58	 mov	 ecx, DWORD PTR $T133596[esp+92]
  02c16	04 40		 add	 al, 64			; 00000040H
  02c18	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  02c1e	8a 99 00 00 00
	00		 mov	 bl, BYTE PTR _PhaseTable[ecx]
  02c24	80 eb 7f	 sub	 bl, 127			; 0000007fH
  02c27	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  02c2c	8a 80 00 00 00
	00		 mov	 al, BYTE PTR _PhaseTable[eax]
  02c32	2c 7f		 sub	 al, 127			; 0000007fH
  02c34	84 db		 test	 bl, bl
  02c36	88 44 24 13	 mov	 BYTE PTR _Ydir$133590[esp+92], al
  02c3a	7d 53		 jge	 SHORT $L133591
  02c3c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  02c42	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  02c48	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  02c4e	83 c2 04	 add	 edx, 4
  02c51	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  02c57	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  02c5d	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  02c63	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  02c69	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  02c6f	0f be d3	 movsx	 edx, bl
  02c72	f7 da		 neg	 edx
  02c74	83 e0 7f	 and	 eax, 127		; 0000007fH
  02c77	3b c2		 cmp	 eax, edx
  02c79	7d 60		 jge	 SHORT $L133594
  02c7b	8b 44 24 18	 mov	 eax, DWORD PTR -68+[esp+92]
  02c7f	8a 08		 mov	 cl, BYTE PTR [eax]
  02c81	8a 96 c8 00 00
	00		 mov	 dl, BYTE PTR [esi+200]
  02c87	fe c9		 dec	 cl
  02c89	22 ca		 and	 cl, dl
  02c8b	88 08		 mov	 BYTE PTR [eax], cl
  02c8d	eb 4c		 jmp	 SHORT $L133594
$L133591:
  02c8f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  02c95	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  02c9b	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  02ca1	83 c2 04	 add	 edx, 4
  02ca4	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  02caa	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  02cb0	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  02cb6	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  02cbc	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  02cc2	83 e0 7f	 and	 eax, 127		; 0000007fH
  02cc5	3a c3		 cmp	 al, bl
  02cc7	7d 12		 jge	 SHORT $L133594
  02cc9	8b 44 24 18	 mov	 eax, DWORD PTR -68+[esp+92]
  02ccd	8a 10		 mov	 dl, BYTE PTR [eax]
  02ccf	8a 8e c8 00 00
	00		 mov	 cl, BYTE PTR [esi+200]
  02cd5	fe c2		 inc	 dl
  02cd7	22 d1		 and	 dl, cl
  02cd9	88 10		 mov	 BYTE PTR [eax], dl
$L133594:
  02cdb	8a 5c 24 13	 mov	 bl, BYTE PTR _Ydir$133590[esp+92]
  02cdf	84 db		 test	 bl, bl
  02ce1	7d 5a		 jge	 SHORT $L133595
  02ce3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  02ce9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  02cef	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  02cf5	83 c2 04	 add	 edx, 4
  02cf8	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  02cfe	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  02d04	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  02d0a	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  02d10	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  02d16	0f be cb	 movsx	 ecx, bl
  02d19	f7 d9		 neg	 ecx
  02d1b	83 e0 7f	 and	 eax, 127		; 0000007fH
  02d1e	3b c1		 cmp	 eax, ecx
  02d20	0f 8d 2b 04 00
	00		 jge	 $L124014
  02d26	8b 44 24 14	 mov	 eax, DWORD PTR -72+[esp+92]
  02d2a	8a 10		 mov	 dl, BYTE PTR [eax]

; 2005 : 
; 2006 : 				// Advance position.
; 2007 :                 MoveSparkXY( ThisSpark, TempSpeedX, TempSpeedY ); 

  02d2c	8a 8e cc 00 00
	00		 mov	 cl, BYTE PTR [esi+204]
  02d32	fe ca		 dec	 dl
  02d34	22 ca		 and	 cl, dl
  02d36	88 08		 mov	 BYTE PTR [eax], cl

; 2008 :             }
; 2009 :             else // Delete the spark.

  02d38	e9 14 04 00 00	 jmp	 $L124014

; 1981 : 
; 1982 :                 // Advance position, in direction of angle SawTooth+ByteD.
; 1983 : 				MoveSparkAngle(ThisSpark, 255& (SawTooth + ThisSpark->ByteD) );

$L133595:
  02d3d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  02d43	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  02d49	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  02d4f	83 c2 04	 add	 edx, 4
  02d52	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  02d58	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  02d5e	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  02d64	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  02d6a	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax

; 1984 :             }
; 1985 :             else  // Delete the spark.

  02d70	e9 ae 01 00 00	 jmp	 $L133697
$L124246:

; 1986 :                 *ThisSpark = Sparks(--ActiveSparkNum);
; 1987 : 			break;
; 1988 : 
; 1989 : 
; 1990 : 		//   Moves in semicircular motions.		
; 1991 : 		case ISPARK_SpawnedTwirl:
; 1992 :             if   ((( ThisSpark->ByteC -= 1 ) < 255 )  )  // Timeout.

  02d75	8a 4c ef 06	 mov	 cl, BYTE PTR [edi+ebp*8+6]
  02d79	fe c9		 dec	 cl
  02d7b	8a c1		 mov	 al, cl
  02d7d	3c ff		 cmp	 al, 255			; 000000ffH
  02d7f	88 4c ef 06	 mov	 BYTE PTR [edi+ebp*8+6], cl
  02d83	0f 83 bc 01 00
	00		 jae	 $L124247

; 1993 :             {
; 1994 : 	            DWORD SparkDest = (DWORD)(ThisSpark->X + ( ThisSpark->Y << UBits ) );
; 1995 :                 // Set spark.
; 1996 :                 Mips(0).DataArray(SparkDest) = ThisSpark->Heat;

  02d89	33 c9		 xor	 ecx, ecx
  02d8b	8a 4c ef 03	 mov	 cl, BYTE PTR [edi+ebp*8+3]
  02d8f	8d 44 ef 03	 lea	 eax, DWORD PTR [edi+ebp*8+3]
  02d93	89 44 24 14	 mov	 DWORD PTR -72+[esp+92], eax
  02d97	8d 54 ef 02	 lea	 edx, DWORD PTR [edi+ebp*8+2]
  02d9b	89 54 24 18	 mov	 DWORD PTR -68+[esp+92], edx
  02d9f	8b c1		 mov	 eax, ecx
  02da1	8a 4e 30	 mov	 cl, BYTE PTR [esi+48]
  02da4	d3 e0		 shl	 eax, cl
  02da6	8b 8e a8 00 00
	00		 mov	 ecx, DWORD PTR [esi+168]
  02dac	8b 59 1c	 mov	 ebx, DWORD PTR [ecx+28]
  02daf	33 c9		 xor	 ecx, ecx
  02db1	8a 0a		 mov	 cl, BYTE PTR [edx]
  02db3	8a 54 ef 01	 mov	 dl, BYTE PTR [edi+ebp*8+1]
  02db7	03 c3		 add	 eax, ebx
  02db9	88 14 08	 mov	 BYTE PTR [eax+ecx], dl

; 1997 : 
; 1998 : 				//BYTE TempSpeedX   =  -128 +  (SBYTE)PhaseTable[(ThisSpark->ByteB+64 ) & 255];
; 1999 : 				//BYTE TempSpeedY   = (-128 + ((SBYTE)PhaseTable[ ThisSpark->ByteB ]) );
; 2000 : 
; 2001 : 				BYTE TempSpeedX = SignedPhaseTable[ (ThisSpark->ByteB+64 ) & 255 ];

  02dbc	33 c0		 xor	 eax, eax
  02dbe	8a 44 ef 05	 mov	 al, BYTE PTR [edi+ebp*8+5]

; 2002 : 				BYTE TempSpeedY = SignedPhaseTable[  ThisSpark->ByteB ];

  02dc2	8a 90 00 00 00
	00		 mov	 dl, BYTE PTR _SignedPhaseTable[eax]
  02dc8	8d 48 40	 lea	 ecx, DWORD PTR [eax+64]
  02dcb	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  02dd1	8a 99 00 00 00
	00		 mov	 bl, BYTE PTR _SignedPhaseTable[ecx]

; 2003 : 
; 2004 : 				*(_WORD*) &(ThisSpark->ByteA) +=  (_WORD) ThisSpark->ByteD << 4 ;   // Add angle delta (4:4) "fixed"-point)

  02dd7	66 0f b6 4c ef
	07		 movzx	 cx, BYTE PTR [edi+ebp*8+7]
  02ddd	8d 44 ef 04	 lea	 eax, DWORD PTR [edi+ebp*8+4]
  02de1	88 54 24 13	 mov	 BYTE PTR _TempSpeedY$124251[esp+92], dl
  02de5	c1 e1 04	 shl	 ecx, 4
  02de8	66 01 08	 add	 WORD PTR [eax], cx

; 2005 : 
; 2006 : 				// Advance position.
; 2007 :                 MoveSparkXY( ThisSpark, TempSpeedX, TempSpeedY ); 

  02deb	84 db		 test	 bl, bl
  02ded	7d 53		 jge	 SHORT $L133633
  02def	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  02df5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  02dfb	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  02e01	83 c2 04	 add	 edx, 4
  02e04	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  02e0a	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  02e10	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  02e16	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  02e1c	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  02e22	0f be d3	 movsx	 edx, bl
  02e25	f7 da		 neg	 edx
  02e27	83 e0 7f	 and	 eax, 127		; 0000007fH
  02e2a	3b c2		 cmp	 eax, edx
  02e2c	7d 60		 jge	 SHORT $L133636
  02e2e	8b 44 24 18	 mov	 eax, DWORD PTR -68+[esp+92]
  02e32	8a 08		 mov	 cl, BYTE PTR [eax]
  02e34	8a 96 c8 00 00
	00		 mov	 dl, BYTE PTR [esi+200]
  02e3a	fe c9		 dec	 cl
  02e3c	22 ca		 and	 cl, dl
  02e3e	88 08		 mov	 BYTE PTR [eax], cl
  02e40	eb 4c		 jmp	 SHORT $L133636
$L133633:
  02e42	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  02e48	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  02e4e	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  02e54	83 c2 04	 add	 edx, 4
  02e57	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  02e5d	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  02e63	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  02e69	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  02e6f	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  02e75	83 e0 7f	 and	 eax, 127		; 0000007fH
  02e78	3a c3		 cmp	 al, bl
  02e7a	7d 12		 jge	 SHORT $L133636
  02e7c	8b 44 24 18	 mov	 eax, DWORD PTR -68+[esp+92]
  02e80	8a 10		 mov	 dl, BYTE PTR [eax]
  02e82	8a 8e c8 00 00
	00		 mov	 cl, BYTE PTR [esi+200]
  02e88	fe c2		 inc	 dl
  02e8a	22 d1		 and	 dl, cl
  02e8c	88 10		 mov	 BYTE PTR [eax], dl
$L133636:
  02e8e	8a 5c 24 13	 mov	 bl, BYTE PTR _TempSpeedY$124251[esp+92]
  02e92	84 db		 test	 bl, bl
  02e94	7d 5a		 jge	 SHORT $L133637
  02e96	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  02e9c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  02ea2	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  02ea8	83 c2 04	 add	 edx, 4
  02eab	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  02eb1	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  02eb7	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  02ebd	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  02ec3	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  02ec9	0f be cb	 movsx	 ecx, bl
  02ecc	f7 d9		 neg	 ecx
  02ece	83 e0 7f	 and	 eax, 127		; 0000007fH
  02ed1	3b c1		 cmp	 eax, ecx
  02ed3	0f 8d 78 02 00
	00		 jge	 $L124014
  02ed9	8b 44 24 14	 mov	 eax, DWORD PTR -72+[esp+92]
  02edd	8a 10		 mov	 dl, BYTE PTR [eax]
  02edf	8a 8e cc 00 00
	00		 mov	 cl, BYTE PTR [esi+204]
  02ee5	fe ca		 dec	 dl
  02ee7	22 ca		 and	 cl, dl
  02ee9	88 08		 mov	 BYTE PTR [eax], cl
  02eeb	e9 61 02 00 00	 jmp	 $L124014
$L133637:
  02ef0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  02ef6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  02efc	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  02f02	83 c2 04	 add	 edx, 4
  02f05	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  02f0b	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  02f11	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  02f17	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  02f1d	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
$L133697:
  02f23	83 e0 7f	 and	 eax, 127		; 0000007fH
  02f26	3a c3		 cmp	 al, bl
  02f28	0f 8d 23 02 00
	00		 jge	 $L124014
  02f2e	8b 44 24 14	 mov	 eax, DWORD PTR -72+[esp+92]
  02f32	8a 10		 mov	 dl, BYTE PTR [eax]
  02f34	8a 8e cc 00 00
	00		 mov	 cl, BYTE PTR [esi+204]
  02f3a	fe c2		 inc	 dl
  02f3c	22 ca		 and	 cl, dl
  02f3e	88 08		 mov	 BYTE PTR [eax], cl

; 2008 :             }
; 2009 :             else // Delete the spark.

  02f40	e9 0c 02 00 00	 jmp	 $L124014
$L124247:

; 2010 :                 *ThisSpark = Sparks(--ActiveSparkNum);

  02f45	8b 86 f8 00 00
	00		 mov	 eax, DWORD PTR [esi+248]
  02f4b	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  02f51	48		 dec	 eax
  02f52	89 86 f8 00 00
	00		 mov	 DWORD PTR [esi+248], eax
  02f58	8b 0c c2	 mov	 ecx, DWORD PTR [edx+eax*8]
  02f5b	89 0c ef	 mov	 DWORD PTR [edi+ebp*8], ecx
  02f5e	8b 54 c2 04	 mov	 edx, DWORD PTR [edx+eax*8+4]
  02f62	89 54 ef 04	 mov	 DWORD PTR [edi+ebp*8+4], edx

; 2011 : 			break;

  02f66	e9 e6 01 00 00	 jmp	 $L124014
$L124255:

; 2012 : 
; 2013 : 
; 2014 : 		//   Moves in pseudoturbulent motions.		
; 2015 : 		case ISPARK_SprinklerTwirl:
; 2016 :             if   ((( ThisSpark->ByteC -= 1 ) < 255 )  )  // Timeout.

  02f6b	8a 4c ef 06	 mov	 cl, BYTE PTR [edi+ebp*8+6]
  02f6f	fe c9		 dec	 cl
  02f71	8a c1		 mov	 al, cl
  02f73	3c ff		 cmp	 al, 255			; 000000ffH
  02f75	88 4c ef 06	 mov	 BYTE PTR [edi+ebp*8+6], cl
  02f79	0f 83 b1 01 00
	00		 jae	 $L124256

; 2017 :             {
; 2018 : 	            DWORD SparkDest = (DWORD)(ThisSpark->X + ( ThisSpark->Y << UBits ));
; 2019 :                 // Set spark.
; 2020 :                 Mips(0).DataArray(SparkDest) = ThisSpark->Heat; 

  02f7f	33 c9		 xor	 ecx, ecx
  02f81	8a 4c ef 03	 mov	 cl, BYTE PTR [edi+ebp*8+3]
  02f85	8d 44 ef 03	 lea	 eax, DWORD PTR [edi+ebp*8+3]
  02f89	89 44 24 14	 mov	 DWORD PTR -72+[esp+92], eax
  02f8d	8d 54 ef 02	 lea	 edx, DWORD PTR [edi+ebp*8+2]
  02f91	89 54 24 18	 mov	 DWORD PTR -68+[esp+92], edx
  02f95	8b c1		 mov	 eax, ecx
  02f97	8a 4e 30	 mov	 cl, BYTE PTR [esi+48]
  02f9a	d3 e0		 shl	 eax, cl
  02f9c	8b 8e a8 00 00
	00		 mov	 ecx, DWORD PTR [esi+168]
  02fa2	8b 59 1c	 mov	 ebx, DWORD PTR [ecx+28]
  02fa5	33 c9		 xor	 ecx, ecx
  02fa7	8a 0a		 mov	 cl, BYTE PTR [edx]
  02fa9	8a 54 ef 01	 mov	 dl, BYTE PTR [edi+ebp*8+1]
  02fad	03 c3		 add	 eax, ebx
  02faf	88 14 08	 mov	 BYTE PTR [eax+ecx], dl

; 2021 : 				BYTE TempSpeedX   =  -128 + (SBYTE)PhaseTable[(ThisSpark->ByteA+64 ) & 255]; 

  02fb2	8a 4c ef 04	 mov	 cl, BYTE PTR [edi+ebp*8+4]
  02fb6	33 d2		 xor	 edx, edx
  02fb8	8d 44 ef 04	 lea	 eax, DWORD PTR [edi+ebp*8+4]
  02fbc	8a d1		 mov	 dl, cl
  02fbe	83 c2 40	 add	 edx, 64			; 00000040H
  02fc1	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  02fc7	8a 9a 00 00 00
	00		 mov	 bl, BYTE PTR _PhaseTable[edx]

; 2022 : 				BYTE TempSpeedY   =  ThisSpark->ByteB; 

  02fcd	8a 54 ef 05	 mov	 dl, BYTE PTR [edi+ebp*8+5]
  02fd1	88 54 24 13	 mov	 BYTE PTR _TempSpeedY$124261[esp+92], dl

; 2023 : 				ThisSpark->ByteA +=  ThisSpark->ByteD; 

  02fd5	8a 54 ef 07	 mov	 dl, BYTE PTR [edi+ebp*8+7]
  02fd9	80 c3 80	 add	 bl, 128			; 00000080H
  02fdc	02 d1		 add	 dl, cl

; 2024 : 				// Rotate angle.
; 2025 :                 // (BYTE) (ThisSpark->ByteC);
; 2026 :                 // Advance position.
; 2027 :                 MoveSparkXY( ThisSpark, TempSpeedX, TempSpeedY );

  02fde	84 db		 test	 bl, bl
  02fe0	88 10		 mov	 BYTE PTR [eax], dl
  02fe2	7d 53		 jge	 SHORT $L133677
  02fe4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  02fea	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  02ff0	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  02ff6	83 c2 04	 add	 edx, 4
  02ff9	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  02fff	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  03005	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  0300b	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  03011	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  03017	0f be cb	 movsx	 ecx, bl
  0301a	f7 d9		 neg	 ecx
  0301c	83 e0 7f	 and	 eax, 127		; 0000007fH
  0301f	3b c1		 cmp	 eax, ecx
  03021	7d 60		 jge	 SHORT $L133680
  03023	8b 44 24 18	 mov	 eax, DWORD PTR -68+[esp+92]
  03027	8a 10		 mov	 dl, BYTE PTR [eax]
  03029	8a 8e c8 00 00
	00		 mov	 cl, BYTE PTR [esi+200]
  0302f	fe ca		 dec	 dl
  03031	22 d1		 and	 dl, cl
  03033	88 10		 mov	 BYTE PTR [eax], dl
  03035	eb 4c		 jmp	 SHORT $L133680
$L133677:
  03037	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  0303d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  03043	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  03049	83 c2 04	 add	 edx, 4
  0304c	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  03052	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  03058	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  0305e	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  03064	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  0306a	83 e0 7f	 and	 eax, 127		; 0000007fH
  0306d	3a c3		 cmp	 al, bl
  0306f	7d 12		 jge	 SHORT $L133680
  03071	8b 44 24 18	 mov	 eax, DWORD PTR -68+[esp+92]
  03075	8a 08		 mov	 cl, BYTE PTR [eax]
  03077	8a 96 c8 00 00
	00		 mov	 dl, BYTE PTR [esi+200]
  0307d	fe c1		 inc	 cl
  0307f	22 ca		 and	 cl, dl
  03081	88 08		 mov	 BYTE PTR [eax], cl
$L133680:
  03083	8a 5c 24 13	 mov	 bl, BYTE PTR _TempSpeedY$124261[esp+92]
  03087	84 db		 test	 bl, bl
  03089	7d 57		 jge	 SHORT $L133681
  0308b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  03091	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  03097	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  0309d	83 c2 04	 add	 edx, 4
  030a0	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  030a6	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  030ac	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  030b2	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  030b8	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  030be	0f be d3	 movsx	 edx, bl
  030c1	f7 da		 neg	 edx
  030c3	83 e0 7f	 and	 eax, 127		; 0000007fH
  030c6	3b c2		 cmp	 eax, edx
  030c8	0f 8d 83 00 00
	00		 jge	 $L124014
  030ce	8b 44 24 14	 mov	 eax, DWORD PTR -72+[esp+92]
  030d2	8a 08		 mov	 cl, BYTE PTR [eax]
  030d4	8a 96 cc 00 00
	00		 mov	 dl, BYTE PTR [esi+204]
  030da	fe c9		 dec	 cl
  030dc	22 d1		 and	 dl, cl
  030de	88 10		 mov	 BYTE PTR [eax], dl
  030e0	eb 6f		 jmp	 SHORT $L124014
$L133681:
  030e2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  030e8	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  030ee	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  030f4	83 c2 04	 add	 edx, 4
  030f7	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  030fd	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  03103	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  03109	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  0310f	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  03115	83 e0 7f	 and	 eax, 127		; 0000007fH
  03118	3a c3		 cmp	 al, bl
  0311a	7d 35		 jge	 SHORT $L124014
  0311c	8b 44 24 14	 mov	 eax, DWORD PTR -72+[esp+92]
  03120	8a 08		 mov	 cl, BYTE PTR [eax]
  03122	8a 96 cc 00 00
	00		 mov	 dl, BYTE PTR [esi+204]
  03128	fe c1		 inc	 cl
  0312a	22 d1		 and	 dl, cl
  0312c	88 10		 mov	 BYTE PTR [eax], dl

; 2028 :             }
; 2029 :             else // Delete the spark.

  0312e	eb 21		 jmp	 SHORT $L124014
$L124256:

; 2030 :                 *ThisSpark = Sparks(--ActiveSparkNum);

  03130	8b 86 f8 00 00
	00		 mov	 eax, DWORD PTR [esi+248]
  03136	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  0313c	48		 dec	 eax
  0313d	89 86 f8 00 00
	00		 mov	 DWORD PTR [esi+248], eax
  03143	8b 14 c1	 mov	 edx, DWORD PTR [ecx+eax*8]
  03146	89 14 ef	 mov	 DWORD PTR [edi+ebp*8], edx
  03149	8b 44 c1 04	 mov	 eax, DWORD PTR [ecx+eax*8+4]
  0314d	89 44 ef 04	 mov	 DWORD PTR [edi+ebp*8+4], eax
$L124014:
  03151	8b 9e f8 00 00
	00		 mov	 ebx, DWORD PTR [esi+248]
  03157	45		 inc	 ebp
  03158	3b eb		 cmp	 ebp, ebx
  0315a	0f 8c e0 ce ff
	ff		 jl	 $L124013
  03160	5f		 pop	 edi
$L124015:
  03161	5e		 pop	 esi
  03162	5d		 pop	 ebp
  03163	5b		 pop	 ebx

; 2031 : 			break;
; 2032 : 
; 2033 :         } //Switch.
; 2034 : 	}
; 2035 : }

  03164	83 c4 4c	 add	 esp, 76			; 0000004cH
  03167	c3		 ret	 0
$L133704:
  03168	00 00 00 00	 DD	 $L124021
  0316c	00 00 00 00	 DD	 $L124024
  03170	00 00 00 00	 DD	 $L124029
  03174	00 00 00 00	 DD	 $L124033
  03178	00 00 00 00	 DD	 $L124087
  0317c	00 00 00 00	 DD	 $L124090
  03180	00 00 00 00	 DD	 $L124094
  03184	00 00 00 00	 DD	 $L124097
  03188	00 00 00 00	 DD	 $L124101
  0318c	00 00 00 00	 DD	 $L124039
  03190	00 00 00 00	 DD	 $L124049
  03194	00 00 00 00	 DD	 $L124068
  03198	00 00 00 00	 DD	 $L124059
  0319c	00 00 00 00	 DD	 $L124105
  031a0	00 00 00 00	 DD	 $L124108
  031a4	00 00 00 00	 DD	 $L124140
  031a8	00 00 00 00	 DD	 $L124124
  031ac	00 00 00 00	 DD	 $L124111
  031b0	00 00 00 00	 DD	 $L124114
  031b4	00 00 00 00	 DD	 $L124119
  031b8	00 00 00 00	 DD	 $L124134
  031bc	00 00 00 00	 DD	 $L124137
  031c0	00 00 00 00	 DD	 $L124149
  031c4	00 00 00 00	 DD	 $L124152
  031c8	00 00 00 00	 DD	 $L124159
  031cc	00 00 00 00	 DD	 $L124167
  031d0	00 00 00 00	 DD	 $L124143
  031d4	00 00 00 00	 DD	 $L124129
  031d8	00 00 00 00	 DD	 $L124146
  031dc	00 00 00 00	 DD	 $L124075
  031e0	00 00 00 00	 DD	 $L124081
  031e4	00 00 00 00	 DD	 $L124014
  031e8	00 00 00 00	 DD	 $L124188
  031ec	00 00 00 00	 DD	 $L124193
  031f0	00 00 00 00	 DD	 $L124203
  031f4	00 00 00 00	 DD	 $L124218
  031f8	00 00 00 00	 DD	 $L124224
  031fc	00 00 00 00	 DD	 $L124229
  03200	00 00 00 00	 DD	 $L124234
  03204	00 00 00 00	 DD	 $L124246
  03208	00 00 00 00	 DD	 $L124255
  0320c	00 00 00 00	 DD	 $L124198
  03210	00 00 00 00	 DD	 $L124210
  03214	00 00 00 00	 DD	 $L124239
?RedrawSparks@UFireTexture@@AAEXXZ ENDP			; UFireTexture::RedrawSparks
_TEXT	ENDS
PUBLIC	?PostDrawSparks@UFireTexture@@AAEXXZ		; UFireTexture::PostDrawSparks
; Function compile flags: /Ogty
;	COMDAT ?PostDrawSparks@UFireTexture@@AAEXXZ
_TEXT	SEGMENT
?PostDrawSparks@UFireTexture@@AAEXXZ PROC NEAR		; UFireTexture::PostDrawSparks, COMDAT
; _this$ = ecx

; 2040 : {

  00000	8b d1		 mov	 edx, ecx

; 2041 :     DWORD SparkDest;
; 2042 : 
; 2043 : 	BYTE  FoundStar=0;
; 2044 : 
; 2045 : 	if( StarStatus == 0 ) return; // No stars so don't search the array.

  00002	8a 82 10 05 00
	00		 mov	 al, BYTE PTR [edx+1296]
  00008	53		 push	 ebx
  00009	32 db		 xor	 bl, bl
  0000b	84 c0		 test	 al, al
  0000d	57		 push	 edi
  0000e	74 72		 je	 SHORT $L124277

; 2046 : 		
; 2047 : 	for( INT S=0; S < ActiveSparkNum; S++ )

  00010	8b 82 f8 00 00
	00		 mov	 eax, DWORD PTR [edx+248]
  00016	33 ff		 xor	 edi, edi
  00018	85 c0		 test	 eax, eax
  0001a	7e 5f		 jle	 SHORT $L133737
  0001c	56		 push	 esi

; 2070 : }

  0001d	8d 49 00	 npad	 3
$L124270:

; 2046 : 		
; 2047 : 	for( INT S=0; S < ActiveSparkNum; S++ )

  00020	8b 82 fc 00 00
	00		 mov	 eax, DWORD PTR [edx+252]
  00026	8d 34 f8	 lea	 esi, DWORD PTR [eax+edi*8]

; 2048 : 	{
; 2049 :         if  (Sparks(S).Type == SPARK_Stars)

  00029	80 3e 16	 cmp	 BYTE PTR [esi], 22	; 00000016H
  0002c	75 3d		 jne	 SHORT $L124271

; 2050 : 		{
; 2051 : 			FoundStar = 1;
; 2052 : 			//  Fixed stars disappear depending to fire Intensity.
; 2053 : 			//  called here after the update: so restore the original star.
; 2054 : 			//  ByteA has the star itself, ByteB the saved bckgrnd
; 2055 : 
; 2056 : 			SparkDest = (DWORD)(Sparks(S).X
; 2057 : 			+ (Sparks(S).Y << UBits ) );

  0002e	8a 4a 30	 mov	 cl, BYTE PTR [edx+48]
  00031	33 c0		 xor	 eax, eax
  00033	8a 46 03	 mov	 al, BYTE PTR [esi+3]
  00036	b3 01		 mov	 bl, 1
  00038	d3 e0		 shl	 eax, cl
  0003a	33 c9		 xor	 ecx, ecx
  0003c	8a 4e 02	 mov	 cl, BYTE PTR [esi+2]
  0003f	03 c1		 add	 eax, ecx

; 2058 : 
; 2059 : 			//  Save real sky value.
; 2060 : 			BYTE DimStar = Mips(0).DataArray(SparkDest);

  00041	8b 8a a8 00 00
	00		 mov	 ecx, DWORD PTR [edx+168]
  00047	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]
  0004a	8a 0c 08	 mov	 cl, BYTE PTR [eax+ecx]

; 2061 : 			Sparks(S).ByteB = DimStar;
; 2062 : 
; 2063 : 			//  Put in the star if under cutoff.
; 2064 : 			if( DimStar < STAR_CUTOFF )

  0004d	80 f9 26	 cmp	 cl, 38			; 00000026H
  00050	88 4e 05	 mov	 BYTE PTR [esi+5], cl
  00053	73 16		 jae	 SHORT $L124271

; 2065 : 				Mips(0).DataArray(SparkDest) = Sparks(S).ByteA;

  00055	8b 8a fc 00 00
	00		 mov	 ecx, DWORD PTR [edx+252]
  0005b	8b b2 a8 00 00
	00		 mov	 esi, DWORD PTR [edx+168]
  00061	8b 76 1c	 mov	 esi, DWORD PTR [esi+28]
  00064	8a 4c f9 04	 mov	 cl, BYTE PTR [ecx+edi*8+4]
  00068	88 0c 30	 mov	 BYTE PTR [eax+esi], cl
$L124271:
  0006b	8b 82 f8 00 00
	00		 mov	 eax, DWORD PTR [edx+248]
  00071	47		 inc	 edi
  00072	3b f8		 cmp	 edi, eax
  00074	7c aa		 jl	 SHORT $L124270

; 2066 : 		}
; 2067 :     }
; 2068 : 
; 2069 : 	if( FoundStar == 0 ) StarStatus=0;

  00076	84 db		 test	 bl, bl
  00078	5e		 pop	 esi
  00079	75 07		 jne	 SHORT $L124277
$L133737:
  0007b	c6 82 10 05 00
	00 00		 mov	 BYTE PTR [edx+1296], 0
$L124277:
  00082	5f		 pop	 edi
  00083	5b		 pop	 ebx

; 2070 : }

  00084	c3		 ret	 0
?PostDrawSparks@UFireTexture@@AAEXXZ ENDP		; UFireTexture::PostDrawSparks
_TEXT	ENDS
PUBLIC	?CalculateWater@UWaterTexture@@QAEXXZ		; UWaterTexture::CalculateWater
EXTRN	_CalcWaterASM:NEAR
; Function compile flags: /Ogty
;	COMDAT ?CalculateWater@UWaterTexture@@QAEXXZ
_TEXT	SEGMENT
?CalculateWater@UWaterTexture@@QAEXXZ PROC NEAR		; UWaterTexture::CalculateWater, COMDAT
; _this$ = ecx

; 2092 : 	WaveParity++;

  00000	8a 81 f8 12 00
	00		 mov	 al, BYTE PTR [ecx+4856]

; 2093 : 	try
; 2094 : 	{
; 2095 : 		CalcWaterASM
; 2096 : 		(
; 2097 : 			&Mips(0).DataArray(0),
; 2098 : 			SourceFields,
; 2099 : 			RenderTable,
; 2100 : 			WaveTable,
; 2101 : 			USize,
; 2102 : 			VSize,
; 2103 : 			WaveParity
; 2104 : 		);

  00006	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  00009	fe c0		 inc	 al
  0000b	88 81 f8 12 00
	00		 mov	 BYTE PTR [ecx+4856], al
  00011	33 c0		 xor	 eax, eax
  00013	8a 81 f8 12 00
	00		 mov	 al, BYTE PTR [ecx+4856]
  00019	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0001e	50		 push	 eax
  0001f	8b 41 38	 mov	 eax, DWORD PTR [ecx+56]
  00022	50		 push	 eax
  00023	52		 push	 edx
  00024	8d 81 f8 0c 00
	00		 lea	 eax, DWORD PTR [ecx+3320]
  0002a	50		 push	 eax
  0002b	8b 81 f0 08 00
	00		 mov	 eax, DWORD PTR [ecx+2288]
  00031	8d 91 f4 08 00
	00		 lea	 edx, DWORD PTR [ecx+2292]
  00037	8b 89 a8 00 00
	00		 mov	 ecx, DWORD PTR [ecx+168]
  0003d	52		 push	 edx
  0003e	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00041	50		 push	 eax
  00042	52		 push	 edx
  00043	e8 00 00 00 00	 call	 _CalcWaterASM
  00048	83 c4 1c	 add	 esp, 28			; 0000001cH

; 2105 : 	}
; 2106 : 	catch( ... )
; 2107 : 	{}
; 2108 : }

  0004b	c3		 ret	 0
?CalculateWater@UWaterTexture@@QAEXXZ ENDP		; UWaterTexture::CalculateWater
_TEXT	ENDS
PUBLIC	?ApplyWetTexture@UWetTexture@@AAEXXZ		; UWetTexture::ApplyWetTexture
; Function compile flags: /Ogty
;	COMDAT ?ApplyWetTexture@UWetTexture@@AAEXXZ
_TEXT	SEGMENT
_this$ = -12
_BitMapAddr$ = -16
_SourceMapAddr$ = -8
_Xdimension$ = -20
_Ydimension$ = -36
_UMask$ = -24
_v$ = -4
_LineStart$124305 = -32
_SourceStart$124306 = -28
?ApplyWetTexture@UWetTexture@@AAEXXZ PROC NEAR		; UWetTexture::ApplyWetTexture, COMDAT
; _this$ = ecx

; 2555 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H

; 2556 :     // Apply texture: SourceTexture to
; 2557 :     // the current (output) texture,
; 2558 :     // using displacement effects.
; 2559 : 
; 2560 : 	// Any source texture selected yet ?
; 2561 :     if( SourceTexture == NULL ) return;

  00006	8b 91 00 13 00
	00		 mov	 edx, DWORD PTR [ecx+4864]
  0000c	85 d2		 test	 edx, edx
  0000e	53		 push	 ebx
  0000f	56		 push	 esi
  00010	57		 push	 edi
  00011	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
  00014	0f 84 da 00 00
	00		 je	 $L124304

; 2562 : 
; 2563 :     BYTE* BitMapAddr     = &Mips(0).DataArray(0);     // pointer

  0001a	8b 81 a8 00 00
	00		 mov	 eax, DWORD PTR [ecx+168]
  00020	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  00023	89 45 f0	 mov	 DWORD PTR _BitMapAddr$[ebp], eax

; 2564 : 
; 2565 : 	BYTE* SourceMapAddr;
; 2566 : 
; 2567 : 	if( LocalSourceBitmap ) 

  00026	8b 81 08 13 00
	00		 mov	 eax, DWORD PTR [ecx+4872]
  0002c	85 c0		 test	 eax, eax

; 2568 : 		SourceMapAddr = LocalSourceBitmap;
; 2569 : 	else 

  0002e	75 09		 jne	 SHORT $L133771

; 2570 : 		SourceMapAddr = &SourceTexture->Mips(0).DataArray(0);

  00030	8b 92 a8 00 00
	00		 mov	 edx, DWORD PTR [edx+168]
  00036	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
$L133771:

; 2571 : 
; 2572 :     INT  Xdimension = USize;
; 2573 :     INT  Ydimension = VSize;

  00039	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  0003c	89 45 f8	 mov	 DWORD PTR _SourceMapAddr$[ebp], eax
  0003f	8b 41 34	 mov	 eax, DWORD PTR [ecx+52]
  00042	89 45 ec	 mov	 DWORD PTR _Xdimension$[ebp], eax

; 2574 : 
; 2575 : 	INT UMask = USize - 1;

  00045	48		 dec	 eax

; 2576 : 
; 2577 : #if WETASM
; 2578 : 
; 2579 :     for( INT v=0; v<Ydimension; v++ )

  00046	85 d2		 test	 edx, edx
  00048	89 55 dc	 mov	 DWORD PTR _Ydimension$[ebp], edx
  0004b	89 45 e8	 mov	 DWORD PTR _UMask$[ebp], eax
  0004e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _v$[ebp], 0
  00055	0f 8e 99 00 00
	00		 jle	 $L124304
  0005b	eb 03		 jmp	 SHORT $L124302
$L133770:
  0005d	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
$L124302:

; 2580 :     {
; 2581 : 		BYTE* LineStart =  BitMapAddr + (v << UBits);

  00060	8a 49 30	 mov	 cl, BYTE PTR [ecx+48]
  00063	8b 45 fc	 mov	 eax, DWORD PTR _v$[ebp]
  00066	d3 e0		 shl	 eax, cl
  00068	8b 4d f0	 mov	 ecx, DWORD PTR _BitMapAddr$[ebp]
  0006b	8d 14 08	 lea	 edx, DWORD PTR [eax+ecx]

; 2582 : 		BYTE* SourceStart = SourceMapAddr + (v << UBits);

  0006e	8b 4d f8	 mov	 ecx, DWORD PTR _SourceMapAddr$[ebp]
  00071	03 c1		 add	 eax, ecx
  00073	89 55 e0	 mov	 DWORD PTR _LineStart$124305[ebp], edx
  00076	89 45 e4	 mov	 DWORD PTR _SourceStart$124306[ebp], eax

; 2585 :         {
; 2586 :             mov     esi,LineStart

  00079	8b 75 e0	 mov	 esi, DWORD PTR _LineStart$124305[ebp]

; 2587 :             mov     edi,SourceStart

  0007c	8b 7d e4	 mov	 edi, DWORD PTR _SourceStart$124306[ebp]

; 2588 : 
; 2589 :             xor     eax,eax

  0007f	33 c0		 xor	 eax, eax

; 2590 :             push    ebp

  00081	55		 push	 ebp

; 2591 : 
; 2592 :             mov     ecx,UMask

  00082	8b 4d e8	 mov	 ecx, DWORD PTR _UMask$[ebp]

; 2593 : 			mov     ebp,Xdimension

  00085	8b 6d ec	 mov	 ebp, DWORD PTR _Xdimension$[ebp]

; 2594 : 
; 2595 : 			xor     edx,edx

  00088	33 d2		 xor	 edx, edx

; 2596 :             xor     ebx,ebx

  0008a	33 db		 xor	 ebx, ebx

; 2597 : 
; 2598 : 			mov     dl,[esi+eax] // move up DL processing - skewed pipe

  0008c	8a 14 06	 mov	 dl, BYTE PTR [esi+eax]

; 2599 : 			sub     ebp,2  // last 2 texels done separately.

  0008f	83 ed 02	 sub	 ebp, 2

; 2646 :         }
; 2647 :     }
; 2648 : 
; 2649 : #else
; 2650 : 
; 2651 :     for( INT v=0; v<Ydimension; v++ )
; 2652 :     {
; 2653 : 		BYTE* LineStart =  BitMapAddr + (v << UBits);
; 2654 : 		BYTE* SourceStart = SourceMapAddr + (v << UBits);
; 2655 : 
; 2656 : 		for( INT u=0; u<Xdimension; u += 2 )
; 2657 :         {
; 2658 : 
; 2659 : 		 // coolish effect combining half warped, half original.
; 2660 : 		 // LineStart[u] = (  SourceStart[(u+LineStart[u]) & UMask ] + SourceStart[(u+128) & UMask]  ) >> 1;
; 2661 : 		 INT  u2 = u+1;
; 2662 : 
; 2663 : 		 LineStart[ u] =  SourceStart[(  u + LineStart[ u]) & UMask ];
; 2664 : 		 LineStart[u2] =  SourceStart[( u2 + LineStart[u2]) & UMask ];
; 2665 : 
; 2666 :         }
; 2667 :     }
; 2668 : 
; 2669 : #endif
; 2670 : }

  00092	8d a4 24 00 00
	00 00 8d a4 24
	00 00 00 00	 npad	 14
$CopyLoop$124307:

; 2600 : 
; 2601 :             ;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 2602 :                                      ;;
; 2603 :             align 16                 ;;
; 2604 :             CopyLoop:                ;;
; 2605 :                                      ;;
; 2606 :             add     dl,al            ;; Linestart[u]+u

  000a0	02 d0		 add	 dl, al

; 2607 :             mov     bl,[esi+eax+1]   ;; Get linestart[u+1] (= water displ.ment)

  000a2	8a 5c 06 01	 mov	 bl, BYTE PTR [esi+eax+1]

; 2608 :                                      ;;
; 2609 :             and     dl,cl			 ;;

  000a6	22 d1		 and	 dl, cl

; 2610 : 			add     bl,al			 ;;

  000a8	02 d8		 add	 bl, al

; 2611 : 
; 2612 :             inc     bl               ;; Linestart[u+1] + u+1

  000aa	fe c3		 inc	 bl

; 2613 :             add     al,2			 ;;

  000ac	04 02		 add	 al, 2

; 2614 : 
; 2615 :             mov     dl,[edi+edx]     ;;

  000ae	8a 14 17	 mov	 dl, BYTE PTR [edi+edx]

; 2616 :             and     bl,cl			 ;;

  000b1	22 d9		 and	 bl, cl

; 2617 : 
; 2618 :             cmp     eax,ebp          ;;

  000b3	3b c5		 cmp	 eax, ebp

; 2619 :             mov     [esi+eax-2],dl   ;;

  000b5	88 54 06 fe	 mov	 BYTE PTR [esi+eax-2], dl

; 2620 : 
; 2621 :             mov     bl,[edi+ebx]     ;;

  000b9	8a 1c 1f	 mov	 bl, BYTE PTR [edi+ebx]

; 2622 :             mov     dl,[esi+eax]     ;; Get linestart[u] -  pixel 2

  000bc	8a 14 06	 mov	 dl, BYTE PTR [esi+eax]

; 2623 :                                      ;;
; 2624 :             mov     [esi+eax-2+1],bl ;;

  000bf	88 5c 06 ff	 mov	 BYTE PTR [esi+eax-1], bl

; 2625 :             jb      CopyLoop         ;;

  000c3	72 db		 jb	 SHORT $CopyLoop$124307

; 2626 :                                      ;;
; 2627 :             ;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 2628 : 
; 2629 :             nop

  000c5	90		 npad	 1

; 2630 : 			mov     bl,[esi+eax+1]  ;; get pixel 2

  000c6	8a 5c 06 01	 mov	 bl, BYTE PTR [esi+eax+1]

; 2631 : 
; 2632 : 			add     dl,al

  000ca	02 d0		 add	 dl, al

; 2633 : 			add     bl,al

  000cc	02 d8		 add	 bl, al

; 2634 : 
; 2635 : 			inc     bl		// ebx	    	   ;;

  000ce	fe c3		 inc	 bl

; 2636 :             and     dl,cl	// edx,ecx         ;;

  000d0	22 d1		 and	 dl, cl

; 2637 : 
; 2638 :             pop     ebp     //

  000d2	5d		 pop	 ebp

; 2639 :             and     bl,cl	// ebx,ecx         ;;

  000d3	22 d9		 and	 bl, cl

; 2640 : 
; 2641 :             mov     dl,[edi+edx]    ;; Texel

  000d5	8a 14 17	 mov	 dl, BYTE PTR [edi+edx]

; 2642 :             mov     bl,[edi+ebx]    ;; Texel

  000d8	8a 1c 1f	 mov	 bl, BYTE PTR [edi+ebx]

; 2643 : 
; 2644 :             mov     [esi+eax],dl    ;; Dest

  000db	88 14 06	 mov	 BYTE PTR [esi+eax], dl

; 2645 :             mov     [esi+eax+1],bl  ;; Dest

  000de	88 5c 06 01	 mov	 BYTE PTR [esi+eax+1], bl

; 2583 : 
; 2584 :         __asm

  000e2	8b 45 fc	 mov	 eax, DWORD PTR _v$[ebp]
  000e5	8b 4d dc	 mov	 ecx, DWORD PTR _Ydimension$[ebp]
  000e8	40		 inc	 eax
  000e9	3b c1		 cmp	 eax, ecx
  000eb	89 45 fc	 mov	 DWORD PTR _v$[ebp], eax
  000ee	0f 8c 69 ff ff
	ff		 jl	 $L133770
$L124304:

; 2646 :         }
; 2647 :     }
; 2648 : 
; 2649 : #else
; 2650 : 
; 2651 :     for( INT v=0; v<Ydimension; v++ )
; 2652 :     {
; 2653 : 		BYTE* LineStart =  BitMapAddr + (v << UBits);
; 2654 : 		BYTE* SourceStart = SourceMapAddr + (v << UBits);
; 2655 : 
; 2656 : 		for( INT u=0; u<Xdimension; u += 2 )
; 2657 :         {
; 2658 : 
; 2659 : 		 // coolish effect combining half warped, half original.
; 2660 : 		 // LineStart[u] = (  SourceStart[(u+LineStart[u]) & UMask ] + SourceStart[(u+128) & UMask]  ) >> 1;
; 2661 : 		 INT  u2 = u+1;
; 2662 : 
; 2663 : 		 LineStart[ u] =  SourceStart[(  u + LineStart[ u]) & UMask ];
; 2664 : 		 LineStart[u2] =  SourceStart[( u2 + LineStart[u2]) & UMask ];
; 2665 : 
; 2666 :         }
; 2667 :     }
; 2668 : 
; 2669 : #endif
; 2670 : }

  000f4	5f		 pop	 edi
  000f5	5e		 pop	 esi
  000f6	5b		 pop	 ebx
  000f7	8b e5		 mov	 esp, ebp
  000f9	5d		 pop	 ebp
  000fa	c3		 ret	 0
?ApplyWetTexture@UWetTexture@@AAEXXZ ENDP		; UWetTexture::ApplyWetTexture
_TEXT	ENDS
PUBLIC	?MoveIcePosition@UIceTexture@@AAEXM@Z		; UIceTexture::MoveIcePosition
PUBLIC	__real@42f00000
PUBLIC	__real@3a9d4952
PUBLIC	__real@3a902de0
PUBLIC	__real@3fe0000000000000
;	COMDAT __real@42f00000
; File ..\..\Core\Inc\UnVcWin32.h
CONST	SEGMENT
__real@42f00000 DD 042f00000r			; 120
CONST	ENDS
;	COMDAT __real@3a9d4952
CONST	SEGMENT
__real@3a9d4952 DD 03a9d4952r			; 0.0012
CONST	ENDS
;	COMDAT __real@3a902de0
CONST	SEGMENT
__real@3a902de0 DD 03a902de0r			; 0.0011
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
; Function compile flags: /Ogty
; File C:\duke4\Fire\Src\UnFractal.cpp
CONST	ENDS
;	COMDAT ?MoveIcePosition@UIceTexture@@AAEXM@Z
_TEXT	SEGMENT
_DeltaTime$ = 8
_I$133781 = -4
$T133783 = 8
_I$133792 = -4
$T133794 = 8
_I$133803 = -4
$T133805 = 8
_I$133814 = -4
$T133816 = 8
_I$133825 = -4
$T133827 = 8
_I$133836 = -4
$T133838 = 8
?MoveIcePosition@UIceTexture@@AAEXM@Z PROC NEAR		; UIceTexture::MoveIcePosition, COMDAT
; _this$ = ecx

; 2679 : {

  00000	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 2680 : 	MasterCount += DeltaTime*120.0f;  //Virtual time ticks.

  00003	d9 44 24 10	 fld	 DWORD PTR _DeltaTime$[esp+8]

; 2681 : 
; 2682 : 	UDisplace += 2.0f * DeltaTime * -((SBYTE)(HorizPanSpeed - 128));

  00007	8a 91 ea 00 00
	00		 mov	 dl, BYTE PTR [ecx+234]
  0000d	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@42f00000
  00013	80 c2 80	 add	 dl, -128		; ffffff80H
  00016	d8 81 f4 00 00
	00		 fadd	 DWORD PTR [ecx+244]
  0001c	d9 5c 24 00	 fstp	 DWORD PTR -12+[esp+12]
  00020	8b 44 24 00	 mov	 eax, DWORD PTR -12+[esp+12]
  00024	89 81 f4 00 00
	00		 mov	 DWORD PTR [ecx+244], eax
  0002a	0f be c2	 movsx	 eax, dl
  0002d	89 44 24 04	 mov	 DWORD PTR -8+[esp+12], eax

; 2683 : 	VDisplace += 2.0f * DeltaTime *  ((SBYTE)(VertPanSpeed  - 128));

  00031	8a 81 eb 00 00
	00		 mov	 al, BYTE PTR [ecx+235]
  00037	04 80		 add	 al, -128		; ffffff80H
  00039	db 44 24 04	 fild	 DWORD PTR -8+[esp+12]
  0003d	d8 4c 24 10	 fmul	 DWORD PTR _DeltaTime$[esp+8]
  00041	dc c0		 fadd	 ST(0), ST(0)
  00043	d8 a9 f8 00 00
	00		 fsubr	 DWORD PTR [ecx+248]
  00049	d9 5c 24 04	 fstp	 DWORD PTR -8+[esp+12]
  0004d	8b 54 24 04	 mov	 edx, DWORD PTR -8+[esp+12]
  00051	89 91 f8 00 00
	00		 mov	 DWORD PTR [ecx+248], edx
  00057	0f be d0	 movsx	 edx, al
  0005a	89 54 24 08	 mov	 DWORD PTR -4+[esp+12], edx
  0005e	db 44 24 08	 fild	 DWORD PTR -4+[esp+12]
  00062	d8 4c 24 10	 fmul	 DWORD PTR _DeltaTime$[esp+8]
  00066	dc c0		 fadd	 ST(0), ST(0)
  00068	d8 81 fc 00 00
	00		 fadd	 DWORD PTR [ecx+252]
  0006e	d9 5c 24 10	 fstp	 DWORD PTR 8+[esp+8]
  00072	8b 44 24 10	 mov	 eax, DWORD PTR 8+[esp+8]
  00076	89 81 fc 00 00
	00		 mov	 DWORD PTR [ecx+252], eax

; 2684 : 
; 2685 : 	switch (PanningStyle)
; 2686 : 	{

  0007c	33 c0		 xor	 eax, eax
  0007e	8a 81 e8 00 00
	00		 mov	 al, BYTE PTR [ecx+232]
  00084	83 f8 04	 cmp	 eax, 4
  00087	0f 87 f3 01 00
	00		 ja	 $L124315
  0008d	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $L133851[eax*4]
$L124318:

; 2687 : 		case SLIDE_Linear:
; 2688 : 			UPosition  = UDisplace;

  00094	8b 54 24 04	 mov	 edx, DWORD PTR -8+[esp+12]

; 2689 : 			VPosition  = VDisplace;

  00098	8b 44 24 10	 mov	 eax, DWORD PTR 8+[esp+8]
  0009c	89 91 00 01 00
	00		 mov	 DWORD PTR [ecx+256], edx
  000a2	89 81 04 01 00
	00		 mov	 DWORD PTR [ecx+260], eax

; 2710 : 		break;
; 2711 : 	}	
; 2712 : }

  000a8	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ab	c2 04 00	 ret	 4
$L124319:

; 2690 : 		break;
; 2691 : 
; 2692 : 		case SLIDE_Circular: 
; 2693 : 			UPosition =  UDisplace + appRound( (FLOAT)(Amplitude+1) * appSin( MasterCount * (Frequency+1) * 0.0012f));

  000ae	33 d2		 xor	 edx, edx
  000b0	8a 91 ec 00 00
	00		 mov	 dl, BYTE PTR [ecx+236]
  000b6	33 c0		 xor	 eax, eax
  000b8	8a 81 ed 00 00
	00		 mov	 al, BYTE PTR [ecx+237]
  000be	42		 inc	 edx
  000bf	89 54 24 10	 mov	 DWORD PTR 8+[esp+8], edx
  000c3	db 44 24 10	 fild	 DWORD PTR 8+[esp+8]
  000c7	40		 inc	 eax
  000c8	89 44 24 10	 mov	 DWORD PTR 8+[esp+8], eax

; 2704 : 			VPosition =  VDisplace;
; 2705 : 		break;
; 2706 : 
; 2707 : 		case SLIDE_WavyY: // Y movement, with X sinewave 			
; 2708 : 			UPosition =  UDisplace;
; 2709 : 			VPosition =  VDisplace + appRound( 0.5*(FLOAT)(Amplitude+1) * appCos( MasterCount * (Frequency+1) * 0.0012f));

  000cc	d8 4c 24 00	 fmul	 DWORD PTR -12+[esp+12]
  000d0	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3a9d4952
  000d6	d9 fe		 fsin
  000d8	da 4c 24 10	 fimul	 DWORD PTR 8+[esp+8]
  000dc	d9 5c 24 10	 fstp	 DWORD PTR $T133783[esp+8]

; 2690 : 		break;
; 2691 : 
; 2692 : 		case SLIDE_Circular: 
; 2693 : 			UPosition =  UDisplace + appRound( (FLOAT)(Amplitude+1) * appSin( MasterCount * (Frequency+1) * 0.0012f));

  000e0	d9 44 24 10	 fld	 DWORD PTR $T133783[esp+8]
  000e4	db 5c 24 08	 fistp	 DWORD PTR _I$133781[esp+12]

; 2704 : 			VPosition =  VDisplace;
; 2705 : 		break;
; 2706 : 
; 2707 : 		case SLIDE_WavyY: // Y movement, with X sinewave 			
; 2708 : 			UPosition =  UDisplace;
; 2709 : 			VPosition =  VDisplace + appRound( 0.5*(FLOAT)(Amplitude+1) * appCos( MasterCount * (Frequency+1) * 0.0012f));

  000e8	db 44 24 08	 fild	 DWORD PTR _I$133781[esp+12]
  000ec	33 d2		 xor	 edx, edx
  000ee	8a 91 ec 00 00
	00		 mov	 dl, BYTE PTR [ecx+236]
  000f4	33 c0		 xor	 eax, eax
  000f6	d8 81 f8 00 00
	00		 fadd	 DWORD PTR [ecx+248]
  000fc	8a 81 ed 00 00
	00		 mov	 al, BYTE PTR [ecx+237]
  00102	d9 99 00 01 00
	00		 fstp	 DWORD PTR [ecx+256]
  00108	42		 inc	 edx
  00109	89 54 24 10	 mov	 DWORD PTR 8+[esp+8], edx
  0010d	db 44 24 10	 fild	 DWORD PTR 8+[esp+8]
  00111	40		 inc	 eax
  00112	89 44 24 10	 mov	 DWORD PTR 8+[esp+8], eax
  00116	d8 89 f4 00 00
	00		 fmul	 DWORD PTR [ecx+244]
  0011c	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3a9d4952
  00122	d9 ff		 fcos
  00124	da 4c 24 10	 fimul	 DWORD PTR 8+[esp+8]
  00128	d9 5c 24 10	 fstp	 DWORD PTR $T133794[esp+8]

; 2694 : 			VPosition =  VDisplace + appRound( (FLOAT)(Amplitude+1) * appCos( MasterCount * (Frequency+1) * 0.0012f));

  0012c	d9 44 24 10	 fld	 DWORD PTR $T133794[esp+8]
  00130	db 5c 24 08	 fistp	 DWORD PTR _I$133792[esp+12]

; 2704 : 			VPosition =  VDisplace;
; 2705 : 		break;
; 2706 : 
; 2707 : 		case SLIDE_WavyY: // Y movement, with X sinewave 			
; 2708 : 			UPosition =  UDisplace;
; 2709 : 			VPosition =  VDisplace + appRound( 0.5*(FLOAT)(Amplitude+1) * appCos( MasterCount * (Frequency+1) * 0.0012f));

  00134	e9 37 01 00 00	 jmp	 $L133850
$L124322:

; 2695 : 		break;
; 2696 : 
; 2697 : 		case SLIDE_Gestation: // just some out-of-phase movement.
; 2698 : 			UPosition =  UDisplace + appRound( (FLOAT)(Amplitude+1) * appSin( MasterCount * (Frequency+1) * 0.0012f));

  00139	33 d2		 xor	 edx, edx
  0013b	8a 91 ec 00 00
	00		 mov	 dl, BYTE PTR [ecx+236]
  00141	33 c0		 xor	 eax, eax
  00143	8a 81 ed 00 00
	00		 mov	 al, BYTE PTR [ecx+237]
  00149	42		 inc	 edx
  0014a	89 54 24 10	 mov	 DWORD PTR 8+[esp+8], edx
  0014e	db 44 24 10	 fild	 DWORD PTR 8+[esp+8]
  00152	40		 inc	 eax
  00153	89 44 24 10	 mov	 DWORD PTR 8+[esp+8], eax

; 2704 : 			VPosition =  VDisplace;
; 2705 : 		break;
; 2706 : 
; 2707 : 		case SLIDE_WavyY: // Y movement, with X sinewave 			
; 2708 : 			UPosition =  UDisplace;
; 2709 : 			VPosition =  VDisplace + appRound( 0.5*(FLOAT)(Amplitude+1) * appCos( MasterCount * (Frequency+1) * 0.0012f));

  00157	d8 4c 24 00	 fmul	 DWORD PTR -12+[esp+12]
  0015b	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3a9d4952
  00161	d9 fe		 fsin
  00163	da 4c 24 10	 fimul	 DWORD PTR 8+[esp+8]
  00167	d9 5c 24 10	 fstp	 DWORD PTR $T133805[esp+8]

; 2695 : 		break;
; 2696 : 
; 2697 : 		case SLIDE_Gestation: // just some out-of-phase movement.
; 2698 : 			UPosition =  UDisplace + appRound( (FLOAT)(Amplitude+1) * appSin( MasterCount * (Frequency+1) * 0.0012f));

  0016b	d9 44 24 10	 fld	 DWORD PTR $T133805[esp+8]
  0016f	db 5c 24 08	 fistp	 DWORD PTR _I$133803[esp+12]

; 2704 : 			VPosition =  VDisplace;
; 2705 : 		break;
; 2706 : 
; 2707 : 		case SLIDE_WavyY: // Y movement, with X sinewave 			
; 2708 : 			UPosition =  UDisplace;
; 2709 : 			VPosition =  VDisplace + appRound( 0.5*(FLOAT)(Amplitude+1) * appCos( MasterCount * (Frequency+1) * 0.0012f));

  00173	db 44 24 08	 fild	 DWORD PTR _I$133803[esp+12]
  00177	33 d2		 xor	 edx, edx
  00179	8a 91 ec 00 00
	00		 mov	 dl, BYTE PTR [ecx+236]
  0017f	33 c0		 xor	 eax, eax
  00181	d8 81 f8 00 00
	00		 fadd	 DWORD PTR [ecx+248]
  00187	8a 81 ed 00 00
	00		 mov	 al, BYTE PTR [ecx+237]
  0018d	d9 99 00 01 00
	00		 fstp	 DWORD PTR [ecx+256]
  00193	42		 inc	 edx
  00194	89 54 24 10	 mov	 DWORD PTR 8+[esp+8], edx
  00198	db 44 24 10	 fild	 DWORD PTR 8+[esp+8]
  0019c	40		 inc	 eax
  0019d	89 44 24 10	 mov	 DWORD PTR 8+[esp+8], eax
  001a1	d8 89 f4 00 00
	00		 fmul	 DWORD PTR [ecx+244]
  001a7	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3a902de0
  001ad	d9 ff		 fcos
  001af	da 4c 24 10	 fimul	 DWORD PTR 8+[esp+8]
  001b3	d9 5c 24 10	 fstp	 DWORD PTR $T133816[esp+8]

; 2699 : 			VPosition =  VDisplace + appRound( (FLOAT)(Amplitude+1) * appCos( MasterCount * (Frequency+1) * 0.0011f));

  001b7	d9 44 24 10	 fld	 DWORD PTR $T133816[esp+8]
  001bb	db 5c 24 08	 fistp	 DWORD PTR _I$133814[esp+12]

; 2704 : 			VPosition =  VDisplace;
; 2705 : 		break;
; 2706 : 
; 2707 : 		case SLIDE_WavyY: // Y movement, with X sinewave 			
; 2708 : 			UPosition =  UDisplace;
; 2709 : 			VPosition =  VDisplace + appRound( 0.5*(FLOAT)(Amplitude+1) * appCos( MasterCount * (Frequency+1) * 0.0012f));

  001bf	e9 ac 00 00 00	 jmp	 $L133850
$L124325:

; 2700 : 		break;
; 2701 : 
; 2702 : 		case SLIDE_WavyX:  // X movement, with Y sinewave
; 2703 : 			UPosition =  UDisplace + appRound( 0.5*(FLOAT)(Amplitude+1) * appSin( MasterCount * (Frequency+1) * 0.0012f));

  001c4	33 d2		 xor	 edx, edx
  001c6	8a 91 ec 00 00
	00		 mov	 dl, BYTE PTR [ecx+236]
  001cc	33 c0		 xor	 eax, eax
  001ce	8a 81 ed 00 00
	00		 mov	 al, BYTE PTR [ecx+237]
  001d4	42		 inc	 edx
  001d5	89 54 24 10	 mov	 DWORD PTR 8+[esp+8], edx
  001d9	db 44 24 10	 fild	 DWORD PTR 8+[esp+8]
  001dd	40		 inc	 eax
  001de	89 44 24 10	 mov	 DWORD PTR 8+[esp+8], eax

; 2704 : 			VPosition =  VDisplace;
; 2705 : 		break;
; 2706 : 
; 2707 : 		case SLIDE_WavyY: // Y movement, with X sinewave 			
; 2708 : 			UPosition =  UDisplace;
; 2709 : 			VPosition =  VDisplace + appRound( 0.5*(FLOAT)(Amplitude+1) * appCos( MasterCount * (Frequency+1) * 0.0012f));

  001e2	d8 4c 24 00	 fmul	 DWORD PTR -12+[esp+12]
  001e6	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3a9d4952
  001ec	d9 fe		 fsin
  001ee	da 4c 24 10	 fimul	 DWORD PTR 8+[esp+8]
  001f2	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@3fe0000000000000
  001f8	d9 5c 24 10	 fstp	 DWORD PTR $T133827[esp+8]

; 2700 : 		break;
; 2701 : 
; 2702 : 		case SLIDE_WavyX:  // X movement, with Y sinewave
; 2703 : 			UPosition =  UDisplace + appRound( 0.5*(FLOAT)(Amplitude+1) * appSin( MasterCount * (Frequency+1) * 0.0012f));

  001fc	d9 44 24 10	 fld	 DWORD PTR $T133827[esp+8]
  00200	db 5c 24 08	 fistp	 DWORD PTR _I$133825[esp+12]

; 2704 : 			VPosition =  VDisplace;
; 2705 : 		break;
; 2706 : 
; 2707 : 		case SLIDE_WavyY: // Y movement, with X sinewave 			
; 2708 : 			UPosition =  UDisplace;
; 2709 : 			VPosition =  VDisplace + appRound( 0.5*(FLOAT)(Amplitude+1) * appCos( MasterCount * (Frequency+1) * 0.0012f));

  00204	db 44 24 08	 fild	 DWORD PTR _I$133825[esp+12]
  00208	8b 91 fc 00 00
	00		 mov	 edx, DWORD PTR [ecx+252]
  0020e	89 91 04 01 00
	00		 mov	 DWORD PTR [ecx+260], edx
  00214	d8 81 f8 00 00
	00		 fadd	 DWORD PTR [ecx+248]
  0021a	d9 99 00 01 00
	00		 fstp	 DWORD PTR [ecx+256]

; 2710 : 		break;
; 2711 : 	}	
; 2712 : }

  00220	83 c4 0c	 add	 esp, 12			; 0000000cH
  00223	c2 04 00	 ret	 4
$L124327:

; 2704 : 			VPosition =  VDisplace;
; 2705 : 		break;
; 2706 : 
; 2707 : 		case SLIDE_WavyY: // Y movement, with X sinewave 			
; 2708 : 			UPosition =  UDisplace;
; 2709 : 			VPosition =  VDisplace + appRound( 0.5*(FLOAT)(Amplitude+1) * appCos( MasterCount * (Frequency+1) * 0.0012f));

  00226	33 d2		 xor	 edx, edx
  00228	8a 91 ec 00 00
	00		 mov	 dl, BYTE PTR [ecx+236]
  0022e	8b 44 24 04	 mov	 eax, DWORD PTR -8+[esp+12]
  00232	89 81 00 01 00
	00		 mov	 DWORD PTR [ecx+256], eax
  00238	33 c0		 xor	 eax, eax
  0023a	8a 81 ed 00 00
	00		 mov	 al, BYTE PTR [ecx+237]
  00240	42		 inc	 edx
  00241	89 54 24 10	 mov	 DWORD PTR 8+[esp+8], edx
  00245	db 44 24 10	 fild	 DWORD PTR 8+[esp+8]
  00249	d8 4c 24 00	 fmul	 DWORD PTR -12+[esp+12]
  0024d	40		 inc	 eax
  0024e	89 44 24 10	 mov	 DWORD PTR 8+[esp+8], eax
  00252	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3a9d4952
  00258	d9 ff		 fcos
  0025a	da 4c 24 10	 fimul	 DWORD PTR 8+[esp+8]
  0025e	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@3fe0000000000000
  00264	d9 5c 24 10	 fstp	 DWORD PTR $T133838[esp+8]
  00268	d9 44 24 10	 fld	 DWORD PTR $T133838[esp+8]
  0026c	db 5c 24 08	 fistp	 DWORD PTR _I$133836[esp+12]
$L133850:
  00270	db 44 24 08	 fild	 DWORD PTR _I$133836[esp+12]
  00274	d8 81 fc 00 00
	00		 fadd	 DWORD PTR [ecx+252]
  0027a	d9 99 04 01 00
	00		 fstp	 DWORD PTR [ecx+260]
$L124315:

; 2710 : 		break;
; 2711 : 	}	
; 2712 : }

  00280	83 c4 0c	 add	 esp, 12			; 0000000cH
  00283	c2 04 00	 ret	 4
  00286	8b ff		 npad	 2
$L133851:
  00288	00 00 00 00	 DD	 $L124318
  0028c	00 00 00 00	 DD	 $L124319
  00290	00 00 00 00	 DD	 $L124322
  00294	00 00 00 00	 DD	 $L124325
  00298	00 00 00 00	 DD	 $L124327
?MoveIcePosition@UIceTexture@@AAEXM@Z ENDP		; UIceTexture::MoveIcePosition
_TEXT	ENDS
PUBLIC	?BlitTexIce@UIceTexture@@AAEXXZ			; UIceTexture::BlitTexIce
EXTRN	__imp__GIsPentiumPro:DWORD
_BSS	SEGMENT
?ESPStorage@?3??BlitTexIce@UIceTexture@@AAEXXZ@4KA DD 01H DUP (?) ; ESPStorage
?EBPStorage@?3??BlitTexIce@UIceTexture@@AAEXXZ@4KA DD 01H DUP (?) ; EBPStorage
; Function compile flags: /Ogty
_BSS	ENDS
;	COMDAT ?BlitTexIce@UIceTexture@@AAEXXZ
_TEXT	SEGMENT
_this$ = -32
_TexAddr$ = -44
_GlassAddr$ = -48
_BitMapAddr$ = -40
_Xdimension$ = -16
_Ydimension$ = -52
_TempUMask$ = -20
_UDisp$ = -12
_VDisp$ = -36
_v$ = -4
_LineStart$124349 = -28
_TexStart$124350 = -24
_GlassStart$124351 = -8
_I$133881 = -24
$T133883 = -28
_I$133887 = -24
$T133889 = -28
?BlitTexIce@UIceTexture@@AAEXXZ PROC NEAR		; UIceTexture::BlitTexIce, COMDAT
; _this$ = ecx

; 2720 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	8b c1		 mov	 eax, ecx

; 2721 :     // Warning: Source/GlassTexture must have same dimensions.
; 2722 : 
; 2723 :     BYTE* TexAddr		= &SourceTexture->Mips(0).DataArray(0);
; 2724 : 	BYTE* GlassAddr		= &GlassTexture->Mips(0).DataArray(0);

  00008	8b 88 e0 00 00
	00		 mov	 ecx, DWORD PTR [eax+224]
  0000e	8b 91 a8 00 00
	00		 mov	 edx, DWORD PTR [ecx+168]
  00014	8b 4a 1c	 mov	 ecx, DWORD PTR [edx+28]

; 2725 :     BYTE* BitMapAddr	= &Mips(0).DataArray(0);  // Pointer.

  00017	8b 90 a8 00 00
	00		 mov	 edx, DWORD PTR [eax+168]
  0001d	89 4d d0	 mov	 DWORD PTR _GlassAddr$[ebp], ecx
  00020	8b 4a 1c	 mov	 ecx, DWORD PTR [edx+28]
  00023	53		 push	 ebx
  00024	89 4d d8	 mov	 DWORD PTR _BitMapAddr$[ebp], ecx

; 2726 : 
; 2727 : 	if( LocalSourceBitmap ) return; // Static local source, no update needed.

  00027	8b 88 1c 01 00
	00		 mov	 ecx, DWORD PTR [eax+284]
  0002d	85 c9		 test	 ecx, ecx
  0002f	56		 push	 esi
  00030	57		 push	 edi
  00031	89 45 e0	 mov	 DWORD PTR _this$[ebp], eax
  00034	0f 85 36 03 00
	00		 jne	 $L124348

; 2728 : 
; 2729 : 	TexAddr = &SourceTexture->Mips(0).DataArray(0);

  0003a	8b 90 e4 00 00
	00		 mov	 edx, DWORD PTR [eax+228]
  00040	8b 8a a8 00 00
	00		 mov	 ecx, DWORD PTR [edx+168]
  00046	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]

; 2730 : 
; 2731 :     INT  Xdimension   = USize;  // Wrap needed for 8-bit counters.

  00049	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  0004c	89 55 d4	 mov	 DWORD PTR _TexAddr$[ebp], edx

; 2732 :     INT  Ydimension   = VSize;  // 
; 2733 : 
; 2734 : #if ICEASM
; 2735 : 	INT  TempUMask    = UMask;  //

  0004f	8b 90 c8 00 00
	00		 mov	 edx, DWORD PTR [eax+200]
  00055	89 4d f0	 mov	 DWORD PTR _Xdimension$[ebp], ecx
  00058	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  0005b	89 55 ec	 mov	 DWORD PTR _TempUMask$[ebp], edx

; 2736 : #endif
; 2737 : 
; 2738 : 	static	DWORD ESPStorage;   // Temp ESP  storage.
; 2739 : 	static	DWORD EBPStorage;   // Temp EBP  storage.
; 2740 : 
; 2741 : 	// Positionments are (signed) fixed-point 3:4
; 2742 : 	INT  UDisp =  appRound(UPosition) & UMask;

  0005e	8b 90 00 01 00
	00		 mov	 edx, DWORD PTR [eax+256]
  00064	89 4d cc	 mov	 DWORD PTR _Ydimension$[ebp], ecx
  00067	89 55 e4	 mov	 DWORD PTR $T133883[ebp], edx
  0006a	d9 45 e4	 fld	 DWORD PTR $T133883[ebp]
  0006d	db 5d e8	 fistp	 DWORD PTR _I$133881[ebp]
  00070	8b 90 c8 00 00
	00		 mov	 edx, DWORD PTR [eax+200]
  00076	23 55 e8	 and	 edx, DWORD PTR _I$133881[ebp]
  00079	89 55 f4	 mov	 DWORD PTR _UDisp$[ebp], edx

; 2743 : 	INT  VDisp =  appRound(VPosition) & VMask;

  0007c	8b 90 04 01 00
	00		 mov	 edx, DWORD PTR [eax+260]
  00082	89 55 e4	 mov	 DWORD PTR $T133889[ebp], edx
  00085	d9 45 e4	 fld	 DWORD PTR $T133889[ebp]
  00088	db 5d e8	 fistp	 DWORD PTR _I$133887[ebp]
  0008b	8b b0 cc 00 00
	00		 mov	 esi, DWORD PTR [eax+204]
  00091	8b 7d e8	 mov	 edi, DWORD PTR _I$133887[ebp]
  00094	23 fe		 and	 edi, esi

; 2744 : 
; 2745 :     for( INT v=0; v<Ydimension; v++ )

  00096	33 f6		 xor	 esi, esi
  00098	85 c9		 test	 ecx, ecx
  0009a	89 7d dc	 mov	 DWORD PTR _VDisp$[ebp], edi
  0009d	89 75 fc	 mov	 DWORD PTR _v$[ebp], esi
  000a0	0f 8e ca 02 00
	00		 jle	 $L124348
  000a6	eb 09		 jmp	 SHORT $L124346
$L133893:
  000a8	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  000ab	8b 7d dc	 mov	 edi, DWORD PTR _VDisp$[ebp]
  000ae	8b 75 fc	 mov	 esi, DWORD PTR _v$[ebp]
$L124346:

; 2746 :     {
; 2747 : 		BYTE* LineStart   = BitMapAddr +    (v << UBits);

  000b1	8b 5d d8	 mov	 ebx, DWORD PTR _BitMapAddr$[ebp]
  000b4	33 c9		 xor	 ecx, ecx
  000b6	8a 48 30	 mov	 cl, BYTE PTR [eax+48]
  000b9	8b d6		 mov	 edx, esi
  000bb	d3 e2		 shl	 edx, cl

; 2748 : 		BYTE* TexStart    = TexAddr    +    (v << UBits);
; 2749 : 		BYTE* GlassStart  = GlassAddr  +  (((v + VDisp ) & VMask) << UBits);

  000bd	03 f7		 add	 esi, edi
  000bf	03 da		 add	 ebx, edx
  000c1	89 5d e4	 mov	 DWORD PTR _LineStart$124349[ebp], ebx
  000c4	8b 5d d4	 mov	 ebx, DWORD PTR _TexAddr$[ebp]
  000c7	03 d3		 add	 edx, ebx
  000c9	8b 98 cc 00 00
	00		 mov	 ebx, DWORD PTR [eax+204]

; 2750 : 
; 2751 : #if ICEASM
; 2752 : 
; 2753 : 		if( GIsPentiumPro )

  000cf	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__GIsPentiumPro
  000d4	23 f3		 and	 esi, ebx
  000d6	d3 e6		 shl	 esi, cl
  000d8	8b 08		 mov	 ecx, DWORD PTR [eax]
  000da	89 55 e8	 mov	 DWORD PTR _TexStart$124350[ebp], edx
  000dd	03 75 d0	 add	 esi, DWORD PTR _GlassAddr$[ebp]
  000e0	85 c9		 test	 ecx, ecx
  000e2	89 75 f8	 mov	 DWORD PTR _GlassStart$124351[ebp], esi
  000e5	0f 84 38 01 00
	00		 je	 $L124352

; 2754 : 		{  		
; 2755 : 		// Pentium PRO/II version 
; 2756 : 			__asm                        //
; 2757 : 			{                            //
; 2758 : 				mov     esi, LineStart   //

  000eb	8b 75 e4	 mov	 esi, DWORD PTR _LineStart$124349[ebp]

; 2759 : 				mov     edi, TexStart    //

  000ee	8b 7d e8	 mov	 edi, DWORD PTR _TexStart$124350[ebp]

; 2760 : 
; 2761 : 				mov     ecx, [TempUMask] //

  000f1	8b 4d ec	 mov	 ecx, DWORD PTR _TempUMask$[ebp]

; 2762 : 				mov     ebx, Xdimension  //

  000f4	8b 5d f0	 mov	 ebx, DWORD PTR _Xdimension$[ebp]

; 2763 : 				xor     eax, eax         //

  000f7	33 c0		 xor	 eax, eax

; 2764 : 
; 2765 : 				mov     ebx, Xdimension  //

  000f9	8b 5d f0	 mov	 ebx, DWORD PTR _Xdimension$[ebp]

; 2766 : 				sub     ebx, UDisp       //

  000fc	2b 5d f4	 sub	 ebx, DWORD PTR _UDisp$[ebp]

; 2767 : 
; 2768 : 				test    ebx, ecx 	     //  zero? - no split 

  000ff	85 d9		 test	 ebx, ecx

; 2769 : 				jz      ppNoSplit          //

  00101	74 0f		 je	 SHORT $ppNoSplit$124353

; 2770 : 
; 2771 : 				cmp     ebx, 7           //  

  00103	83 fb 07	 cmp	 ebx, 7

; 2772 : 				ja      ppSkipFirstBit     //  Skip if not in first 8 pixels.

  00106	77 12		 ja	 SHORT $ppSkipFirstBit$124354

; 2773 : 
; 2774 : 				;; split is in first 8 pixels and Unaligned.
; 2775 : 
; 2776 : 				mov     edx, GlassStart  //

  00108	8b 55 f8	 mov	 edx, DWORD PTR _GlassStart$124351[ebp]

; 2777 : 				call    ppIceMisc8Pixelz   //

  0010b	e8 d0 00 00 00	 call	 $ppIceMisc8Pixelz$124355

; 2778 : 				jmp     ppDoEndChunk       //

  00110	eb 29		 jmp	 SHORT $ppDoEndChunk$124356
$ppNoSplit$124353:

; 2779 : 
; 2780 : 			ppNoSplit:                     //
; 2781 : 				mov     ebx, Xdimension  //

  00112	8b 5d f0	 mov	 ebx, DWORD PTR _Xdimension$[ebp]

; 2782 : 				mov     edx, GlassStart  //

  00115	8b 55 f8	 mov	 edx, DWORD PTR _GlassStart$124351[ebp]

; 2783 : 				jmp     ppDoLastChunk      //

  00118	eb 35		 jmp	 SHORT $ppDoLastChunk$124357
$ppSkipFirstBit$124354:

; 2784 : 
; 2785 : 				///////////////////////////
; 2786 : 
; 2787 : 			ppSkipFirstBit:
; 2788 : 
; 2789 : 				and		ebx, 0x0FF-7;     // FF - 3     = stretch before wrapping needed

  0011a	81 e3 f8 00 00
	00		 and	 ebx, 248		; 000000f8H

; 2790 : 				mov		edx, GlassStart   //

  00120	8b 55 f8	 mov	 edx, DWORD PTR _GlassStart$124351[ebp]

; 2791 : 				add		edx, UDisp        //

  00123	03 55 f4	 add	 edx, DWORD PTR _UDisp$[ebp]

; 2792 : 				call	ppIce4Npixelz       // 

  00126	e8 35 00 00 00	 call	 $ppIce4Npixelz$124358

; 2793 : 
; 2794 : 				mov     ebx, UDisp        //

  0012b	8b 5d f4	 mov	 ebx, DWORD PTR _UDisp$[ebp]

; 2795 : 				and     ebx, 7            //

  0012e	83 e3 07	 and	 ebx, 7

; 2796 : 				jz      ppDoEndChunk        // No unaligned Positionment

  00131	74 08		 je	 SHORT $ppDoEndChunk$124356

; 2797 : 
; 2798 : 				mov		edx, GlassStart   //

  00133	8b 55 f8	 mov	 edx, DWORD PTR _GlassStart$124351[ebp]

; 2799 : 				call	ppIceMisc8Pixelz    //

  00136	e8 a5 00 00 00	 call	 $ppIceMisc8Pixelz$124355
$ppDoEndChunk$124356:

; 2800 : 
; 2801 : 			ppDoEndChunk:                   // 
; 2802 : 				cmp		eax,Xdimension    // Any pixels left to do ? 

  0013b	3b 45 f0	 cmp	 eax, DWORD PTR _Xdimension$[ebp]

; 2803 : 				je		ppEndIceRender      //

  0013e	0f 84 da 00 00
	00		 je	 $ppEndIceRender$124359

; 2804 : 
; 2805 : 				mov     ebx, Xdimension   // Da end marker

  00144	8b 5d f0	 mov	 ebx, DWORD PTR _Xdimension$[ebp]

; 2806 : 				mov		edx, GlassStart   //

  00147	8b 55 f8	 mov	 edx, DWORD PTR _GlassStart$124351[ebp]

; 2807 : 				add     edx, UDisp        // Need to since we're past the skip

  0014a	03 55 f4	 add	 edx, DWORD PTR _UDisp$[ebp]

; 2808 : 				sub     edx, ebx          //

  0014d	2b d3		 sub	 edx, ebx
$ppDoLastChunk$124357:

; 2809 : 			ppDoLastChunk:
; 2810 : 				Call    ppIce4Npixelz       //

  0014f	e8 0c 00 00 00	 call	 $ppIce4Npixelz$124358

; 2811 : 				jmp     ppEndIceRender      //

  00154	e9 c5 00 00 00	 jmp	 $ppEndIceRender$124359

; 3110 : 
; 3111 : 			 EndIceRender:
; 3112 : 			}
; 3113 : 		}
; 3114 : 
; 3115 : #else
; 3116 : 		for( INT u=0; u<Xdimension; u+=2 )
; 3117 :         {
; 3118 : 			// Coolish effect combining half warped, half original.
; 3119 : 			// LineStart[u] = (  SourceStart[(u+LineStart[u]) & UMask ] + SourceStart[(u+128) & UMask]  ) >> 1;
; 3120 : 
; 3121 : 			INT u2 = u+1;
; 3122 : 			// Help C++ with pipelining...
; 3123 : 
; 3124 : 			LineStart[u]  =  TexStart[( u +  GlassStart[(u +UDisp) & UMask]) & UMask ] ;
; 3125 : 			LineStart[u2] =  TexStart[( u2 + GlassStart[(u2+UDisp) & UMask]) & UMask ] ;
; 3126 :         }
; 3127 : #endif
; 3128 : 
; 3129 : 	}
; 3130 : }

  00159	8d a4 24 00 00
	00 00		 npad	 7
$ppIce4Npixelz$124358:

; 2812 : 
; 2813 : 				;;  esi = LineStart
; 2814 : 				;;  edi = TexStart
; 2815 : 				;;  edx = GlassStart
; 2816 : 				;;
; 2817 : 				;;  eax = (8bit) proceeding/startpoint
; 2818 : 				;;  ebx = endpoint (compared against eax)
; 2819 : 				;;  ecx = UMask
; 2820 : 
; 2821 : 			align 16
; 2822 : 			ppIce4Npixelz:
; 2823 : 				mov     ESPStorage,esp    //

  00160	89 25 00 00 00
	00		 mov	 DWORD PTR ?ESPStorage@?3??BlitTexIce@UIceTexture@@AAEXXZ@4KA, esp

; 2824 : 				mov     EBPStorage,ebp    //

  00166	89 2d 00 00 00
	00		 mov	 DWORD PTR ?EBPStorage@?3??BlitTexIce@UIceTexture@@AAEXXZ@4KA, ebp

; 2825 : 				sub     ebx,2             // do last 2 pixels separately

  0016c	83 eb 02	 sub	 ebx, 2

; 2826 : 				mov     ebp,edx           //

  0016f	8b ea		 mov	 ebp, edx

; 2827 : 
; 2828 : 				mov     esp,ebx           //

  00171	8b e3		 mov	 esp, ebx

; 2829 : 										  //
; 2830 : 				xor     edx,edx           //

  00173	33 d2		 xor	 edx, edx

; 2831 : 				xor     ebx,ebx           //

  00175	33 db		 xor	 ebx, ebx

; 2832 : 				mov     dl,[ebp+ eax]    // Preload  dl  

  00177	8a 54 05 00	 mov	 dl, BYTE PTR [ebp+eax]

; 3110 : 
; 3111 : 			 EndIceRender:
; 3112 : 			}
; 3113 : 		}
; 3114 : 
; 3115 : #else
; 3116 : 		for( INT u=0; u<Xdimension; u+=2 )
; 3117 :         {
; 3118 : 			// Coolish effect combining half warped, half original.
; 3119 : 			// LineStart[u] = (  SourceStart[(u+LineStart[u]) & UMask ] + SourceStart[(u+128) & UMask]  ) >> 1;
; 3120 : 
; 3121 : 			INT u2 = u+1;
; 3122 : 			// Help C++ with pipelining...
; 3123 : 
; 3124 : 			LineStart[u]  =  TexStart[( u +  GlassStart[(u +UDisp) & UMask]) & UMask ] ;
; 3125 : 			LineStart[u2] =  TexStart[( u2 + GlassStart[(u2+UDisp) & UMask]) & UMask ] ;
; 3126 :         }
; 3127 : #endif
; 3128 : 
; 3129 : 	}
; 3130 : }

  0017b	90 8d 64 24 00	 npad	 5
$ppCopyLoop$124360:

; 2833 : 
; 2834 : 			 align 16 
; 2835 : 			 ppCopyLoop:
; 2836 : 
; 2837 : 				add     dl,al             ;;  Linestart[u]+u

  00180	02 d0		 add	 dl, al

; 2838 : 				mov     bl,[ebp+eax+1]    ;;  Glass

  00182	8a 5c 05 01	 mov	 bl, BYTE PTR [ebp+eax+1]

; 2839 :                                       
; 2840 : 				and     dl,cl			  ;;

  00186	22 d1		 and	 dl, cl

; 2841 : 				add     bl,al			  ;;

  00188	02 d8		 add	 bl, al

; 2842 :                                       
; 2843 : 				inc     bl                ;;  Linestart[u+1] + u+1

  0018a	fe c3		 inc	 bl

; 2844 : 				add     eax,2			  ;;

  0018c	83 c0 02	 add	 eax, 2

; 2845 : 										  ;;
; 2846 : 				mov     dl,[edi+edx]      ;;  Texel

  0018f	8a 14 17	 mov	 dl, BYTE PTR [edi+edx]

; 2847 : 				and     bl,cl			  ;;

  00192	22 d9		 and	 bl, cl

; 2848 : 										  ;;
; 2849 : 				cmp     esp,eax           ;;  

  00194	3b e0		 cmp	 esp, eax

; 2850 : 				mov     [esi+eax-2],dl    ;;  Store

  00196	88 54 06 fe	 mov	 BYTE PTR [esi+eax-2], dl

; 2851 :                                       
; 2852 : 				mov     bl,[edi+ebx]      ;;  Texel  // non-Positiond one WILL have Pentium-clash with Glass...

  0019a	8a 1c 1f	 mov	 bl, BYTE PTR [edi+ebx]

; 2853 : 				mov     dl,[ebp+eax]      ;;  Glass  // (_if still horizontally aligned...) but not usually..

  0019d	8a 54 05 00	 mov	 dl, BYTE PTR [ebp+eax]

; 2854 : 										  ;;
; 2855 : 				mov     [esi+eax-2+1],bl  ;;  Store

  001a1	88 5c 06 ff	 mov	 BYTE PTR [esi+eax-1], bl

; 2856 : 				jne     ppCopyLoop          ;;

  001a5	75 d9		 jne	 SHORT $ppCopyLoop$124360

; 2857 : 										  ;;
; 2858 : 				;;;;;;;;;;;;;;;;;;;;;;;;;;;; 8 cyc/2pix...
; 2859 : 
; 2860 : 				mov     esp,ESPStorage    ;;

  001a7	8b 25 00 00 00
	00		 mov	 esp, DWORD PTR ?ESPStorage@?3??BlitTexIce@UIceTexture@@AAEXXZ@4KA

; 2861 : 				mov     bl,[ebp+eax+1]    ;; get glasspixel 2

  001ad	8a 5c 05 01	 mov	 bl, BYTE PTR [ebp+eax+1]

; 2862 : 
; 2863 : 				add     dl,al             ;;

  001b1	02 d0		 add	 dl, al

; 2864 : 				add     bl,al             ;;

  001b3	02 d8		 add	 bl, al

; 2865 : 
; 2866 : 				inc     bl	              ;;

  001b5	fe c3		 inc	 bl

; 2867 : 				and     dl,cl             ;;

  001b7	22 d1		 and	 dl, cl

; 2868 : 
; 2869 : 				mov     ebp,EBPStorage    ;;

  001b9	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR ?EBPStorage@?3??BlitTexIce@UIceTexture@@AAEXXZ@4KA

; 2870 : 				and     bl,cl             ;;

  001bf	22 d9		 and	 bl, cl

; 2871 : 
; 2872 : 				mov     dl,[edi+edx]      ;; Texel

  001c1	8a 14 17	 mov	 dl, BYTE PTR [edi+edx]

; 2873 : 				mov     bl,[edi+ebx]      ;; Texel

  001c4	8a 1c 1f	 mov	 bl, BYTE PTR [edi+ebx]

; 2874 : 
; 2875 : 				mov     [esi+eax],dl      ;; Dest

  001c7	88 14 06	 mov	 BYTE PTR [esi+eax], dl

; 2876 : 				mov     [esi+eax+1],bl    ;; Dest

  001ca	88 5c 06 01	 mov	 BYTE PTR [esi+eax+1], bl

; 2877 : 
; 2878 : 				add     eax,2             ;;

  001ce	83 c0 02	 add	 eax, 2

; 2879 : 				retn                      ;;

  001d1	c3		 ret	 0

; 3110 : 
; 3111 : 			 EndIceRender:
; 3112 : 			}
; 3113 : 		}
; 3114 : 
; 3115 : #else
; 3116 : 		for( INT u=0; u<Xdimension; u+=2 )
; 3117 :         {
; 3118 : 			// Coolish effect combining half warped, half original.
; 3119 : 			// LineStart[u] = (  SourceStart[(u+LineStart[u]) & UMask ] + SourceStart[(u+128) & UMask]  ) >> 1;
; 3120 : 
; 3121 : 			INT u2 = u+1;
; 3122 : 			// Help C++ with pipelining...
; 3123 : 
; 3124 : 			LineStart[u]  =  TexStart[( u +  GlassStart[(u +UDisp) & UMask]) & UMask ] ;
; 3125 : 			LineStart[u2] =  TexStart[( u2 + GlassStart[(u2+UDisp) & UMask]) & UMask ] ;
; 3126 :         }
; 3127 : #endif
; 3128 : 
; 3129 : 	}
; 3130 : }

  001d2	8d a4 24 00 00
	00 00 8d a4 24
	00 00 00 00	 npad	 14
$ppIceMisc8Pixelz$124355:

; 2880 : 
; 2881 : 				;;
; 2882 : 				;;  esi = LineStart
; 2883 : 				;;  edi = TexStart
; 2884 : 				;;  edx = GlassStart
; 2885 : 				;;
; 2886 : 				;;  eax = (8bit) proceeding/startpoint
; 2887 : 				;;  ecx = UMask
; 2888 : 				;;
; 2889 : 
; 2890 : 			align 16
; 2891 : 			ppIceMisc8Pixelz:
; 2892 : 				mov     ebx,[esi+eax] // First destin word - cache warming. 

  001e0	8b 1c 06	 mov	 ebx, DWORD PTR [esi+eax]

; 2893 : 				mov     ebx,UDisp

  001e3	8b 5d f4	 mov	 ebx, DWORD PTR _UDisp$[ebp]

; 2894 : 				push    ebp

  001e6	55		 push	 ebp

; 2895 : 				mov     ESPStorage, esp

  001e7	89 25 00 00 00
	00		 mov	 DWORD PTR ?ESPStorage@?3??BlitTexIce@UIceTexture@@AAEXXZ@4KA, esp

; 2896 : 
; 2897 : 				mov		ebp, eax   //

  001ed	8b e8		 mov	 ebp, eax

; 2898 : 				add     ebp, 8     // current cntr + nr of pixels to do

  001ef	83 c5 08	 add	 ebp, 8

; 2899 : 
; 2900 : 				mov     esp, edx   // GlassStart

  001f2	8b e2		 mov	 esp, edx

; 2901 : 				
; 2902 : 				add     ebx, eax

  001f4	03 d8		 add	 ebx, eax

; 2903 : 				xor     edx, edx

  001f6	33 d2		 xor	 edx, edx

; 2904 : 				and     ebx, ecx

  001f8	23 d9		 and	 ebx, ecx

; 3110 : 
; 3111 : 			 EndIceRender:
; 3112 : 			}
; 3113 : 		}
; 3114 : 
; 3115 : #else
; 3116 : 		for( INT u=0; u<Xdimension; u+=2 )
; 3117 :         {
; 3118 : 			// Coolish effect combining half warped, half original.
; 3119 : 			// LineStart[u] = (  SourceStart[(u+LineStart[u]) & UMask ] + SourceStart[(u+128) & UMask]  ) >> 1;
; 3120 : 
; 3121 : 			INT u2 = u+1;
; 3122 : 			// Help C++ with pipelining...
; 3123 : 
; 3124 : 			LineStart[u]  =  TexStart[( u +  GlassStart[(u +UDisp) & UMask]) & UMask ] ;
; 3125 : 			LineStart[u2] =  TexStart[( u2 + GlassStart[(u2+UDisp) & UMask]) & UMask ] ;
; 3126 :         }
; 3127 : #endif
; 3128 : 
; 3129 : 	}
; 3130 : }

  001fa	8d 9b 00 00 00
	00		 npad	 6
$ppCopyLp$124361:

; 2905 : 
; 2906 : 			align 16
; 2907 : 			ppCopyLp:
; 2908 : 				mov     dl, [esp+ebx]   ;; GlassStart [edx]

  00200	8a 14 1c	 mov	 dl, BYTE PTR [esp+ebx]

; 2909 : 
; 2910 : 				add     dl, al		    ;;

  00203	02 d0		 add	 dl, al

; 2911 : 				inc     ebx             ;;

  00205	43		 inc	 ebx

; 2912 : 
; 2913 : 				and     dl, cl          ;;

  00206	22 d1		 and	 dl, cl

; 2914 : 
; 2915 : 				and     ebx, ecx        ;;

  00208	23 d9		 and	 ebx, ecx

; 2916 : 				mov     dl, [edi+edx]   ;; Texel

  0020a	8a 14 17	 mov	 dl, BYTE PTR [edi+edx]

; 2917 : 
; 2918 : 				mov     [esi+eax], dl   ;; Destin

  0020d	88 14 06	 mov	 BYTE PTR [esi+eax], dl

; 2919 : 				inc     eax      	    ;;

  00210	40		 inc	 eax

; 2920 : 
; 2921 : 				cmp     ebp, eax	    ;;

  00211	3b e8		 cmp	 ebp, eax

; 2922 : 				jne     ppCopyLp          ;;

  00213	75 eb		 jne	 SHORT $ppCopyLp$124361

; 2923 : 
; 2924 : 				mov		esp, ESPStorage ;;

  00215	8b 25 00 00 00
	00		 mov	 esp, DWORD PTR ?ESPStorage@?3??BlitTexIce@UIceTexture@@AAEXXZ@4KA

; 2925 : 				nop

  0021b	90		 npad	 1

; 2926 : 				pop		ebp             ;;

  0021c	5d		 pop	 ebp

; 2927 : 				retn

  0021d	c3		 ret	 0
$ppEndIceRender$124359:

; 2928 : 
; 2929 : 			 ppEndIceRender:
; 2930 : 			}
; 2931 : 		}
; 2932 : 		else

  0021e	e9 3b 01 00 00	 jmp	 $L124347
$L124352:

; 2933 : 		{
; 2934 : 			// Regular Pentium version - using cache warming.
; 2935 : 			__asm                        //
; 2936 : 			{                            //
; 2937 : 				mov     esi, LineStart   //

  00223	8b 75 e4	 mov	 esi, DWORD PTR _LineStart$124349[ebp]

; 2938 : 				mov     edi, TexStart    //

  00226	8b 7d e8	 mov	 edi, DWORD PTR _TexStart$124350[ebp]

; 2939 : 
; 2940 : 				mov     ecx, [TempUMask] //

  00229	8b 4d ec	 mov	 ecx, DWORD PTR _TempUMask$[ebp]

; 2941 : 				mov     ebx, Xdimension  //

  0022c	8b 5d f0	 mov	 ebx, DWORD PTR _Xdimension$[ebp]

; 2942 : 				xor     eax, eax         //

  0022f	33 c0		 xor	 eax, eax

; 2943 : 
; 2944 : 				mov     ebx, Xdimension  //

  00231	8b 5d f0	 mov	 ebx, DWORD PTR _Xdimension$[ebp]

; 2945 : 				sub     ebx, UDisp       //

  00234	2b 5d f4	 sub	 ebx, DWORD PTR _UDisp$[ebp]

; 2946 : 
; 2947 : 				test    ebx, ecx 	     //  zero? - no split 

  00237	85 d9		 test	 ebx, ecx

; 2948 : 				jz      NoSplit          //

  00239	74 0f		 je	 SHORT $NoSplit$124363

; 2949 : 
; 2950 : 				cmp     ebx, 7           //  

  0023b	83 fb 07	 cmp	 ebx, 7

; 2951 : 				ja      SkipFirstBit     //  Skip if not in first 8 pixels.

  0023e	77 12		 ja	 SHORT $SkipFirstBit$124364

; 2952 : 
; 2953 : 				;; split is in first 8 pixels and Unaligned.
; 2954 : 
; 2955 : 				mov     edx, GlassStart  //

  00240	8b 55 f8	 mov	 edx, DWORD PTR _GlassStart$124351[ebp]

; 2956 : 				call    IceMisc8Pixelz   //

  00243	e8 d8 00 00 00	 call	 $IceMisc8Pixelz$124365

; 2957 : 				jmp     DoEndChunk       //

  00248	eb 29		 jmp	 SHORT $DoEndChunk$124366
$NoSplit$124363:

; 2958 : 
; 2959 : 			NoSplit:                     //
; 2960 : 				mov     ebx, Xdimension  //

  0024a	8b 5d f0	 mov	 ebx, DWORD PTR _Xdimension$[ebp]

; 2961 : 				mov     edx, GlassStart  //

  0024d	8b 55 f8	 mov	 edx, DWORD PTR _GlassStart$124351[ebp]

; 2962 : 				jmp     DoLastChunk      //

  00250	eb 35		 jmp	 SHORT $DoLastChunk$124367
$SkipFirstBit$124364:

; 2963 : 
; 2964 : 				///////////////////////////
; 2965 : 
; 2966 : 			SkipFirstBit:
; 2967 : 
; 2968 : 				and		ebx, 0x0FF-7;     // FF - 3     = stretch before wrapping needed

  00252	81 e3 f8 00 00
	00		 and	 ebx, 248		; 000000f8H

; 2969 : 				mov		edx, GlassStart   //

  00258	8b 55 f8	 mov	 edx, DWORD PTR _GlassStart$124351[ebp]

; 2970 : 				add		edx, UDisp        //

  0025b	03 55 f4	 add	 edx, DWORD PTR _UDisp$[ebp]

; 2971 : 				call	Ice4Npixelz       // 

  0025e	e8 3d 00 00 00	 call	 $Ice4Npixelz$124368

; 2972 : 
; 2973 : 				mov     ebx, UDisp        //

  00263	8b 5d f4	 mov	 ebx, DWORD PTR _UDisp$[ebp]

; 2974 : 				and     ebx, 7            //

  00266	83 e3 07	 and	 ebx, 7

; 2975 : 				jz      DoEndChunk        // No unaligned Positionment

  00269	74 08		 je	 SHORT $DoEndChunk$124366

; 2976 : 
; 2977 : 				mov		edx, GlassStart   //

  0026b	8b 55 f8	 mov	 edx, DWORD PTR _GlassStart$124351[ebp]

; 2978 : 				call	IceMisc8Pixelz    //

  0026e	e8 ad 00 00 00	 call	 $IceMisc8Pixelz$124365
$DoEndChunk$124366:

; 2979 : 
; 2980 : 			DoEndChunk:                   // 
; 2981 : 				cmp		eax,Xdimension    // Any pixels left to do ? 

  00273	3b 45 f0	 cmp	 eax, DWORD PTR _Xdimension$[ebp]

; 2982 : 				je		EndIceRender      //

  00276	0f 84 e2 00 00
	00		 je	 $EndIceRender$124369

; 2983 : 
; 2984 : 				mov     ebx, Xdimension   // Da end marker

  0027c	8b 5d f0	 mov	 ebx, DWORD PTR _Xdimension$[ebp]

; 2985 : 				mov		edx, GlassStart   //

  0027f	8b 55 f8	 mov	 edx, DWORD PTR _GlassStart$124351[ebp]

; 2986 : 				add     edx, UDisp        // Need to since we're past the skip

  00282	03 55 f4	 add	 edx, DWORD PTR _UDisp$[ebp]

; 2987 : 				sub     edx, ebx          //

  00285	2b d3		 sub	 edx, ebx
$DoLastChunk$124367:

; 2988 : 			DoLastChunk:
; 2989 : 				Call    Ice4Npixelz       //

  00287	e8 14 00 00 00	 call	 $Ice4Npixelz$124368

; 2990 : 				jmp     EndIceRender      //

  0028c	e9 cd 00 00 00	 jmp	 $EndIceRender$124369

; 3110 : 
; 3111 : 			 EndIceRender:
; 3112 : 			}
; 3113 : 		}
; 3114 : 
; 3115 : #else
; 3116 : 		for( INT u=0; u<Xdimension; u+=2 )
; 3117 :         {
; 3118 : 			// Coolish effect combining half warped, half original.
; 3119 : 			// LineStart[u] = (  SourceStart[(u+LineStart[u]) & UMask ] + SourceStart[(u+128) & UMask]  ) >> 1;
; 3120 : 
; 3121 : 			INT u2 = u+1;
; 3122 : 			// Help C++ with pipelining...
; 3123 : 
; 3124 : 			LineStart[u]  =  TexStart[( u +  GlassStart[(u +UDisp) & UMask]) & UMask ] ;
; 3125 : 			LineStart[u2] =  TexStart[( u2 + GlassStart[(u2+UDisp) & UMask]) & UMask ] ;
; 3126 :         }
; 3127 : #endif
; 3128 : 
; 3129 : 	}
; 3130 : }

  00291	8d a4 24 00 00
	00 00 8d a4 24
	00 00 00 00 90	 npad	 15
$Ice4Npixelz$124368:

; 2991 : 
; 2992 : 				;;  esi = LineStart
; 2993 : 				;;  edi = TexStart
; 2994 : 				;;  edx = GlassStart
; 2995 : 				;;
; 2996 : 				;;  eax = (8bit) proceeding/startpoint
; 2997 : 				;;  ebx = endpoint (compared against eax)
; 2998 : 				;;  ecx = UMask
; 2999 : 
; 3000 : 			align 16
; 3001 : 			Ice4Npixelz:
; 3002 : 				mov     ESPStorage,esp    //

  002a0	89 25 00 00 00
	00		 mov	 DWORD PTR ?ESPStorage@?3??BlitTexIce@UIceTexture@@AAEXXZ@4KA, esp

; 3003 : 				mov     EBPStorage,ebp    //

  002a6	89 2d 00 00 00
	00		 mov	 DWORD PTR ?EBPStorage@?3??BlitTexIce@UIceTexture@@AAEXXZ@4KA, ebp

; 3004 : 				sub     ebx,2             // do last 2 pixels separately

  002ac	83 eb 02	 sub	 ebx, 2

; 3005 : 				mov     ebp,edx           //

  002af	8b ea		 mov	 ebp, edx

; 3006 : 
; 3007 : 				mov     esp,ebx           //

  002b1	8b e3		 mov	 esp, ebx

; 3008 : 										  //
; 3009 : 				xor     edx,edx           //

  002b3	33 d2		 xor	 edx, edx

; 3010 : 				xor     ebx,ebx           //

  002b5	33 db		 xor	 ebx, ebx

; 3011 : 				mov     dl,[ebp+ eax]    // Preload  dl

  002b7	8a 54 05 00	 mov	 dl, BYTE PTR [ebp+eax]

; 3110 : 
; 3111 : 			 EndIceRender:
; 3112 : 			}
; 3113 : 		}
; 3114 : 
; 3115 : #else
; 3116 : 		for( INT u=0; u<Xdimension; u+=2 )
; 3117 :         {
; 3118 : 			// Coolish effect combining half warped, half original.
; 3119 : 			// LineStart[u] = (  SourceStart[(u+LineStart[u]) & UMask ] + SourceStart[(u+128) & UMask]  ) >> 1;
; 3120 : 
; 3121 : 			INT u2 = u+1;
; 3122 : 			// Help C++ with pipelining...
; 3123 : 
; 3124 : 			LineStart[u]  =  TexStart[( u +  GlassStart[(u +UDisp) & UMask]) & UMask ] ;
; 3125 : 			LineStart[u2] =  TexStart[( u2 + GlassStart[(u2+UDisp) & UMask]) & UMask ] ;
; 3126 :         }
; 3127 : #endif
; 3128 : 
; 3129 : 	}
; 3130 : }

  002bb	90 8d 64 24 00	 npad	 5
$CopyLoop$124370:

; 3012 : 
; 3013 : 			 align 16 
; 3014 : 			 CopyLoop:
; 3015 : 				// cache warming by loading destination to dummy (bl)
; 3016 : 				nop                       // xor ebx,ebx slightly faster on PII

  002c0	90		 npad	 1

; 3017 : 				mov     bl,[esi+eax+2]    // This'll prime the cache EVERY 2 bytes - wasteful..

  002c1	8a 5c 06 02	 mov	 bl, BYTE PTR [esi+eax+2]

; 3018 : 			
; 3019 : 				add     dl,al             ;;  Linestart[u]+u

  002c5	02 d0		 add	 dl, al

; 3020 : 				mov     bl,[ebp+eax+1]    ;;  Glass

  002c7	8a 5c 05 01	 mov	 bl, BYTE PTR [ebp+eax+1]

; 3021 :                                       
; 3022 : 				and     dl,cl			  ;;

  002cb	22 d1		 and	 dl, cl

; 3023 : 				add     bl,al			  ;;

  002cd	02 d8		 add	 bl, al

; 3024 :                                       
; 3025 : 				inc     bl                ;;  Linestart[u+1] + u+1

  002cf	fe c3		 inc	 bl

; 3026 : 				add     eax,2			  ;;

  002d1	83 c0 02	 add	 eax, 2

; 3027 : 										  ;;
; 3028 : 				mov     dl,[edi+edx]      ;;  Texel

  002d4	8a 14 17	 mov	 dl, BYTE PTR [edi+edx]

; 3029 : 				and     bl,cl			  ;;

  002d7	22 d9		 and	 bl, cl

; 3030 : 										  ;;
; 3031 : 				cmp     esp,eax           ;;  

  002d9	3b e0		 cmp	 esp, eax

; 3032 : 				mov     [esi+eax-2],dl    ;;  Store

  002db	88 54 06 fe	 mov	 BYTE PTR [esi+eax-2], dl

; 3033 :                                       
; 3034 : 				mov     bl,[edi+ebx]      ;;  Texel  // non-Positiond one WILL have Pentium-clash with Glass...

  002df	8a 1c 1f	 mov	 bl, BYTE PTR [edi+ebx]

; 3035 : 				mov     dl,[ebp+eax]      ;;  Glass  // (_if still horizontally aligned...) but not usually..

  002e2	8a 54 05 00	 mov	 dl, BYTE PTR [ebp+eax]

; 3036 : 										  ;;
; 3037 : 				mov     [esi+eax-2+1],bl  ;;  Store

  002e6	88 5c 06 ff	 mov	 BYTE PTR [esi+eax-1], bl

; 3038 : 				jne     CopyLoop          ;;

  002ea	75 d4		 jne	 SHORT $CopyLoop$124370

; 3039 : 										  ;;
; 3040 : 				;;;;;;;;;;;;;;;;;;;;;;;;;;;; 8 cyc/2pix...
; 3041 : 
; 3042 : 				mov     esp,ESPStorage    ;;

  002ec	8b 25 00 00 00
	00		 mov	 esp, DWORD PTR ?ESPStorage@?3??BlitTexIce@UIceTexture@@AAEXXZ@4KA

; 3043 : 				mov     bl,[ebp+eax+1]    ;; get glasspixel 2

  002f2	8a 5c 05 01	 mov	 bl, BYTE PTR [ebp+eax+1]

; 3044 : 
; 3045 : 				add     dl,al             ;;

  002f6	02 d0		 add	 dl, al

; 3046 : 				add     bl,al             ;;

  002f8	02 d8		 add	 bl, al

; 3047 : 
; 3048 : 				inc     bl	              ;;

  002fa	fe c3		 inc	 bl

; 3049 : 				and     dl,cl             ;;

  002fc	22 d1		 and	 dl, cl

; 3050 : 
; 3051 : 				mov     ebp,EBPStorage    ;;

  002fe	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR ?EBPStorage@?3??BlitTexIce@UIceTexture@@AAEXXZ@4KA

; 3052 : 				and     bl,cl             ;;

  00304	22 d9		 and	 bl, cl

; 3053 : 
; 3054 : 				mov     dl,[edi+edx]      ;; Texel

  00306	8a 14 17	 mov	 dl, BYTE PTR [edi+edx]

; 3055 : 				mov     bl,[edi+ebx]      ;; Texel

  00309	8a 1c 1f	 mov	 bl, BYTE PTR [edi+ebx]

; 3056 : 
; 3057 : 				mov     [esi+eax],dl      ;; Dest

  0030c	88 14 06	 mov	 BYTE PTR [esi+eax], dl

; 3058 : 				mov     [esi+eax+1],bl    ;; Dest

  0030f	88 5c 06 01	 mov	 BYTE PTR [esi+eax+1], bl

; 3059 : 
; 3060 : 				add     eax,2             ;;

  00313	83 c0 02	 add	 eax, 2

; 3061 : 				retn                      ;;

  00316	c3		 ret	 0

; 3110 : 
; 3111 : 			 EndIceRender:
; 3112 : 			}
; 3113 : 		}
; 3114 : 
; 3115 : #else
; 3116 : 		for( INT u=0; u<Xdimension; u+=2 )
; 3117 :         {
; 3118 : 			// Coolish effect combining half warped, half original.
; 3119 : 			// LineStart[u] = (  SourceStart[(u+LineStart[u]) & UMask ] + SourceStart[(u+128) & UMask]  ) >> 1;
; 3120 : 
; 3121 : 			INT u2 = u+1;
; 3122 : 			// Help C++ with pipelining...
; 3123 : 
; 3124 : 			LineStart[u]  =  TexStart[( u +  GlassStart[(u +UDisp) & UMask]) & UMask ] ;
; 3125 : 			LineStart[u2] =  TexStart[( u2 + GlassStart[(u2+UDisp) & UMask]) & UMask ] ;
; 3126 :         }
; 3127 : #endif
; 3128 : 
; 3129 : 	}
; 3130 : }

  00317	8d a4 24 00 00
	00 00 8b ff	 npad	 9
$IceMisc8Pixelz$124365:

; 3062 : 
; 3063 : 				;;
; 3064 : 				;;  esi = LineStart
; 3065 : 				;;  edi = TexStart
; 3066 : 				;;  edx = GlassStart
; 3067 : 				;;
; 3068 : 				;;  eax = (8bit) proceeding/startpoint
; 3069 : 				;;  ecx = UMask
; 3070 : 				;;
; 3071 : 
; 3072 : 			align 16
; 3073 : 			IceMisc8Pixelz:
; 3074 : 				mov     ebx,[esi+eax] // First destin word - cache warming. 

  00320	8b 1c 06	 mov	 ebx, DWORD PTR [esi+eax]

; 3075 : 				mov     ebx,UDisp

  00323	8b 5d f4	 mov	 ebx, DWORD PTR _UDisp$[ebp]

; 3076 : 				push    ebp

  00326	55		 push	 ebp

; 3077 : 				mov     ESPStorage, esp

  00327	89 25 00 00 00
	00		 mov	 DWORD PTR ?ESPStorage@?3??BlitTexIce@UIceTexture@@AAEXXZ@4KA, esp

; 3078 : 
; 3079 : 				mov		ebp, eax   //

  0032d	8b e8		 mov	 ebp, eax

; 3080 : 				add     ebp, 8     // current cntr + nr of pixels to do

  0032f	83 c5 08	 add	 ebp, 8

; 3081 : 
; 3082 : 				mov     esp, edx   // GlassStart

  00332	8b e2		 mov	 esp, edx

; 3083 : 				
; 3084 : 				add     ebx, eax

  00334	03 d8		 add	 ebx, eax

; 3085 : 				xor     edx, edx

  00336	33 d2		 xor	 edx, edx

; 3086 : 				and     ebx, ecx

  00338	23 d9		 and	 ebx, ecx

; 3110 : 
; 3111 : 			 EndIceRender:
; 3112 : 			}
; 3113 : 		}
; 3114 : 
; 3115 : #else
; 3116 : 		for( INT u=0; u<Xdimension; u+=2 )
; 3117 :         {
; 3118 : 			// Coolish effect combining half warped, half original.
; 3119 : 			// LineStart[u] = (  SourceStart[(u+LineStart[u]) & UMask ] + SourceStart[(u+128) & UMask]  ) >> 1;
; 3120 : 
; 3121 : 			INT u2 = u+1;
; 3122 : 			// Help C++ with pipelining...
; 3123 : 
; 3124 : 			LineStart[u]  =  TexStart[( u +  GlassStart[(u +UDisp) & UMask]) & UMask ] ;
; 3125 : 			LineStart[u2] =  TexStart[( u2 + GlassStart[(u2+UDisp) & UMask]) & UMask ] ;
; 3126 :         }
; 3127 : #endif
; 3128 : 
; 3129 : 	}
; 3130 : }

  0033a	8d 9b 00 00 00
	00		 npad	 6
$CopyLp$124371:

; 3087 : 
; 3088 : 			align 16
; 3089 : 			CopyLp:
; 3090 : 				mov     dl, [esp+ebx]   ;; GlassStart [edx]

  00340	8a 14 1c	 mov	 dl, BYTE PTR [esp+ebx]

; 3091 : 
; 3092 : 				add     dl, al		    ;;

  00343	02 d0		 add	 dl, al

; 3093 : 				inc     ebx             ;;

  00345	43		 inc	 ebx

; 3094 : 
; 3095 : 				and     dl, cl          ;;

  00346	22 d1		 and	 dl, cl

; 3096 : 
; 3097 : 				and     ebx, ecx        ;;

  00348	23 d9		 and	 ebx, ecx

; 3098 : 				mov     dl, [edi+edx]   ;; Texel

  0034a	8a 14 17	 mov	 dl, BYTE PTR [edi+edx]

; 3099 : 
; 3100 : 				mov     [esi+eax], dl   ;; Destin

  0034d	88 14 06	 mov	 BYTE PTR [esi+eax], dl

; 3101 : 				inc     eax      	    ;;

  00350	40		 inc	 eax

; 3102 : 
; 3103 : 				cmp     ebp, eax	    ;;

  00351	3b e8		 cmp	 ebp, eax

; 3104 : 				jne     CopyLp          ;;

  00353	75 eb		 jne	 SHORT $CopyLp$124371

; 3105 : 
; 3106 : 				mov		esp, ESPStorage ;;

  00355	8b 25 00 00 00
	00		 mov	 esp, DWORD PTR ?ESPStorage@?3??BlitTexIce@UIceTexture@@AAEXXZ@4KA

; 3107 : 				nop

  0035b	90		 npad	 1

; 3108 : 				pop		ebp             ;;

  0035c	5d		 pop	 ebp

; 3109 : 				retn

  0035d	c3		 ret	 0
$EndIceRender$124369:
$L124347:

; 2744 : 
; 2745 :     for( INT v=0; v<Ydimension; v++ )

  0035e	8b 45 fc	 mov	 eax, DWORD PTR _v$[ebp]
  00361	8b 4d cc	 mov	 ecx, DWORD PTR _Ydimension$[ebp]
  00364	40		 inc	 eax
  00365	3b c1		 cmp	 eax, ecx
  00367	89 45 fc	 mov	 DWORD PTR _v$[ebp], eax
  0036a	0f 8c 38 fd ff
	ff		 jl	 $L133893
$L124348:

; 3110 : 
; 3111 : 			 EndIceRender:
; 3112 : 			}
; 3113 : 		}
; 3114 : 
; 3115 : #else
; 3116 : 		for( INT u=0; u<Xdimension; u+=2 )
; 3117 :         {
; 3118 : 			// Coolish effect combining half warped, half original.
; 3119 : 			// LineStart[u] = (  SourceStart[(u+LineStart[u]) & UMask ] + SourceStart[(u+128) & UMask]  ) >> 1;
; 3120 : 
; 3121 : 			INT u2 = u+1;
; 3122 : 			// Help C++ with pipelining...
; 3123 : 
; 3124 : 			LineStart[u]  =  TexStart[( u +  GlassStart[(u +UDisp) & UMask]) & UMask ] ;
; 3125 : 			LineStart[u2] =  TexStart[( u2 + GlassStart[(u2+UDisp) & UMask]) & UMask ] ;
; 3126 :         }
; 3127 : #endif
; 3128 : 
; 3129 : 	}
; 3130 : }

  00370	5f		 pop	 edi
  00371	5e		 pop	 esi
  00372	5b		 pop	 ebx
  00373	8b e5		 mov	 esp, ebp
  00375	5d		 pop	 ebp
  00376	c3		 ret	 0
?BlitTexIce@UIceTexture@@AAEXXZ ENDP			; UIceTexture::BlitTexIce
_TEXT	ENDS
PUBLIC	?BlitIceTex@UIceTexture@@AAEXXZ			; UIceTexture::BlitIceTex
_BSS	SEGMENT
?ESPStorage@?3??BlitIceTex@UIceTexture@@AAEXXZ@4KA DD 01H DUP (?) ; ESPStorage
?EBPStorage@?3??BlitIceTex@UIceTexture@@AAEXXZ@4KA DD 01H DUP (?) ; EBPStorage
; Function compile flags: /Ogty
_BSS	ENDS
;	COMDAT ?BlitIceTex@UIceTexture@@AAEXXZ
_TEXT	SEGMENT
_this$ = -32
_TexAddr$ = -44
_GlassAddr$ = -48
_BitMapAddr$ = -40
_Xdimension$ = -16
_Ydimension$ = -52
_TempUMask$ = -20
_UDisp$ = -8
_VDisp$ = -36
_v$ = -4
_LineStart$124392 = -28
_TexStart$124393 = -24
_GlassStart$124394 = -12
_I$133916 = -24
$T133918 = -28
_I$133922 = -24
$T133924 = -28
?BlitIceTex@UIceTexture@@AAEXXZ PROC NEAR		; UIceTexture::BlitIceTex, COMDAT
; _this$ = ecx

; 3138 : {	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	8b c1		 mov	 eax, ecx

; 3139 :     // Warning: Source/GlassTexture must have same dimensions..
; 3140 : 
; 3141 :     BYTE* TexAddr		= &SourceTexture->Mips(0).DataArray(0);

  00008	8b 88 e4 00 00
	00		 mov	 ecx, DWORD PTR [eax+228]
  0000e	8b 91 a8 00 00
	00		 mov	 edx, DWORD PTR [ecx+168]
  00014	8b 4a 1c	 mov	 ecx, DWORD PTR [edx+28]

; 3142 : 	BYTE* GlassAddr		= &GlassTexture->Mips(0).DataArray(0);

  00017	8b 90 e0 00 00
	00		 mov	 edx, DWORD PTR [eax+224]
  0001d	89 4d d4	 mov	 DWORD PTR _TexAddr$[ebp], ecx
  00020	8b 8a a8 00 00
	00		 mov	 ecx, DWORD PTR [edx+168]
  00026	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]

; 3143 :     BYTE* BitMapAddr	= &Mips(0).DataArray(0);  // Pointer

  00029	8b 88 a8 00 00
	00		 mov	 ecx, DWORD PTR [eax+168]
  0002f	89 55 d0	 mov	 DWORD PTR _GlassAddr$[ebp], edx
  00032	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]

; 3144 : 
; 3145 : 	if( LocalSourceBitmap ) return; // Static local source, no update needed.

  00035	8b 88 1c 01 00
	00		 mov	 ecx, DWORD PTR [eax+284]
  0003b	85 c9		 test	 ecx, ecx
  0003d	56		 push	 esi
  0003e	57		 push	 edi
  0003f	89 45 e0	 mov	 DWORD PTR _this$[ebp], eax
  00042	89 55 d8	 mov	 DWORD PTR _BitMapAddr$[ebp], edx
  00045	0f 85 cb 01 00
	00		 jne	 $L124391

; 3146 : 
; 3147 :     INT  Xdimension   = USize;  // Wrap needed for 8-bit counters.

  0004b	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]

; 3148 :     INT  Ydimension   = VSize;  //
; 3149 : 
; 3150 : #if ICEASM
; 3151 : 	INT  TempUMask    = UMask;

  0004e	8b 90 c8 00 00
	00		 mov	 edx, DWORD PTR [eax+200]
  00054	89 4d f0	 mov	 DWORD PTR _Xdimension$[ebp], ecx
  00057	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  0005a	89 55 ec	 mov	 DWORD PTR _TempUMask$[ebp], edx

; 3152 : #endif
; 3153 : 
; 3154 : 	static	DWORD ESPStorage;   // Temp ESP storage
; 3155 : 	static	DWORD EBPStorage;   // Temp EBP storage
; 3156 : 
; 3157 : 	// Positionments are (signed) fixed-point 3:4
; 3158 : 	INT  UDisp = appRound(UPosition) & UMask;

  0005d	8b 90 00 01 00
	00		 mov	 edx, DWORD PTR [eax+256]
  00063	89 4d cc	 mov	 DWORD PTR _Ydimension$[ebp], ecx
  00066	89 55 e4	 mov	 DWORD PTR $T133918[ebp], edx
  00069	d9 45 e4	 fld	 DWORD PTR $T133918[ebp]
  0006c	db 5d e8	 fistp	 DWORD PTR _I$133916[ebp]
  0006f	8b 90 c8 00 00
	00		 mov	 edx, DWORD PTR [eax+200]
  00075	23 55 e8	 and	 edx, DWORD PTR _I$133916[ebp]
  00078	89 55 f8	 mov	 DWORD PTR _UDisp$[ebp], edx

; 3159 : 	INT  VDisp = appRound(VPosition) & VMask;

  0007b	8b 90 04 01 00
	00		 mov	 edx, DWORD PTR [eax+260]
  00081	89 55 e4	 mov	 DWORD PTR $T133924[ebp], edx
  00084	d9 45 e4	 fld	 DWORD PTR $T133924[ebp]
  00087	db 5d e8	 fistp	 DWORD PTR _I$133922[ebp]
  0008a	8b b0 cc 00 00
	00		 mov	 esi, DWORD PTR [eax+204]
  00090	8b 7d e8	 mov	 edi, DWORD PTR _I$133922[ebp]
  00093	23 fe		 and	 edi, esi

; 3160 : 
; 3161 :     for( INT v=0; v<Ydimension; v++ )

  00095	33 f6		 xor	 esi, esi
  00097	85 c9		 test	 ecx, ecx
  00099	89 7d dc	 mov	 DWORD PTR _VDisp$[ebp], edi
  0009c	89 75 fc	 mov	 DWORD PTR _v$[ebp], esi
  0009f	0f 8e 71 01 00
	00		 jle	 $L124391
  000a5	53		 push	 ebx
  000a6	eb 09		 jmp	 SHORT $L124389
$L133928:
  000a8	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  000ab	8b 7d dc	 mov	 edi, DWORD PTR _VDisp$[ebp]
  000ae	8b 75 fc	 mov	 esi, DWORD PTR _v$[ebp]
$L124389:

; 3162 :     {
; 3163 : 		BYTE* LineStart   = BitMapAddr +    ( v << UBits );

  000b1	8b 5d d8	 mov	 ebx, DWORD PTR _BitMapAddr$[ebp]
  000b4	33 c9		 xor	 ecx, ecx
  000b6	8a 48 30	 mov	 cl, BYTE PTR [eax+48]
  000b9	8b d6		 mov	 edx, esi
  000bb	d3 e2		 shl	 edx, cl

; 3164 : 		BYTE* TexStart    = TexAddr    + (((v + VDisp) & VMask) << UBits);

  000bd	03 f7		 add	 esi, edi
  000bf	03 da		 add	 ebx, edx
  000c1	89 5d e4	 mov	 DWORD PTR _LineStart$124392[ebp], ebx
  000c4	8b 98 cc 00 00
	00		 mov	 ebx, DWORD PTR [eax+204]

; 3165 : 		BYTE* GlassStart  = GlassAddr  +    ( v << UBits );

  000ca	8b 45 d0	 mov	 eax, DWORD PTR _GlassAddr$[ebp]
  000cd	23 f3		 and	 esi, ebx
  000cf	d3 e6		 shl	 esi, cl
  000d1	8b 4d d4	 mov	 ecx, DWORD PTR _TexAddr$[ebp]
  000d4	03 d0		 add	 edx, eax
  000d6	89 55 f4	 mov	 DWORD PTR _GlassStart$124394[ebp], edx
  000d9	03 f1		 add	 esi, ecx

; 3166 : 
; 3167 : #if ICEASM
; 3168 : 
; 3169 : 		// PPro-optimized version (no cache warming)
; 3170 : 		if( GIsPentiumPro )

  000db	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp__GIsPentiumPro
  000e1	83 39 00	 cmp	 DWORD PTR [ecx], 0
  000e4	89 75 e8	 mov	 DWORD PTR _TexStart$124393[ebp], esi
  000e7	0f 84 86 00 00
	00		 je	 $L124395

; 3171 : 		{  		
; 3172 : 			__asm                         
; 3173 : 			{                             
; 3174 : 				mov     esi, LineStart    //

  000ed	8b 75 e4	 mov	 esi, DWORD PTR _LineStart$124392[ebp]

; 3175 : 				mov     edi, TexStart     //

  000f0	8b 7d e8	 mov	 edi, DWORD PTR _TexStart$124393[ebp]

; 3176 : 
; 3177 : 				mov     ecx, [TempUMask]  //

  000f3	8b 4d ec	 mov	 ecx, DWORD PTR _TempUMask$[ebp]

; 3178 : 
; 3179 : 				mov     ebx, Xdimension   //

  000f6	8b 5d f0	 mov	 ebx, DWORD PTR _Xdimension$[ebp]

; 3180 : 				mov     edx, GlassStart   //

  000f9	8b 55 f4	 mov	 edx, DWORD PTR _GlassStart$124394[ebp]

; 3181 : 
; 3182 : 				mov     eax, UDisp        //

  000fc	8b 45 f8	 mov	 eax, DWORD PTR _UDisp$[ebp]

; 3183 : 
; 3184 : 				add		ebx,eax           //  compensate for source-texture X-bias

  000ff	03 d8		 add	 ebx, eax

; 3185 : 				sub     edx,eax           //

  00101	2b d0		 sub	 edx, eax

; 3186 : 				sub     esi,eax           //

  00103	2b f0		 sub	 esi, eax

; 3187 : 
; 3188 : 			//Ice4Npixelz:
; 3189 : 
; 3190 : 				mov     ESPStorage,esp    //

  00105	89 25 00 00 00
	00		 mov	 DWORD PTR ?ESPStorage@?3??BlitIceTex@UIceTexture@@AAEXXZ@4KA, esp

; 3191 : 				mov     EBPStorage,ebp    //

  0010b	89 2d 00 00 00
	00		 mov	 DWORD PTR ?EBPStorage@?3??BlitIceTex@UIceTexture@@AAEXXZ@4KA, ebp

; 3192 : 
; 3193 : 				sub     ebx,2             //  Do last 2 pixels separately

  00111	83 eb 02	 sub	 ebx, 2

; 3194 : 				mov     ebp,edx           //

  00114	8b ea		 mov	 ebp, edx

; 3195 : 				mov     esp,ebx           //

  00116	8b e3		 mov	 esp, ebx

; 3196 : 
; 3197 : 				xor     edx,edx           //

  00118	33 d2		 xor	 edx, edx

; 3198 : 				xor     ebx,ebx           //

  0011a	33 db		 xor	 ebx, ebx

; 3199 : 
; 3200 : 				mov     dl,[ebp+eax]      //  Preload  dl

  0011c	8a 54 05 00	 mov	 dl, BYTE PTR [ebp+eax]
$CopyLoop$124396:

; 3201 : 
; 3202 : 			 align 16
; 3203 : 			 CopyLoop: 
; 3204 : 				add     dl,al             //  Linestart[u]+u

  00120	02 d0		 add	 dl, al

; 3205 : 				mov     bl,[ebp+eax+1]    //  Glass

  00122	8a 5c 05 01	 mov	 bl, BYTE PTR [ebp+eax+1]

; 3206 : 										  //
; 3207 : 				and     dl,cl			  //  wrap using mask

  00126	22 d1		 and	 dl, cl

; 3208 : 				add     bl,al			  //

  00128	02 d8		 add	 bl, al

; 3209 : 										  //
; 3210 : 				inc     bl                //  Linestart[u+1] + u+1

  0012a	fe c3		 inc	 bl

; 3211 : 				add     eax,2			  //  // AL not changed itself so no stall

  0012c	83 c0 02	 add	 eax, 2

; 3212 : 										  //
; 3213 : 				mov     dl,[edi+edx]      //  Texel

  0012f	8a 14 17	 mov	 dl, BYTE PTR [edi+edx]

; 3214 : 				and     bl,cl			  //  wrap using mask

  00132	22 d9		 and	 bl, cl

; 3215 : 										  //
; 3216 : 				cmp     esp,eax           //

  00134	3b e0		 cmp	 esp, eax

; 3217 : 				mov     [esi+eax-2],dl    //  Store

  00136	88 54 06 fe	 mov	 BYTE PTR [esi+eax-2], dl

; 3218 : 										  //
; 3219 : 				mov     bl,[edi+ebx]      //  Texel

  0013a	8a 1c 1f	 mov	 bl, BYTE PTR [edi+ebx]

; 3220 : 				mov     dl,[ebp+eax]      //  Glass

  0013d	8a 54 05 00	 mov	 dl, BYTE PTR [ebp+eax]

; 3221 : 										  //
; 3222 : 				mov     [esi+eax-2+1],bl  //  Store

  00141	88 5c 06 ff	 mov	 BYTE PTR [esi+eax-1], bl

; 3223 : 				jne     CopyLoop          //

  00145	75 d9		 jne	 SHORT $CopyLoop$124396

; 3224 : 										  //
; 3225 : 				////////////////////////////
; 3226 : 
; 3227 : 				mov     esp,ESPStorage    //

  00147	8b 25 00 00 00
	00		 mov	 esp, DWORD PTR ?ESPStorage@?3??BlitIceTex@UIceTexture@@AAEXXZ@4KA

; 3228 : 				mov     bl,[ebp+eax+1]    // get glasspixel 2

  0014d	8a 5c 05 01	 mov	 bl, BYTE PTR [ebp+eax+1]

; 3229 : 
; 3230 : 				add     dl,al             //

  00151	02 d0		 add	 dl, al

; 3231 : 				add     bl,al             //

  00153	02 d8		 add	 bl, al

; 3232 : 
; 3233 : 				inc     bl	              // ebx	    

  00155	fe c3		 inc	 bl

; 3234 : 				and     dl,cl             // edx,ecx 

  00157	22 d1		 and	 dl, cl

; 3235 : 
; 3236 : 				mov     ebp,EBPStorage

  00159	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR ?EBPStorage@?3??BlitIceTex@UIceTexture@@AAEXXZ@4KA

; 3237 : 				and     bl,cl             // ebx,ecx 

  0015f	22 d9		 and	 bl, cl

; 3238 : 
; 3239 : 				mov     dl,[edi+edx]      // Texel

  00161	8a 14 17	 mov	 dl, BYTE PTR [edi+edx]

; 3240 : 				mov     bl,[edi+ebx]      // Texel

  00164	8a 1c 1f	 mov	 bl, BYTE PTR [edi+ebx]

; 3241 : 
; 3242 : 				mov     [esi+eax],dl      // Dest

  00167	88 14 06	 mov	 BYTE PTR [esi+eax], dl

; 3243 : 				mov     [esi+eax+1],bl    // Dest

  0016a	88 5c 06 01	 mov	 BYTE PTR [esi+eax+1], bl

; 3244 : 
; 3245 : 			}
; 3246 : 		}		
; 3247 : 		else

  0016e	e9 90 00 00 00	 jmp	 $L124390
$L124395:

; 3248 : 
; 3249 : 		// Pentium / Pentium MMX optimized version (WITH cache warming)
; 3250 : 		{
; 3251 : 			__asm                         
; 3252 : 			{                             
; 3253 : 				mov     esi, LineStart    //

  00173	8b 75 e4	 mov	 esi, DWORD PTR _LineStart$124392[ebp]

; 3254 : 				mov     edi, TexStart     //

  00176	8b 7d e8	 mov	 edi, DWORD PTR _TexStart$124393[ebp]

; 3255 : 
; 3256 : 				mov     ecx, [TempUMask]  //

  00179	8b 4d ec	 mov	 ecx, DWORD PTR _TempUMask$[ebp]

; 3257 : 
; 3258 : 				mov     ebx, Xdimension   //

  0017c	8b 5d f0	 mov	 ebx, DWORD PTR _Xdimension$[ebp]

; 3259 : 				mov     edx, GlassStart   //

  0017f	8b 55 f4	 mov	 edx, DWORD PTR _GlassStart$124394[ebp]

; 3260 : 
; 3261 : 				mov     eax, UDisp        //

  00182	8b 45 f8	 mov	 eax, DWORD PTR _UDisp$[ebp]

; 3262 : 
; 3263 : 				add		ebx,eax           //  compensate for source-texture X-bias

  00185	03 d8		 add	 ebx, eax

; 3264 : 				sub     edx,eax           //

  00187	2b d0		 sub	 edx, eax

; 3265 : 				sub     esi,eax           //

  00189	2b f0		 sub	 esi, eax

; 3266 : 
; 3267 : 			//Ice4Npixelz:
; 3268 : 
; 3269 : 				mov     ESPStorage,esp    //

  0018b	89 25 00 00 00
	00		 mov	 DWORD PTR ?ESPStorage@?3??BlitIceTex@UIceTexture@@AAEXXZ@4KA, esp

; 3270 : 				mov     EBPStorage,ebp    //

  00191	89 2d 00 00 00
	00		 mov	 DWORD PTR ?EBPStorage@?3??BlitIceTex@UIceTexture@@AAEXXZ@4KA, ebp

; 3271 : 
; 3272 : 				sub     ebx,2             //  Do last 2 pixels separately

  00197	83 eb 02	 sub	 ebx, 2

; 3273 : 				mov     ebp,edx           //

  0019a	8b ea		 mov	 ebp, edx

; 3274 : 				mov     esp,ebx           //

  0019c	8b e3		 mov	 esp, ebx

; 3275 : 
; 3276 : 				xor     edx,edx           //

  0019e	33 d2		 xor	 edx, edx

; 3277 : 				xor     ebx,ebx           //

  001a0	33 db		 xor	 ebx, ebx

; 3278 : 
; 3279 : 				mov     dl,[ebp+eax]      //  Preload  dl

  001a2	8a 54 05 00	 mov	 dl, BYTE PTR [ebp+eax]

; 3327 : 			}
; 3328 : 		}
; 3329 : #else
; 3330 : 		for( INT u=0; u<Xdimension; u+=2 )
; 3331 :         {
; 3332 : 			// Coolish effect combining half warped, half original.
; 3333 : 			// LineStart[u] = (  SourceStart[(u+LineStart[u]) & UMask ] + SourceStart[(u+128) & UMask]  ) >> 1;
; 3334 : 
; 3335 : 			INT u2 = u+1; // Help C++ with pipelining...
; 3336 : 
; 3337 : 			LineStart[u]  =  TexStart[(  u + UDisp + GlassStart[ u]) & UMask ] ;
; 3338 : 			LineStart[u2] =  TexStart[( u2 + UDisp + GlassStart[u2]) & UMask ] ;
; 3339 :         }
; 3340 : #endif
; 3341 : 
; 3342 : 	}
; 3343 : }

  001a6	8d a4 24 00 00
	00 00 8d 49 00	 npad	 10
$CopyLoop2$124398:

; 3280 : 
; 3281 : 			 align 16
; 3282 :     		 CopyLoop2: 
; 3283 : 
; 3284 : 				nop				 		  //  

  001b0	90		 npad	 1

; 3285 : 				mov     bl,[esi+eax-2]    //  cache-warming load - per word..

  001b1	8a 5c 06 fe	 mov	 bl, BYTE PTR [esi+eax-2]

; 3286 : 
; 3287 : 				add     dl,al             //  Linestart[u]+u

  001b5	02 d0		 add	 dl, al

; 3288 : 				mov     bl,[ebp+eax+1]    //  Glass

  001b7	8a 5c 05 01	 mov	 bl, BYTE PTR [ebp+eax+1]

; 3289 : 										  //
; 3290 : 				and     dl,cl			  //

  001bb	22 d1		 and	 dl, cl

; 3291 : 				add     bl,al			  //

  001bd	02 d8		 add	 bl, al

; 3292 : 										  //
; 3293 : 				inc     bl                //  Linestart[u+1] + u+1

  001bf	fe c3		 inc	 bl

; 3294 : 				add     eax,2			  //  // AL not changed itself so no stall

  001c1	83 c0 02	 add	 eax, 2

; 3295 : 										  //
; 3296 : 				mov     dl,[edi+edx]      //  Texel

  001c4	8a 14 17	 mov	 dl, BYTE PTR [edi+edx]

; 3297 : 				and     bl,cl			  //

  001c7	22 d9		 and	 bl, cl

; 3298 : 										  //
; 3299 : 				cmp     esp,eax           //

  001c9	3b e0		 cmp	 esp, eax

; 3300 : 				mov     [esi+eax-2],dl    //  Store

  001cb	88 54 06 fe	 mov	 BYTE PTR [esi+eax-2], dl

; 3301 : 										  //
; 3302 : 				mov     bl,[edi+ebx]      //  Texel

  001cf	8a 1c 1f	 mov	 bl, BYTE PTR [edi+ebx]

; 3303 : 				mov     dl,[ebp+eax]      //  Glass

  001d2	8a 54 05 00	 mov	 dl, BYTE PTR [ebp+eax]

; 3304 : 										  //
; 3305 : 				mov     [esi+eax-2+1],bl  //  Store

  001d6	88 5c 06 ff	 mov	 BYTE PTR [esi+eax-1], bl

; 3306 : 				jne     CopyLoop2         //

  001da	75 d4		 jne	 SHORT $CopyLoop2$124398

; 3307 : 										  //
; 3308 : 				////////////////////////////
; 3309 : 
; 3310 : 				mov     esp,ESPStorage    //

  001dc	8b 25 00 00 00
	00		 mov	 esp, DWORD PTR ?ESPStorage@?3??BlitIceTex@UIceTexture@@AAEXXZ@4KA

; 3311 : 				mov     bl,[ebp+eax+1]    // get glasspixel 2

  001e2	8a 5c 05 01	 mov	 bl, BYTE PTR [ebp+eax+1]

; 3312 : 
; 3313 : 				add     dl,al             //

  001e6	02 d0		 add	 dl, al

; 3314 : 				add     bl,al             //

  001e8	02 d8		 add	 bl, al

; 3315 : 
; 3316 : 				inc     bl				  //

  001ea	fe c3		 inc	 bl

; 3317 : 				and     dl,cl			  //

  001ec	22 d1		 and	 dl, cl

; 3318 : 
; 3319 : 				mov     ebp,EBPStorage    //

  001ee	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR ?EBPStorage@?3??BlitIceTex@UIceTexture@@AAEXXZ@4KA

; 3320 : 				and     bl,cl		      //

  001f4	22 d9		 and	 bl, cl

; 3321 : 
; 3322 : 				mov     dl,[edi+edx]      // Texel

  001f6	8a 14 17	 mov	 dl, BYTE PTR [edi+edx]

; 3323 : 				mov     bl,[edi+ebx]      // Texel

  001f9	8a 1c 1f	 mov	 bl, BYTE PTR [edi+ebx]

; 3324 : 
; 3325 : 				mov     [esi+eax],dl      // Dest

  001fc	88 14 06	 mov	 BYTE PTR [esi+eax], dl

; 3326 : 				mov     [esi+eax+1],bl    // Dest

  001ff	88 5c 06 01	 mov	 BYTE PTR [esi+eax+1], bl
$L124390:

; 3160 : 
; 3161 :     for( INT v=0; v<Ydimension; v++ )

  00203	8b 45 fc	 mov	 eax, DWORD PTR _v$[ebp]
  00206	8b 4d cc	 mov	 ecx, DWORD PTR _Ydimension$[ebp]
  00209	40		 inc	 eax
  0020a	3b c1		 cmp	 eax, ecx
  0020c	89 45 fc	 mov	 DWORD PTR _v$[ebp], eax
  0020f	0f 8c 93 fe ff
	ff		 jl	 $L133928
  00215	5b		 pop	 ebx
$L124391:
  00216	5f		 pop	 edi
  00217	5e		 pop	 esi

; 3327 : 			}
; 3328 : 		}
; 3329 : #else
; 3330 : 		for( INT u=0; u<Xdimension; u+=2 )
; 3331 :         {
; 3332 : 			// Coolish effect combining half warped, half original.
; 3333 : 			// LineStart[u] = (  SourceStart[(u+LineStart[u]) & UMask ] + SourceStart[(u+128) & UMask]  ) >> 1;
; 3334 : 
; 3335 : 			INT u2 = u+1; // Help C++ with pipelining...
; 3336 : 
; 3337 : 			LineStart[u]  =  TexStart[(  u + UDisp + GlassStart[ u]) & UMask ] ;
; 3338 : 			LineStart[u2] =  TexStart[( u2 + UDisp + GlassStart[u2]) & UMask ] ;
; 3339 :         }
; 3340 : #endif
; 3341 : 
; 3342 : 	}
; 3343 : }

  00218	8b e5		 mov	 esp, ebp
  0021a	5d		 pop	 ebp
  0021b	c3		 ret	 0
?BlitIceTex@UIceTexture@@AAEXXZ ENDP			; UIceTexture::BlitIceTex
_TEXT	ENDS
PUBLIC	?WaterRedrawDrops@UWaterTexture@@QAEXXZ		; UWaterTexture::WaterRedrawDrops
; Function compile flags: /Ogty
;	COMDAT ?WaterRedrawDrops@UWaterTexture@@QAEXXZ
_TEXT	SEGMENT
_this$ = -68
_U2Mask$ = -48
_V2Mask$ = -52
_SegSize$ = -60
_Depth$ = -69
_t$ = -44
_S$ = -20
_Xnow$124420 = -36
_Ynow$124421 = -32
_DropDest$124422 = -56
_Spray$124541 = -12
_AddDestY$124542 = -16
$T133934 = -69
$T133942 = -69
$T133962 = -8
$T133966 = -4
?WaterRedrawDrops@UWaterTexture@@QAEXXZ PROC NEAR	; UWaterTexture::WaterRedrawDrops, COMDAT
; _this$ = ecx

; 3357 : {

  00000	83 ec 48	 sub	 esp, 72			; 00000048H

; 3358 :     //
; 3359 :     // Waterdrops setting from the editable list.
; 3360 :     //
; 3361 : 	//
; 3362 :     // Warning: All code manipulating the wave source-field
; 3363 :     //          must be aware it only has 1/2 the dimension
; 3364 :     //          of the actual output bitmap.
; 3365 : 	//
; 3366 : 
; 3367 :     BYTE  U2Mask = UMask >> 1;       // warning: 1/2 of full output size

  00003	8b 81 c8 00 00
	00		 mov	 eax, DWORD PTR [ecx+200]
  00009	d1 f8		 sar	 eax, 1
  0000b	88 44 24 18	 mov	 BYTE PTR _U2Mask$[esp+72], al

; 3368 :     BYTE  V2Mask = VMask >> 1;       // 

  0000f	8b 81 cc 00 00
	00		 mov	 eax, DWORD PTR [ecx+204]
  00015	d1 f8		 sar	 eax, 1
  00017	88 44 24 14	 mov	 BYTE PTR _V2Mask$[esp+72], al

; 3369 :     INT   XSize  = USize/2;          // 

  0001b	8b 41 34	 mov	 eax, DWORD PTR [ecx+52]
  0001e	99		 cdq
  0001f	2b c2		 sub	 eax, edx

; 3370 :     BYTE* WaveFieldA = SourceFields; //
; 3371 :     BYTE* WaveFieldB = SourceFields + XSize;
; 3372 :     INT   SegSize;
; 3373 : 	BYTE  Depth;
; 3374 : 
; 3375 :     GlobalPhase++;

  00021	8b 91 d8 00 00
	00		 mov	 edx, DWORD PTR [ecx+216]
  00027	53		 push	 ebx
  00028	8b 99 f0 08 00
	00		 mov	 ebx, DWORD PTR [ecx+2288]
  0002e	55		 push	 ebp
  0002f	8b e8		 mov	 ebp, eax

; 3376 : 
; 3377 : 	INT  t;
; 3378 : 
; 3379 :     for( INT S=0; S<NumDrops; S++ )

  00031	8b 81 ec 00 00
	00		 mov	 eax, DWORD PTR [ecx+236]
  00037	d1 fd		 sar	 ebp, 1
  00039	03 eb		 add	 ebp, ebx
  0003b	42		 inc	 edx
  0003c	85 c0		 test	 eax, eax
  0003e	89 4c 24 0c	 mov	 DWORD PTR _this$[esp+80], ecx
  00042	89 91 d8 00 00
	00		 mov	 DWORD PTR [ecx+216], edx
  00048	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR _S$[esp+80], 0
  00050	0f 8e 2b 0b 00
	00		 jle	 $L124419
  00056	56		 push	 esi
  00057	57		 push	 edi
  00058	8d b1 f7 00 00
	00		 lea	 esi, DWORD PTR [ecx+247]
  0005e	eb 04		 jmp	 SHORT $L124417
$L133994:

; 3358 :     //
; 3359 :     // Waterdrops setting from the editable list.
; 3360 :     //
; 3361 : 	//
; 3362 :     // Warning: All code manipulating the wave source-field
; 3363 :     //          must be aware it only has 1/2 the dimension
; 3364 :     //          of the actual output bitmap.
; 3365 : 	//
; 3366 : 
; 3367 :     BYTE  U2Mask = UMask >> 1;       // warning: 1/2 of full output size

  00060	8b 4c 24 14	 mov	 ecx, DWORD PTR _this$[esp+88]
$L124417:

; 3380 :     {
; 3381 :         BYTE Xnow = Drops[S].X;
; 3382 :         BYTE Ynow = Drops[S].Y;

  00064	8a 56 fc	 mov	 dl, BYTE PTR [esi-4]
  00067	8a 46 fb	 mov	 al, BYTE PTR [esi-5]

; 3383 :         DWORD DropDest   = (DWORD)( ( Ynow << UBits ) + Xnow);

  0006a	8a 49 30	 mov	 cl, BYTE PTR [ecx+48]
  0006d	88 54 24 38	 mov	 BYTE PTR _Ynow$124421[esp+88], dl
  00071	88 44 24 34	 mov	 BYTE PTR _Xnow$124420[esp+88], al
  00075	8b 44 24 38	 mov	 eax, DWORD PTR _Ynow$124421[esp+88]
  00079	8b 7c 24 34	 mov	 edi, DWORD PTR _Xnow$124420[esp+88]
  0007d	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00082	8b d0		 mov	 edx, eax
  00084	d3 e2		 shl	 edx, cl
  00086	81 e7 ff 00 00
	00		 and	 edi, 255		; 000000ffH
  0008c	89 44 24 48	 mov	 DWORD PTR -16+[esp+88], eax
  00090	8d 0c 17	 lea	 ecx, DWORD PTR [edi+edx]
  00093	89 4c 24 20	 mov	 DWORD PTR _DropDest$124422[esp+88], ecx

; 3384 : 
; 3385 :         switch( Drops[S].Type )
; 3386 :         {

  00097	33 c9		 xor	 ecx, ecx
  00099	8a 4e f9	 mov	 cl, BYTE PTR [esi-7]
  0009c	89 54 24 30	 mov	 DWORD PTR -40+[esp+88], edx
  000a0	83 f9 41	 cmp	 ecx, 65			; 00000041H
  000a3	0f 87 b8 0a 00
	00		 ja	 $L124418
  000a9	33 d2		 xor	 edx, edx
  000ab	8a 91 00 00 00
	00		 mov	 dl, BYTE PTR $L133993[ecx]
  000b1	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $L134009[edx*4]
$L124428:

; 3387 : 
; 3388 :         case DROP_FixedDepth:   // FIXEDD-depth pixy
; 3389 :             Depth = Drops[S].ByteD;

  000b8	8a 06		 mov	 al, BYTE PTR [esi]

; 3390 :             WaveFieldA[ DropDest ]  =  Depth;

  000ba	8b 4c 24 20	 mov	 ecx, DWORD PTR _DropDest$124422[esp+88]
  000be	88 04 19	 mov	 BYTE PTR [ecx+ebx], al

; 3391 :             WaveFieldB[ DropDest ]  =  Depth;

  000c1	88 04 29	 mov	 BYTE PTR [ecx+ebp], al

; 3392 :             break; 

  000c4	e9 98 0a 00 00	 jmp	 $L124418
$L124429:

; 3393 : 
; 3394 : 		case DROP_PhaseSpot:   // Phased I
; 3395 : 			{
; 3396 :        	    Drops[S].Depth += Drops[S].ByteD; // update phase

  000c9	8a 06		 mov	 al, BYTE PTR [esi]
  000cb	8a 56 fa	 mov	 dl, BYTE PTR [esi-6]

; 3397 :             Depth = PhaseTable[ Drops[S].Depth ];
; 3398 :             WaveFieldA[ DropDest ]  =  Depth;

  000ce	8b 4c 24 20	 mov	 ecx, DWORD PTR _DropDest$124422[esp+88]
  000d2	02 d0		 add	 dl, al
  000d4	33 c0		 xor	 eax, eax
  000d6	8a c2		 mov	 al, dl
  000d8	88 56 fa	 mov	 BYTE PTR [esi-6], dl
  000db	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000e0	8a 80 00 00 00
	00		 mov	 al, BYTE PTR _PhaseTable[eax]
  000e6	88 04 19	 mov	 BYTE PTR [ecx+ebx], al

; 3399 :             WaveFieldB[ DropDest ]  =  Depth;

  000e9	88 04 29	 mov	 BYTE PTR [ecx+ebp], al

; 3400 : 
; 3401 : 			/*
; 3402 : 			DWORD Phase16 = ((DWORD)Drops[S].ByteB << 8) + (DWORD)Drops[S].ByteA;
; 3403 : 				  Phase16=0xFFFF & ( Phase16 + ((DWORD)Drops[S].ByteD << 8) + (DWORD)Drops[S].ByteC );
; 3404 : 
; 3405 : 			Drops[S].ByteA =    Phase16 & 0xFF;
; 3406 : 			Drops[S].ByteB =  ( Phase16 >> 8 ) & 0xFF;
; 3407 : 
; 3408 : 			// Real 16-bit phase is B:A, delta= D:C
; 3409 : 			Depth = PhaseTable[ Drops[S].ByteB ];
; 3410 : 			WaveFieldA[ DropDest ]  =  Depth;
; 3411 : 			WaveFieldB[ DropDest ]  =  Depth;
; 3412 : 			*/
; 3413 : 
; 3414 : 			}
; 3415 :             break;

  000ec	e9 70 0a 00 00	 jmp	 $L124418
$L124430:

; 3416 : 
; 3417 : 		case DROP_HalfAmpl:     // half amplitude: only goes down INT  o water
; 3418 : 			Drops[S].Depth += Drops[S].ByteD; // update phase

  000f1	8a 46 fa	 mov	 al, BYTE PTR [esi-6]
  000f4	8a 0e		 mov	 cl, BYTE PTR [esi]
  000f6	02 c1		 add	 al, cl
  000f8	88 46 fa	 mov	 BYTE PTR [esi-6], al

; 3419 :             Depth = PhaseTable[ Drops[S].Depth ];

  000fb	33 c0		 xor	 eax, eax
  000fd	8a 46 fa	 mov	 al, BYTE PTR [esi-6]
  00100	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00105	8a 80 00 00 00
	00		 mov	 al, BYTE PTR _PhaseTable[eax]

; 3420 : 			if( Depth<128 ) Depth = 128; // clamp it

  0010b	3c 80		 cmp	 al, 128			; 00000080H
  0010d	73 02		 jae	 SHORT $L124431
  0010f	b0 80		 mov	 al, 128			; 00000080H
$L124431:

; 3421 :             WaveFieldA[ DropDest ]  =  Depth;

  00111	8b 4c 24 20	 mov	 ecx, DWORD PTR _DropDest$124422[esp+88]
  00115	88 04 19	 mov	 BYTE PTR [ecx+ebx], al

; 3422 :             WaveFieldB[ DropDest ]  =  Depth;

  00118	88 04 29	 mov	 BYTE PTR [ecx+ebp], al

; 3423 :             break;

  0011b	e9 41 0a 00 00	 jmp	 $L124418
$L124432:

; 3424 : 
; 3425 :         case DROP_ShallowSpot: // Phased II
; 3426 :        	    Drops[S].Depth += Drops[S].ByteD; // update phase

  00120	8a 46 fa	 mov	 al, BYTE PTR [esi-6]
  00123	8a 16		 mov	 dl, BYTE PTR [esi]

; 3427 :             Depth = 64+ (PhaseTable[ Drops[S].Depth ] >> 1) ;
; 3428 :             WaveFieldA[ DropDest ]  =  Depth;

  00125	8b 4c 24 20	 mov	 ecx, DWORD PTR _DropDest$124422[esp+88]
  00129	02 c2		 add	 al, dl
  0012b	88 46 fa	 mov	 BYTE PTR [esi-6], al
  0012e	33 c0		 xor	 eax, eax
  00130	8a 46 fa	 mov	 al, BYTE PTR [esi-6]
  00133	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00138	8a 80 00 00 00
	00		 mov	 al, BYTE PTR _PhaseTable[eax]
  0013e	d0 e8		 shr	 al, 1
  00140	04 40		 add	 al, 64			; 00000040H
  00142	88 04 19	 mov	 BYTE PTR [ecx+ebx], al

; 3429 :             WaveFieldB[ DropDest ]  =  Depth;

  00145	88 04 29	 mov	 BYTE PTR [ecx+ebp], al

; 3430 :             break;

  00148	e9 14 0a 00 00	 jmp	 $L124418
$L124433:

; 3431 : 
; 3432 :         case DROP_RandomMover: // 'movers'
; 3433 :             Drops[S].X = U2Mask & (Xnow - (SpeedRand()&3) + (SpeedRand()&3) );

  0014d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  00153	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  00159	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  0015f	83 c2 04	 add	 edx, 4
  00162	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  00168	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  0016e	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  00174	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  0017a	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  00180	88 44 24 13	 mov	 BYTE PTR $T133934[esp+88], al
  00184	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  0018a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  00190	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00196	83 c2 04	 add	 edx, 4
  00199	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  0019f	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  001a5	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  001ab	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  001b1	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  001b7	8a 4c 24 13	 mov	 cl, BYTE PTR $T133934[esp+88]
  001bb	8a 54 24 34	 mov	 dl, BYTE PTR _Xnow$124420[esp+88]
  001bf	24 03		 and	 al, 3
  001c1	80 e1 03	 and	 cl, 3
  001c4	2a c1		 sub	 al, cl
  001c6	8a 4c 24 28	 mov	 cl, BYTE PTR _U2Mask$[esp+88]
  001ca	02 c2		 add	 al, dl
  001cc	22 c1		 and	 al, cl
  001ce	88 46 fb	 mov	 BYTE PTR [esi-5], al

; 3434 :             Drops[S].Y = V2Mask & (Ynow - (SpeedRand()&3) + (SpeedRand()&3) );

  001d1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  001d7	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  001dd	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  001e3	83 c2 04	 add	 edx, 4
  001e6	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  001ec	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  001f2	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  001f8	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  001fe	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  00204	88 44 24 13	 mov	 BYTE PTR $T133942[esp+88], al
  00208	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  0020e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  00214	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  0021a	83 c2 04	 add	 edx, 4
  0021d	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  00223	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  00229	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  0022f	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  00235	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  0023b	8a 4c 24 13	 mov	 cl, BYTE PTR $T133942[esp+88]
  0023f	8a 54 24 38	 mov	 dl, BYTE PTR _Ynow$124421[esp+88]
  00243	24 03		 and	 al, 3
  00245	80 e1 03	 and	 cl, 3
  00248	2a c1		 sub	 al, cl
  0024a	8a 4c 24 24	 mov	 cl, BYTE PTR _V2Mask$[esp+88]
  0024e	02 c2		 add	 al, dl
  00250	22 c1		 and	 al, cl
  00252	88 46 fc	 mov	 BYTE PTR [esi-4], al

; 3435 :             WaveFieldA[ DropDest ]  =  128+57;

  00255	8b 44 24 20	 mov	 eax, DWORD PTR _DropDest$124422[esp+88]
  00259	c6 04 18 b9	 mov	 BYTE PTR [eax+ebx], 185	; 000000b9H

; 3436 :             WaveFieldB[ DropDest ]  =  128-57;

  0025d	c6 04 28 47	 mov	 BYTE PTR [eax+ebp], 71	; 00000047H

; 3437 :             break;

  00261	e9 fb 08 00 00	 jmp	 $L124418
$L124434:

; 3438 : 
; 3439 :         case DROP_FixedRandomSpot: // 'totally random'  fixed wavesource
; 3440 :             WaveFieldA[ DropDest ]  =  SpeedRand();

  00266	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  0026c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  00272	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00278	83 c2 04	 add	 edx, 4
  0027b	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  00281	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  00287	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  0028d	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  00293	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  00299	8b 7c 24 20	 mov	 edi, DWORD PTR _DropDest$124422[esp+88]
  0029d	88 04 1f	 mov	 BYTE PTR [edi+ebx], al

; 3441 :             WaveFieldB[ DropDest ]  =  SpeedRand();

  002a0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  002a6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  002ac	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  002b2	83 c2 04	 add	 edx, 4
  002b5	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  002bb	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  002c1	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  002c7	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  002cd	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  002d3	88 04 2f	 mov	 BYTE PTR [edi+ebp], al

; 3442 :             break;

  002d6	e9 86 08 00 00	 jmp	 $L124418
$L124435:

; 3443 : 
; 3444 : 		
; 3445 : 		case DROP_WhirlyThing: // Circular stirring.
; 3446 : 			{
; 3447 : 				DWORD Phase16 = ((DWORD)Drops[S].ByteB << 8) + (DWORD)Drops[S].ByteA;
; 3448 : 					  Phase16=0xFFFF & ( Phase16 + ((DWORD)Drops[S].ByteD << 8) + (DWORD)Drops[S].ByteC );

  002db	33 c9		 xor	 ecx, ecx
  002dd	8a 4e fe	 mov	 cl, BYTE PTR [esi-2]
  002e0	33 d2		 xor	 edx, edx
  002e2	8a 16		 mov	 dl, BYTE PTR [esi]

; 3449 : 
; 3450 : 				Drops[S].ByteA =    Phase16 & 0xFF;
; 3451 : 				Drops[S].ByteB =  ( Phase16 >> 8 ) & 0xFF;
; 3452 : 
; 3453 : 				// So real 16-bit phase is B:A, delta= D:C
; 3454 : 
; 3455 : 				DWORD AddDestX =    U2Mask & (Xnow + (PhaseTable[ Drops[S].ByteB ] >>4));
; 3456 : 				DWORD AddDestY = (  V2Mask & (Ynow + (PhaseTable[(Drops[S].ByteB+64) & 255 ]>>4)) ) << UBits;

  002e4	89 5c 24 40	 mov	 DWORD PTR -24+[esp+88], ebx
  002e8	33 db		 xor	 ebx, ebx
  002ea	03 ca		 add	 ecx, edx
  002ec	33 d2		 xor	 edx, edx
  002ee	8a 56 ff	 mov	 dl, BYTE PTR [esi-1]
  002f1	c1 e1 08	 shl	 ecx, 8
  002f4	03 ca		 add	 ecx, edx
  002f6	33 d2		 xor	 edx, edx
  002f8	8a 56 fd	 mov	 dl, BYTE PTR [esi-3]
  002fb	03 ca		 add	 ecx, edx
  002fd	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  00303	88 4e fd	 mov	 BYTE PTR [esi-3], cl
  00306	c1 e9 08	 shr	 ecx, 8
  00309	88 4e fe	 mov	 BYTE PTR [esi-2], cl
  0030c	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00312	33 d2		 xor	 edx, edx
  00314	8a 91 00 00 00
	00		 mov	 dl, BYTE PTR _PhaseTable[ecx]
  0031a	83 c1 40	 add	 ecx, 64			; 00000040H
  0031d	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00323	8a 99 00 00 00
	00		 mov	 bl, BYTE PTR _PhaseTable[ecx]
  00329	8b 4c 24 14	 mov	 ecx, DWORD PTR _this$[esp+88]
  0032d	8a 49 30	 mov	 cl, BYTE PTR [ecx+48]
  00330	c1 ea 04	 shr	 edx, 4
  00333	03 d7		 add	 edx, edi
  00335	8b 7c 24 28	 mov	 edi, DWORD PTR _U2Mask$[esp+88]
  00339	81 e7 ff 00 00
	00		 and	 edi, 255		; 000000ffH
  0033f	23 d7		 and	 edx, edi
  00341	8b fb		 mov	 edi, ebx

; 3457 : 				WaveFieldA[ AddDestX + AddDestY ] = Drops[S].Depth;

  00343	8b 5c 24 40	 mov	 ebx, DWORD PTR -24+[esp+88]
  00347	c1 ef 04	 shr	 edi, 4
  0034a	03 f8		 add	 edi, eax
  0034c	8b 44 24 24	 mov	 eax, DWORD PTR _V2Mask$[esp+88]
  00350	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00355	23 f8		 and	 edi, eax
  00357	8a 46 fa	 mov	 al, BYTE PTR [esi-6]
  0035a	d3 e7		 shl	 edi, cl
  0035c	03 d7		 add	 edx, edi
  0035e	88 04 1a	 mov	 BYTE PTR [edx+ebx], al

; 3458 : 				WaveFieldB[ AddDestX + AddDestY ] = Drops[S].Depth;

  00361	8a 4e fa	 mov	 cl, BYTE PTR [esi-6]
  00364	88 0c 2a	 mov	 BYTE PTR [edx+ebp], cl

; 3459 :             }
; 3460 : 			break;

  00367	e9 f5 07 00 00	 jmp	 $L124418
$L124443:

; 3461 : 
; 3462 : 		case DROP_WhirlyBack: // Circular stirring.
; 3463 : 			{
; 3464 : 				DWORD Phase16 = ((DWORD)Drops[S].ByteB << 8) + (DWORD)Drops[S].ByteA;
; 3465 : 					  Phase16=0xFFFF & ( Phase16 - ((DWORD)Drops[S].ByteD << 8) - (DWORD)Drops[S].ByteC );

  0036c	33 c9		 xor	 ecx, ecx
  0036e	8a 4e fe	 mov	 cl, BYTE PTR [esi-2]
  00371	33 d2		 xor	 edx, edx
  00373	8a 56 ff	 mov	 dl, BYTE PTR [esi-1]

; 3466 : 
; 3467 : 				Drops[S].ByteA =    Phase16 & 0xFF;
; 3468 : 				Drops[S].ByteB =  ( Phase16 >> 8 ) & 0xFF;
; 3469 : 
; 3470 : 				// So real 16-bit phase is B:A, delta= D:C
; 3471 : 
; 3472 : 				DWORD AddDestX =    U2Mask & (Xnow + (PhaseTable[ Drops[S].ByteB ] >>4));
; 3473 : 				DWORD AddDestY = (  V2Mask & (Ynow + (PhaseTable[(Drops[S].ByteB+64) & 255 ]>>4)) ) << UBits;

  00376	89 5c 24 40	 mov	 DWORD PTR -24+[esp+88], ebx
  0037a	33 db		 xor	 ebx, ebx
  0037c	c1 e1 08	 shl	 ecx, 8
  0037f	2b ca		 sub	 ecx, edx
  00381	33 d2		 xor	 edx, edx
  00383	8a 36		 mov	 dh, BYTE PTR [esi]
  00385	2b ca		 sub	 ecx, edx
  00387	33 d2		 xor	 edx, edx
  00389	8a 56 fd	 mov	 dl, BYTE PTR [esi-3]
  0038c	03 ca		 add	 ecx, edx
  0038e	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  00394	88 4e fd	 mov	 BYTE PTR [esi-3], cl
  00397	c1 e9 08	 shr	 ecx, 8
  0039a	88 4e fe	 mov	 BYTE PTR [esi-2], cl
  0039d	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  003a3	33 d2		 xor	 edx, edx
  003a5	8a 91 00 00 00
	00		 mov	 dl, BYTE PTR _PhaseTable[ecx]
  003ab	83 c1 40	 add	 ecx, 64			; 00000040H
  003ae	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  003b4	8a 99 00 00 00
	00		 mov	 bl, BYTE PTR _PhaseTable[ecx]
  003ba	8b 4c 24 14	 mov	 ecx, DWORD PTR _this$[esp+88]
  003be	8a 49 30	 mov	 cl, BYTE PTR [ecx+48]
  003c1	c1 ea 04	 shr	 edx, 4
  003c4	03 d7		 add	 edx, edi
  003c6	8b 7c 24 28	 mov	 edi, DWORD PTR _U2Mask$[esp+88]
  003ca	81 e7 ff 00 00
	00		 and	 edi, 255		; 000000ffH
  003d0	23 d7		 and	 edx, edi
  003d2	8b fb		 mov	 edi, ebx

; 3474 : 				WaveFieldA[ AddDestX + AddDestY ] = Drops[S].Depth;

  003d4	8b 5c 24 40	 mov	 ebx, DWORD PTR -24+[esp+88]
  003d8	c1 ef 04	 shr	 edi, 4
  003db	03 f8		 add	 edi, eax
  003dd	8b 44 24 24	 mov	 eax, DWORD PTR _V2Mask$[esp+88]
  003e1	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  003e6	23 f8		 and	 edi, eax
  003e8	8a 46 fa	 mov	 al, BYTE PTR [esi-6]
  003eb	d3 e7		 shl	 edi, cl
  003ed	03 d7		 add	 edx, edi
  003ef	88 04 1a	 mov	 BYTE PTR [edx+ebx], al

; 3475 : 				WaveFieldB[ AddDestX + AddDestY ] = Drops[S].Depth;

  003f2	8a 4e fa	 mov	 cl, BYTE PTR [esi-6]
  003f5	88 0c 2a	 mov	 BYTE PTR [edx+ebp], cl

; 3476 :             }
; 3477 : 			break;

  003f8	e9 64 07 00 00	 jmp	 $L124418
$L124451:

; 3478 : 
; 3479 : 		case DROP_BigWhirly: // Simple single-direction mover.  
; 3480 : 			{
; 3481 : 				DWORD Phase16 = ( *(DWORD*)&(Drops[S].ByteA) );
; 3482 : 				      Phase16=0xFFFF & ( Phase16 + *(_WORD*)&(Drops[S].ByteC) );

  003fd	8b 56 fd	 mov	 edx, DWORD PTR [esi-3]
  00400	33 c9		 xor	 ecx, ecx
  00402	66 8b 4e ff	 mov	 cx, WORD PTR [esi-1]

; 3483 : 
; 3484 : 				Drops[S].ByteB =  ( Phase16 >> 8 ) & 0xFF;
; 3485 : 				Drops[S].ByteA =    Phase16 & 0xFF;
; 3486 : 
; 3487 : 				// So real 16-bit phase is B:A, delta= D.
; 3488 : 
; 3489 : 				DWORD AddDestX =    U2Mask & (Xnow + (PhaseTable[ Drops[S].ByteB] >>3) ) ;
; 3490 : 				DWORD AddDestY = (  V2Mask & (Ynow + (PhaseTable[(Drops[S].ByteB+64) & 255] >>3) ) ) << UBits ;

  00406	89 5c 24 40	 mov	 DWORD PTR -24+[esp+88], ebx
  0040a	33 db		 xor	 ebx, ebx
  0040c	03 ca		 add	 ecx, edx
  0040e	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  00414	8b d1		 mov	 edx, ecx
  00416	88 4e fd	 mov	 BYTE PTR [esi-3], cl
  00419	c1 ea 08	 shr	 edx, 8
  0041c	88 56 fe	 mov	 BYTE PTR [esi-2], dl
  0041f	8b ca		 mov	 ecx, edx
  00421	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00427	33 d2		 xor	 edx, edx
  00429	8a 91 00 00 00
	00		 mov	 dl, BYTE PTR _PhaseTable[ecx]
  0042f	83 c1 40	 add	 ecx, 64			; 00000040H
  00432	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00438	8a 99 00 00 00
	00		 mov	 bl, BYTE PTR _PhaseTable[ecx]
  0043e	8b 4c 24 14	 mov	 ecx, DWORD PTR _this$[esp+88]
  00442	8a 49 30	 mov	 cl, BYTE PTR [ecx+48]
  00445	c1 ea 03	 shr	 edx, 3
  00448	03 d7		 add	 edx, edi
  0044a	8b 7c 24 28	 mov	 edi, DWORD PTR _U2Mask$[esp+88]
  0044e	81 e7 ff 00 00
	00		 and	 edi, 255		; 000000ffH
  00454	23 d7		 and	 edx, edi
  00456	8b fb		 mov	 edi, ebx

; 3491 : 				WaveFieldA[ AddDestX + AddDestY ]  =  Drops[S].Depth;

  00458	8b 5c 24 40	 mov	 ebx, DWORD PTR -24+[esp+88]
  0045c	c1 ef 03	 shr	 edi, 3
  0045f	03 f8		 add	 edi, eax
  00461	8b 44 24 24	 mov	 eax, DWORD PTR _V2Mask$[esp+88]
  00465	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0046a	23 f8		 and	 edi, eax
  0046c	8a 46 fa	 mov	 al, BYTE PTR [esi-6]
  0046f	d3 e7		 shl	 edi, cl
  00471	03 d7		 add	 edx, edi
  00473	88 04 1a	 mov	 BYTE PTR [edx+ebx], al

; 3492 : 				WaveFieldB[ AddDestX + AddDestY ]  =  Drops[S].Depth;

  00476	8a 4e fa	 mov	 cl, BYTE PTR [esi-6]
  00479	88 0c 2a	 mov	 BYTE PTR [edx+ebp], cl

; 3493 :             }
; 3494 : 			break;

  0047c	e9 e0 06 00 00	 jmp	 $L124418
$L124457:

; 3495 : 
; 3496 : 		case DROP_BigWhirlyBack: // Simple single-direction mover.  
; 3497 : 			{
; 3498 : 				DWORD Phase16 = ((DWORD)Drops[S].ByteB << 8) + (DWORD)Drops[S].ByteA;
; 3499 : 				      Phase16=0xFFFF & ( Phase16 - ((DWORD)Drops[S].ByteD << 8) - (DWORD)Drops[S].ByteC );

  00481	33 c9		 xor	 ecx, ecx
  00483	8a 4e fe	 mov	 cl, BYTE PTR [esi-2]
  00486	33 d2		 xor	 edx, edx
  00488	8a 56 ff	 mov	 dl, BYTE PTR [esi-1]

; 3500 : 
; 3501 : 				Drops[S].ByteB =  ( Phase16 >> 8 ) & 0xFF;
; 3502 : 				Drops[S].ByteA =    Phase16 & 0xFF;
; 3503 : 
; 3504 : 				// So real 16-bit phase is B:A, delta= D.
; 3505 : 
; 3506 : 				DWORD AddDestX =    U2Mask & (Xnow + (PhaseTable[ Drops[S].ByteB] >>3) ) ;
; 3507 : 				DWORD AddDestY = (  V2Mask & (Ynow + (PhaseTable[(Drops[S].ByteB+64) & 255] >>3) ) ) << UBits ;

  0048b	89 5c 24 40	 mov	 DWORD PTR -24+[esp+88], ebx
  0048f	33 db		 xor	 ebx, ebx
  00491	c1 e1 08	 shl	 ecx, 8
  00494	2b ca		 sub	 ecx, edx
  00496	33 d2		 xor	 edx, edx
  00498	8a 36		 mov	 dh, BYTE PTR [esi]
  0049a	2b ca		 sub	 ecx, edx
  0049c	33 d2		 xor	 edx, edx
  0049e	8a 56 fd	 mov	 dl, BYTE PTR [esi-3]
  004a1	03 ca		 add	 ecx, edx
  004a3	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  004a9	8b d1		 mov	 edx, ecx
  004ab	88 4e fd	 mov	 BYTE PTR [esi-3], cl
  004ae	c1 ea 08	 shr	 edx, 8
  004b1	88 56 fe	 mov	 BYTE PTR [esi-2], dl
  004b4	8b ca		 mov	 ecx, edx
  004b6	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  004bc	33 d2		 xor	 edx, edx
  004be	8a 91 00 00 00
	00		 mov	 dl, BYTE PTR _PhaseTable[ecx]
  004c4	83 c1 40	 add	 ecx, 64			; 00000040H
  004c7	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  004cd	8a 99 00 00 00
	00		 mov	 bl, BYTE PTR _PhaseTable[ecx]
  004d3	8b 4c 24 14	 mov	 ecx, DWORD PTR _this$[esp+88]
  004d7	8a 49 30	 mov	 cl, BYTE PTR [ecx+48]
  004da	c1 ea 03	 shr	 edx, 3
  004dd	03 d7		 add	 edx, edi
  004df	8b 7c 24 28	 mov	 edi, DWORD PTR _U2Mask$[esp+88]
  004e3	81 e7 ff 00 00
	00		 and	 edi, 255		; 000000ffH
  004e9	23 d7		 and	 edx, edi
  004eb	8b fb		 mov	 edi, ebx

; 3508 : 				WaveFieldA[ AddDestX + AddDestY ]  =  Drops[S].Depth;

  004ed	8b 5c 24 40	 mov	 ebx, DWORD PTR -24+[esp+88]
  004f1	c1 ef 03	 shr	 edi, 3
  004f4	03 f8		 add	 edi, eax
  004f6	8b 44 24 24	 mov	 eax, DWORD PTR _V2Mask$[esp+88]
  004fa	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  004ff	23 f8		 and	 edi, eax
  00501	8a 46 fa	 mov	 al, BYTE PTR [esi-6]
  00504	d3 e7		 shl	 edi, cl
  00506	03 d7		 add	 edx, edi
  00508	88 04 1a	 mov	 BYTE PTR [edx+ebx], al

; 3509 : 				WaveFieldB[ AddDestX + AddDestY ]  =  Drops[S].Depth;

  0050b	8a 4e fa	 mov	 cl, BYTE PTR [esi-6]
  0050e	88 0c 2a	 mov	 BYTE PTR [edx+ebp], cl

; 3510 :             }
; 3511 : 			break;

  00511	e9 4b 06 00 00	 jmp	 $L124418
$L124465:

; 3512 : 
; 3513 :         case DROP_HorizontalLine: //  Horizontal linesegment.
; 3514 : 			{
; 3515 : 				Depth = Drops[S].Depth;

  00516	8a 56 fa	 mov	 dl, BYTE PTR [esi-6]

; 3516 : 				SegSize = Drops[S].ByteD >> 1;

  00519	33 c9		 xor	 ecx, ecx
  0051b	8a 0e		 mov	 cl, BYTE PTR [esi]
  0051d	88 54 24 13	 mov	 BYTE PTR _Depth$[esp+88], dl
  00521	d1 e9		 shr	 ecx, 1

; 3517 : 				DWORD DropDestX0 = (DWORD)  ( Ynow << UBits ); 
; 3518 : 				for( t=0; t<=SegSize; t++ )

  00523	85 c9		 test	 ecx, ecx
  00525	0f 8c 36 06 00
	00		 jl	 $L124418
  0052b	8b 54 24 30	 mov	 edx, DWORD PTR -40+[esp+88]
  0052f	8b 44 24 28	 mov	 eax, DWORD PTR _U2Mask$[esp+88]
  00533	03 d3		 add	 edx, ebx
  00535	89 54 24 40	 mov	 DWORD PTR -24+[esp+88], edx
  00539	8b 54 24 30	 mov	 edx, DWORD PTR -40+[esp+88]
  0053d	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00542	03 d5		 add	 edx, ebp
  00544	41		 inc	 ecx
  00545	89 4c 24 30	 mov	 DWORD PTR -40+[esp+88], ecx
  00549	8a 4c 24 13	 mov	 cl, BYTE PTR _Depth$[esp+88]
  0054d	89 44 24 20	 mov	 DWORD PTR -56+[esp+88], eax
  00551	89 54 24 3c	 mov	 DWORD PTR -28+[esp+88], edx
  00555	eb 09		 jmp	 SHORT $L124468
$L134007:

; 3512 : 
; 3513 :         case DROP_HorizontalLine: //  Horizontal linesegment.
; 3514 : 			{
; 3515 : 				Depth = Drops[S].Depth;

  00557	8b 44 24 20	 mov	 eax, DWORD PTR -56+[esp+88]

; 3681 : 				}
; 3682 : 			}
; 3683 :             break;
; 3684 :       
; 3685 :         } //switch
; 3686 : 
; 3687 :     }
; 3688 : }

  0055b	90 8d 64 24 00	 npad	 5
$L124468:

; 3519 : 				{
; 3520 : 					DWORD AddDestX = (DWORD) ((t+Xnow) & U2Mask);
; 3521 : 					WaveFieldA[ DropDestX0 + AddDestX ] = Depth;

  00560	8b 54 24 40	 mov	 edx, DWORD PTR -24+[esp+88]
  00564	23 c7		 and	 eax, edi
  00566	88 0c 02	 mov	 BYTE PTR [edx+eax], cl

; 3522 : 					WaveFieldB[ DropDestX0 + AddDestX ] = Depth;

  00569	8b 54 24 3c	 mov	 edx, DWORD PTR -28+[esp+88]
  0056d	88 0c 02	 mov	 BYTE PTR [edx+eax], cl
  00570	8b 44 24 30	 mov	 eax, DWORD PTR -40+[esp+88]
  00574	47		 inc	 edi
  00575	48		 dec	 eax
  00576	89 44 24 30	 mov	 DWORD PTR -40+[esp+88], eax
  0057a	75 db		 jne	 SHORT $L134007

; 3523 : 				}
; 3524 : 			}
; 3525 :             break;

  0057c	e9 e0 05 00 00	 jmp	 $L124418
$L124473:

; 3526 : 
; 3527 :         case DROP_VerticalLine: //  Vertical linesegment.
; 3528 :             Depth = Drops[S].Depth;

  00581	8a 56 fa	 mov	 dl, BYTE PTR [esi-6]

; 3529 :             SegSize = Drops[S].ByteD >> 1;

  00584	33 c9		 xor	 ecx, ecx
  00586	8a 0e		 mov	 cl, BYTE PTR [esi]
  00588	d1 e9		 shr	 ecx, 1

; 3530 :             for( t=0; t<=SegSize; t++ )

  0058a	85 c9		 test	 ecx, ecx
  0058c	89 4c 24 1c	 mov	 DWORD PTR _SegSize$[esp+88], ecx
  00590	0f 8c cb 05 00
	00		 jl	 $L124418
  00596	8b 4c 24 24	 mov	 ecx, DWORD PTR _V2Mask$[esp+88]
  0059a	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  005a0	89 4c 24 18	 mov	 DWORD PTR -64+[esp+88], ecx

; 3531 :             {
; 3532 :                 DWORD AddDestY =  (DWORD) ( ((Ynow+t) & V2Mask) << UBits );

  005a4	8d 0c 1f	 lea	 ecx, DWORD PTR [edi+ebx]
  005a7	03 fd		 add	 edi, ebp
  005a9	89 7c 24 2c	 mov	 DWORD PTR -44+[esp+88], edi
  005ad	8b f8		 mov	 edi, eax
  005af	8b 44 24 1c	 mov	 eax, DWORD PTR _SegSize$[esp+88]
  005b3	40		 inc	 eax
  005b4	89 4c 24 30	 mov	 DWORD PTR -40+[esp+88], ecx
  005b8	89 44 24 20	 mov	 DWORD PTR -56+[esp+88], eax

; 3681 : 				}
; 3682 : 			}
; 3683 :             break;
; 3684 :       
; 3685 :         } //switch
; 3686 : 
; 3687 :     }
; 3688 : }

  005bc	8d 64 24 00	 npad	 4

; 3531 :             {
; 3532 :                 DWORD AddDestY =  (DWORD) ( ((Ynow+t) & V2Mask) << UBits );

$L124474:
  005c0	8b 4c 24 14	 mov	 ecx, DWORD PTR _this$[esp+88]
  005c4	8a 49 30	 mov	 cl, BYTE PTR [ecx+48]
  005c7	8b 44 24 18	 mov	 eax, DWORD PTR -64+[esp+88]
  005cb	23 c7		 and	 eax, edi
  005cd	d3 e0		 shl	 eax, cl

; 3533 :                 WaveFieldA[Xnow + AddDestY] = Depth;

  005cf	8b 4c 24 30	 mov	 ecx, DWORD PTR -40+[esp+88]
  005d3	47		 inc	 edi
  005d4	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 3534 :                 WaveFieldB[Xnow + AddDestY] = Depth;

  005d7	8b 4c 24 2c	 mov	 ecx, DWORD PTR -44+[esp+88]
  005db	88 14 01	 mov	 BYTE PTR [ecx+eax], dl
  005de	ff 4c 24 20	 dec	 DWORD PTR -56+[esp+88]
  005e2	75 dc		 jne	 SHORT $L124474

; 3535 : 				
; 3536 :             }
; 3537 :             break;

  005e4	e9 78 05 00 00	 jmp	 $L124418
$L124479:

; 3538 : 
; 3539 :         case DROP_DiagonalLine1: //  diagonal (slash)
; 3540 :             Depth = Drops[S].Depth;

  005e9	8a 56 fa	 mov	 dl, BYTE PTR [esi-6]

; 3541 :             SegSize = Drops[S].ByteD >> 1;

  005ec	33 c9		 xor	 ecx, ecx
  005ee	8a 0e		 mov	 cl, BYTE PTR [esi]
  005f0	88 54 24 13	 mov	 BYTE PTR _Depth$[esp+88], dl

; 3542 :             for( t=0; t<=SegSize; t++ )

  005f4	33 d2		 xor	 edx, edx
  005f6	89 54 24 2c	 mov	 DWORD PTR _t$[esp+88], edx
  005fa	d1 e9		 shr	 ecx, 1
  005fc	85 c9		 test	 ecx, ecx
  005fe	89 4c 24 1c	 mov	 DWORD PTR _SegSize$[esp+88], ecx
  00602	0f 8c 59 05 00
	00		 jl	 $L124418
  00608	8b 4c 24 24	 mov	 ecx, DWORD PTR _V2Mask$[esp+88]
  0060c	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00612	89 4c 24 18	 mov	 DWORD PTR -64+[esp+88], ecx
  00616	8b 4c 24 28	 mov	 ecx, DWORD PTR _U2Mask$[esp+88]
  0061a	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00620	89 4c 24 20	 mov	 DWORD PTR -56+[esp+88], ecx
  00624	89 44 24 30	 mov	 DWORD PTR -40+[esp+88], eax
$L124480:

; 3543 :             {
; 3544 :                 DWORD AddDestY = (DWORD) ( ((Ynow+t) & V2Mask) << UBits );

  00628	8b 4c 24 30	 mov	 ecx, DWORD PTR -40+[esp+88]
  0062c	8b 44 24 18	 mov	 eax, DWORD PTR -64+[esp+88]
  00630	23 c1		 and	 eax, ecx
  00632	8b 4c 24 14	 mov	 ecx, DWORD PTR _this$[esp+88]
  00636	8a 49 30	 mov	 cl, BYTE PTR [ecx+48]
  00639	d3 e0		 shl	 eax, cl

; 3545 :                 DWORD AddDestX = (DWORD) (  (Xnow-t) & U2Mask);

  0063b	8b cf		 mov	 ecx, edi
  0063d	2b ca		 sub	 ecx, edx
  0063f	23 4c 24 20	 and	 ecx, DWORD PTR -56+[esp+88]
  00643	8b 54 24 2c	 mov	 edx, DWORD PTR _t$[esp+88]

; 3546 :                 WaveFieldA[ AddDestY + AddDestX] = Depth;

  00647	03 c1		 add	 eax, ecx
  00649	8a 4c 24 13	 mov	 cl, BYTE PTR _Depth$[esp+88]
  0064d	88 0c 18	 mov	 BYTE PTR [eax+ebx], cl

; 3547 :                 WaveFieldB[ AddDestY + AddDestX] = Depth;

  00650	88 0c 28	 mov	 BYTE PTR [eax+ebp], cl
  00653	8b 4c 24 30	 mov	 ecx, DWORD PTR -40+[esp+88]
  00657	8b 44 24 1c	 mov	 eax, DWORD PTR _SegSize$[esp+88]
  0065b	42		 inc	 edx
  0065c	41		 inc	 ecx
  0065d	3b d0		 cmp	 edx, eax
  0065f	89 54 24 2c	 mov	 DWORD PTR _t$[esp+88], edx
  00663	89 4c 24 30	 mov	 DWORD PTR -40+[esp+88], ecx
  00667	7e bf		 jle	 SHORT $L124480

; 3548 :             }
; 3549 :             break;

  00669	e9 f3 04 00 00	 jmp	 $L124418
$L124487:

; 3550 : 
; 3551 : 
; 3552 :         case DROP_DiagonalLine2: //  diagonal (backslash)
; 3553 :             Depth = Drops[S].Depth;

  0066e	8a 56 fa	 mov	 dl, BYTE PTR [esi-6]

; 3554 :             SegSize = Drops[S].ByteD >> 1;

  00671	33 c9		 xor	 ecx, ecx
  00673	8a 0e		 mov	 cl, BYTE PTR [esi]
  00675	88 54 24 13	 mov	 BYTE PTR _Depth$[esp+88], dl
  00679	d1 e9		 shr	 ecx, 1

; 3555 :             for( t=0; t<=SegSize; t++ )

  0067b	85 c9		 test	 ecx, ecx
  0067d	89 4c 24 1c	 mov	 DWORD PTR _SegSize$[esp+88], ecx
  00681	0f 8c da 04 00
	00		 jl	 $L124418
  00687	8b 54 24 28	 mov	 edx, DWORD PTR _U2Mask$[esp+88]
  0068b	8b 4c 24 24	 mov	 ecx, DWORD PTR _V2Mask$[esp+88]
  0068f	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00695	89 54 24 20	 mov	 DWORD PTR -56+[esp+88], edx
  00699	8b d7		 mov	 edx, edi
  0069b	8b f8		 mov	 edi, eax
  0069d	8b 44 24 1c	 mov	 eax, DWORD PTR _SegSize$[esp+88]
  006a1	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  006a7	40		 inc	 eax
  006a8	89 4c 24 18	 mov	 DWORD PTR -64+[esp+88], ecx
  006ac	89 44 24 30	 mov	 DWORD PTR -40+[esp+88], eax
  006b0	eb 04		 jmp	 SHORT $L124488
$L134003:

; 3550 : 
; 3551 : 
; 3552 :         case DROP_DiagonalLine2: //  diagonal (backslash)
; 3553 :             Depth = Drops[S].Depth;

  006b2	8b 4c 24 18	 mov	 ecx, DWORD PTR -64+[esp+88]
$L124488:

; 3556 :             {
; 3557 :                 DWORD AddDestY = (DWORD) ( ((Ynow+t) & V2Mask) << UBits );

  006b6	8b c1		 mov	 eax, ecx
  006b8	8b 4c 24 14	 mov	 ecx, DWORD PTR _this$[esp+88]
  006bc	8a 49 30	 mov	 cl, BYTE PTR [ecx+48]
  006bf	23 c7		 and	 eax, edi
  006c1	d3 e0		 shl	 eax, cl

; 3558 :                 DWORD AddDestX = (DWORD) (  (Xnow+t) & U2Mask);

  006c3	8b 4c 24 20	 mov	 ecx, DWORD PTR -56+[esp+88]
  006c7	23 ca		 and	 ecx, edx

; 3559 :                 WaveFieldA[ AddDestY + AddDestX] = Depth;

  006c9	03 c1		 add	 eax, ecx
  006cb	8a 4c 24 13	 mov	 cl, BYTE PTR _Depth$[esp+88]
  006cf	88 0c 18	 mov	 BYTE PTR [eax+ebx], cl

; 3560 :                 WaveFieldB[ AddDestY + AddDestX] = Depth;

  006d2	88 0c 28	 mov	 BYTE PTR [eax+ebp], cl
  006d5	8b 44 24 30	 mov	 eax, DWORD PTR -40+[esp+88]
  006d9	47		 inc	 edi
  006da	42		 inc	 edx
  006db	48		 dec	 eax
  006dc	89 44 24 30	 mov	 DWORD PTR -40+[esp+88], eax
  006e0	75 d0		 jne	 SHORT $L134003

; 3561 :             }
; 3562 :             break;

  006e2	e9 7a 04 00 00	 jmp	 $L124418
$L124495:

; 3563 : 
; 3564 : 
; 3565 :         case DROP_HorizontalOsc: //  Horizontal linesegment.
; 3566 : 			{
; 3567 :        			Drops[S].Depth += Drops[S].ByteC; // update phase

  006e7	8a 4e fa	 mov	 cl, BYTE PTR [esi-6]
  006ea	8a 56 ff	 mov	 dl, BYTE PTR [esi-1]
  006ed	02 ca		 add	 cl, dl
  006ef	88 4e fa	 mov	 BYTE PTR [esi-6], cl

; 3568 : 				Depth = PhaseTable[ Drops[S].Depth ];

  006f2	33 c9		 xor	 ecx, ecx
  006f4	8a 4e fa	 mov	 cl, BYTE PTR [esi-6]

; 3569 : 				SegSize = Drops[S].ByteD >> 1;

  006f7	33 d2		 xor	 edx, edx
  006f9	8a 16		 mov	 dl, BYTE PTR [esi]
  006fb	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00701	8a 89 00 00 00
	00		 mov	 cl, BYTE PTR _PhaseTable[ecx]
  00707	88 4c 24 13	 mov	 BYTE PTR _Depth$[esp+88], cl

; 3570 : 				DWORD DropDestX0 = (DWORD)  ( Ynow << UBits ); 

  0070b	8b 4c 24 14	 mov	 ecx, DWORD PTR _this$[esp+88]
  0070f	8a 49 30	 mov	 cl, BYTE PTR [ecx+48]
  00712	d1 ea		 shr	 edx, 1
  00714	d3 e0		 shl	 eax, cl

; 3571 : 				for( t=0; t<=SegSize; t++ )

  00716	85 d2		 test	 edx, edx
  00718	0f 8c 43 04 00
	00		 jl	 $L124418
  0071e	8b 4c 24 28	 mov	 ecx, DWORD PTR _U2Mask$[esp+88]
  00722	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00728	89 4c 24 20	 mov	 DWORD PTR -56+[esp+88], ecx
  0072c	8d 0c 18	 lea	 ecx, DWORD PTR [eax+ebx]
  0072f	03 c5		 add	 eax, ebp
  00731	42		 inc	 edx
  00732	89 4c 24 40	 mov	 DWORD PTR -24+[esp+88], ecx
  00736	89 44 24 3c	 mov	 DWORD PTR -28+[esp+88], eax
  0073a	89 54 24 30	 mov	 DWORD PTR -40+[esp+88], edx

; 3681 : 				}
; 3682 : 			}
; 3683 :             break;
; 3684 :       
; 3685 :         } //switch
; 3686 : 
; 3687 :     }
; 3688 : }

  0073e	8b ff		 npad	 2

; 3571 : 				for( t=0; t<=SegSize; t++ )

$L124498:

; 3572 : 				{
; 3573 : 					DWORD AddDestX = (DWORD) ((t+Xnow) & U2Mask);

  00740	8b 44 24 20	 mov	 eax, DWORD PTR -56+[esp+88]

; 3574 : 					WaveFieldA[ DropDestX0 + AddDestX ] = Depth;

  00744	8a 4c 24 13	 mov	 cl, BYTE PTR _Depth$[esp+88]
  00748	8b 54 24 40	 mov	 edx, DWORD PTR -24+[esp+88]
  0074c	23 c7		 and	 eax, edi
  0074e	88 0c 02	 mov	 BYTE PTR [edx+eax], cl

; 3575 : 					WaveFieldB[ DropDestX0 + AddDestX ] = Depth;

  00751	8b 54 24 3c	 mov	 edx, DWORD PTR -28+[esp+88]
  00755	88 0c 02	 mov	 BYTE PTR [edx+eax], cl
  00758	8b 44 24 30	 mov	 eax, DWORD PTR -40+[esp+88]
  0075c	47		 inc	 edi
  0075d	48		 dec	 eax
  0075e	89 44 24 30	 mov	 DWORD PTR -40+[esp+88], eax
  00762	75 dc		 jne	 SHORT $L124498

; 3576 : 				}
; 3577 : 			}
; 3578 :             break;

  00764	e9 f8 03 00 00	 jmp	 $L124418
$L124503:

; 3579 : 
; 3580 : 
; 3581 :         case DROP_VerticalOsc: //  Vertical linesegment.
; 3582 :        	    Drops[S].Depth += Drops[S].ByteC; // update phase

  00769	8a 4e ff	 mov	 cl, BYTE PTR [esi-1]
  0076c	8a 56 fa	 mov	 dl, BYTE PTR [esi-6]
  0076f	02 d1		 add	 dl, cl

; 3583 :             Depth = PhaseTable[ Drops[S].Depth ];

  00771	33 c9		 xor	 ecx, ecx
  00773	8a ca		 mov	 cl, dl
  00775	88 56 fa	 mov	 BYTE PTR [esi-6], dl
  00778	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0077e	8a 91 00 00 00
	00		 mov	 dl, BYTE PTR _PhaseTable[ecx]

; 3584 :             SegSize = Drops[S].ByteD >> 1;

  00784	33 c9		 xor	 ecx, ecx
  00786	8a 0e		 mov	 cl, BYTE PTR [esi]
  00788	88 54 24 13	 mov	 BYTE PTR _Depth$[esp+88], dl
  0078c	d1 e9		 shr	 ecx, 1

; 3585 :             for( t=0; t<=SegSize; t++ )

  0078e	85 c9		 test	 ecx, ecx
  00790	0f 8c cb 03 00
	00		 jl	 $L124418
  00796	8b 54 24 24	 mov	 edx, DWORD PTR _V2Mask$[esp+88]
  0079a	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  007a0	89 54 24 18	 mov	 DWORD PTR -64+[esp+88], edx
  007a4	8d 14 1f	 lea	 edx, DWORD PTR [edi+ebx]
  007a7	03 fd		 add	 edi, ebp
  007a9	41		 inc	 ecx
  007aa	89 54 24 30	 mov	 DWORD PTR -40+[esp+88], edx
  007ae	8a 54 24 13	 mov	 dl, BYTE PTR _Depth$[esp+88]
  007b2	89 7c 24 2c	 mov	 DWORD PTR -44+[esp+88], edi
  007b6	8b f8		 mov	 edi, eax
  007b8	89 4c 24 20	 mov	 DWORD PTR -56+[esp+88], ecx

; 3681 : 				}
; 3682 : 			}
; 3683 :             break;
; 3684 :       
; 3685 :         } //switch
; 3686 : 
; 3687 :     }
; 3688 : }

  007bc	8d 64 24 00	 npad	 4

; 3585 :             for( t=0; t<=SegSize; t++ )

$L124504:

; 3586 :             {
; 3587 :                 DWORD AddDestY = (DWORD) ( ((Ynow+t)& V2Mask) << UBits );

  007c0	8b 4c 24 14	 mov	 ecx, DWORD PTR _this$[esp+88]
  007c4	8a 49 30	 mov	 cl, BYTE PTR [ecx+48]
  007c7	8b 44 24 18	 mov	 eax, DWORD PTR -64+[esp+88]
  007cb	23 c7		 and	 eax, edi
  007cd	d3 e0		 shl	 eax, cl

; 3588 :                 WaveFieldA[Xnow + AddDestY] = Depth;

  007cf	8b 4c 24 30	 mov	 ecx, DWORD PTR -40+[esp+88]
  007d3	47		 inc	 edi
  007d4	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 3589 :                 WaveFieldB[Xnow + AddDestY] = Depth;

  007d7	8b 4c 24 2c	 mov	 ecx, DWORD PTR -44+[esp+88]
  007db	88 14 01	 mov	 BYTE PTR [ecx+eax], dl
  007de	ff 4c 24 20	 dec	 DWORD PTR -56+[esp+88]
  007e2	75 dc		 jne	 SHORT $L124504

; 3590 :             }
; 3591 :             break;

  007e4	e9 78 03 00 00	 jmp	 $L124418
$L124509:

; 3592 : 
; 3593 : 
; 3594 :         case DROP_DiagonalOsc1: //  diagonal (slash)
; 3595 :        	    Drops[S].Depth += Drops[S].ByteC; // update phase

  007e9	8a 4e fa	 mov	 cl, BYTE PTR [esi-6]
  007ec	8a 56 ff	 mov	 dl, BYTE PTR [esi-1]
  007ef	02 ca		 add	 cl, dl
  007f1	88 4e fa	 mov	 BYTE PTR [esi-6], cl

; 3596 :             Depth = PhaseTable[ Drops[S].Depth ];

  007f4	33 c9		 xor	 ecx, ecx
  007f6	8a 4e fa	 mov	 cl, BYTE PTR [esi-6]

; 3597 :             SegSize = Drops[S].ByteD >> 1;
; 3598 :             for( t=0; t<=SegSize; t++ )

  007f9	33 d2		 xor	 edx, edx
  007fb	89 54 24 2c	 mov	 DWORD PTR _t$[esp+88], edx
  007ff	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00805	8a 89 00 00 00
	00		 mov	 cl, BYTE PTR _PhaseTable[ecx]
  0080b	88 4c 24 13	 mov	 BYTE PTR _Depth$[esp+88], cl
  0080f	33 c9		 xor	 ecx, ecx
  00811	8a 0e		 mov	 cl, BYTE PTR [esi]
  00813	d1 e9		 shr	 ecx, 1
  00815	85 c9		 test	 ecx, ecx
  00817	89 4c 24 1c	 mov	 DWORD PTR _SegSize$[esp+88], ecx
  0081b	0f 8c 40 03 00
	00		 jl	 $L124418
  00821	8b 4c 24 24	 mov	 ecx, DWORD PTR _V2Mask$[esp+88]
  00825	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0082b	89 4c 24 18	 mov	 DWORD PTR -64+[esp+88], ecx
  0082f	8b 4c 24 28	 mov	 ecx, DWORD PTR _U2Mask$[esp+88]
  00833	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00839	89 4c 24 20	 mov	 DWORD PTR -56+[esp+88], ecx
  0083d	89 44 24 30	 mov	 DWORD PTR -40+[esp+88], eax
$L124510:

; 3599 :             {
; 3600 :                 DWORD AddDestY = (DWORD) ( ((Ynow+t) & V2Mask) << UBits );

  00841	8b 4c 24 30	 mov	 ecx, DWORD PTR -40+[esp+88]
  00845	8b 44 24 18	 mov	 eax, DWORD PTR -64+[esp+88]
  00849	23 c1		 and	 eax, ecx
  0084b	8b 4c 24 14	 mov	 ecx, DWORD PTR _this$[esp+88]
  0084f	8a 49 30	 mov	 cl, BYTE PTR [ecx+48]
  00852	d3 e0		 shl	 eax, cl

; 3601 :                 DWORD AddDestX = (DWORD) (  (Xnow-t) & U2Mask);

  00854	8b cf		 mov	 ecx, edi
  00856	2b ca		 sub	 ecx, edx
  00858	23 4c 24 20	 and	 ecx, DWORD PTR -56+[esp+88]
  0085c	8b 54 24 2c	 mov	 edx, DWORD PTR _t$[esp+88]

; 3602 :                 WaveFieldA[ AddDestY + AddDestX] = Depth;

  00860	03 c1		 add	 eax, ecx
  00862	8a 4c 24 13	 mov	 cl, BYTE PTR _Depth$[esp+88]
  00866	88 0c 18	 mov	 BYTE PTR [eax+ebx], cl

; 3603 :                 WaveFieldB[ AddDestY + AddDestX] = Depth;

  00869	88 0c 28	 mov	 BYTE PTR [eax+ebp], cl
  0086c	8b 4c 24 30	 mov	 ecx, DWORD PTR -40+[esp+88]
  00870	8b 44 24 1c	 mov	 eax, DWORD PTR _SegSize$[esp+88]
  00874	42		 inc	 edx
  00875	41		 inc	 ecx
  00876	3b d0		 cmp	 edx, eax
  00878	89 54 24 2c	 mov	 DWORD PTR _t$[esp+88], edx
  0087c	89 4c 24 30	 mov	 DWORD PTR -40+[esp+88], ecx
  00880	7e bf		 jle	 SHORT $L124510

; 3604 :             }
; 3605 :             break;

  00882	e9 da 02 00 00	 jmp	 $L124418
$L124517:

; 3606 : 
; 3607 : 
; 3608 :         case DROP_DiagonalOsc2: //  diagonal (backslash)
; 3609 :        	    Drops[S].Depth += Drops[S].ByteC; // update phase

  00887	8a 4e fa	 mov	 cl, BYTE PTR [esi-6]
  0088a	8a 56 ff	 mov	 dl, BYTE PTR [esi-1]
  0088d	02 ca		 add	 cl, dl
  0088f	88 4e fa	 mov	 BYTE PTR [esi-6], cl

; 3610 :             Depth = PhaseTable[ Drops[S].Depth ];

  00892	33 c9		 xor	 ecx, ecx
  00894	8a 4e fa	 mov	 cl, BYTE PTR [esi-6]
  00897	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0089d	8a 89 00 00 00
	00		 mov	 cl, BYTE PTR _PhaseTable[ecx]
  008a3	88 4c 24 13	 mov	 BYTE PTR _Depth$[esp+88], cl

; 3611 :             SegSize = Drops[S].ByteD >> 1;

  008a7	33 c9		 xor	 ecx, ecx
  008a9	8a 0e		 mov	 cl, BYTE PTR [esi]
  008ab	d1 e9		 shr	 ecx, 1

; 3612 :             for( t=0; t<=SegSize; t++ )

  008ad	85 c9		 test	 ecx, ecx
  008af	89 4c 24 1c	 mov	 DWORD PTR _SegSize$[esp+88], ecx
  008b3	0f 8c a8 02 00
	00		 jl	 $L124418
  008b9	8b 54 24 28	 mov	 edx, DWORD PTR _U2Mask$[esp+88]
  008bd	8b 4c 24 24	 mov	 ecx, DWORD PTR _V2Mask$[esp+88]
  008c1	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  008c7	89 54 24 20	 mov	 DWORD PTR -56+[esp+88], edx
  008cb	8b d7		 mov	 edx, edi
  008cd	8b f8		 mov	 edi, eax
  008cf	8b 44 24 1c	 mov	 eax, DWORD PTR _SegSize$[esp+88]
  008d3	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  008d9	40		 inc	 eax
  008da	89 4c 24 18	 mov	 DWORD PTR -64+[esp+88], ecx
  008de	89 44 24 30	 mov	 DWORD PTR -40+[esp+88], eax
  008e2	eb 04		 jmp	 SHORT $L124518
$L134002:

; 3606 : 
; 3607 : 
; 3608 :         case DROP_DiagonalOsc2: //  diagonal (backslash)
; 3609 :        	    Drops[S].Depth += Drops[S].ByteC; // update phase

  008e4	8b 4c 24 18	 mov	 ecx, DWORD PTR -64+[esp+88]
$L124518:

; 3613 :             {
; 3614 :                 DWORD AddDestY = (DWORD) ( ((Ynow+t) & V2Mask) << UBits );

  008e8	8b c1		 mov	 eax, ecx
  008ea	8b 4c 24 14	 mov	 ecx, DWORD PTR _this$[esp+88]
  008ee	8a 49 30	 mov	 cl, BYTE PTR [ecx+48]
  008f1	23 c7		 and	 eax, edi
  008f3	d3 e0		 shl	 eax, cl

; 3615 :                 DWORD AddDestX = (DWORD) (  (Xnow+t) & U2Mask);

  008f5	8b 4c 24 20	 mov	 ecx, DWORD PTR -56+[esp+88]
  008f9	23 ca		 and	 ecx, edx

; 3616 :                 WaveFieldA[ AddDestY + AddDestX] = Depth;

  008fb	03 c1		 add	 eax, ecx
  008fd	8a 4c 24 13	 mov	 cl, BYTE PTR _Depth$[esp+88]
  00901	88 0c 18	 mov	 BYTE PTR [eax+ebx], cl

; 3617 :                 WaveFieldB[ AddDestY + AddDestX] = Depth;

  00904	88 0c 28	 mov	 BYTE PTR [eax+ebp], cl
  00907	8b 44 24 30	 mov	 eax, DWORD PTR -40+[esp+88]
  0090b	47		 inc	 edi
  0090c	42		 inc	 edx
  0090d	48		 dec	 eax
  0090e	89 44 24 30	 mov	 DWORD PTR -40+[esp+88], eax
  00912	75 d0		 jne	 SHORT $L134002

; 3618 :             }
; 3619 :             break;

  00914	e9 48 02 00 00	 jmp	 $L124418
$L124525:

; 3620 : 
; 3621 :         
; 3622 : 		case DROP_AreaClamp: // Fixed-depth/adaptive-depth rect areas.
; 3623 : 			{
; 3624 : 				Depth   = Drops[S].Depth;

  00919	8a 56 fa	 mov	 dl, BYTE PTR [esi-6]

; 3625 : 				SegSize = Drops[S].ByteD >> 1;

  0091c	33 c9		 xor	 ecx, ecx
  0091e	8a 0e		 mov	 cl, BYTE PTR [esi]
  00920	88 54 24 13	 mov	 BYTE PTR _Depth$[esp+88], dl
  00924	d1 e9		 shr	 ecx, 1

; 3626 : 
; 3627 : 				DWORD DestY = (DWORD) ( ((Ynow) & V2Mask) << UBits );
; 3628 : 
; 3629 : 				for( INT v=0; v<SegSize; v++ )

  00926	85 c9		 test	 ecx, ecx
  00928	89 4c 24 1c	 mov	 DWORD PTR _SegSize$[esp+88], ecx
  0092c	0f 8e 2f 02 00
	00		 jle	 $L124418
  00932	8b 54 24 28	 mov	 edx, DWORD PTR _U2Mask$[esp+88]
  00936	8b 4c 24 24	 mov	 ecx, DWORD PTR _V2Mask$[esp+88]
  0093a	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00940	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00946	89 54 24 20	 mov	 DWORD PTR -56+[esp+88], edx
  0094a	89 44 24 30	 mov	 DWORD PTR -40+[esp+88], eax
  0094e	8b 44 24 1c	 mov	 eax, DWORD PTR _SegSize$[esp+88]
  00952	23 d7		 and	 edx, edi
  00954	89 4c 24 18	 mov	 DWORD PTR -64+[esp+88], ecx
  00958	89 54 24 48	 mov	 DWORD PTR -16+[esp+88], edx
  0095c	89 44 24 40	 mov	 DWORD PTR -24+[esp+88], eax
  00960	eb 0e		 jmp	 SHORT $L124529
$L134001:

; 3620 : 
; 3621 :         
; 3622 : 		case DROP_AreaClamp: // Fixed-depth/adaptive-depth rect areas.
; 3623 : 			{
; 3624 : 				Depth   = Drops[S].Depth;

  00962	8b 54 24 48	 mov	 edx, DWORD PTR -16+[esp+88]
  00966	8b 4c 24 18	 mov	 ecx, DWORD PTR -64+[esp+88]

; 3681 : 				}
; 3682 : 			}
; 3683 :             break;
; 3684 :       
; 3685 :         } //switch
; 3686 : 
; 3687 :     }
; 3688 : }

  0096a	8d 9b 00 00 00
	00		 npad	 6

; 3620 : 
; 3621 :         
; 3622 : 		case DROP_AreaClamp: // Fixed-depth/adaptive-depth rect areas.
; 3623 : 			{
; 3624 : 				Depth   = Drops[S].Depth;

$L124529:

; 3630 : 				{
; 3631 : 					DestY = (DWORD) ( (( Ynow+v ) & V2Mask) << UBits );

  00970	8b c1		 mov	 eax, ecx
  00972	23 44 24 30	 and	 eax, DWORD PTR -40+[esp+88]
  00976	8b 4c 24 14	 mov	 ecx, DWORD PTR _this$[esp+88]
  0097a	8a 49 30	 mov	 cl, BYTE PTR [ecx+48]
  0097d	d3 e0		 shl	 eax, cl

; 3632 : 					DWORD Dest  = DestY + ( Xnow & U2Mask );

  0097f	8d 0c 02	 lea	 ecx, DWORD PTR [edx+eax]

; 3633 : 
; 3634 :   					for( INT u = 1; u<=SegSize; u++ )

  00982	83 7c 24 1c 01	 cmp	 DWORD PTR _SegSize$[esp+88], 1
  00987	7c 30		 jl	 SHORT $L124530
  00989	8d 57 01	 lea	 edx, DWORD PTR [edi+1]
  0098c	89 54 24 2c	 mov	 DWORD PTR -44+[esp+88], edx
  00990	8b 54 24 1c	 mov	 edx, DWORD PTR _SegSize$[esp+88]
  00994	89 54 24 3c	 mov	 DWORD PTR -28+[esp+88], edx
$L124535:

; 3635 : 					{
; 3636 : 						WaveFieldA[ Dest] = Depth;

  00998	8a 54 24 13	 mov	 dl, BYTE PTR _Depth$[esp+88]
  0099c	88 14 19	 mov	 BYTE PTR [ecx+ebx], dl

; 3637 : 						WaveFieldB[ Dest] = Depth;

  0099f	88 14 29	 mov	 BYTE PTR [ecx+ebp], dl

; 3638 : 						Dest = DestY + ((DWORD) (u+Xnow) & U2Mask);

  009a2	8b 54 24 2c	 mov	 edx, DWORD PTR -44+[esp+88]
  009a6	8b 4c 24 20	 mov	 ecx, DWORD PTR -56+[esp+88]
  009aa	23 ca		 and	 ecx, edx
  009ac	03 c8		 add	 ecx, eax
  009ae	42		 inc	 edx
  009af	89 54 24 2c	 mov	 DWORD PTR -44+[esp+88], edx
  009b3	ff 4c 24 3c	 dec	 DWORD PTR -28+[esp+88]
  009b7	75 df		 jne	 SHORT $L124535
$L124530:

; 3626 : 
; 3627 : 				DWORD DestY = (DWORD) ( ((Ynow) & V2Mask) << UBits );
; 3628 : 
; 3629 : 				for( INT v=0; v<SegSize; v++ )

  009b9	8b 4c 24 30	 mov	 ecx, DWORD PTR -40+[esp+88]
  009bd	8b 44 24 40	 mov	 eax, DWORD PTR -24+[esp+88]
  009c1	41		 inc	 ecx
  009c2	48		 dec	 eax
  009c3	89 4c 24 30	 mov	 DWORD PTR -40+[esp+88], ecx
  009c7	89 44 24 40	 mov	 DWORD PTR -24+[esp+88], eax
  009cb	75 95		 jne	 SHORT $L134001

; 3639 : 					}
; 3640 : 				}
; 3641 : 			}
; 3642 : 			break; 

  009cd	e9 8f 01 00 00	 jmp	 $L124418
$L124539:

; 3643 :        
; 3644 : 
; 3645 : 		case DROP_RainDrops: //  Rain drizzle.
; 3646 : 			{
; 3647 : 				// Keep the action sparse - just draw more sparks if needed...
; 3648 : 				if( (SpeedRand()&15)==0 )

  009d2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  009d8	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  009de	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  009e4	83 c2 04	 add	 edx, 4
  009e7	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  009ed	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  009f3	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  009f9	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  009ff	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  00a05	a8 0f		 test	 al, 15			; 0000000fH
  00a07	0f 85 54 01 00
	00		 jne	 $L124418

; 3649 : 				{
; 3650 : 					Depth = Drops[S].Depth;

  00a0d	8a 46 fa	 mov	 al, BYTE PTR [esi-6]

; 3651 : 					BYTE  Spray = Drops[S].ByteD;

  00a10	8a 0e		 mov	 cl, BYTE PTR [esi]
  00a12	88 44 24 13	 mov	 BYTE PTR _Depth$[esp+88], al
  00a16	88 4c 24 4c	 mov	 BYTE PTR _Spray$124541[esp+88], cl

; 3652 : 					DWORD  AddDestY = (DWORD) (((Ynow+(SpeedRand()*Spray >> 8) ) & V2Mask) << UBits );

  00a1a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  00a20	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  00a26	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00a2c	83 c2 04	 add	 edx, 4
  00a2f	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  00a35	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  00a3b	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  00a41	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  00a47	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  00a4d	8b 4c 24 4c	 mov	 ecx, DWORD PTR _Spray$124541[esp+88]
  00a51	8b 54 24 48	 mov	 edx, DWORD PTR -16+[esp+88]
  00a55	88 44 24 50	 mov	 BYTE PTR $T133962[esp+88], al
  00a59	8b 44 24 50	 mov	 eax, DWORD PTR $T133962[esp+88]
  00a5d	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00a62	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00a68	0f af c1	 imul	 eax, ecx
  00a6b	c1 f8 08	 sar	 eax, 8
  00a6e	03 c2		 add	 eax, edx
  00a70	8b 54 24 24	 mov	 edx, DWORD PTR _V2Mask$[esp+88]
  00a74	89 4c 24 40	 mov	 DWORD PTR -24+[esp+88], ecx
  00a78	8b 4c 24 14	 mov	 ecx, DWORD PTR _this$[esp+88]
  00a7c	8a 49 30	 mov	 cl, BYTE PTR [ecx+48]
  00a7f	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00a85	23 c2		 and	 eax, edx
  00a87	d3 e0		 shl	 eax, cl
  00a89	89 44 24 48	 mov	 DWORD PTR _AddDestY$124542[esp+88], eax

; 3653 : 					DWORD  AddDestX = (DWORD)  ((Xnow+(SpeedRand()*Spray >> 8) ) & U2Mask);

  00a8d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  00a93	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  00a99	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00a9f	83 c2 04	 add	 edx, 4
  00aa2	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  00aa8	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  00aae	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  00ab4	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  00aba	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  00ac0	8b 54 24 28	 mov	 edx, DWORD PTR _U2Mask$[esp+88]

; 3654 : 					WaveFieldA[ AddDestY + AddDestX] = Depth;

  00ac4	8b 4c 24 48	 mov	 ecx, DWORD PTR _AddDestY$124542[esp+88]
  00ac8	88 44 24 54	 mov	 BYTE PTR $T133966[esp+88], al
  00acc	8b 44 24 54	 mov	 eax, DWORD PTR $T133966[esp+88]
  00ad0	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00ad5	0f af 44 24 40	 imul	 eax, DWORD PTR -24+[esp+88]
  00ada	c1 f8 08	 sar	 eax, 8
  00add	03 c7		 add	 eax, edi
  00adf	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00ae5	23 c2		 and	 eax, edx
  00ae7	03 c8		 add	 ecx, eax
  00ae9	8a 44 24 13	 mov	 al, BYTE PTR _Depth$[esp+88]
  00aed	88 04 19	 mov	 BYTE PTR [ecx+ebx], al

; 3655 : 					WaveFieldB[ AddDestY + AddDestX] = 255^Depth;

  00af0	f6 d0		 not	 al
  00af2	88 04 29	 mov	 BYTE PTR [ecx+ebp], al

; 3656 : 				}
; 3657 : 			}
; 3658 :             break;

  00af5	eb 6a		 jmp	 SHORT $L124418
$L124546:

; 3659 : 
; 3660 : 
; 3661 : 		case DROP_LeakyTap: // Selfexplanatory.
; 3662 : 			{
; 3663 : 				// Keep the action sparse - just draw more sparks if needed...
; 3664 : 				if( (Drops[S].ByteA +=Drops[S].ByteD) <= Drops[S].ByteD ) 

  00af7	8a 06		 mov	 al, BYTE PTR [esi]
  00af9	8a 56 fd	 mov	 dl, BYTE PTR [esi-3]
  00afc	02 d0		 add	 dl, al
  00afe	8a ca		 mov	 cl, dl
  00b00	3a c8		 cmp	 cl, al
  00b02	88 56 fd	 mov	 BYTE PTR [esi-3], dl
  00b05	77 5a		 ja	 SHORT $L124418

; 3665 : 				{
; 3666 : 					WaveFieldA[ DropDest ]  =  Drops[S].Depth;
; 3667 : 					WaveFieldB[ DropDest ]  =  255^Drops[S].Depth;
; 3668 : 				}
; 3669 : 			}
; 3670 :             break;

  00b07	eb 46		 jmp	 SHORT $L134008
$L124548:

; 3671 : 
; 3672 : 			
; 3673 : 		case DROP_DrippyTap: // Irregular Leaky Tap.
; 3674 : 			{
; 3675 : 				// Keep the action sparse - just draw more sparks if needed...
; 3676 : 				if( (Drops[S].ByteA +=Drops[S].ByteD) <= Drops[S].ByteD ) 

  00b09	8a 06		 mov	 al, BYTE PTR [esi]
  00b0b	8a 56 fd	 mov	 dl, BYTE PTR [esi-3]
  00b0e	02 d0		 add	 dl, al
  00b10	8a ca		 mov	 cl, dl
  00b12	3a c8		 cmp	 cl, al
  00b14	88 56 fd	 mov	 BYTE PTR [esi-3], dl
  00b17	77 48		 ja	 SHORT $L124418

; 3677 : 				{ 
; 3678 : 					Drops[S].ByteA = SpeedRand();

  00b19	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  00b1f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  00b25	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00b2b	83 c2 04	 add	 edx, 4
  00b2e	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  00b34	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  00b3a	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  00b40	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  00b46	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  00b4c	88 46 fd	 mov	 BYTE PTR [esi-3], al
$L134008:

; 3679 : 					WaveFieldA[ DropDest ]  =  Drops[S].Depth;

  00b4f	8a 56 fa	 mov	 dl, BYTE PTR [esi-6]
  00b52	8b 44 24 20	 mov	 eax, DWORD PTR _DropDest$124422[esp+88]
  00b56	88 14 18	 mov	 BYTE PTR [eax+ebx], dl

; 3680 : 					WaveFieldB[ DropDest ]  =  255^Drops[S].Depth;

  00b59	8a 4e fa	 mov	 cl, BYTE PTR [esi-6]
  00b5c	f6 d1		 not	 cl
  00b5e	88 0c 28	 mov	 BYTE PTR [eax+ebp], cl
$L124418:
  00b61	8b 44 24 44	 mov	 eax, DWORD PTR _S$[esp+88]
  00b65	8b 54 24 14	 mov	 edx, DWORD PTR _this$[esp+88]
  00b69	8b 8a ec 00 00
	00		 mov	 ecx, DWORD PTR [edx+236]
  00b6f	40		 inc	 eax
  00b70	83 c6 08	 add	 esi, 8
  00b73	3b c1		 cmp	 eax, ecx
  00b75	89 44 24 44	 mov	 DWORD PTR _S$[esp+88], eax
  00b79	0f 8c e1 f4 ff
	ff		 jl	 $L133994
  00b7f	5f		 pop	 edi
  00b80	5e		 pop	 esi
$L124419:
  00b81	5d		 pop	 ebp
  00b82	5b		 pop	 ebx

; 3681 : 				}
; 3682 : 			}
; 3683 :             break;
; 3684 :       
; 3685 :         } //switch
; 3686 : 
; 3687 :     }
; 3688 : }

  00b83	83 c4 48	 add	 esp, 72			; 00000048H
  00b86	c3		 ret	 0
  00b87	90		 npad	 1
$L134009:
  00b88	00 00 00 00	 DD	 $L124428
  00b8c	00 00 00 00	 DD	 $L124429
  00b90	00 00 00 00	 DD	 $L124432
  00b94	00 00 00 00	 DD	 $L124430
  00b98	00 00 00 00	 DD	 $L124433
  00b9c	00 00 00 00	 DD	 $L124434
  00ba0	00 00 00 00	 DD	 $L124435
  00ba4	00 00 00 00	 DD	 $L124451
  00ba8	00 00 00 00	 DD	 $L124465
  00bac	00 00 00 00	 DD	 $L124473
  00bb0	00 00 00 00	 DD	 $L124479
  00bb4	00 00 00 00	 DD	 $L124487
  00bb8	00 00 00 00	 DD	 $L124495
  00bbc	00 00 00 00	 DD	 $L124503
  00bc0	00 00 00 00	 DD	 $L124509
  00bc4	00 00 00 00	 DD	 $L124517
  00bc8	00 00 00 00	 DD	 $L124539
  00bcc	00 00 00 00	 DD	 $L124525
  00bd0	00 00 00 00	 DD	 $L124546
  00bd4	00 00 00 00	 DD	 $L124548
  00bd8	00 00 00 00	 DD	 $L124443
  00bdc	00 00 00 00	 DD	 $L124457
  00be0	00 00 00 00	 DD	 $L124418
$L133993:
  00be4	00		 DB	 0
  00be5	01		 DB	 1
  00be6	02		 DB	 2
  00be7	03		 DB	 3
  00be8	04		 DB	 4
  00be9	05		 DB	 5
  00bea	06		 DB	 6
  00beb	07		 DB	 7
  00bec	08		 DB	 8
  00bed	09		 DB	 9
  00bee	0a		 DB	 10			; 0000000aH
  00bef	0b		 DB	 11			; 0000000bH
  00bf0	0c		 DB	 12			; 0000000cH
  00bf1	0d		 DB	 13			; 0000000dH
  00bf2	0e		 DB	 14			; 0000000eH
  00bf3	0f		 DB	 15			; 0000000fH
  00bf4	10		 DB	 16			; 00000010H
  00bf5	11		 DB	 17			; 00000011H
  00bf6	12		 DB	 18			; 00000012H
  00bf7	13		 DB	 19			; 00000013H
  00bf8	16		 DB	 22			; 00000016H
  00bf9	16		 DB	 22			; 00000016H
  00bfa	16		 DB	 22			; 00000016H
  00bfb	16		 DB	 22			; 00000016H
  00bfc	16		 DB	 22			; 00000016H
  00bfd	16		 DB	 22			; 00000016H
  00bfe	16		 DB	 22			; 00000016H
  00bff	16		 DB	 22			; 00000016H
  00c00	16		 DB	 22			; 00000016H
  00c01	16		 DB	 22			; 00000016H
  00c02	16		 DB	 22			; 00000016H
  00c03	16		 DB	 22			; 00000016H
  00c04	16		 DB	 22			; 00000016H
  00c05	16		 DB	 22			; 00000016H
  00c06	16		 DB	 22			; 00000016H
  00c07	16		 DB	 22			; 00000016H
  00c08	16		 DB	 22			; 00000016H
  00c09	16		 DB	 22			; 00000016H
  00c0a	16		 DB	 22			; 00000016H
  00c0b	16		 DB	 22			; 00000016H
  00c0c	16		 DB	 22			; 00000016H
  00c0d	16		 DB	 22			; 00000016H
  00c0e	16		 DB	 22			; 00000016H
  00c0f	16		 DB	 22			; 00000016H
  00c10	16		 DB	 22			; 00000016H
  00c11	16		 DB	 22			; 00000016H
  00c12	16		 DB	 22			; 00000016H
  00c13	16		 DB	 22			; 00000016H
  00c14	16		 DB	 22			; 00000016H
  00c15	16		 DB	 22			; 00000016H
  00c16	16		 DB	 22			; 00000016H
  00c17	16		 DB	 22			; 00000016H
  00c18	16		 DB	 22			; 00000016H
  00c19	16		 DB	 22			; 00000016H
  00c1a	16		 DB	 22			; 00000016H
  00c1b	16		 DB	 22			; 00000016H
  00c1c	16		 DB	 22			; 00000016H
  00c1d	16		 DB	 22			; 00000016H
  00c1e	16		 DB	 22			; 00000016H
  00c1f	16		 DB	 22			; 00000016H
  00c20	16		 DB	 22			; 00000016H
  00c21	16		 DB	 22			; 00000016H
  00c22	16		 DB	 22			; 00000016H
  00c23	16		 DB	 22			; 00000016H
  00c24	14		 DB	 20			; 00000014H
  00c25	15		 DB	 21			; 00000015H
?WaterRedrawDrops@UWaterTexture@@QAEXXZ ENDP		; UWaterTexture::WaterRedrawDrops
_TEXT	ENDS
PUBLIC	??2@YAPAXI@Z					; operator new
PUBLIC	??_C@_17JBDG@?$AAn?$AAe?$AAw?$AA?$AA@		; `string'
EXTRN	__imp_?GMalloc@@3PAVFMalloc@@A:DWORD
;	COMDAT ??_C@_17JBDG@?$AAn?$AAe?$AAw?$AA?$AA@
; File ..\..\Core\Inc\UnFile.h
_DATA	SEGMENT
??_C@_17JBDG@?$AAn?$AAe?$AAw?$AA?$AA@ DB 'n', 00H, 'e', 00H, 'w', 00H, 00H
	DB	00H						; `string'
; Function compile flags: /Ogty
_DATA	ENDS
;	COMDAT ??2@YAPAXI@Z
_TEXT	SEGMENT
_Size$ = 8
??2@YAPAXI@Z PROC NEAR					; operator new, COMDAT

; 624  : 	return appMalloc( Size, TEXT("new") );

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?GMalloc@@3PAVFMalloc@@A
  00005	8b 08		 mov	 ecx, DWORD PTR [eax]
  00007	8b 44 24 04	 mov	 eax, DWORD PTR _Size$[esp-4]
  0000b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_17JBDG@?$AAn?$AAe?$AAw?$AA?$AA@ ; `string'
  00012	50		 push	 eax
  00013	ff 12		 call	 DWORD PTR [edx]

; 625  : }

  00015	c3		 ret	 0
??2@YAPAXI@Z ENDP					; operator new
_TEXT	ENDS
PUBLIC	??3@YAXPAX@Z					; operator delete
; Function compile flags: /Ogty
;	COMDAT ??3@YAXPAX@Z
_TEXT	SEGMENT
_Ptr$ = 8
??3@YAXPAX@Z PROC NEAR					; operator delete, COMDAT

; 628  : 	appFree( Ptr );

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?GMalloc@@3PAVFMalloc@@A
  00005	8b 08		 mov	 ecx, DWORD PTR [eax]
  00007	8b 44 24 04	 mov	 eax, DWORD PTR _Ptr$[esp-4]
  0000b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000d	50		 push	 eax
  0000e	ff 52 08	 call	 DWORD PTR [edx+8]

; 629  : }

  00011	c3		 ret	 0
??3@YAXPAX@Z ENDP					; operator delete
_TEXT	ENDS
PUBLIC	?AddDrop@UWaterTexture@@AAEXHH@Z		; UWaterTexture::AddDrop
; Function compile flags: /Ogty
; File C:\duke4\Fire\Src\UnFractal.cpp
;	COMDAT ?AddDrop@UWaterTexture@@AAEXHH@Z
_TEXT	SEGMENT
_DropX$ = 8
_DropY$ = 12
?AddDrop@UWaterTexture@@AAEXHH@Z PROC NEAR		; UWaterTexture::AddDrop, COMDAT
; _this$ = ecx

; 3697 : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 3698 :     // Return if out of bounds or out of Drops.
; 3699 :     if( DropX>=USize || DropY>=VSize || DropX<0 || DropY<0 || NumDrops>=MaxDrops )

  00003	8b 4c 24 08	 mov	 ecx, DWORD PTR _DropX$[esp]
  00007	3b 4e 34	 cmp	 ecx, DWORD PTR [esi+52]
  0000a	57		 push	 edi
  0000b	0f 8d a1 02 00
	00		 jge	 $L124559
  00011	8b 44 24 10	 mov	 eax, DWORD PTR _DropY$[esp+4]
  00015	3b 46 38	 cmp	 eax, DWORD PTR [esi+56]
  00018	0f 8d 94 02 00
	00		 jge	 $L124559
  0001e	33 d2		 xor	 edx, edx
  00020	3b ca		 cmp	 ecx, edx
  00022	0f 8c 8a 02 00
	00		 jl	 $L124559
  00028	3b c2		 cmp	 eax, edx
  0002a	0f 8c 82 02 00
	00		 jl	 $L124559
  00030	8b be ec 00 00
	00		 mov	 edi, DWORD PTR [esi+236]
  00036	81 ff 00 01 00
	00		 cmp	 edi, 256		; 00000100H
  0003c	0f 8d 70 02 00
	00		 jge	 $L124559

; 3700 :         return;
; 3701 : 
; 3702 :     INT  S = NumDrops++;
; 3703 : 
; 3704 :     Drops[S].X = DropX >> 1;
; 3705 :     Drops[S].Y = DropY >> 1;

  00042	d1 f8		 sar	 eax, 1
  00044	53		 push	 ebx
  00045	8d 5f 01	 lea	 ebx, DWORD PTR [edi+1]
  00048	89 9e ec 00 00
	00		 mov	 DWORD PTR [esi+236], ebx
  0004e	d1 f9		 sar	 ecx, 1
  00050	88 84 fe f3 00
	00 00		 mov	 BYTE PTR [esi+edi*8+243], al
  00057	88 8c fe f2 00
	00 00		 mov	 BYTE PTR [esi+edi*8+242], cl

; 3706 :     Drops[S].Type = DropType;

  0005e	8a 86 e0 00 00
	00		 mov	 al, BYTE PTR [esi+224]
  00064	88 84 fe f0 00
	00 00		 mov	 BYTE PTR [esi+edi*8+240], al

; 3707 : 
; 3708 :     DrawPhase++;

  0006b	8a 9e dc 00 00
	00		 mov	 bl, BYTE PTR [esi+220]

; 3709 : 
; 3710 :     // The rest are Drop-type specific assignments.
; 3711 : 
; 3712 : 	switch( DropType )
; 3713 :     {

  00071	33 c0		 xor	 eax, eax
  00073	8a 86 e0 00 00
	00		 mov	 al, BYTE PTR [esi+224]
  00079	fe c3		 inc	 bl
  0007b	88 9e dc 00 00
	00		 mov	 BYTE PTR [esi+220], bl
  00081	5b		 pop	 ebx
  00082	48		 dec	 eax
  00083	83 f8 12	 cmp	 eax, 18			; 00000012H
  00086	0f 87 26 02 00
	00		 ja	 $L124559
  0008c	33 c9		 xor	 ecx, ecx
  0008e	8a 88 00 00 00
	00		 mov	 cl, BYTE PTR $L134023[eax]
  00094	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $L134026[ecx*4]
$L124562:

; 3714 : 		// Force a certain area to FX_Depth.
; 3715 : 
; 3716 : 		case DROP_PhaseSpot:  // Align new phase in-step.
; 3717 : 		case DROP_HalfAmpl:   // 
; 3718 : 			{
; 3719 : 			Drops[S].Depth = ( GlobalPhase * ( FX_Frequency  ) + FX_Phase) & 255;

  0009b	8a 86 d8 00 00
	00		 mov	 al, BYTE PTR [esi+216]
  000a1	f6 ae e2 00 00
	00		 imul	 BYTE PTR [esi+226]
  000a7	02 86 e3 00 00
	00		 add	 al, BYTE PTR [esi+227]
  000ad	88 84 fe f1 00
	00 00		 mov	 BYTE PTR [esi+edi*8+241], al

; 3720 : 			Drops[S].ByteD = FX_Frequency;

  000b4	8a 86 e2 00 00
	00		 mov	 al, BYTE PTR [esi+226]

; 3721 : 			Drops[S].ByteA=0;

  000ba	88 94 fe f4 00
	00 00		 mov	 BYTE PTR [esi+edi*8+244], dl

; 3722 : 			Drops[S].ByteB=0;

  000c1	88 94 fe f5 00
	00 00		 mov	 BYTE PTR [esi+edi*8+245], dl

; 3723 : 			Drops[S].ByteC=0;

  000c8	88 94 fe f6 00
	00 00		 mov	 BYTE PTR [esi+edi*8+246], dl

; 3807 : 			Drops[S].ByteD = (FX_Frequency ) >>2;

  000cf	88 84 fe f7 00
	00 00		 mov	 BYTE PTR [esi+edi*8+247], al
  000d6	5f		 pop	 edi
  000d7	5e		 pop	 esi

; 3808 : 			break;		
; 3809 : 	}
; 3810 : }

  000d8	c2 08 00	 ret	 8
$L124563:

; 3724 : 			}
; 3725 : 			break;
; 3726 : 
; 3727 : 		case DROP_ShallowSpot: // Align new phase in-step, whatever the period.
; 3728 : 			Drops[S].Depth = ( GlobalPhase * FX_Frequency + FX_Phase) & 255;

  000db	8a 86 d8 00 00
	00		 mov	 al, BYTE PTR [esi+216]
  000e1	f6 ae e2 00 00
	00		 imul	 BYTE PTR [esi+226]
  000e7	02 86 e3 00 00
	00		 add	 al, BYTE PTR [esi+227]
  000ed	88 84 fe f1 00
	00 00		 mov	 BYTE PTR [esi+edi*8+241], al

; 3729 : 			Drops[S].ByteD = FX_Frequency;

  000f4	8a 8e e2 00 00
	00		 mov	 cl, BYTE PTR [esi+226]
  000fa	88 8c fe f7 00
	00 00		 mov	 BYTE PTR [esi+edi*8+247], cl
  00101	5f		 pop	 edi
  00102	5e		 pop	 esi

; 3808 : 			break;		
; 3809 : 	}
; 3810 : }

  00103	c2 08 00	 ret	 8
$L124565:

; 3730 : 			break;
; 3731 : 
; 3732 : 		case DROP_FixedRandomSpot: // random fixed spot
; 3733 : 			break;
; 3734 : 
; 3735 : 		// All sparks that need ParamsB as their 'depth':
; 3736 : 		case DROP_HorizontalLine:
; 3737 : 		case DROP_VerticalLine:
; 3738 : 		case DROP_DiagonalLine1:
; 3739 : 		case DROP_DiagonalLine2:
; 3740 : 		case DROP_RainDrops:
; 3741 : 			Drops[S].Depth = FX_Depth;

  00106	8a 96 e8 00 00
	00		 mov	 dl, BYTE PTR [esi+232]
  0010c	88 94 fe f1 00
	00 00		 mov	 BYTE PTR [esi+edi*8+241], dl

; 3742 : 			Drops[S].ByteD = FX_Size;

  00113	8a 86 e7 00 00
	00		 mov	 al, BYTE PTR [esi+231]

; 3807 : 			Drops[S].ByteD = (FX_Frequency ) >>2;

  00119	88 84 fe f7 00
	00 00		 mov	 BYTE PTR [esi+edi*8+247], al
  00120	5f		 pop	 edi
  00121	5e		 pop	 esi

; 3808 : 			break;		
; 3809 : 	}
; 3810 : }

  00122	c2 08 00	 ret	 8
$L124566:

; 3743 : 			break;
; 3744 : 
; 3745 : 		// All linesegments that need a fixed relative phase:
; 3746 : 		case DROP_HorizontalOsc:
; 3747 : 		case DROP_VerticalOsc:
; 3748 : 		case DROP_DiagonalOsc1:
; 3749 : 		case DROP_DiagonalOsc2:
; 3750 : 			Drops[S].Depth = ( GlobalPhase * FX_Frequency + FX_Phase) & 255;

  00125	8a 86 d8 00 00
	00		 mov	 al, BYTE PTR [esi+216]
  0012b	f6 ae e2 00 00
	00		 imul	 BYTE PTR [esi+226]
  00131	02 86 e3 00 00
	00		 add	 al, BYTE PTR [esi+227]
  00137	88 84 fe f1 00
	00 00		 mov	 BYTE PTR [esi+edi*8+241], al

; 3751 : 			Drops[S].ByteC = FX_Frequency;

  0013e	8a 8e e2 00 00
	00		 mov	 cl, BYTE PTR [esi+226]
  00144	88 8c fe f6 00
	00 00		 mov	 BYTE PTR [esi+edi*8+246], cl

; 3752 : 			Drops[S].ByteD = FX_Size;

  0014b	8a 96 e7 00 00
	00		 mov	 dl, BYTE PTR [esi+231]
  00151	88 94 fe f7 00
	00 00		 mov	 BYTE PTR [esi+edi*8+247], dl
  00158	5f		 pop	 edi
  00159	5e		 pop	 esi

; 3808 : 			break;		
; 3809 : 	}
; 3810 : }

  0015a	c2 08 00	 ret	 8
$L124567:

; 3753 : 			break;
; 3754 : 
; 3755 : 		case DROP_AreaClamp:
; 3756 : 			Drops[S].Depth = FX_Depth;

  0015d	8a 86 e8 00 00
	00		 mov	 al, BYTE PTR [esi+232]
  00163	88 84 fe f1 00
	00 00		 mov	 BYTE PTR [esi+edi*8+241], al

; 3757 : 			Drops[S].ByteD = FX_Size;

  0016a	8a 8e e7 00 00
	00		 mov	 cl, BYTE PTR [esi+231]
  00170	88 8c fe f7 00
	00 00		 mov	 BYTE PTR [esi+edi*8+247], cl
  00177	5f		 pop	 edi
  00178	5e		 pop	 esi

; 3808 : 			break;		
; 3809 : 	}
; 3810 : }

  00179	c2 08 00	 ret	 8
$L124568:

; 3758 : 			break;
; 3759 : 
; 3760 : 		case DROP_WhirlyThing:
; 3761 : 			{
; 3762 : 			Drops[S].Depth = FX_Depth;

  0017c	8a 86 e8 00 00
	00		 mov	 al, BYTE PTR [esi+232]
  00182	88 84 fe f1 00
	00 00		 mov	 BYTE PTR [esi+edi*8+241], al

; 3763 : 			Drops[S].ByteA=0; // Low-byte of phase.
; 3764 : 
; 3765 : 			INT TempFreq = FX_Frequency;

  00189	33 c0		 xor	 eax, eax
  0018b	88 94 fe f4 00
	00 00		 mov	 BYTE PTR [esi+edi*8+244], dl
  00192	8a 86 e2 00 00
	00		 mov	 al, BYTE PTR [esi+226]

; 3766 : 			if( TempFreq > 127 ) // negative variant

  00198	83 f8 7f	 cmp	 eax, 127		; 0000007fH
  0019b	7e 3c		 jle	 SHORT $L124575

; 3767 : 				{
; 3768 : 				Drops[S].Type = DROP_WhirlyBack;

  0019d	c6 84 fe f0 00
	00 00 40	 mov	 BYTE PTR [esi+edi*8+240], 64 ; 00000040H

; 3769 : 				TempFreq = 255-TempFreq;
; 3770 : 				}
; 3771 : 
; 3772 : 			DWORD TimeDelta = 65535/( (INT)(127-TempFreq) +1); //65536
; 3773 : 			Drops[S].ByteC =  ( TimeDelta & 0x00FF );
; 3774 : 			Drops[S].ByteD =  ( TimeDelta & 0xFF00 ) >> 8;
; 3775 : 			Drops[S].ByteB = (( (GlobalPhase * ( TimeDelta )) + (FX_Phase << 8) ) >> 8 ) & 255;
; 3776 : 			}
; 3777 : 			break;

  001a5	eb 29		 jmp	 SHORT $L134025
$L124573:

; 3778 : 
; 3779 : 		case DROP_BigWhirly:
; 3780 : 			{
; 3781 : 			Drops[S].Depth = FX_Depth;

  001a7	8a 86 e8 00 00
	00		 mov	 al, BYTE PTR [esi+232]
  001ad	88 84 fe f1 00
	00 00		 mov	 BYTE PTR [esi+edi*8+241], al

; 3782 : 			Drops[S].ByteA=0; // Low-byte of phase.
; 3783 : 
; 3784 : 			INT TempFreq = FX_Frequency;

  001b4	33 c0		 xor	 eax, eax
  001b6	88 94 fe f4 00
	00 00		 mov	 BYTE PTR [esi+edi*8+244], dl
  001bd	8a 86 e2 00 00
	00		 mov	 al, BYTE PTR [esi+226]

; 3785 : 			if( TempFreq > 127 ) // negative variant

  001c3	83 f8 7f	 cmp	 eax, 127		; 0000007fH
  001c6	7e 11		 jle	 SHORT $L124575

; 3786 : 				{
; 3787 : 				Drops[S].Type = DROP_BigWhirlyBack;

  001c8	c6 84 fe f0 00
	00 00 41	 mov	 BYTE PTR [esi+edi*8+240], 65 ; 00000041H
$L134025:

; 3788 : 				TempFreq = 255-TempFreq;

  001d0	b9 ff 00 00 00	 mov	 ecx, 255		; 000000ffH
  001d5	2b c8		 sub	 ecx, eax
  001d7	8b c1		 mov	 eax, ecx
$L124575:

; 3789 : 				}
; 3790 : 
; 3791 : 			DWORD TimeDelta = 65535/( (INT)(127-TempFreq) +1); //65537

  001d9	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  001de	2b c8		 sub	 ecx, eax
  001e0	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  001e5	99		 cdq
  001e6	f7 f9		 idiv	 ecx

; 3792 : 			Drops[S].ByteC =  ( TimeDelta & 0x00FF );
; 3793 : 			Drops[S].ByteD =  ( TimeDelta & 0xFF00 ) >> 8;
; 3794 : 			Drops[S].ByteB = (( (GlobalPhase * ( TimeDelta )) + (FX_Phase << 8) ) >> 8 ) & 255;

  001e8	33 c9		 xor	 ecx, ecx
  001ea	8b d0		 mov	 edx, eax
  001ec	c1 ea 08	 shr	 edx, 8
  001ef	88 94 fe f7 00
	00 00		 mov	 BYTE PTR [esi+edi*8+247], dl
  001f6	88 84 fe f6 00
	00 00		 mov	 BYTE PTR [esi+edi*8+246], al
  001fd	8b 96 d8 00 00
	00		 mov	 edx, DWORD PTR [esi+216]
  00203	8a 8e e3 00 00
	00		 mov	 cl, BYTE PTR [esi+227]
  00209	0f af d0	 imul	 edx, eax
  0020c	c1 e1 08	 shl	 ecx, 8
  0020f	03 ca		 add	 ecx, edx
  00211	c1 e9 08	 shr	 ecx, 8
  00214	88 8c fe f5 00
	00 00		 mov	 BYTE PTR [esi+edi*8+245], cl
  0021b	5f		 pop	 edi
  0021c	5e		 pop	 esi

; 3808 : 			break;		
; 3809 : 	}
; 3810 : }

  0021d	c2 08 00	 ret	 8
$L124578:

; 3795 : 			}
; 3796 : 			break;
; 3797 : 
; 3798 : 		case DROP_LeakyTap:
; 3799 : 			Drops[S].Depth = FX_Depth;

  00220	8a 86 e8 00 00
	00		 mov	 al, BYTE PTR [esi+232]
  00226	88 84 fe f1 00
	00 00		 mov	 BYTE PTR [esi+edi*8+241], al

; 3800 : 			Drops[S].ByteA = ( GlobalPhase * FX_Frequency + FX_Phase) & 255;

  0022d	8a 86 d8 00 00
	00		 mov	 al, BYTE PTR [esi+216]
  00233	f6 ae e2 00 00
	00		 imul	 BYTE PTR [esi+226]
  00239	02 86 e3 00 00
	00		 add	 al, BYTE PTR [esi+227]
  0023f	88 84 fe f4 00
	00 00		 mov	 BYTE PTR [esi+edi*8+244], al

; 3801 : 			Drops[S].ByteD = ( FX_Frequency ) >>2;

  00246	8a 8e e2 00 00
	00		 mov	 cl, BYTE PTR [esi+226]
  0024c	c0 e9 02	 shr	 cl, 2
  0024f	88 8c fe f7 00
	00 00		 mov	 BYTE PTR [esi+edi*8+247], cl
  00256	5f		 pop	 edi
  00257	5e		 pop	 esi

; 3808 : 			break;		
; 3809 : 	}
; 3810 : }

  00258	c2 08 00	 ret	 8
$L124579:

; 3802 : 			break;		
; 3803 : 
; 3804 : 		case DROP_DrippyTap:
; 3805 : 			Drops[S].Depth = FX_Depth;

  0025b	8a 96 e8 00 00
	00		 mov	 dl, BYTE PTR [esi+232]
  00261	88 94 fe f1 00
	00 00		 mov	 BYTE PTR [esi+edi*8+241], dl

; 3806 : 			Drops[S].ByteA = SpeedRand();

  00268	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  0026e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  00274	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  0027a	83 c2 04	 add	 edx, 4
  0027d	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  00283	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  00289	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  0028f	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  00295	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  0029b	88 84 fe f4 00
	00 00		 mov	 BYTE PTR [esi+edi*8+244], al

; 3807 : 			Drops[S].ByteD = (FX_Frequency ) >>2;

  002a2	8a 86 e2 00 00
	00		 mov	 al, BYTE PTR [esi+226]
  002a8	c0 e8 02	 shr	 al, 2
  002ab	88 84 fe f7 00
	00 00		 mov	 BYTE PTR [esi+edi*8+247], al
$L124559:
  002b2	5f		 pop	 edi
  002b3	5e		 pop	 esi

; 3808 : 			break;		
; 3809 : 	}
; 3810 : }

  002b4	c2 08 00	 ret	 8
  002b7	90		 npad	 1
$L134026:
  002b8	00 00 00 00	 DD	 $L124562
  002bc	00 00 00 00	 DD	 $L124563
  002c0	00 00 00 00	 DD	 $L124568
  002c4	00 00 00 00	 DD	 $L124573
  002c8	00 00 00 00	 DD	 $L124565
  002cc	00 00 00 00	 DD	 $L124566
  002d0	00 00 00 00	 DD	 $L124567
  002d4	00 00 00 00	 DD	 $L124578
  002d8	00 00 00 00	 DD	 $L124579
  002dc	00 00 00 00	 DD	 $L124559
$L134023:
  002e0	00		 DB	 0
  002e1	01		 DB	 1
  002e2	00		 DB	 0
  002e3	09		 DB	 9
  002e4	09		 DB	 9
  002e5	02		 DB	 2
  002e6	03		 DB	 3
  002e7	04		 DB	 4
  002e8	04		 DB	 4
  002e9	04		 DB	 4
  002ea	04		 DB	 4
  002eb	05		 DB	 5
  002ec	05		 DB	 5
  002ed	05		 DB	 5
  002ee	05		 DB	 5
  002ef	04		 DB	 4
  002f0	06		 DB	 6
  002f1	07		 DB	 7
  002f2	08		 DB	 8
?AddDrop@UWaterTexture@@AAEXHH@Z ENDP			; UWaterTexture::AddDrop
_TEXT	ENDS
PUBLIC	?DeleteDrops@UWaterTexture@@AAEXHHH@Z		; UWaterTexture::DeleteDrops
; Function compile flags: /Ogty
;	COMDAT ?DeleteDrops@UWaterTexture@@AAEXHHH@Z
_TEXT	SEGMENT
_DropX$ = 8
_DropY$ = 12
_AreaWidth$ = 16
?DeleteDrops@UWaterTexture@@AAEXHHH@Z PROC NEAR		; UWaterTexture::DeleteDrops, COMDAT
; _this$ = ecx

; 3815 : {

  00000	55		 push	 ebp
  00001	56		 push	 esi

; 3816 :     for( INT S=0; S<NumDrops; S++ )

  00002	8b b1 ec 00 00
	00		 mov	 esi, DWORD PTR [ecx+236]
  00008	33 ed		 xor	 ebp, ebp
  0000a	85 f6		 test	 esi, esi
  0000c	7e 64		 jle	 SHORT $L124589
  0000e	53		 push	 ebx
  0000f	57		 push	 edi
  00010	8d 91 f3 00 00
	00		 lea	 edx, DWORD PTR [ecx+243]
$L124587:

; 3817 :     {
; 3818 :         if( AreaWidth >= ( Abs(DropX - (Drops[S].X << 1) ) +
; 3819 :                            Abs(DropY - (Drops[S].Y << 1) ) ) )

  00016	33 c0		 xor	 eax, eax
  00018	8a 42 ff	 mov	 al, BYTE PTR [edx-1]
  0001b	d1 e0		 shl	 eax, 1
  0001d	8b f8		 mov	 edi, eax
  0001f	8b 44 24 14	 mov	 eax, DWORD PTR _DropX$[esp+12]
  00023	2b c7		 sub	 eax, edi
  00025	79 02		 jns	 SHORT $L134049
  00027	f7 d8		 neg	 eax
$L134049:
  00029	8b f8		 mov	 edi, eax
  0002b	33 c0		 xor	 eax, eax
  0002d	8a 02		 mov	 al, BYTE PTR [edx]
  0002f	d1 e0		 shl	 eax, 1
  00031	8b d8		 mov	 ebx, eax
  00033	8b 44 24 18	 mov	 eax, DWORD PTR _DropY$[esp+12]
  00037	2b c3		 sub	 eax, ebx
  00039	79 02		 jns	 SHORT $L134044
  0003b	f7 d8		 neg	 eax
$L134044:
  0003d	03 c7		 add	 eax, edi
  0003f	39 44 24 1c	 cmp	 DWORD PTR _AreaWidth$[esp+12], eax
  00043	7c 1d		 jl	 SHORT $L124588

; 3820 :         {
; 3821 :             // Delete Drop by replacing it with last one (+ delete last one).
; 3822 :             INT  LastDrop = --NumDrops;

  00045	8d 46 ff	 lea	 eax, DWORD PTR [esi-1]
  00048	89 81 ec 00 00
	00		 mov	 DWORD PTR [ecx+236], eax

; 3823 :             Drops[S] = Drops[LastDrop];

  0004e	8b b4 c1 f0 00
	00 00		 mov	 esi, DWORD PTR [ecx+eax*8+240]
  00055	89 72 fd	 mov	 DWORD PTR [edx-3], esi
  00058	8b 84 c1 f4 00
	00 00		 mov	 eax, DWORD PTR [ecx+eax*8+244]
  0005f	89 42 01	 mov	 DWORD PTR [edx+1], eax
$L124588:
  00062	8b b1 ec 00 00
	00		 mov	 esi, DWORD PTR [ecx+236]
  00068	45		 inc	 ebp
  00069	83 c2 08	 add	 edx, 8
  0006c	3b ee		 cmp	 ebp, esi
  0006e	7c a6		 jl	 SHORT $L124587
  00070	5f		 pop	 edi
  00071	5b		 pop	 ebx
$L124589:
  00072	5e		 pop	 esi
  00073	5d		 pop	 ebp

; 3824 :         }
; 3825 :     }
; 3826 : }

  00074	c2 0c 00	 ret	 12			; 0000000cH
?DeleteDrops@UWaterTexture@@AAEXHHH@Z ENDP		; UWaterTexture::DeleteDrops
_TEXT	ENDS
PUBLIC	?TempDrawSpark@UFireTexture@@AAEXHHH@Z		; UFireTexture::TempDrawSpark
; Function compile flags: /Ogty
;	COMDAT ?TempDrawSpark@UFireTexture@@AAEXHHH@Z
_TEXT	SEGMENT
_PosX$ = 8
_PosY$ = 12
_Intensity$ = 16
?TempDrawSpark@UFireTexture@@AAEXHHH@Z PROC NEAR	; UFireTexture::TempDrawSpark, COMDAT
; _this$ = ecx

; 3834 : {

  00000	8b c1		 mov	 eax, ecx

; 3835 :     DWORD SparkDest;
; 3836 : 
; 3837 :     SparkDest = (DWORD)(   (UMask & PosX) +
; 3838 :                           ((VMask & PosY)<< UBits )   );

  00002	8b 90 cc 00 00
	00		 mov	 edx, DWORD PTR [eax+204]
  00008	23 54 24 08	 and	 edx, DWORD PTR _PosY$[esp-4]
  0000c	8a 48 30	 mov	 cl, BYTE PTR [eax+48]
  0000f	d3 e2		 shl	 edx, cl
  00011	8b 88 c8 00 00
	00		 mov	 ecx, DWORD PTR [eax+200]

; 3839 : 
; 3840 :     Mips(0).DataArray(SparkDest) = (BYTE) Intensity;

  00017	8b 80 a8 00 00
	00		 mov	 eax, DWORD PTR [eax+168]
  0001d	23 4c 24 04	 and	 ecx, DWORD PTR _PosX$[esp-4]
  00021	03 d1		 add	 edx, ecx
  00023	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00026	8a 44 24 0c	 mov	 al, BYTE PTR _Intensity$[esp-4]
  0002a	88 04 0a	 mov	 BYTE PTR [edx+ecx], al

; 3841 : }

  0002d	c2 0c 00	 ret	 12			; 0000000cH
?TempDrawSpark@UFireTexture@@AAEXHHH@Z ENDP		; UFireTexture::TempDrawSpark
_TEXT	ENDS
PUBLIC	?BlueLagunaPalette@@YAXPAVUPalette@@@Z		; BlueLagunaPalette
; Function compile flags: /Ogty
;	COMDAT ?BlueLagunaPalette@@YAXPAVUPalette@@@Z
_TEXT	SEGMENT
_TargetPal$ = 8
?BlueLagunaPalette@@YAXPAVUPalette@@@Z PROC NEAR	; BlueLagunaPalette, COMDAT

; 3849 : {

  00000	83 ec 20	 sub	 esp, 32			; 00000020H

; 3850 : 	for( INT i=0; i< 64; i++ )

  00003	33 c9		 xor	 ecx, ecx
  00005	53		 push	 ebx
  00006	55		 push	 ebp
  00007	56		 push	 esi
  00008	8b 74 24 30	 mov	 esi, DWORD PTR _TargetPal$[esp+40]
  0000c	33 ed		 xor	 ebp, ebp
  0000e	57		 push	 edi
  0000f	89 4c 24 2c	 mov	 DWORD PTR -4+[esp+48], ecx
  00013	89 4c 24 28	 mov	 DWORD PTR -8+[esp+48], ecx
  00017	89 4c 24 24	 mov	 DWORD PTR -12+[esp+48], ecx
  0001b	89 4c 24 20	 mov	 DWORD PTR -16+[esp+48], ecx
  0001f	89 4c 24 1c	 mov	 DWORD PTR -20+[esp+48], ecx
  00023	89 4c 24 18	 mov	 DWORD PTR -24+[esp+48], ecx
  00027	89 4c 24 14	 mov	 DWORD PTR -28+[esp+48], ecx
  0002b	89 4c 24 10	 mov	 DWORD PTR -32+[esp+48], ecx
  0002f	89 4c 24 34	 mov	 DWORD PTR 8+[esp+44], ecx
  00033	33 db		 xor	 ebx, ebx
$L124611:

; 3851 : 	{
; 3852 : 		TargetPal->Colors(i).R     = Min(    0+ (i* 59)/64 ,255);

  00035	8b c3		 mov	 eax, ebx
  00037	99		 cdq
  00038	83 e2 3f	 and	 edx, 63			; 0000003fH
  0003b	03 c2		 add	 eax, edx
  0003d	c1 f8 06	 sar	 eax, 6
  00040	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00045	7e 05		 jle	 SHORT $L134068
  00047	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
$L134068:
  0004c	8b 56 28	 mov	 edx, DWORD PTR [esi+40]
  0004f	88 04 11	 mov	 BYTE PTR [ecx+edx], al

; 3853 : 		TargetPal->Colors(i).G     = Min(    0+ (i* 67)/64 ,255);

  00052	8b 44 24 34	 mov	 eax, DWORD PTR 8+[esp+44]
  00056	99		 cdq
  00057	83 e2 3f	 and	 edx, 63			; 0000003fH
  0005a	03 c2		 add	 eax, edx
  0005c	c1 f8 06	 sar	 eax, 6
  0005f	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00064	7e 05		 jle	 SHORT $L134079
  00066	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
$L134079:
  0006b	8b 56 28	 mov	 edx, DWORD PTR [esi+40]
  0006e	88 44 11 01	 mov	 BYTE PTR [ecx+edx+1], al

; 3854 : 		TargetPal->Colors(i).B     = Min(    0+ (i*100)/64 ,255);

  00072	8b 44 24 10	 mov	 eax, DWORD PTR -32+[esp+48]
  00076	99		 cdq
  00077	83 e2 3f	 and	 edx, 63			; 0000003fH
  0007a	03 c2		 add	 eax, edx
  0007c	c1 f8 06	 sar	 eax, 6
  0007f	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00084	7e 05		 jle	 SHORT $L134090
  00086	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
$L134090:
  0008b	8b 56 28	 mov	 edx, DWORD PTR [esi+40]
  0008e	88 44 11 02	 mov	 BYTE PTR [ecx+edx+2], al

; 3855 : 
; 3856 : 		TargetPal->Colors(i+64).R  = Min(   59+ (i* 55)/64 ,255);

  00092	8b c5		 mov	 eax, ebp
  00094	99		 cdq
  00095	83 e2 3f	 and	 edx, 63			; 0000003fH
  00098	03 c2		 add	 eax, edx
  0009a	c1 f8 06	 sar	 eax, 6
  0009d	83 c0 3b	 add	 eax, 59			; 0000003bH
  000a0	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  000a5	7e 05		 jle	 SHORT $L134101
  000a7	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
$L134101:
  000ac	8b 56 28	 mov	 edx, DWORD PTR [esi+40]
  000af	88 84 11 00 01
	00 00		 mov	 BYTE PTR [ecx+edx+256], al

; 3857 : 		TargetPal->Colors(i+64).G  = Min(   67+ (i* 60)/64 ,255);

  000b6	8b 44 24 1c	 mov	 eax, DWORD PTR -20+[esp+48]
  000ba	99		 cdq
  000bb	83 e2 3f	 and	 edx, 63			; 0000003fH
  000be	03 c2		 add	 eax, edx
  000c0	8b f8		 mov	 edi, eax
  000c2	c1 ff 06	 sar	 edi, 6
  000c5	8d 47 43	 lea	 eax, DWORD PTR [edi+67]
  000c8	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  000cd	7e 05		 jle	 SHORT $L134112
  000cf	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
$L134112:
  000d4	8b 56 28	 mov	 edx, DWORD PTR [esi+40]
  000d7	88 84 11 01 01
	00 00		 mov	 BYTE PTR [ecx+edx+257], al

; 3858 : 		TargetPal->Colors(i+64).B  = Min(  100+ (i* 97)/64 ,255);

  000de	8b 44 24 14	 mov	 eax, DWORD PTR -28+[esp+48]
  000e2	99		 cdq
  000e3	83 e2 3f	 and	 edx, 63			; 0000003fH
  000e6	03 c2		 add	 eax, edx
  000e8	c1 f8 06	 sar	 eax, 6
  000eb	83 c0 64	 add	 eax, 100		; 00000064H
  000ee	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  000f3	7e 05		 jle	 SHORT $L134122
  000f5	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
$L134122:
  000fa	8b 56 28	 mov	 edx, DWORD PTR [esi+40]
  000fd	88 84 11 02 01
	00 00		 mov	 BYTE PTR [ecx+edx+258], al

; 3859 : 
; 3860 : 		TargetPal->Colors(i+128).R = Min(  114+ (i* 64)/64 ,255);

  00104	8b 44 24 18	 mov	 eax, DWORD PTR -24+[esp+48]
  00108	99		 cdq
  00109	83 e2 3f	 and	 edx, 63			; 0000003fH
  0010c	03 c2		 add	 eax, edx
  0010e	c1 f8 06	 sar	 eax, 6
  00111	83 c0 72	 add	 eax, 114		; 00000072H
  00114	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00119	7e 05		 jle	 SHORT $L134133
  0011b	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
$L134133:
  00120	8b 56 28	 mov	 edx, DWORD PTR [esi+40]
  00123	88 84 11 00 02
	00 00		 mov	 BYTE PTR [ecx+edx+512], al

; 3861 : 		TargetPal->Colors(i+128).G = Min(  127+ (i* 60)/64 ,255);

  0012a	8d 47 7f	 lea	 eax, DWORD PTR [edi+127]
  0012d	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00132	7e 05		 jle	 SHORT $L134144
  00134	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
$L134144:
  00139	8b 56 28	 mov	 edx, DWORD PTR [esi+40]
  0013c	88 84 11 01 02
	00 00		 mov	 BYTE PTR [ecx+edx+513], al

; 3862 : 		TargetPal->Colors(i+128).B = Min(  197+ (i* 33)/64 ,255);

  00143	8b 44 24 20	 mov	 eax, DWORD PTR -16+[esp+48]
  00147	99		 cdq
  00148	83 e2 3f	 and	 edx, 63			; 0000003fH
  0014b	03 c2		 add	 eax, edx
  0014d	c1 f8 06	 sar	 eax, 6
  00150	05 c5 00 00 00	 add	 eax, 197		; 000000c5H
  00155	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  0015a	7e 05		 jle	 SHORT $L134155
  0015c	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
$L134155:
  00161	8b 56 28	 mov	 edx, DWORD PTR [esi+40]
  00164	88 84 11 02 02
	00 00		 mov	 BYTE PTR [ecx+edx+514], al

; 3863 : 
; 3864 : 		TargetPal->Colors(i+192).R = Min(  178+ (i* 78)/64 ,255);

  0016b	8b 44 24 24	 mov	 eax, DWORD PTR -12+[esp+48]
  0016f	99		 cdq
  00170	83 e2 3f	 and	 edx, 63			; 0000003fH
  00173	03 c2		 add	 eax, edx
  00175	c1 f8 06	 sar	 eax, 6
  00178	05 b2 00 00 00	 add	 eax, 178		; 000000b2H
  0017d	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00182	7e 05		 jle	 SHORT $L134166
  00184	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
$L134166:
  00189	8b 56 28	 mov	 edx, DWORD PTR [esi+40]
  0018c	88 84 11 00 03
	00 00		 mov	 BYTE PTR [ecx+edx+768], al

; 3865 : 		TargetPal->Colors(i+192).G = Min(  187+ (i* 69)/64 ,255);

  00193	8b 44 24 28	 mov	 eax, DWORD PTR -8+[esp+48]
  00197	99		 cdq
  00198	83 e2 3f	 and	 edx, 63			; 0000003fH
  0019b	03 c2		 add	 eax, edx
  0019d	c1 f8 06	 sar	 eax, 6
  001a0	05 bb 00 00 00	 add	 eax, 187		; 000000bbH
  001a5	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  001aa	7e 05		 jle	 SHORT $L134177
  001ac	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
$L134177:
  001b1	8b 56 28	 mov	 edx, DWORD PTR [esi+40]
  001b4	88 84 11 01 03
	00 00		 mov	 BYTE PTR [ecx+edx+769], al

; 3866 : 		TargetPal->Colors(i+192).B = Min(  230+ (i* 26)/64 ,255);

  001bb	8b 44 24 2c	 mov	 eax, DWORD PTR -4+[esp+48]
  001bf	99		 cdq
  001c0	83 e2 3f	 and	 edx, 63			; 0000003fH
  001c3	03 c2		 add	 eax, edx
  001c5	c1 f8 06	 sar	 eax, 6
  001c8	05 e6 00 00 00	 add	 eax, 230		; 000000e6H
  001cd	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  001d2	7e 05		 jle	 SHORT $L134188
  001d4	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
$L134188:
  001d9	8b 7c 24 34	 mov	 edi, DWORD PTR 8+[esp+44]
  001dd	8b 56 28	 mov	 edx, DWORD PTR [esi+40]
  001e0	88 84 11 02 03
	00 00		 mov	 BYTE PTR [ecx+edx+770], al
  001e7	8b 54 24 10	 mov	 edx, DWORD PTR -32+[esp+48]
  001eb	8b 44 24 1c	 mov	 eax, DWORD PTR -20+[esp+48]
  001ef	83 c7 43	 add	 edi, 67			; 00000043H
  001f2	89 7c 24 34	 mov	 DWORD PTR 8+[esp+44], edi
  001f6	8b 7c 24 14	 mov	 edi, DWORD PTR -28+[esp+48]
  001fa	83 c2 64	 add	 edx, 100		; 00000064H
  001fd	83 c7 61	 add	 edi, 97			; 00000061H
  00200	89 54 24 10	 mov	 DWORD PTR -32+[esp+48], edx
  00204	8b 54 24 18	 mov	 edx, DWORD PTR -24+[esp+48]
  00208	89 7c 24 14	 mov	 DWORD PTR -28+[esp+48], edi
  0020c	8b 7c 24 20	 mov	 edi, DWORD PTR -16+[esp+48]
  00210	83 c2 40	 add	 edx, 64			; 00000040H
  00213	83 c0 3c	 add	 eax, 60			; 0000003cH
  00216	83 c7 21	 add	 edi, 33			; 00000021H
  00219	89 54 24 18	 mov	 DWORD PTR -24+[esp+48], edx
  0021d	8b 54 24 24	 mov	 edx, DWORD PTR -12+[esp+48]
  00221	89 44 24 1c	 mov	 DWORD PTR -20+[esp+48], eax
  00225	8b 44 24 28	 mov	 eax, DWORD PTR -8+[esp+48]
  00229	89 7c 24 20	 mov	 DWORD PTR -16+[esp+48], edi
  0022d	8b 7c 24 2c	 mov	 edi, DWORD PTR -4+[esp+48]
  00231	83 c3 3b	 add	 ebx, 59			; 0000003bH
  00234	83 c2 4e	 add	 edx, 78			; 0000004eH
  00237	83 c0 45	 add	 eax, 69			; 00000045H
  0023a	83 c7 1a	 add	 edi, 26			; 0000001aH
  0023d	83 c5 37	 add	 ebp, 55			; 00000037H
  00240	83 c1 04	 add	 ecx, 4
  00243	81 fb c0 0e 00
	00		 cmp	 ebx, 3776		; 00000ec0H
  00249	89 54 24 24	 mov	 DWORD PTR -12+[esp+48], edx
  0024d	89 44 24 28	 mov	 DWORD PTR -8+[esp+48], eax
  00251	89 7c 24 2c	 mov	 DWORD PTR -4+[esp+48], edi
  00255	0f 8c da fd ff
	ff		 jl	 $L124611
  0025b	5f		 pop	 edi
  0025c	5e		 pop	 esi
  0025d	5d		 pop	 ebp
  0025e	5b		 pop	 ebx

; 3867 : 	}
; 3868 : };

  0025f	83 c4 20	 add	 esp, 32			; 00000020H
  00262	c3		 ret	 0
?BlueLagunaPalette@@YAXPAVUPalette@@@Z ENDP		; BlueLagunaPalette
_TEXT	ENDS
PUBLIC	??0UFractalTexture@@QAE@XZ			; UFractalTexture::UFractalTexture
PUBLIC	?PostLoad@UFractalTexture@@UAEXXZ		; UFractalTexture::PostLoad
PUBLIC	?PostEditChange@UFractalTexture@@UAEXXZ		; UFractalTexture::PostEditChange
PUBLIC	?Init@UFractalTexture@@UAEXHH@Z			; UFractalTexture::Init
PUBLIC	?TouchTexture@UFractalTexture@@UAEXHHM@Z	; UFractalTexture::TouchTexture
PUBLIC	??_7UFractalTexture@@6B@			; UFractalTexture::`vftable'
PUBLIC	??_EUFractalTexture@@UAEPAXI@Z			; UFractalTexture::`vector deleting destructor'
EXTRN	?GetMip@UTexture@@UAEPAUFMipmapBase@@H@Z:NEAR	; UTexture::GetMip
EXTRN	?MousePosition@UTexture@@UAEXKMM@Z:NEAR		; UTexture::MousePosition
EXTRN	?Click@UTexture@@UAEXKMM@Z:NEAR			; UTexture::Click
EXTRN	?Serialize@UTexture@@UAEXAAVFArchive@@@Z:NEAR	; UTexture::Serialize
EXTRN	?Destroy@UTexture@@UAEXXZ:NEAR			; UTexture::Destroy
EXTRN	?Lock@UTexture@@UAIXAAUFTextureInfo@@NHPAVURenderDevice@@@Z:NEAR ; UTexture::Lock
EXTRN	?Unlock@UTexture@@UAIXAAUFTextureInfo@@@Z:NEAR	; UTexture::Unlock
EXTRN	?Clear@UTexture@@UAEXK@Z:NEAR			; UTexture::Clear
EXTRN	?Tick@UTexture@@UAIXM@Z:NEAR			; UTexture::Tick
EXTRN	?ConstantTimeTick@UTexture@@UAEXXZ:NEAR		; UTexture::ConstantTimeTick
EXTRN	?Update@UTexture@@UAEXN@Z:NEAR			; UTexture::Update
EXTRN	?IsPendingKill@UObject@@UAEHXZ:NEAR		; UObject::IsPendingKill
EXTRN	?GetName@UObject@@UBEPBGXZ:NEAR			; UObject::GetName
EXTRN	?ProcessEvent@UObject@@UAEXPAVUFunction@@PAX1@Z:NEAR ; UObject::ProcessEvent
EXTRN	?ProcessState@UObject@@UAEXM@Z:NEAR		; UObject::ProcessState
EXTRN	?ProcessRemoteFunction@UObject@@UAEHPAVUFunction@@PAXPAUFFrame@@@Z:NEAR ; UObject::ProcessRemoteFunction
EXTRN	?Modify@UObject@@UAEXXZ:NEAR			; UObject::Modify
EXTRN	?GotoLabel@UObject@@UAEHVFName@@@Z:NEAR		; UObject::GotoLabel
EXTRN	?InitExecution@UObject@@UAEXXZ:NEAR		; UObject::InitExecution
EXTRN	?ShutdownAfterError@UObject@@UAEXXZ:NEAR	; UObject::ShutdownAfterError
EXTRN	?CallFunction@UObject@@UAEXAAUFFrame@@QAXPAVUFunction@@@Z:NEAR ; UObject::CallFunction
EXTRN	?ScriptConsoleExec@UObject@@UAEHPBGAAVFOutputDevice@@PAV1@@Z:NEAR ; UObject::ScriptConsoleExec
EXTRN	?Register@UObject@@UAEXXZ:NEAR			; UObject::Register
EXTRN	?LanguageChange@UObject@@UAEXXZ:NEAR		; UObject::LanguageChange
EXTRN	__imp_??0UTexture@@QAE@XZ:NEAR
;	COMDAT ??_7UFractalTexture@@6B@
CONST	SEGMENT
??_7UFractalTexture@@6B@ DD FLAT:??_EUFractalTexture@@UAEPAXI@Z ; UFractalTexture::`vftable'
	DD	FLAT:?ProcessEvent@UObject@@UAEXPAVUFunction@@PAX1@Z
	DD	FLAT:?ProcessState@UObject@@UAEXM@Z
	DD	FLAT:?ProcessRemoteFunction@UObject@@UAEHPAVUFunction@@PAXPAUFFrame@@@Z
	DD	FLAT:?Modify@UObject@@UAEXXZ
	DD	FLAT:?PostLoad@UFractalTexture@@UAEXXZ
	DD	FLAT:?Destroy@UTexture@@UAEXXZ
	DD	FLAT:?Serialize@UTexture@@UAEXAAVFArchive@@@Z
	DD	FLAT:?IsPendingKill@UObject@@UAEHXZ
	DD	FLAT:?GotoLabel@UObject@@UAEHVFName@@@Z
	DD	FLAT:?InitExecution@UObject@@UAEXXZ
	DD	FLAT:?ShutdownAfterError@UObject@@UAEXXZ
	DD	FLAT:?PostEditChange@UFractalTexture@@UAEXXZ
	DD	FLAT:?CallFunction@UObject@@UAEXAAUFFrame@@QAXPAVUFunction@@@Z
	DD	FLAT:?ScriptConsoleExec@UObject@@UAEHPBGAAVFOutputDevice@@PAV1@@Z
	DD	FLAT:?Register@UObject@@UAEXXZ
	DD	FLAT:?LanguageChange@UObject@@UAEXXZ
	DD	FLAT:?GetName@UObject@@UBEPBGXZ
	DD	FLAT:?Lock@UTexture@@UAIXAAUFTextureInfo@@NHPAVURenderDevice@@@Z
	DD	FLAT:?Unlock@UTexture@@UAIXAAUFTextureInfo@@@Z
	DD	FLAT:?GetMip@UTexture@@UAEPAUFMipmapBase@@H@Z
	DD	FLAT:?Clear@UTexture@@UAEXK@Z
	DD	FLAT:?Init@UFractalTexture@@UAEXHH@Z
	DD	FLAT:?Tick@UTexture@@UAIXM@Z
	DD	FLAT:?ConstantTimeTick@UTexture@@UAEXXZ
	DD	FLAT:?MousePosition@UTexture@@UAEXKMM@Z
	DD	FLAT:?Click@UTexture@@UAEXKMM@Z
	DD	FLAT:?Update@UTexture@@UAEXN@Z
	DD	FLAT:?TouchTexture@UFractalTexture@@UAEXHHM@Z
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ??0UFractalTexture@@QAE@XZ
_TEXT	SEGMENT
??0UFractalTexture@@QAE@XZ PROC NEAR			; UFractalTexture::UFractalTexture, COMDAT
; _this$ = ecx

; 3876 : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0UTexture@@QAE@XZ

; 3877 : 	// Mark the texture as parametric (so bitmap is not saved).
; 3878 : 	// Mark the texture as realtime   (so it is regenerated each tick).
; 3879 : 	bParametric = 1;
; 3880 : 	bRealtime   = 1;

  00009	8b 86 88 00 00
	00		 mov	 eax, DWORD PTR [esi+136]
  0000f	83 c8 0c	 or	 eax, 12			; 0000000cH
  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7UFractalTexture@@6B@ ; UFractalTexture::`vftable'
  00018	89 86 88 00 00
	00		 mov	 DWORD PTR [esi+136], eax

; 3881 : 
; 3882 : 	InitTables(); // Global LUTS, checks itself to see if already initzed.

  0001e	e8 00 00 00 00	 call	 ?InitTables@@YAXXZ	; InitTables

; 3883 : 
; 3884 : 	DrawPhase  =0;

  00023	33 c0		 xor	 eax, eax
  00025	88 86 dc 00 00
	00		 mov	 BYTE PTR [esi+220], al

; 3885 : 	AuxPhase   =0;

  0002b	88 86 dd 00 00
	00		 mov	 BYTE PTR [esi+221], al

; 3886 :     GlobalPhase=0;

  00031	89 86 d8 00 00
	00		 mov	 DWORD PTR [esi+216], eax

; 3887 : }

  00037	8b c6		 mov	 eax, esi
  00039	5e		 pop	 esi
  0003a	c3		 ret	 0
??0UFractalTexture@@QAE@XZ ENDP				; UFractalTexture::UFractalTexture
_TEXT	ENDS
PUBLIC	??_C@_1BO@JBP@?$AAF?$AAr?$AAa?$AAc?$AAt?$AAa?$AAl?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@BHOC@?$AAU?$AAM?$AAa?$AAs?$AAk?$AA?$AA@ ; `string'
PUBLIC	??_C@_1FK@OIBJ@?$AAC?$AAl?$AAa?$AAs?$AAs?$AA?5?$AA?$CF?$AAs?$AA?5?$AAM?$AAe?$AAm?$AAb?$AAe?$AAr?$AA?5?$AA?$CF?$AAs?$AA?5?$AAp@ ; `string'
PUBLIC	??_C@_0CA@CDIN@C?3?2duke4?2Fire?2Src?2UnFractal?4cpp?$AA@ ; `string'
PUBLIC	??_C@_0BJ@LFBK@?$CIInUSize?$CG?$CIInUSize?91?$CJ?$CJ?$DN?$DN0?$AA@ ; `string'
PUBLIC	??_C@_0BJ@LDOB@?$CIInVSize?$CG?$CIInVSize?91?$CJ?$CJ?$DN?$DN0?$AA@ ; `string'
EXTRN	__imp_?GError@@3PAVFOutputDeviceError@@A:DWORD
EXTRN	__imp_?appFailAssert@@YAXPBD0H@Z:NEAR
EXTRN	__imp_?PrivateStaticClass@UClass@@0V1@A:BYTE
EXTRN	__imp_?appStricmp@@YAHPBG0@Z:NEAR
EXTRN	__imp_?PrivateStaticClass@UProperty@@0VUClass@@A:BYTE
EXTRN	__imp_?Logf@FOutputDevice@@QAAXPBGZZ:NEAR
EXTRN	__imp_?Init@UTexture@@UAEXHH@Z:NEAR
EXTRN	__imp_?StaticFindObjectChecked@UObject@@SAPAV1@PAVUClass@@PAV1@PBGH@Z:NEAR
;	COMDAT ??_C@_1BO@JBP@?$AAF?$AAr?$AAa?$AAc?$AAt?$AAa?$AAl?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@
; File ..\..\Core\Inc\UnClass.h
_DATA	SEGMENT
??_C@_1BO@JBP@?$AAF?$AAr?$AAa?$AAc?$AAt?$AAa?$AAl?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@ DB 'F'
	DB	00H, 'r', 00H, 'a', 00H, 'c', 00H, 't', 00H, 'a', 00H, 'l', 00H
	DB	'T', 00H, 'e', 00H, 'x', 00H, 't', 00H, 'u', 00H, 'r', 00H, 'e'
	DB	00H, 00H, 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_1M@BHOC@?$AAU?$AAM?$AAa?$AAs?$AAk?$AA?$AA@
_DATA	SEGMENT
??_C@_1M@BHOC@?$AAU?$AAM?$AAa?$AAs?$AAk?$AA?$AA@ DB 'U', 00H, 'M', 00H, 'a'
	DB	00H, 's', 00H, 'k', 00H, 00H, 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_1FK@OIBJ@?$AAC?$AAl?$AAa?$AAs?$AAs?$AA?5?$AA?$CF?$AAs?$AA?5?$AAM?$AAe?$AAm?$AAb?$AAe?$AAr?$AA?5?$AA?$CF?$AAs?$AA?5?$AAp@
_DATA	SEGMENT
??_C@_1FK@OIBJ@?$AAC?$AAl?$AAa?$AAs?$AAs?$AA?5?$AA?$CF?$AAs?$AA?5?$AAM?$AAe?$AAm?$AAb?$AAe?$AAr?$AA?5?$AA?$CF?$AAs?$AA?5?$AAp@ DB 'C'
	DB	00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H, ' ', 00H, '%', 00H
	DB	's', 00H, ' ', 00H, 'M', 00H, 'e', 00H, 'm', 00H, 'b', 00H, 'e'
	DB	00H, 'r', 00H, ' ', 00H, '%', 00H, 's', 00H, ' ', 00H, 'p', 00H
	DB	'r', 00H, 'o', 00H, 'b', 00H, 'l', 00H, 'e', 00H, 'm', 00H, ':'
	DB	00H, ' ', 00H, 'S', 00H, 'c', 00H, 'r', 00H, 'i', 00H, 'p', 00H
	DB	't', 00H, '=', 00H, '%', 00H, 'i', 00H, ' ', 00H, 'C', 00H, '+'
	DB	00H, '+', 00H, '=', 00H, '%', 00H, 'i', 00H, 00H, 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CA@CDIN@C?3?2duke4?2Fire?2Src?2UnFractal?4cpp?$AA@
_DATA	SEGMENT
??_C@_0CA@CDIN@C?3?2duke4?2Fire?2Src?2UnFractal?4cpp?$AA@ DB 'C:\duke4\Fi'
	DB	're\Src\UnFractal.cpp', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BJ@LFBK@?$CIInUSize?$CG?$CIInUSize?91?$CJ?$CJ?$DN?$DN0?$AA@
_DATA	SEGMENT
??_C@_0BJ@LFBK@?$CIInUSize?$CG?$CIInUSize?91?$CJ?$CJ?$DN?$DN0?$AA@ DB '(I'
	DB	'nUSize&(InUSize-1))==0', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BJ@LDOB@?$CIInVSize?$CG?$CIInVSize?91?$CJ?$CJ?$DN?$DN0?$AA@
_DATA	SEGMENT
??_C@_0BJ@LDOB@?$CIInVSize?$CG?$CIInVSize?91?$CJ?$CJ?$DN?$DN0?$AA@ DB '(I'
	DB	'nVSize&(InVSize-1))==0', 00H		; `string'
; Function compile flags: /Ogty
; File C:\duke4\Fire\Src\UnFractal.cpp
_DATA	ENDS
;	COMDAT ?Init@UFractalTexture@@UAEXHH@Z
_TEXT	SEGMENT
_InUSize$ = 8
_InVSize$ = 12
_this$ = -4
?Init@UFractalTexture@@UAEXHH@Z PROC NEAR		; UFractalTexture::Init, COMDAT
; _this$ = ecx

; 3891 : {

  00000	51		 push	 ecx

; 3892 : 	VERIFY_CLASS_OFFSET(U,FractalTexture,UMask); // verifies correct mirroring..

  00001	a1 18 00 00 00	 mov	 eax, DWORD PTR ?PrivateStaticClass@UFractalTexture@@0VUClass@@A+24
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	6a 00		 push	 0
  0000b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1BO@JBP@?$AAF?$AAr?$AAa?$AAc?$AAt?$AAa?$AAl?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@ ; `string'
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?PrivateStaticClass@UClass@@0V1@A
  00016	50		 push	 eax
  00017	89 4c 24 1c	 mov	 DWORD PTR _this$[esp+32], ecx
  0001b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?StaticFindObjectChecked@UObject@@SAPAV1@PAVUClass@@PAV1@PBGH@Z
  00021	8b f8		 mov	 edi, eax
  00023	83 c4 10	 add	 esp, 16			; 00000010H
  00026	85 ff		 test	 edi, edi
  00028	74 05		 je	 SHORT $L134257
  0002a	8b 77 40	 mov	 esi, DWORD PTR [edi+64]
  0002d	eb 02		 jmp	 SHORT $L134258
$L134257:
  0002f	33 f6		 xor	 esi, esi
$L134258:
  00031	85 ff		 test	 edi, edi
  00033	74 41		 je	 SHORT $L134350
$L134270:
  00035	85 f6		 test	 esi, esi
  00037	74 2b		 je	 SHORT $L134273
  00039	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?PrivateStaticClass@UProperty@@0VUClass@@A

; 3900 : }

  0003f	90		 npad	 1

; 3892 : 	VERIFY_CLASS_OFFSET(U,FractalTexture,UMask); // verifies correct mirroring..

$L134272:
  00040	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  00043	85 c0		 test	 eax, eax
  00045	74 0b		 je	 SHORT $L134266
$L134264:
  00047	3b c1		 cmp	 eax, ecx
  00049	74 2b		 je	 SHORT $L134350
  0004b	8b 40 28	 mov	 eax, DWORD PTR [eax+40]
  0004e	85 c0		 test	 eax, eax
  00050	75 f5		 jne	 SHORT $L134264
$L134266:
  00052	33 c0		 xor	 eax, eax
  00054	85 c9		 test	 ecx, ecx
  00056	0f 94 c0	 sete	 al
  00059	85 c0		 test	 eax, eax
  0005b	75 19		 jne	 SHORT $L134350
  0005d	8b 76 2c	 mov	 esi, DWORD PTR [esi+44]
  00060	85 f6		 test	 esi, esi
  00062	75 dc		 jne	 SHORT $L134272
$L134273:
  00064	8b 17		 mov	 edx, DWORD PTR [edi]
  00066	8b cf		 mov	 ecx, edi
  00068	ff 52 5c	 call	 DWORD PTR [edx+92]
  0006b	8b f8		 mov	 edi, eax
  0006d	85 ff		 test	 edi, edi
  0006f	74 05		 je	 SHORT $L134350
  00071	8b 77 40	 mov	 esi, DWORD PTR [edi+64]
  00074	eb bf		 jmp	 SHORT $L134270
$L134350:
  00076	85 f6		 test	 esi, esi
  00078	0f 84 b1 00 00
	00		 je	 $L124682
  0007e	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp_?Logf@FOutputDevice@@QAAXPBGZZ
  00084	55		 push	 ebp
  00085	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp_?appStricmp@@YAHPBG0@Z

; 3900 : }

  0008b	90 8d 64 24 00	 npad	 5

; 3892 : 	VERIFY_CLASS_OFFSET(U,FractalTexture,UMask); // verifies correct mirroring..

$L134327:
  00090	8b 06		 mov	 eax, DWORD PTR [esi]
  00092	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1M@BHOC@?$AAU?$AAM?$AAa?$AAs?$AAk?$AA?$AA@ ; `string'
  00097	8b ce		 mov	 ecx, esi
  00099	ff 50 44	 call	 DWORD PTR [eax+68]
  0009c	50		 push	 eax
  0009d	ff d5		 call	 ebp
  0009f	83 c4 08	 add	 esp, 8
  000a2	85 c0		 test	 eax, eax
  000a4	75 2d		 jne	 SHORT $L124681
  000a6	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  000a9	3d c8 00 00 00	 cmp	 eax, 200		; 000000c8H
  000ae	74 23		 je	 SHORT $L124681
  000b0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?GError@@3PAVFOutputDeviceError@@A
  000b6	8b 11		 mov	 edx, DWORD PTR [ecx]
  000b8	68 c8 00 00 00	 push	 200			; 000000c8H
  000bd	50		 push	 eax
  000be	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1M@BHOC@?$AAU?$AAM?$AAa?$AAs?$AAk?$AA?$AA@ ; `string'
  000c3	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1BO@JBP@?$AAF?$AAr?$AAa?$AAc?$AAt?$AAa?$AAl?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@ ; `string'
  000c8	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1FK@OIBJ@?$AAC?$AAl?$AAa?$AAs?$AAs?$AA?5?$AA?$CF?$AAs?$AA?5?$AAM?$AAe?$AAm?$AAb?$AAe?$AAr?$AA?5?$AA?$CF?$AAs?$AA?5?$AAp@ ; `string'
  000cd	52		 push	 edx
  000ce	ff d3		 call	 ebx
  000d0	83 c4 18	 add	 esp, 24			; 00000018H
$L124681:
  000d3	85 ff		 test	 edi, edi
  000d5	8b 76 2c	 mov	 esi, DWORD PTR [esi+44]
  000d8	74 4c		 je	 SHORT $L134352

; 3900 : }

  000da	8d 9b 00 00 00
	00		 npad	 6

; 3892 : 	VERIFY_CLASS_OFFSET(U,FractalTexture,UMask); // verifies correct mirroring..

$L134321:
  000e0	85 f6		 test	 esi, esi
  000e2	74 30		 je	 SHORT $L134324
  000e4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?PrivateStaticClass@UProperty@@0VUClass@@A

; 3900 : }

  000ea	8d 9b 00 00 00
	00		 npad	 6

; 3892 : 	VERIFY_CLASS_OFFSET(U,FractalTexture,UMask); // verifies correct mirroring..

$L134323:
  000f0	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  000f3	85 c0		 test	 eax, eax
  000f5	74 0b		 je	 SHORT $L134317
$L134315:
  000f7	3b c1		 cmp	 eax, ecx
  000f9	74 2b		 je	 SHORT $L134352
  000fb	8b 40 28	 mov	 eax, DWORD PTR [eax+40]
  000fe	85 c0		 test	 eax, eax
  00100	75 f5		 jne	 SHORT $L134315
$L134317:
  00102	33 c0		 xor	 eax, eax
  00104	85 c9		 test	 ecx, ecx
  00106	0f 94 c0	 sete	 al
  00109	85 c0		 test	 eax, eax
  0010b	75 19		 jne	 SHORT $L134352
  0010d	8b 76 2c	 mov	 esi, DWORD PTR [esi+44]
  00110	85 f6		 test	 esi, esi
  00112	75 dc		 jne	 SHORT $L134323
$L134324:
  00114	8b 07		 mov	 eax, DWORD PTR [edi]
  00116	8b cf		 mov	 ecx, edi
  00118	ff 50 5c	 call	 DWORD PTR [eax+92]
  0011b	8b f8		 mov	 edi, eax
  0011d	85 ff		 test	 edi, edi
  0011f	74 05		 je	 SHORT $L134352
  00121	8b 77 40	 mov	 esi, DWORD PTR [edi+64]
  00124	eb ba		 jmp	 SHORT $L134321
$L134352:
  00126	85 f6		 test	 esi, esi
  00128	0f 85 62 ff ff
	ff		 jne	 $L134327
  0012e	5d		 pop	 ebp
$L124682:

; 3893 : 
; 3894 : 	// Proper-powers-of-two verification.
; 3895 : 	check((InUSize&(InUSize-1))==0); 

  0012f	8b 74 24 14	 mov	 esi, DWORD PTR _InUSize$[esp+12]
  00133	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp_?appFailAssert@@YAXPBD0H@Z
  00139	8d 4e ff	 lea	 ecx, DWORD PTR [esi-1]
  0013c	85 ce		 test	 ecx, esi
  0013e	74 14		 je	 SHORT $L124691
  00140	68 37 0f 00 00	 push	 3895			; 00000f37H
  00145	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CA@CDIN@C?3?2duke4?2Fire?2Src?2UnFractal?4cpp?$AA@ ; `string'
  0014a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BJ@LFBK@?$CIInUSize?$CG?$CIInUSize?91?$CJ?$CJ?$DN?$DN0?$AA@ ; `string'
  0014f	ff d3		 call	 ebx
  00151	83 c4 0c	 add	 esp, 12			; 0000000cH
$L124691:

; 3896 : 	check((InVSize&(InVSize-1))==0);

  00154	8b 7c 24 18	 mov	 edi, DWORD PTR _InVSize$[esp+12]
  00158	8d 57 ff	 lea	 edx, DWORD PTR [edi-1]
  0015b	85 d7		 test	 edx, edi
  0015d	74 14		 je	 SHORT $L124694
  0015f	68 38 0f 00 00	 push	 3896			; 00000f38H
  00164	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CA@CDIN@C?3?2duke4?2Fire?2Src?2UnFractal?4cpp?$AA@ ; `string'
  00169	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BJ@LDOB@?$CIInVSize?$CG?$CIInVSize?91?$CJ?$CJ?$DN?$DN0?$AA@ ; `string'
  0016e	ff d3		 call	 ebx
  00170	83 c4 0c	 add	 esp, 12			; 0000000cH
$L124694:

; 3897 : 
; 3898 : 	// Init base class.
; 3899 : 	UTexture::Init( InUSize, InVSize );

  00173	8b 4c 24 0c	 mov	 ecx, DWORD PTR _this$[esp+16]
  00177	57		 push	 edi
  00178	56		 push	 esi
  00179	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Init@UTexture@@UAEXHH@Z
  0017f	5f		 pop	 edi
  00180	5e		 pop	 esi
  00181	5b		 pop	 ebx

; 3900 : }

  00182	59		 pop	 ecx
  00183	c2 08 00	 ret	 8
?Init@UFractalTexture@@UAEXHH@Z ENDP			; UFractalTexture::Init
_TEXT	ENDS
EXTRN	__imp_?PostLoad@UTexture@@UAEXXZ:NEAR
; Function compile flags: /Ogty
;	COMDAT ?PostLoad@UFractalTexture@@UAEXXZ
_TEXT	SEGMENT
?PostLoad@UFractalTexture@@UAEXXZ PROC NEAR		; UFractalTexture::PostLoad, COMDAT
; _this$ = ecx

; 3904 : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 3905 : 	Super::PostLoad();

  00003	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?PostLoad@UTexture@@UAEXXZ

; 3906 : 
; 3907 : 	UMask = USize - 1;

  00009	8b 46 34	 mov	 eax, DWORD PTR [esi+52]

; 3908 : 	VMask = VSize - 1;

  0000c	8b 4e 38	 mov	 ecx, DWORD PTR [esi+56]
  0000f	48		 dec	 eax
  00010	49		 dec	 ecx
  00011	89 86 c8 00 00
	00		 mov	 DWORD PTR [esi+200], eax
  00017	89 8e cc 00 00
	00		 mov	 DWORD PTR [esi+204], ecx
  0001d	5e		 pop	 esi

; 3909 : }

  0001e	c3		 ret	 0
?PostLoad@UFractalTexture@@UAEXXZ ENDP			; UFractalTexture::PostLoad
_TEXT	ENDS
PUBLIC	??_C@_1CA@OMBM@?$AAU?$AAF?$AAr?$AAa?$AAc?$AAt?$AAa?$AAl?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1O@KHFL@?$AAS?$AAy?$AAs?$AAt?$AAe?$AAm?$AA?$AA@ ; `string'
EXTRN	_atexit:NEAR
EXTRN	__imp_?PrivateStaticClass@UObject@@0VUClass@@A:BYTE
EXTRN	__imp_?PrivateStaticClass@UProceduralTexture@@0VUClass@@A:BYTE
EXTRN	__imp_??0UClass@@QAE@W4ENativeConstructor@@KKPAV0@1VFGuid@@PBG33KP6AXPAX@ZP8UObject@@AEXXZ@Z:NEAR
EXTRN	__imp_?InternalConstructor@UTexture@@SAXPAX@Z:NEAR
EXTRN	__imp_?StaticConstructor@UObject@@QAEXXZ:NEAR
;	COMDAT ??_C@_1O@KHFL@?$AAS?$AAy?$AAs?$AAt?$AAe?$AAm?$AA?$AA@
_DATA	SEGMENT
??_C@_1O@KHFL@?$AAS?$AAy?$AAs?$AAt?$AAe?$AAm?$AA?$AA@ DB 'S', 00H, 'y', 00H
	DB	's', 00H, 't', 00H, 'e', 00H, 'm', 00H, 00H, 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_1CA@OMBM@?$AAU?$AAF?$AAr?$AAa?$AAc?$AAt?$AAa?$AAl?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@
_DATA	SEGMENT
??_C@_1CA@OMBM@?$AAU?$AAF?$AAr?$AAa?$AAc?$AAt?$AAa?$AAl?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@ DB 'U'
	DB	00H, 'F', 00H, 'r', 00H, 'a', 00H, 'c', 00H, 't', 00H, 'a', 00H
	DB	'l', 00H, 'T', 00H, 'e', 00H, 'x', 00H, 't', 00H, 'u', 00H, 'r'
	DB	00H, 'e', 00H, 00H, 00H			; `string'
; Function compile flags: /Ogty
_DATA	ENDS
;	COMDAT _$E188
_TEXT	SEGMENT
_$E188	PROC NEAR					; COMDAT
  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?StaticConstructor@UObject@@QAEXXZ
  00005	53		 push	 ebx
  00006	55		 push	 ebp
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	83 ec 10	 sub	 esp, 16			; 00000010H
  0000c	8b ec		 mov	 ebp, esp
  0000e	89 45 00	 mov	 DWORD PTR [ebp], eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?InternalConstructor@UTexture@@SAXPAX@Z
  00016	50		 push	 eax
  00017	68 04 40 08 04	 push	 67649540		; 04084004H
  0001c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1O@KHFL@?$AAS?$AAy?$AAs?$AAt?$AAe?$AAm?$AA?$AA@ ; `string'
  00021	68 00 00 00 00	 push	 OFFSET FLAT:_GPackage
  00026	33 c9		 xor	 ecx, ecx
  00028	89 4d 04	 mov	 DWORD PTR [ebp+4], ecx
  0002b	68 02 00 00 00	 push	 OFFSET FLAT:??_C@_1CA@OMBM@?$AAU?$AAF?$AAr?$AAa?$AAc?$AAt?$AAa?$AAl?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@+2
  00030	83 ec 10	 sub	 esp, 16			; 00000010H
  00033	8b cc		 mov	 ecx, esp
  00035	33 d2		 xor	 edx, edx
  00037	89 55 08	 mov	 DWORD PTR [ebp+8], edx
  0003a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR __imp_?PrivateStaticClass@UObject@@0VUClass@@A
  00040	33 f6		 xor	 esi, esi
  00042	89 75 0c	 mov	 DWORD PTR [ebp+12], esi
  00045	33 ff		 xor	 edi, edi
  00047	89 39		 mov	 DWORD PTR [ecx], edi
  00049	33 db		 xor	 ebx, ebx
  0004b	89 59 04	 mov	 DWORD PTR [ecx+4], ebx
  0004e	33 c0		 xor	 eax, eax
  00050	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00053	52		 push	 edx
  00054	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  00057	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?PrivateStaticClass@UProceduralTexture@@0VUClass@@A
  0005c	50		 push	 eax
  0005d	6a 01		 push	 1
  0005f	68 e0 00 00 00	 push	 224			; 000000e0H
  00064	53		 push	 ebx
  00065	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?PrivateStaticClass@UFractalTexture@@0VUClass@@A
  0006a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0UClass@@QAE@W4ENativeConstructor@@KKPAV0@1VFGuid@@PBG33KP6AXPAX@ZP8UObject@@AEXXZ@Z
  00070	68 00 00 00 00	 push	 OFFSET FLAT:_$E185
  00075	e8 00 00 00 00	 call	 _atexit
  0007a	83 c4 04	 add	 esp, 4
  0007d	5f		 pop	 edi
  0007e	5e		 pop	 esi
  0007f	5d		 pop	 ebp
  00080	5b		 pop	 ebx
  00081	c3		 ret	 0
_$E188	ENDP
_TEXT	ENDS
EXTRN	__imp_??1UClass@@UAE@XZ:NEAR
_BSS	SEGMENT
_$S186	DB	01H DUP (?)
; Function compile flags: /Ogty
_BSS	ENDS
;	COMDAT _$E185
_TEXT	SEGMENT
_$E185	PROC NEAR					; COMDAT
  00000	8a 0d 00 00 00
	00		 mov	 cl, BYTE PTR _$S186
  00006	b0 01		 mov	 al, 1
  00008	84 c8		 test	 cl, al
  0000a	75 13		 jne	 SHORT $L124711
  0000c	0a c8		 or	 cl, al
  0000e	88 0d 00 00 00
	00		 mov	 BYTE PTR _$S186, cl
  00014	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?PrivateStaticClass@UFractalTexture@@0VUClass@@A
  00019	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1UClass@@UAE@XZ
$L124711:
  0001f	c3		 ret	 0
_$E185	ENDP
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT _$E191
_TEXT	SEGMENT
_$E191	PROC NEAR					; COMDAT
  00000	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _autoclassUFractalTexture, OFFSET FLAT:?PrivateStaticClass@UFractalTexture@@0VUClass@@A ; UFractalTexture::PrivateStaticClass
  0000a	c3		 ret	 0
_$E191	ENDP
_TEXT	ENDS
PUBLIC	??0UFireTexture@@QAE@XZ				; UFireTexture::UFireTexture
PUBLIC	?PostLoad@UFireTexture@@UAEXXZ			; UFireTexture::PostLoad
PUBLIC	?Serialize@UFireTexture@@UAEXAAVFArchive@@@Z	; UFireTexture::Serialize
PUBLIC	?Init@UFireTexture@@UAEXHH@Z			; UFireTexture::Init
PUBLIC	?Clear@UFireTexture@@UAEXK@Z			; UFireTexture::Clear
PUBLIC	?ConstantTimeTick@UFireTexture@@UAEXXZ		; UFireTexture::ConstantTimeTick
PUBLIC	?MousePosition@UFireTexture@@UAEXKMM@Z		; UFireTexture::MousePosition
PUBLIC	?Click@UFireTexture@@UAEXKMM@Z			; UFireTexture::Click
PUBLIC	?TouchTexture@UFireTexture@@UAEXHHM@Z		; UFireTexture::TouchTexture
PUBLIC	??_7UFireTexture@@6B@				; UFireTexture::`vftable'
PUBLIC	??_EUFireTexture@@UAEPAXI@Z			; UFireTexture::`vector deleting destructor'
;	COMDAT ??_7UFireTexture@@6B@
; File ..\..\Core\Inc\UnTemplate.h
CONST	SEGMENT
??_7UFireTexture@@6B@ DD FLAT:??_EUFireTexture@@UAEPAXI@Z ; UFireTexture::`vftable'
	DD	FLAT:?ProcessEvent@UObject@@UAEXPAVUFunction@@PAX1@Z
	DD	FLAT:?ProcessState@UObject@@UAEXM@Z
	DD	FLAT:?ProcessRemoteFunction@UObject@@UAEHPAVUFunction@@PAXPAUFFrame@@@Z
	DD	FLAT:?Modify@UObject@@UAEXXZ
	DD	FLAT:?PostLoad@UFireTexture@@UAEXXZ
	DD	FLAT:?Destroy@UTexture@@UAEXXZ
	DD	FLAT:?Serialize@UFireTexture@@UAEXAAVFArchive@@@Z
	DD	FLAT:?IsPendingKill@UObject@@UAEHXZ
	DD	FLAT:?GotoLabel@UObject@@UAEHVFName@@@Z
	DD	FLAT:?InitExecution@UObject@@UAEXXZ
	DD	FLAT:?ShutdownAfterError@UObject@@UAEXXZ
	DD	FLAT:?PostEditChange@UFractalTexture@@UAEXXZ
	DD	FLAT:?CallFunction@UObject@@UAEXAAUFFrame@@QAXPAVUFunction@@@Z
	DD	FLAT:?ScriptConsoleExec@UObject@@UAEHPBGAAVFOutputDevice@@PAV1@@Z
	DD	FLAT:?Register@UObject@@UAEXXZ
	DD	FLAT:?LanguageChange@UObject@@UAEXXZ
	DD	FLAT:?GetName@UObject@@UBEPBGXZ
	DD	FLAT:?Lock@UTexture@@UAIXAAUFTextureInfo@@NHPAVURenderDevice@@@Z
	DD	FLAT:?Unlock@UTexture@@UAIXAAUFTextureInfo@@@Z
	DD	FLAT:?GetMip@UTexture@@UAEPAUFMipmapBase@@H@Z
	DD	FLAT:?Clear@UFireTexture@@UAEXK@Z
	DD	FLAT:?Init@UFireTexture@@UAEXHH@Z
	DD	FLAT:?Tick@UTexture@@UAIXM@Z
	DD	FLAT:?ConstantTimeTick@UFireTexture@@UAEXXZ
	DD	FLAT:?MousePosition@UFireTexture@@UAEXKMM@Z
	DD	FLAT:?Click@UFireTexture@@UAEXKMM@Z
	DD	FLAT:?Update@UTexture@@UAEXN@Z
	DD	FLAT:?TouchTexture@UFireTexture@@UAEXHHM@Z
; Function compile flags: /Ogty
; File C:\duke4\Fire\Src\UnFractal.cpp
CONST	ENDS
;	COMDAT ??0UFireTexture@@QAE@XZ
_TEXT	SEGMENT
??0UFireTexture@@QAE@XZ PROC NEAR			; UFireTexture::UFireTexture, COMDAT
; _this$ = ecx

; 3921 : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0UTexture@@QAE@XZ
  00009	8b 86 88 00 00
	00		 mov	 eax, DWORD PTR [esi+136]
  0000f	83 c8 0c	 or	 eax, 12			; 0000000cH
  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7UFractalTexture@@6B@ ; UFractalTexture::`vftable'
  00018	89 86 88 00 00
	00		 mov	 DWORD PTR [esi+136], eax
  0001e	e8 00 00 00 00	 call	 ?InitTables@@YAXXZ	; InitTables
  00023	33 c0		 xor	 eax, eax
  00025	88 86 dc 00 00
	00		 mov	 BYTE PTR [esi+220], al
  0002b	89 86 d8 00 00
	00		 mov	 DWORD PTR [esi+216], eax
  00031	89 86 fc 00 00
	00		 mov	 DWORD PTR [esi+252], eax
  00037	89 86 00 01 00
	00		 mov	 DWORD PTR [esi+256], eax
  0003d	89 86 04 01 00
	00		 mov	 DWORD PTR [esi+260], eax

; 3922 :     // Init all non-serialized variables. 
; 3923 : 
; 3924 : 	OldRenderHeat  =  -1; 
; 3925 : 	AuxPhase       =   0;

  00043	88 86 dd 00 00
	00		 mov	 BYTE PTR [esi+221], al
  00049	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7UFireTexture@@6B@ ; UFireTexture::`vftable'
  0004f	c7 86 08 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [esi+264], -1

; 3926 : 	StarStatus	   =   1; // Assume some stars until, we find otherwise.

  00059	c6 86 10 05 00
	00 01		 mov	 BYTE PTR [esi+1296], 1

; 3927 : 
; 3928 : 	// initialize the routines we should call for rising/nonrising fire;
; 3929 : 	// one for Pentium/MMX es and one for Ppro/PII's
; 3930 : 
; 3931 : 	//void (*MergePass)( INT Y, INT X, INT InnerX );
; 3932 : 
; 3933 : }

  00060	8b c6		 mov	 eax, esi
  00062	5e		 pop	 esi
  00063	c3		 ret	 0
??0UFireTexture@@QAE@XZ ENDP				; UFireTexture::UFireTexture
_TEXT	ENDS
PUBLIC	??_SUPalette@@6B@				; UPalette::`local vftable'
PUBLIC	??_GUPalette@@UAEPAXI@Z				; UPalette::`scalar deleting destructor'
PUBLIC	??_EUPalette@@UAEPAXI@Z				; UPalette::`vector deleting destructor'
PUBLIC	??_C@_1BI@MMMC@?$AAF?$AAi?$AAr?$AAe?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BE@GEFN@?$AAS?$AAp?$AAa?$AAr?$AAk?$AAT?$AAy?$AAp?$AAe?$AA?$AA@ ; `string'
EXTRN	__imp_?StaticAllocateObject@UObject@@SAPAV1@PAVUClass@@PAV1@VFName@@K1PAVFOutputDevice@@1@Z:NEAR
EXTRN	?Serialize@UPalette@@UAEXAAVFArchive@@@Z:NEAR	; UPalette::Serialize
EXTRN	__imp_?GetOuter@UObject@@QBEPAV1@XZ:NEAR
EXTRN	__imp_?Realloc@FArray@@IAEXH@Z:NEAR
EXTRN	__imp_?PrivateStaticClass@UPalette@@0VUClass@@A:BYTE
EXTRN	__imp_??0UPalette@@QAE@XZ:NEAR
EXTRN	__imp_??0FName@@QAE@W4EName@@@Z:NEAR
EXTRN	?PostLoad@UObject@@UAEXXZ:NEAR			; UObject::PostLoad
EXTRN	?Destroy@UObject@@UAEXXZ:NEAR			; UObject::Destroy
EXTRN	?PostEditChange@UObject@@UAEXXZ:NEAR		; UObject::PostEditChange
;	COMDAT ??_C@_1BI@MMMC@?$AAF?$AAi?$AAr?$AAe?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@
; File ..\..\Core\Inc\UnFile.h
_DATA	SEGMENT
??_C@_1BI@MMMC@?$AAF?$AAi?$AAr?$AAe?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@ DB 'F'
	DB	00H, 'i', 00H, 'r', 00H, 'e', 00H, 'T', 00H, 'e', 00H, 'x', 00H
	DB	't', 00H, 'u', 00H, 'r', 00H, 'e', 00H, 00H, 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_1BE@GEFN@?$AAS?$AAp?$AAa?$AAr?$AAk?$AAT?$AAy?$AAp?$AAe?$AA?$AA@
_DATA	SEGMENT
??_C@_1BE@GEFN@?$AAS?$AAp?$AAa?$AAr?$AAk?$AAT?$AAy?$AAp?$AAe?$AA?$AA@ DB 'S'
	DB	00H, 'p', 00H, 'a', 00H, 'r', 00H, 'k', 00H, 'T', 00H, 'y', 00H
	DB	'p', 00H, 'e', 00H, 00H, 00H			; `string'
_DATA	ENDS
;	COMDAT ??_SUPalette@@6B@
CONST	SEGMENT
??_SUPalette@@6B@ DD FLAT:??_EUPalette@@UAEPAXI@Z	; UPalette::`local vftable'
	DD	FLAT:?ProcessEvent@UObject@@UAEXPAVUFunction@@PAX1@Z
	DD	FLAT:?ProcessState@UObject@@UAEXM@Z
	DD	FLAT:?ProcessRemoteFunction@UObject@@UAEHPAVUFunction@@PAXPAUFFrame@@@Z
	DD	FLAT:?Modify@UObject@@UAEXXZ
	DD	FLAT:?PostLoad@UObject@@UAEXXZ
	DD	FLAT:?Destroy@UObject@@UAEXXZ
	DD	FLAT:?Serialize@UPalette@@UAEXAAVFArchive@@@Z
	DD	FLAT:?IsPendingKill@UObject@@UAEHXZ
	DD	FLAT:?GotoLabel@UObject@@UAEHVFName@@@Z
	DD	FLAT:?InitExecution@UObject@@UAEXXZ
	DD	FLAT:?ShutdownAfterError@UObject@@UAEXXZ
	DD	FLAT:?PostEditChange@UObject@@UAEXXZ
	DD	FLAT:?CallFunction@UObject@@UAEXAAUFFrame@@QAXPAVUFunction@@@Z
	DD	FLAT:?ScriptConsoleExec@UObject@@UAEHPBGAAVFOutputDevice@@PAV1@@Z
	DD	FLAT:?Register@UObject@@UAEXXZ
	DD	FLAT:?LanguageChange@UObject@@UAEXXZ
	DD	FLAT:?GetName@UObject@@UBEPBGXZ
; Function compile flags: /Ogty
; File C:\duke4\Fire\Src\UnFractal.cpp
CONST	ENDS
;	COMDAT ?Init@UFireTexture@@UAEXHH@Z
_TEXT	SEGMENT
$T134587 = 12
_InUSize$ = 8
_InVSize$ = 12
_this$ = -4
?Init@UFireTexture@@UAEXHH@Z PROC NEAR			; UFireTexture::Init, COMDAT
; _this$ = ecx

; 3940 : {

  00000	51		 push	 ecx

; 3941 : 	VERIFY_CLASS_OFFSET(U,FireTexture,SparkType);

  00001	a1 18 00 00 00	 mov	 eax, DWORD PTR ?PrivateStaticClass@UFireTexture@@0VUClass@@A+24
  00006	53		 push	 ebx
  00007	55		 push	 ebp
  00008	56		 push	 esi
  00009	57		 push	 edi
  0000a	6a 00		 push	 0
  0000c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1BI@MMMC@?$AAF?$AAi?$AAr?$AAe?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@ ; `string'
  00011	50		 push	 eax
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?PrivateStaticClass@UClass@@0V1@A
  00017	8b f9		 mov	 edi, ecx
  00019	50		 push	 eax
  0001a	89 7c 24 20	 mov	 DWORD PTR _this$[esp+36], edi
  0001e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?StaticFindObjectChecked@UObject@@SAPAV1@PAVUClass@@PAV1@PBGH@Z
  00024	8b d8		 mov	 ebx, eax
  00026	83 c4 10	 add	 esp, 16			; 00000010H
  00029	85 db		 test	 ebx, ebx
  0002b	74 05		 je	 SHORT $L134493
  0002d	8b 73 40	 mov	 esi, DWORD PTR [ebx+64]
  00030	eb 02		 jmp	 SHORT $L134494
$L134493:
  00032	33 f6		 xor	 esi, esi
$L134494:
  00034	85 db		 test	 ebx, ebx
  00036	74 47		 je	 SHORT $L134655
$L134506:
  00038	85 f6		 test	 esi, esi
  0003a	74 31		 je	 SHORT $L134509
  0003c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?PrivateStaticClass@UProperty@@0VUClass@@A
$L134508:
  00042	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  00045	85 c0		 test	 eax, eax
  00047	74 12		 je	 SHORT $L134502

; 3969 : }

  00049	8d a4 24 00 00
	00 00		 npad	 7

; 3941 : 	VERIFY_CLASS_OFFSET(U,FireTexture,SparkType);

$L134500:
  00050	3b c1		 cmp	 eax, ecx
  00052	74 2b		 je	 SHORT $L134655
  00054	8b 40 28	 mov	 eax, DWORD PTR [eax+40]
  00057	85 c0		 test	 eax, eax
  00059	75 f5		 jne	 SHORT $L134500
$L134502:
  0005b	33 c0		 xor	 eax, eax
  0005d	85 c9		 test	 ecx, ecx
  0005f	0f 94 c0	 sete	 al
  00062	85 c0		 test	 eax, eax
  00064	75 19		 jne	 SHORT $L134655
  00066	8b 76 2c	 mov	 esi, DWORD PTR [esi+44]
  00069	85 f6		 test	 esi, esi
  0006b	75 d5		 jne	 SHORT $L134508
$L134509:
  0006d	8b 13		 mov	 edx, DWORD PTR [ebx]
  0006f	8b cb		 mov	 ecx, ebx
  00071	ff 52 5c	 call	 DWORD PTR [edx+92]
  00074	8b d8		 mov	 ebx, eax
  00076	85 db		 test	 ebx, ebx
  00078	74 05		 je	 SHORT $L134655
  0007a	8b 73 40	 mov	 esi, DWORD PTR [ebx+64]
  0007d	eb b9		 jmp	 SHORT $L134506
$L134655:
  0007f	85 f6		 test	 esi, esi
  00081	0f 84 ab 00 00
	00		 je	 $L124745
  00087	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp_?appStricmp@@YAHPBG0@Z
  0008d	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp_?Logf@FOutputDevice@@QAAXPBGZZ
$L134563:
  00093	8b 06		 mov	 eax, DWORD PTR [esi]
  00095	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1BE@GEFN@?$AAS?$AAp?$AAa?$AAr?$AAk?$AAT?$AAy?$AAp?$AAe?$AA?$AA@ ; `string'
  0009a	8b ce		 mov	 ecx, esi
  0009c	ff 50 44	 call	 DWORD PTR [eax+68]
  0009f	50		 push	 eax
  000a0	ff d7		 call	 edi
  000a2	83 c4 08	 add	 esp, 8
  000a5	85 c0		 test	 eax, eax
  000a7	75 2d		 jne	 SHORT $L124744
  000a9	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  000ac	3d e0 00 00 00	 cmp	 eax, 224		; 000000e0H
  000b1	74 23		 je	 SHORT $L124744
  000b3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?GError@@3PAVFOutputDeviceError@@A
  000b9	8b 11		 mov	 edx, DWORD PTR [ecx]
  000bb	68 e0 00 00 00	 push	 224			; 000000e0H
  000c0	50		 push	 eax
  000c1	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1BE@GEFN@?$AAS?$AAp?$AAa?$AAr?$AAk?$AAT?$AAy?$AAp?$AAe?$AA?$AA@ ; `string'
  000c6	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1BI@MMMC@?$AAF?$AAi?$AAr?$AAe?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@ ; `string'
  000cb	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1FK@OIBJ@?$AAC?$AAl?$AAa?$AAs?$AAs?$AA?5?$AA?$CF?$AAs?$AA?5?$AAM?$AAe?$AAm?$AAb?$AAe?$AAr?$AA?5?$AA?$CF?$AAs?$AA?5?$AAp@ ; `string'
  000d0	52		 push	 edx
  000d1	ff d5		 call	 ebp
  000d3	83 c4 18	 add	 esp, 24			; 00000018H
$L124744:
  000d6	85 db		 test	 ebx, ebx
  000d8	8b 76 2c	 mov	 esi, DWORD PTR [esi+44]
  000db	74 49		 je	 SHORT $L134657

; 3969 : }

  000dd	8d 49 00	 npad	 3

; 3941 : 	VERIFY_CLASS_OFFSET(U,FireTexture,SparkType);

$L134557:
  000e0	85 f6		 test	 esi, esi
  000e2	74 30		 je	 SHORT $L134560
  000e4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?PrivateStaticClass@UProperty@@0VUClass@@A

; 3969 : }

  000ea	8d 9b 00 00 00
	00		 npad	 6

; 3941 : 	VERIFY_CLASS_OFFSET(U,FireTexture,SparkType);

$L134559:
  000f0	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  000f3	85 c0		 test	 eax, eax
  000f5	74 0b		 je	 SHORT $L134553
$L134551:
  000f7	3b c1		 cmp	 eax, ecx
  000f9	74 2b		 je	 SHORT $L134657
  000fb	8b 40 28	 mov	 eax, DWORD PTR [eax+40]
  000fe	85 c0		 test	 eax, eax
  00100	75 f5		 jne	 SHORT $L134551
$L134553:
  00102	33 c0		 xor	 eax, eax
  00104	85 c9		 test	 ecx, ecx
  00106	0f 94 c0	 sete	 al
  00109	85 c0		 test	 eax, eax
  0010b	75 19		 jne	 SHORT $L134657
  0010d	8b 76 2c	 mov	 esi, DWORD PTR [esi+44]
  00110	85 f6		 test	 esi, esi
  00112	75 dc		 jne	 SHORT $L134559
$L134560:
  00114	8b 03		 mov	 eax, DWORD PTR [ebx]
  00116	8b cb		 mov	 ecx, ebx
  00118	ff 50 5c	 call	 DWORD PTR [eax+92]
  0011b	8b d8		 mov	 ebx, eax
  0011d	85 db		 test	 ebx, ebx
  0011f	74 05		 je	 SHORT $L134657
  00121	8b 73 40	 mov	 esi, DWORD PTR [ebx+64]
  00124	eb ba		 jmp	 SHORT $L134557
$L134657:
  00126	85 f6		 test	 esi, esi
  00128	0f 85 65 ff ff
	ff		 jne	 $L134563
  0012e	8b 7c 24 10	 mov	 edi, DWORD PTR _this$[esp+20]
$L124745:

; 3942 : 
; 3943 : 	// Init base class.
; 3944 : 	UFractalTexture::Init( InUSize, InVSize );

  00132	8b 4c 24 1c	 mov	 ecx, DWORD PTR _InVSize$[esp+16]
  00136	8b 54 24 18	 mov	 edx, DWORD PTR _InUSize$[esp+16]
  0013a	51		 push	 ecx
  0013b	52		 push	 edx
  0013c	8b cf		 mov	 ecx, edi
  0013e	e8 00 00 00 00	 call	 ?Init@UFractalTexture@@UAEXHH@Z ; UFractalTexture::Init

; 3945 : 
; 3946 : 	// Create a custom palette.
; 3947 : 	Palette = new( GetOuter() )UPalette;

  00143	6a 00		 push	 0
  00145	8d 4c 24 20	 lea	 ecx, DWORD PTR $T134587[esp+20]
  00149	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0FName@@QAE@W4EName@@@Z
  0014f	8b cf		 mov	 ecx, edi
  00151	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetOuter@UObject@@QBEPAV1@XZ
  00157	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?GError@@3PAVFOutputDeviceError@@A
  0015d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0015f	8b 4c 24 1c	 mov	 ecx, DWORD PTR $T134587[esp+16]
  00163	6a 00		 push	 0
  00165	52		 push	 edx
  00166	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR __imp_?PrivateStaticClass@UPalette@@0VUClass@@A
  0016c	6a 00		 push	 0
  0016e	6a 00		 push	 0
  00170	51		 push	 ecx
  00171	50		 push	 eax
  00172	52		 push	 edx
  00173	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?StaticAllocateObject@UObject@@SAPAV1@PAVUClass@@PAV1@VFName@@K1PAVFOutputDevice@@1@Z
  00179	8b f0		 mov	 esi, eax
  0017b	83 c4 1c	 add	 esp, 28			; 0000001cH
  0017e	85 f6		 test	 esi, esi
  00180	74 10		 je	 SHORT $L134439
  00182	8b ce		 mov	 ecx, esi
  00184	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0UPalette@@QAE@XZ
  0018a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_SUPalette@@6B@ ; UPalette::`local vftable'
  00190	eb 02		 jmp	 SHORT $L134440
$L134439:
  00192	33 f6		 xor	 esi, esi
$L134440:

; 3948 : 	for( INT i=0; i<256; i++ )

  00194	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp_?Realloc@FArray@@IAEXH@Z
  0019a	89 77 2c	 mov	 DWORD PTR [edi+44], esi
  0019d	33 db		 xor	 ebx, ebx

; 3969 : }

  0019f	90		 npad	 1

; 3948 : 	for( INT i=0; i<256; i++ )

$L124761:

; 3949 : 		new(Palette->Colors)FColor(i,i,0);

  001a0	8b 77 2c	 mov	 esi, DWORD PTR [edi+44]
  001a3	8b 7e 2c	 mov	 edi, DWORD PTR [esi+44]
  001a6	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  001a9	83 c6 28	 add	 esi, 40			; 00000028H
  001ac	8d 4f 01	 lea	 ecx, DWORD PTR [edi+1]
  001af	3b c8		 cmp	 ecx, eax
  001b1	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  001b4	7e 19		 jle	 SHORT $L134604
  001b6	8d 04 49	 lea	 eax, DWORD PTR [ecx+ecx*2]
  001b9	99		 cdq
  001ba	83 e2 07	 and	 edx, 7
  001bd	03 c2		 add	 eax, edx
  001bf	c1 f8 03	 sar	 eax, 3
  001c2	8d 44 08 20	 lea	 eax, DWORD PTR [eax+ecx+32]
  001c6	6a 04		 push	 4
  001c8	8b ce		 mov	 ecx, esi
  001ca	89 46 08	 mov	 DWORD PTR [esi+8], eax
  001cd	ff d5		 call	 ebp
$L134604:
  001cf	8b 0e		 mov	 ecx, DWORD PTR [esi]
  001d1	8d 04 b9	 lea	 eax, DWORD PTR [ecx+edi*4]
  001d4	85 c0		 test	 eax, eax
  001d6	74 09		 je	 SHORT $L124762
  001d8	88 18		 mov	 BYTE PTR [eax], bl
  001da	88 58 01	 mov	 BYTE PTR [eax+1], bl
  001dd	c6 40 02 00	 mov	 BYTE PTR [eax+2], 0
$L124762:

; 3950 : 	BlueLagunaPalette(Palette);

  001e1	8b 7c 24 10	 mov	 edi, DWORD PTR _this$[esp+20]
  001e5	43		 inc	 ebx
  001e6	81 fb 00 01 00
	00		 cmp	 ebx, 256		; 00000100H
  001ec	7c b2		 jl	 SHORT $L124761
  001ee	8b 57 2c	 mov	 edx, DWORD PTR [edi+44]
  001f1	52		 push	 edx
  001f2	e8 00 00 00 00	 call	 ?BlueLagunaPalette@@YAXPAVUPalette@@@Z ; BlueLagunaPalette

; 3951 : 	MipZero    = Palette->Colors(128);

  001f7	8b 47 2c	 mov	 eax, DWORD PTR [edi+44]
  001fa	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  001fd	8b 91 00 02 00
	00		 mov	 edx, DWORD PTR [ecx+512]

; 3952 : 
; 3953 : 	// initialize all to-be-serialized variables
; 3954 :     RenderHeat  = 220;
; 3955 : 	ActiveSparkNum   =   0;
; 3956 :     SparkType   = SPARK_Blaze;
; 3957 : 	SparksLimit = MAXSPARKSINIT; // inital maximum

  00203	b8 00 04 00 00	 mov	 eax, 1024		; 00000400H
  00208	89 57 44	 mov	 DWORD PTR [edi+68], edx

; 3958 : 
; 3959 : 	//Allocate SparksLimit sparks:
; 3960 : 	Sparks.Add(SparksLimit);

  0020b	8d 8f fc 00 00
	00		 lea	 ecx, DWORD PTR [edi+252]
  00211	c6 87 e1 00 00
	00 dc		 mov	 BYTE PTR [edi+225], 220	; 000000dcH
  00218	c7 87 f8 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+248], 0
  00222	c6 87 e0 00 00
	00 04		 mov	 BYTE PTR [edi+224], 4
  00229	89 87 f4 00 00
	00		 mov	 DWORD PTR [edi+244], eax
  0022f	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00232	03 d0		 add	 edx, eax
  00234	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00237	8b f2		 mov	 esi, edx
  00239	83 c4 04	 add	 esp, 4
  0023c	3b f0		 cmp	 esi, eax
  0023e	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00241	7e 17		 jle	 SHORT $L134638
  00243	8d 04 76	 lea	 eax, DWORD PTR [esi+esi*2]
  00246	99		 cdq
  00247	83 e2 07	 and	 edx, 7
  0024a	03 c2		 add	 eax, edx
  0024c	c1 f8 03	 sar	 eax, 3
  0024f	8d 44 30 20	 lea	 eax, DWORD PTR [eax+esi+32]
  00253	6a 08		 push	 8
  00255	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00258	ff d5		 call	 ebp
$L134638:

; 3961 : 
; 3962 : 	FX_Frequency  =  16;

  0025a	b0 10		 mov	 al, 16			; 00000010H
  0025c	88 87 ec 00 00
	00		 mov	 BYTE PTR [edi+236], al

; 3963 : 	FX_Phase	  =  16;

  00262	88 87 ed 00 00
	00		 mov	 BYTE PTR [edi+237], al

; 3964 : 	FX_Heat		  = 255;

  00268	c6 87 e8 00 00
	00 ff		 mov	 BYTE PTR [edi+232], 255	; 000000ffH

; 3965 : 	FX_Size		  =  96;

  0026f	c6 87 e9 00 00
	00 60		 mov	 BYTE PTR [edi+233], 96	; 00000060H

; 3966 : 	FX_Area		  =  24;

  00276	c6 87 eb 00 00
	00 18		 mov	 BYTE PTR [edi+235], 24	; 00000018H

; 3967 : 	FX_HorizSpeed = 130;

  0027d	c6 87 ee 00 00
	00 82		 mov	 BYTE PTR [edi+238], 130	; 00000082H

; 3968 : 	FX_VertSpeed  = 142;

  00284	c6 87 ef 00 00
	00 8e		 mov	 BYTE PTR [edi+239], 142	; 0000008eH
  0028b	5f		 pop	 edi
  0028c	5e		 pop	 esi
  0028d	5d		 pop	 ebp
  0028e	5b		 pop	 ebx

; 3969 : }

  0028f	59		 pop	 ecx
  00290	c2 08 00	 ret	 8
?Init@UFireTexture@@UAEXHH@Z ENDP			; UFireTexture::Init
_TEXT	ENDS
EXTRN	__imp_?Clear@UTexture@@UAEXK@Z:NEAR
; Function compile flags: /Ogty
;	COMDAT ?Clear@UFireTexture@@UAEXK@Z
_TEXT	SEGMENT
_ClearFlags$ = 8
?Clear@UFireTexture@@UAEXK@Z PROC NEAR			; UFireTexture::Clear, COMDAT
; _this$ = ecx

; 3972 : {

  00000	53		 push	 ebx

; 3973 : 	// Init to zero.
; 3974 : 	UFractalTexture::Clear( ClearFlags );

  00001	8b 5c 24 08	 mov	 ebx, DWORD PTR _ClearFlags$[esp]
  00005	56		 push	 esi
  00006	53		 push	 ebx
  00007	8b f1		 mov	 esi, ecx
  00009	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Clear@UTexture@@UAEXK@Z

; 3975 : 
; 3976 : 	// Clear sparks.
; 3977 : 	if( ClearFlags & TCLEAR_Temporal )

  0000f	f6 c3 01	 test	 bl, 1
  00012	74 0e		 je	 SHORT $L124777

; 3978 : 	{
; 3979 : 		ActiveSparkNum=0;

  00014	33 c0		 xor	 eax, eax
  00016	89 86 f8 00 00
	00		 mov	 DWORD PTR [esi+248], eax

; 3980 : 		StarStatus=0;

  0001c	88 86 10 05 00
	00		 mov	 BYTE PTR [esi+1296], al
$L124777:
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx

; 3981 : 	}
; 3982 : }

  00024	c2 04 00	 ret	 4
?Clear@UFireTexture@@UAEXK@Z ENDP			; UFireTexture::Clear
_TEXT	ENDS
PUBLIC	??_C@_08GCAE@Index?$DO?$DN0?$AA@		; `string'
PUBLIC	??_C@_0BA@FEMP@Index?$DM?$DNArrayNum?$AA@	; `string'
PUBLIC	??_C@_0BG@BEDF@Index?$CLCount?$DM?$DNArrayNum?$AA@ ; `string'
PUBLIC	??_C@_0BM@MLGP@?4?4?2?4?4?2Core?2Inc?2UnTemplate?4h?$AA@ ; `string'
PUBLIC	__real@3fd0000000000000
PUBLIC	__real@3fb0000000000000
PUBLIC	__real@0000000000000000
PUBLIC	__real@406fe00000000000
PUBLIC	??_C@_0EH@ILJB@sizeof?$CIUFireTexture?$CJ?$DN?$DNUFireTextu@ ; `string'
PUBLIC	??_C@_0EF@LBFJ@sizeof?$CIUWetTexture?$CJ?$DN?$DNUWetTexture@ ; `string'
PUBLIC	??_C@_0EH@HCKF@sizeof?$CIUWaveTexture?$CJ?$DN?$DNUWaveTextu@ ; `string'
PUBLIC	??_C@_0EN@CEKJ@sizeof?$CIUFractalTexture?$CJ?$DN?$DNUFracta@ ; `string'
EXTRN	__imp_?Flush@FMemCache@@QAEX_KKH@Z:NEAR
EXTRN	__imp_?GCache@@3VFMemCache@@A:BYTE
EXTRN	__imp_?Remove@FArray@@QAEXHHH@Z:NEAR
EXTRN	__imp_?ReplaceWithExisting@UPalette@@QAEPAV1@XZ:NEAR
EXTRN	__imp_??0FName@@QAE@PBGW4EFindName@@@Z:NEAR
EXTRN	__ftol:NEAR
;	COMDAT ??_C@_0EH@ILJB@sizeof?$CIUFireTexture?$CJ?$DN?$DNUFireTextu@
; File ..\..\Core\Inc\UnFile.h
_DATA	SEGMENT
??_C@_0EH@ILJB@sizeof?$CIUFireTexture?$CJ?$DN?$DNUFireTextu@ DB 'sizeof(U'
	DB	'FireTexture)==UFireTexture::StaticClass()->GetPropertiesSize('
	DB	')', 00H					; `string'
_DATA	ENDS
;	COMDAT ??_C@_0EF@LBFJ@sizeof?$CIUWetTexture?$CJ?$DN?$DNUWetTexture@
_DATA	SEGMENT
??_C@_0EF@LBFJ@sizeof?$CIUWetTexture?$CJ?$DN?$DNUWetTexture@ DB 'sizeof(U'
	DB	'WetTexture)==UWetTexture::StaticClass()->GetPropertiesSize()', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0EH@HCKF@sizeof?$CIUWaveTexture?$CJ?$DN?$DNUWaveTextu@
_DATA	SEGMENT
??_C@_0EH@HCKF@sizeof?$CIUWaveTexture?$CJ?$DN?$DNUWaveTextu@ DB 'sizeof(U'
	DB	'WaveTexture)==UWaveTexture::StaticClass()->GetPropertiesSize('
	DB	')', 00H					; `string'
_DATA	ENDS
;	COMDAT ??_C@_0EN@CEKJ@sizeof?$CIUFractalTexture?$CJ?$DN?$DNUFracta@
_DATA	SEGMENT
??_C@_0EN@CEKJ@sizeof?$CIUFractalTexture?$CJ?$DN?$DNUFracta@ DB 'sizeof(U'
	DB	'FractalTexture)==UFractalTexture::StaticClass()->GetPropertie'
	DB	'sSize()', 00H				; `string'
_DATA	ENDS
;	COMDAT __real@3fd0000000000000
CONST	SEGMENT
__real@3fd0000000000000 DQ 03fd0000000000000r	; 0.25
CONST	ENDS
;	COMDAT __real@3fb0000000000000
CONST	SEGMENT
__real@3fb0000000000000 DQ 03fb0000000000000r	; 0.0625
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT __real@406fe00000000000
CONST	SEGMENT
__real@406fe00000000000 DQ 0406fe00000000000r	; 255
CONST	ENDS
;	COMDAT ??_C@_0BM@MLGP@?4?4?2?4?4?2Core?2Inc?2UnTemplate?4h?$AA@
_DATA	SEGMENT
??_C@_0BM@MLGP@?4?4?2?4?4?2Core?2Inc?2UnTemplate?4h?$AA@ DB '..\..\Core\I'
	DB	'nc\UnTemplate.h', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_08GCAE@Index?$DO?$DN0?$AA@
_DATA	SEGMENT
??_C@_08GCAE@Index?$DO?$DN0?$AA@ DB 'Index>=0', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BA@FEMP@Index?$DM?$DNArrayNum?$AA@
_DATA	SEGMENT
??_C@_0BA@FEMP@Index?$DM?$DNArrayNum?$AA@ DB 'Index<=ArrayNum', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BG@BEDF@Index?$CLCount?$DM?$DNArrayNum?$AA@
_DATA	SEGMENT
??_C@_0BG@BEDF@Index?$CLCount?$DM?$DNArrayNum?$AA@ DB 'Index+Count<=Array'
	DB	'Num', 00H					; `string'
; Function compile flags: /Ogty
; File C:\duke4\Fire\Src\UnFractal.cpp
_DATA	ENDS
;	COMDAT ?PostLoad@UFireTexture@@UAEXXZ
_TEXT	SEGMENT
$T134711 = -4
_NewPalette$124794 = -8
_T$124815 = -8
?PostLoad@UFireTexture@@UAEXXZ PROC NEAR		; UFireTexture::PostLoad, COMDAT
; _this$ = ecx

; 3986 : 	VERIFY_CLASS_SIZE(UFireTexture);

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?PrivateStaticClass@UFireTexture@@0VUClass@@A
  00005	83 ec 08	 sub	 esp, 8
  00008	53		 push	 ebx
  00009	55		 push	 ebp
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	57		 push	 edi
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?PrivateStaticClass@UFireTexture@@0VUClass@@A ; UFireTexture::PrivateStaticClass
  00013	ff 50 58	 call	 DWORD PTR [eax+88]
  00016	3d 14 05 00 00	 cmp	 eax, 1300		; 00000514H
  0001b	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp_?appFailAssert@@YAXPBD0H@Z
  00021	74 14		 je	 SHORT $L124782
  00023	68 92 0f 00 00	 push	 3986			; 00000f92H
  00028	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CA@CDIN@C?3?2duke4?2Fire?2Src?2UnFractal?4cpp?$AA@ ; `string'
  0002d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EH@ILJB@sizeof?$CIUFireTexture?$CJ?$DN?$DNUFireTextu@ ; `string'
  00032	ff d7		 call	 edi
  00034	83 c4 0c	 add	 esp, 12			; 0000000cH
$L124782:

; 3987 : 	VERIFY_CLASS_SIZE(UWetTexture);

  00037	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?PrivateStaticClass@UWetTexture@@0VUClass@@A
  0003d	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?PrivateStaticClass@UWetTexture@@0VUClass@@A ; UWetTexture::PrivateStaticClass
  00042	ff 52 58	 call	 DWORD PTR [edx+88]
  00045	3d 0c 13 00 00	 cmp	 eax, 4876		; 0000130cH
  0004a	74 14		 je	 SHORT $L124785
  0004c	68 93 0f 00 00	 push	 3987			; 00000f93H
  00051	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CA@CDIN@C?3?2duke4?2Fire?2Src?2UnFractal?4cpp?$AA@ ; `string'
  00056	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EF@LBFJ@sizeof?$CIUWetTexture?$CJ?$DN?$DNUWetTexture@ ; `string'
  0005b	ff d7		 call	 edi
  0005d	83 c4 0c	 add	 esp, 12			; 0000000cH
$L124785:

; 3988 : 	VERIFY_CLASS_SIZE(UWaveTexture);

  00060	a1 00 00 00 00	 mov	 eax, DWORD PTR ?PrivateStaticClass@UWaveTexture@@0VUClass@@A
  00065	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?PrivateStaticClass@UWaveTexture@@0VUClass@@A ; UWaveTexture::PrivateStaticClass
  0006a	ff 50 58	 call	 DWORD PTR [eax+88]
  0006d	3d 04 13 00 00	 cmp	 eax, 4868		; 00001304H
  00072	74 14		 je	 SHORT $L124788
  00074	68 94 0f 00 00	 push	 3988			; 00000f94H
  00079	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CA@CDIN@C?3?2duke4?2Fire?2Src?2UnFractal?4cpp?$AA@ ; `string'
  0007e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EH@HCKF@sizeof?$CIUWaveTexture?$CJ?$DN?$DNUWaveTextu@ ; `string'
  00083	ff d7		 call	 edi
  00085	83 c4 0c	 add	 esp, 12			; 0000000cH
$L124788:

; 3989 : 	VERIFY_CLASS_SIZE(UFractalTexture);

  00088	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?PrivateStaticClass@UFractalTexture@@0VUClass@@A
  0008e	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?PrivateStaticClass@UFractalTexture@@0VUClass@@A ; UFractalTexture::PrivateStaticClass
  00093	ff 52 58	 call	 DWORD PTR [edx+88]
  00096	3d e0 00 00 00	 cmp	 eax, 224		; 000000e0H
  0009b	74 14		 je	 SHORT $L124791
  0009d	68 95 0f 00 00	 push	 3989			; 00000f95H
  000a2	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CA@CDIN@C?3?2duke4?2Fire?2Src?2UnFractal?4cpp?$AA@ ; `string'
  000a7	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EN@CEKJ@sizeof?$CIUFractalTexture?$CJ?$DN?$DNUFracta@ ; `string'
  000ac	ff d7		 call	 edi
  000ae	83 c4 0c	 add	 esp, 12			; 0000000cH
$L124791:

; 3990 : 
; 3991 : 	// Call base class.
; 3992 : 	Super::PostLoad();

  000b1	8b ce		 mov	 ecx, esi
  000b3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?PostLoad@UTexture@@UAEXXZ
  000b9	8b 46 34	 mov	 eax, DWORD PTR [esi+52]

; 3993 : 	PolyFlags &= ~PF_Masked;

  000bc	8b 96 84 00 00
	00		 mov	 edx, DWORD PTR [esi+132]
  000c2	8b 4e 38	 mov	 ecx, DWORD PTR [esi+56]
  000c5	48		 dec	 eax
  000c6	89 86 c8 00 00
	00		 mov	 DWORD PTR [esi+200], eax

; 3994 : 
; 3995 : 	// Make sure the texture has its _own_ copy of the palette.
; 3996 : #if COPYPALETTE
; 3997 : 	if( ( Palette!=NULL ) && ( GetOuter()!=Palette->GetOuter() ) )

  000cc	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  000cf	49		 dec	 ecx
  000d0	83 e2 fd	 and	 edx, -3			; fffffffdH
  000d3	33 ed		 xor	 ebp, ebp
  000d5	3b c5		 cmp	 eax, ebp
  000d7	89 8e cc 00 00
	00		 mov	 DWORD PTR [esi+204], ecx
  000dd	89 96 84 00 00
	00		 mov	 DWORD PTR [esi+132], edx
  000e3	0f 84 e8 00 00
	00		 je	 $L124793
  000e9	8b 56 18	 mov	 edx, DWORD PTR [esi+24]
  000ec	3b 50 18	 cmp	 edx, DWORD PTR [eax+24]
  000ef	0f 84 dc 00 00
	00		 je	 $L124793

; 3998 : 	{
; 3999 : 		UPalette* NewPalette = new( GetOuter(), GetName() )UPalette;

  000f5	8b 06		 mov	 eax, DWORD PTR [esi]
  000f7	6a 01		 push	 1
  000f9	8b ce		 mov	 ecx, esi
  000fb	ff 50 44	 call	 DWORD PTR [eax+68]
  000fe	50		 push	 eax
  000ff	8d 4c 24 1c	 lea	 ecx, DWORD PTR $T134711[esp+32]
  00103	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0FName@@QAE@PBGW4EFindName@@@Z
  00109	8b ce		 mov	 ecx, esi
  0010b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetOuter@UObject@@QBEPAV1@XZ
  00111	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?GError@@3PAVFOutputDeviceError@@A
  00117	8b 11		 mov	 edx, DWORD PTR [ecx]
  00119	8b 4c 24 14	 mov	 ecx, DWORD PTR $T134711[esp+24]
  0011d	55		 push	 ebp
  0011e	52		 push	 edx
  0011f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR __imp_?PrivateStaticClass@UPalette@@0VUClass@@A
  00125	55		 push	 ebp
  00126	55		 push	 ebp
  00127	51		 push	 ecx
  00128	50		 push	 eax
  00129	52		 push	 edx
  0012a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?StaticAllocateObject@UObject@@SAPAV1@PAVUClass@@PAV1@VFName@@K1PAVFOutputDevice@@1@Z
  00130	8b f8		 mov	 edi, eax
  00132	83 c4 1c	 add	 esp, 28			; 0000001cH
  00135	3b fd		 cmp	 edi, ebp
  00137	74 14		 je	 SHORT $L134675
  00139	8b cf		 mov	 ecx, edi
  0013b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0UPalette@@QAE@XZ
  00141	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET FLAT:??_SUPalette@@6B@ ; UPalette::`local vftable'
  00147	89 7c 24 10	 mov	 DWORD PTR _NewPalette$124794[esp+24], edi
  0014b	eb 04		 jmp	 SHORT $L134676
$L134675:
  0014d	89 6c 24 10	 mov	 DWORD PTR _NewPalette$124794[esp+24], ebp
$L134676:
  00151	8b 44 24 10	 mov	 eax, DWORD PTR _NewPalette$124794[esp+24]
  00155	8d 78 28	 lea	 edi, DWORD PTR [eax+40]
$L124803:

; 4000 : 		//NewPalette->Colors = Palette->Colors;
; 4001 : 		for( INT i=0; i<256; i++ )
; 4002 : 			new(NewPalette->Colors)FColor( Palette->Colors(i) );

  00158	8b 5f 04	 mov	 ebx, DWORD PTR [edi+4]
  0015b	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  0015e	8d 4b 01	 lea	 ecx, DWORD PTR [ebx+1]
  00161	3b c8		 cmp	 ecx, eax
  00163	89 4f 04	 mov	 DWORD PTR [edi+4], ecx
  00166	7e 1d		 jle	 SHORT $L134727
  00168	8d 04 49	 lea	 eax, DWORD PTR [ecx+ecx*2]
  0016b	99		 cdq
  0016c	83 e2 07	 and	 edx, 7
  0016f	03 c2		 add	 eax, edx
  00171	c1 f8 03	 sar	 eax, 3
  00174	8d 4c 08 20	 lea	 ecx, DWORD PTR [eax+ecx+32]
  00178	89 4f 08	 mov	 DWORD PTR [edi+8], ecx
  0017b	6a 04		 push	 4
  0017d	8b cf		 mov	 ecx, edi
  0017f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Realloc@FArray@@IAEXH@Z
$L134727:
  00185	8b 17		 mov	 edx, DWORD PTR [edi]
  00187	8d 04 9a	 lea	 eax, DWORD PTR [edx+ebx*4]
  0018a	85 c0		 test	 eax, eax
  0018c	74 0b		 je	 SHORT $L124804
  0018e	8b 4e 2c	 mov	 ecx, DWORD PTR [esi+44]
  00191	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  00194	8b 0c 2a	 mov	 ecx, DWORD PTR [edx+ebp]
  00197	89 08		 mov	 DWORD PTR [eax], ecx
$L124804:
  00199	83 c5 04	 add	 ebp, 4
  0019c	81 fd 00 04 00
	00		 cmp	 ebp, 1024		; 00000400H
  001a2	7c b4		 jl	 SHORT $L124803

; 4003 : 		Palette = NewPalette->ReplaceWithExisting();

  001a4	8b 4c 24 10	 mov	 ecx, DWORD PTR _NewPalette$124794[esp+24]
  001a8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?ReplaceWithExisting@UPalette@@QAEPAV1@XZ
  001ae	89 46 2c	 mov	 DWORD PTR [esi+44], eax

; 4004 : 		MipZero = Palette->Colors(128);

  001b1	8b 50 28	 mov	 edx, DWORD PTR [eax+40]
  001b4	8b 82 00 02 00
	00		 mov	 eax, DWORD PTR [edx+512]

; 4005 : 		GCache.Flush();

  001ba	6a 00		 push	 0
  001bc	6a ff		 push	 -1
  001be	6a 00		 push	 0
  001c0	89 46 44	 mov	 DWORD PTR [esi+68], eax
  001c3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?GCache@@3VFMemCache@@A
  001c9	6a 00		 push	 0
  001cb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Flush@FMemCache@@QAEX_KKH@Z
$L124793:

; 4006 : 	}
; 4007 : #endif
; 4008 : 
; 4009 : 	// Fill the fire table.
; 4010 : 	if( OldRenderHeat != RenderHeat )

  001d1	8b 86 08 01 00
	00		 mov	 eax, DWORD PTR [esi+264]
  001d7	33 c9		 xor	 ecx, ecx
  001d9	8a 8e e1 00 00
	00		 mov	 cl, BYTE PTR [esi+225]
  001df	3b c1		 cmp	 eax, ecx
  001e1	0f 84 8b 00 00
	00		 je	 $L124814

; 4011 : 	{
; 4012 : 		for( INT T=0; T<1024; T++ )

  001e7	33 ff		 xor	 edi, edi
  001e9	89 7c 24 10	 mov	 DWORD PTR _T$124815[esp+24], edi

; 4055 : 		}
; 4056 : 		//Sparks.Debug(); 
; 4057 : 	}
; 4058 : }

  001ed	8d 49 00	 npad	 3

; 4011 : 	{
; 4012 : 		for( INT T=0; T<1024; T++ )

$L124816:

; 4013 : 			RenderTable[T] = (BYTE) Clamp( T/4.0 + 1.0 - (255-RenderHeat)/16.0, 0.0, 255.0 );

  001f0	db 44 24 10	 fild	 DWORD PTR _T$124815[esp+24]
  001f4	33 d2		 xor	 edx, edx
  001f6	8a 96 e1 00 00
	00		 mov	 dl, BYTE PTR [esi+225]
  001fc	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
  00201	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@3fd0000000000000
  00207	dc 05 00 00 00
	00		 fadd	 QWORD PTR __real@3ff0000000000000
  0020d	2b c2		 sub	 eax, edx
  0020f	89 44 24 14	 mov	 DWORD PTR -4+[esp+24], eax
  00213	db 44 24 14	 fild	 DWORD PTR -4+[esp+24]
  00217	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@3fb0000000000000
  0021d	de e9		 fsubp	 ST(1), ST(0)
  0021f	dc 15 00 00 00
	00		 fcom	 QWORD PTR __real@0000000000000000
  00225	df e0		 fnstsw	 ax
  00227	f6 c4 05	 test	 ah, 5
  0022a	7a 0a		 jp	 SHORT $L134747
  0022c	dd d8		 fstp	 ST(0)
  0022e	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@0000000000000000
  00234	eb 15		 jmp	 SHORT $L134746
$L134747:
  00236	dc 15 00 00 00
	00		 fcom	 QWORD PTR __real@406fe00000000000
  0023c	df e0		 fnstsw	 ax
  0023e	f6 c4 05	 test	 ah, 5
  00241	7b 08		 jnp	 SHORT $L134746
  00243	dd d8		 fstp	 ST(0)
  00245	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@406fe00000000000
$L134746:
  0024b	e8 00 00 00 00	 call	 __ftol
  00250	88 84 3e 0c 01
	00 00		 mov	 BYTE PTR [esi+edi+268], al
  00257	47		 inc	 edi
  00258	81 ff 00 04 00
	00		 cmp	 edi, 1024		; 00000400H
  0025e	89 7c 24 10	 mov	 DWORD PTR _T$124815[esp+24], edi
  00262	7c 8c		 jl	 SHORT $L124816

; 4014 : 		OldRenderHeat = RenderHeat;

  00264	33 c9		 xor	 ecx, ecx
  00266	8a 8e e1 00 00
	00		 mov	 cl, BYTE PTR [esi+225]
  0026c	89 8e 08 01 00
	00		 mov	 DWORD PTR [esi+264], ecx
$L124814:

; 4015 : 	}
; 4016 : 
; 4017 : 	// Expand/shrink the dynamic array to become
; 4018 : 	// exactly SparksLimit elements.
; 4019 : 	// Acts both at load time and edit time.
; 4020 : 	
; 4021 : 	if( Sparks.Num() != SparksLimit )

  00272	8b 96 00 01 00
	00		 mov	 edx, DWORD PTR [esi+256]
  00278	8b 86 f4 00 00
	00		 mov	 eax, DWORD PTR [esi+244]
  0027e	3b d0		 cmp	 edx, eax
  00280	0f 84 36 01 00
	00		 je	 $L134827

; 4022 : 	{
; 4023 : 		// Make sure not TOO big...
; 4024 : 		if( SparksLimit > MAXSPARKSLIMIT )

  00286	3d 00 20 00 00	 cmp	 eax, 8192		; 00002000H
  0028b	7e 0c		 jle	 SHORT $L124826

; 4025 : 			SparksLimit = MAXSPARKSLIMIT;

  0028d	c7 86 f4 00 00
	00 00 20 00 00	 mov	 DWORD PTR [esi+244], 8192 ; 00002000H

; 4026 : 		else

  00297	eb 0f		 jmp	 SHORT $L124828
$L124826:

; 4027 : 		if( SparksLimit < MINSPARKSLIMIT )

  00299	83 f8 04	 cmp	 eax, 4
  0029c	7d 0a		 jge	 SHORT $L124828

; 4028 : 			SparksLimit = MINSPARKSLIMIT;

  0029e	c7 86 f4 00 00
	00 04 00 00 00	 mov	 DWORD PTR [esi+244], 4
$L124828:

; 4029 : 
; 4030 : 		// New SparksLimit; current size is too big. 
; 4031 : 		if( Sparks.Num() > SparksLimit )

  002a8	8b 86 f4 00 00
	00		 mov	 eax, DWORD PTR [esi+244]
  002ae	3b d0		 cmp	 edx, eax
  002b0	0f 8e d2 00 00
	00		 jle	 $L124829

; 4032 : 		{
; 4033 : 			// Try culling some transients if needed.
; 4034 : 			if  (ActiveSparkNum > SparksLimit)

  002b6	8b 8e f8 00 00
	00		 mov	 ecx, DWORD PTR [esi+248]
  002bc	3b c8		 cmp	 ecx, eax
  002be	7e 39		 jle	 SHORT $L134840

; 4035 : 				for( INT t = (ActiveSparkNum-1); t>=0; t-- )

  002c0	8d 51 ff	 lea	 edx, DWORD PTR [ecx-1]
  002c3	85 d2		 test	 edx, edx
  002c5	7c 32		 jl	 SHORT $L134840
$L124832:

; 4036 : 				{		
; 4037 : 					if( Sparks(t).Type >= ISPARK_TRANSIENTS ) 

  002c7	8b 86 fc 00 00
	00		 mov	 eax, DWORD PTR [esi+252]
  002cd	80 3c d0 1f	 cmp	 BYTE PTR [eax+edx*8], 31 ; 0000001fH
  002d1	72 23		 jb	 SHORT $L124833

; 4038 : 					{
; 4039 : 						Sparks(t) = Sparks(--ActiveSparkNum);	

  002d3	49		 dec	 ecx
  002d4	89 8e f8 00 00
	00		 mov	 DWORD PTR [esi+248], ecx
  002da	8b 3c c8	 mov	 edi, DWORD PTR [eax+ecx*8]
  002dd	89 3c d0	 mov	 DWORD PTR [eax+edx*8], edi
  002e0	8b 4c c8 04	 mov	 ecx, DWORD PTR [eax+ecx*8+4]
  002e4	89 4c d0 04	 mov	 DWORD PTR [eax+edx*8+4], ecx

; 4040 : 						// culled enough ?
; 4041 : 						if( ActiveSparkNum<= SparksLimit ) break;

  002e8	8b 8e f8 00 00
	00		 mov	 ecx, DWORD PTR [esi+248]
  002ee	3b 8e f4 00 00
	00		 cmp	 ecx, DWORD PTR [esi+244]
  002f4	7e 03		 jle	 SHORT $L134840
$L124833:

; 4035 : 				for( INT t = (ActiveSparkNum-1); t>=0; t-- )

  002f6	4a		 dec	 edx
  002f7	79 ce		 jns	 SHORT $L124832
$L134840:

; 4042 : 					}			 
; 4043 : 				}
; 4044 : 
; 4045 : 			// Adjust active sparks the crude way:
; 4046 : 			ActiveSparkNum = Min( ActiveSparkNum, SparksLimit );

  002f9	8b be f4 00 00
	00		 mov	 edi, DWORD PTR [esi+244]
  002ff	8b 86 f8 00 00
	00		 mov	 eax, DWORD PTR [esi+248]
  00305	3b c7		 cmp	 eax, edi
  00307	7e 02		 jle	 SHORT $L134773
  00309	8b c7		 mov	 eax, edi
$L134773:

; 4047 : 			// Now delete the empty tail. 
; 4048 : 			Sparks.Remove( SparksLimit, Sparks.Num()-SparksLimit); 

  0030b	8b 9e 00 01 00
	00		 mov	 ebx, DWORD PTR [esi+256]
  00311	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp_?appFailAssert@@YAXPBD0H@Z
  00317	89 86 f8 00 00
	00		 mov	 DWORD PTR [esi+248], eax
  0031d	2b df		 sub	 ebx, edi
  0031f	81 c6 fc 00 00
	00		 add	 esi, 252		; 000000fcH
  00325	85 ff		 test	 edi, edi
  00327	7d 14		 jge	 SHORT $L134785
  00329	68 fc 01 00 00	 push	 508			; 000001fcH
  0032e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@MLGP@?4?4?2?4?4?2Core?2Inc?2UnTemplate?4h?$AA@ ; `string'
  00333	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08GCAE@Index?$DO?$DN0?$AA@ ; `string'
  00338	ff d5		 call	 ebp
  0033a	83 c4 0c	 add	 esp, 12			; 0000000cH
$L134785:
  0033d	3b 7e 04	 cmp	 edi, DWORD PTR [esi+4]
  00340	7e 14		 jle	 SHORT $L134786
  00342	68 fd 01 00 00	 push	 509			; 000001fdH
  00347	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@MLGP@?4?4?2?4?4?2Core?2Inc?2UnTemplate?4h?$AA@ ; `string'
  0034c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BA@FEMP@Index?$DM?$DNArrayNum?$AA@ ; `string'
  00351	ff d5		 call	 ebp
  00353	83 c4 0c	 add	 esp, 12			; 0000000cH
$L134786:
  00356	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00359	8d 14 1f	 lea	 edx, DWORD PTR [edi+ebx]
  0035c	3b d0		 cmp	 edx, eax
  0035e	7e 14		 jle	 SHORT $L134787
  00360	68 fe 01 00 00	 push	 510			; 000001feH
  00365	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@MLGP@?4?4?2?4?4?2Core?2Inc?2UnTemplate?4h?$AA@ ; `string'
  0036a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BG@BEDF@Index?$CLCount?$DM?$DNArrayNum?$AA@ ; `string'
  0036f	ff d5		 call	 ebp
  00371	83 c4 0c	 add	 esp, 12			; 0000000cH
$L134787:
  00374	6a 08		 push	 8
  00376	53		 push	 ebx
  00377	57		 push	 edi
  00378	8b ce		 mov	 ecx, esi
  0037a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Remove@FArray@@QAEXHHH@Z
  00380	5f		 pop	 edi
  00381	5e		 pop	 esi
  00382	5d		 pop	 ebp
  00383	5b		 pop	 ebx

; 4055 : 		}
; 4056 : 		//Sparks.Debug(); 
; 4057 : 	}
; 4058 : }

  00384	83 c4 08	 add	 esp, 8
  00387	c3		 ret	 0
$L124829:

; 4049 : 
; 4050 : 		}
; 4051 : 		else 
; 4052 : 		// Too small: just expand the array.
; 4053 : 		{
; 4054 : 			Sparks.Add( SparksLimit - Sparks.Num() );

  00388	8d 8e fc 00 00
	00		 lea	 ecx, DWORD PTR [esi+252]
  0038e	2b c2		 sub	 eax, edx
  00390	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00393	03 d0		 add	 edx, eax
  00395	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00398	8b f2		 mov	 esi, edx
  0039a	3b f0		 cmp	 esi, eax
  0039c	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  0039f	7e 1b		 jle	 SHORT $L134827
  003a1	8d 04 76	 lea	 eax, DWORD PTR [esi+esi*2]
  003a4	99		 cdq
  003a5	83 e2 07	 and	 edx, 7
  003a8	03 c2		 add	 eax, edx
  003aa	c1 f8 03	 sar	 eax, 3
  003ad	8d 44 30 20	 lea	 eax, DWORD PTR [eax+esi+32]
  003b1	6a 08		 push	 8
  003b3	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  003b6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Realloc@FArray@@IAEXH@Z
$L134827:
  003bc	5f		 pop	 edi
  003bd	5e		 pop	 esi
  003be	5d		 pop	 ebp
  003bf	5b		 pop	 ebx

; 4055 : 		}
; 4056 : 		//Sparks.Debug(); 
; 4057 : 	}
; 4058 : }

  003c0	83 c4 08	 add	 esp, 8
  003c3	c3		 ret	 0
?PostLoad@UFireTexture@@UAEXXZ ENDP			; UFireTexture::PostLoad
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?TouchTexture@UFireTexture@@UAEXHHM@Z
_TEXT	SEGMENT
_UPos$ = 8
_VPos$ = 12
_Magnitude$ = 16
?TouchTexture@UFireTexture@@UAEXHHM@Z PROC NEAR		; UFireTexture::TouchTexture, COMDAT
; _this$ = ecx

; 4064 :     DWORD SparkDest = (DWORD)(UPos + (VPos << UBits) );
; 4065 :     Mips(0).DataArray(SparkDest) = (BYTE) Magnitude;

  00000	d9 44 24 0c	 fld	 DWORD PTR _Magnitude$[esp-4]
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	e8 00 00 00 00	 call	 __ftol
  0000c	8a 4e 30	 mov	 cl, BYTE PTR [esi+48]
  0000f	8b 54 24 0c	 mov	 edx, DWORD PTR _VPos$[esp]
  00013	d3 e2		 shl	 edx, cl
  00015	8b 8e a8 00 00
	00		 mov	 ecx, DWORD PTR [esi+168]
  0001b	8b 71 1c	 mov	 esi, DWORD PTR [ecx+28]
  0001e	8b 4c 24 08	 mov	 ecx, DWORD PTR _UPos$[esp]
  00022	03 d6		 add	 edx, esi
  00024	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
  00027	5e		 pop	 esi

; 4066 : }

  00028	c2 0c 00	 ret	 12			; 0000000cH
?TouchTexture@UFireTexture@@UAEXHHM@Z ENDP		; UFireTexture::TouchTexture
_TEXT	ENDS
EXTRN	_CalcWrapFire:NEAR
EXTRN	_CalcSlowFire:NEAR
EXTRN	_CalcWrapFireP2:NEAR
EXTRN	_CalcSlowFireP2:NEAR
; Function compile flags: /Ogty
;	COMDAT ?ConstantTimeTick@UFireTexture@@UAEXXZ
_TEXT	SEGMENT
?ConstantTimeTick@UFireTexture@@UAEXXZ PROC NEAR	; UFireTexture::ConstantTimeTick, COMDAT
; _this$ = ecx

; 4070 : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 4071 : 	if( (USize>=8) && (VSize>=8) ) // safe sizes ?

  00003	8b 4e 34	 mov	 ecx, DWORD PTR [esi+52]
  00006	b8 08 00 00 00	 mov	 eax, 8
  0000b	3b c8		 cmp	 ecx, eax
  0000d	0f 8c cc 00 00
	00		 jl	 $L124854
  00013	39 46 38	 cmp	 DWORD PTR [esi+56], eax
  00016	0f 8c c3 00 00
	00		 jl	 $L124854

; 4072 : 	{
; 4073 : 		// Call FireEngine update.
; 4074 : 
; 4075 : 		RedrawSparks();

  0001c	8b ce		 mov	 ecx, esi
  0001e	e8 00 00 00 00	 call	 ?RedrawSparks@UFireTexture@@AAEXXZ ; UFireTexture::RedrawSparks

; 4076 : 
; 4077 : #if FIREASM
; 4078 : 		if( GIsPentiumPro )

  00023	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__GIsPentiumPro
  00028	83 38 00	 cmp	 DWORD PTR [eax], 0

; 4079 : 		{
; 4080 : 			if( bRising ) CalcWrapFireP2( &Mips(0).DataArray(0), RenderTable, USize, VSize );

  0002b	8a 86 e4 00 00
	00		 mov	 al, BYTE PTR [esi+228]
  00031	74 56		 je	 SHORT $L124855
  00033	a8 01		 test	 al, 1
  00035	74 29		 je	 SHORT $L124856
  00037	8b 4e 38	 mov	 ecx, DWORD PTR [esi+56]
  0003a	8b 56 34	 mov	 edx, DWORD PTR [esi+52]
  0003d	51		 push	 ecx
  0003e	8b 8e a8 00 00
	00		 mov	 ecx, DWORD PTR [esi+168]
  00044	52		 push	 edx
  00045	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00048	8d 86 0c 01 00
	00		 lea	 eax, DWORD PTR [esi+268]
  0004e	50		 push	 eax
  0004f	52		 push	 edx
  00050	e8 00 00 00 00	 call	 _CalcWrapFireP2

; 4086 : 				else      CalcSlowFire( &Mips(0).DataArray(0), RenderTable, USize, VSize );

  00055	83 c4 10	 add	 esp, 16			; 00000010H

; 4087 : 		}
; 4088 : #else
; 4089 : 		if( bRising ) CalcWrapFire( &Mips(0).DataArray(0), RenderTable, USize, VSize );
; 4090 : 		else      CalcSlowFire( &Mips(0).DataArray(0), RenderTable, USize, VSize );
; 4091 : #endif
; 4092 : 
; 4093 : 		PostDrawSparks();

  00058	8b ce		 mov	 ecx, esi
  0005a	5e		 pop	 esi
  0005b	e9 00 00 00 00	 jmp	 ?PostDrawSparks@UFireTexture@@AAEXXZ ; UFireTexture::PostDrawSparks
$L124856:

; 4081 : 				else      CalcSlowFireP2( &Mips(0).DataArray(0), RenderTable, USize, VSize );

  00060	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  00063	8b 4e 34	 mov	 ecx, DWORD PTR [esi+52]
  00066	50		 push	 eax
  00067	8b 86 a8 00 00
	00		 mov	 eax, DWORD PTR [esi+168]
  0006d	51		 push	 ecx
  0006e	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00071	8d 96 0c 01 00
	00		 lea	 edx, DWORD PTR [esi+268]
  00077	52		 push	 edx
  00078	51		 push	 ecx
  00079	e8 00 00 00 00	 call	 _CalcSlowFireP2

; 4086 : 				else      CalcSlowFire( &Mips(0).DataArray(0), RenderTable, USize, VSize );

  0007e	83 c4 10	 add	 esp, 16			; 00000010H

; 4087 : 		}
; 4088 : #else
; 4089 : 		if( bRising ) CalcWrapFire( &Mips(0).DataArray(0), RenderTable, USize, VSize );
; 4090 : 		else      CalcSlowFire( &Mips(0).DataArray(0), RenderTable, USize, VSize );
; 4091 : #endif
; 4092 : 
; 4093 : 		PostDrawSparks();

  00081	8b ce		 mov	 ecx, esi
  00083	5e		 pop	 esi
  00084	e9 00 00 00 00	 jmp	 ?PostDrawSparks@UFireTexture@@AAEXXZ ; UFireTexture::PostDrawSparks
$L124855:

; 4082 : 		}
; 4083 : 		else
; 4084 : 		{
; 4085 : 			if( bRising ) CalcWrapFire( &Mips(0).DataArray(0), RenderTable, USize, VSize );

  00089	a8 01		 test	 al, 1
  0008b	74 29		 je	 SHORT $L124859
  0008d	8b 56 38	 mov	 edx, DWORD PTR [esi+56]
  00090	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  00093	52		 push	 edx
  00094	8b 96 a8 00 00
	00		 mov	 edx, DWORD PTR [esi+168]
  0009a	50		 push	 eax
  0009b	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  0009e	8d 8e 0c 01 00
	00		 lea	 ecx, DWORD PTR [esi+268]
  000a4	51		 push	 ecx
  000a5	50		 push	 eax
  000a6	e8 00 00 00 00	 call	 _CalcWrapFire

; 4086 : 				else      CalcSlowFire( &Mips(0).DataArray(0), RenderTable, USize, VSize );

  000ab	83 c4 10	 add	 esp, 16			; 00000010H

; 4087 : 		}
; 4088 : #else
; 4089 : 		if( bRising ) CalcWrapFire( &Mips(0).DataArray(0), RenderTable, USize, VSize );
; 4090 : 		else      CalcSlowFire( &Mips(0).DataArray(0), RenderTable, USize, VSize );
; 4091 : #endif
; 4092 : 
; 4093 : 		PostDrawSparks();

  000ae	8b ce		 mov	 ecx, esi
  000b0	5e		 pop	 esi
  000b1	e9 00 00 00 00	 jmp	 ?PostDrawSparks@UFireTexture@@AAEXXZ ; UFireTexture::PostDrawSparks
$L124859:

; 4086 : 				else      CalcSlowFire( &Mips(0).DataArray(0), RenderTable, USize, VSize );

  000b6	8b 4e 38	 mov	 ecx, DWORD PTR [esi+56]
  000b9	8b 56 34	 mov	 edx, DWORD PTR [esi+52]
  000bc	51		 push	 ecx
  000bd	8b 8e a8 00 00
	00		 mov	 ecx, DWORD PTR [esi+168]
  000c3	52		 push	 edx
  000c4	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  000c7	8d 86 0c 01 00
	00		 lea	 eax, DWORD PTR [esi+268]
  000cd	50		 push	 eax
  000ce	52		 push	 edx
  000cf	e8 00 00 00 00	 call	 _CalcSlowFire
  000d4	83 c4 10	 add	 esp, 16			; 00000010H

; 4087 : 		}
; 4088 : #else
; 4089 : 		if( bRising ) CalcWrapFire( &Mips(0).DataArray(0), RenderTable, USize, VSize );
; 4090 : 		else      CalcSlowFire( &Mips(0).DataArray(0), RenderTable, USize, VSize );
; 4091 : #endif
; 4092 : 
; 4093 : 		PostDrawSparks();

  000d7	8b ce		 mov	 ecx, esi
  000d9	5e		 pop	 esi
  000da	e9 00 00 00 00	 jmp	 ?PostDrawSparks@UFireTexture@@AAEXXZ ; UFireTexture::PostDrawSparks
$L124854:
  000df	5e		 pop	 esi

; 4094 : 	}
; 4095 : }

  000e0	c3		 ret	 0
?ConstantTimeTick@UFireTexture@@UAEXXZ ENDP		; UFireTexture::ConstantTimeTick
_TEXT	ENDS
PUBLIC	__real@3f800000
;	COMDAT __real@3f800000
; File ..\..\Core\Inc\UnTemplate.h
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
; Function compile flags: /Ogty
; File C:\duke4\Fire\Src\UnFractal.cpp
CONST	ENDS
;	COMDAT ?MousePosition@UFireTexture@@UAEXKMM@Z
_TEXT	SEGMENT
_I$134901 = -8
_I$134906 = -4
_Buttons$ = 8
_X$ = 12
_Y$ = 16
?MousePosition@UFireTexture@@UAEXKMM@Z PROC NEAR	; UFireTexture::MousePosition, COMDAT
; _this$ = ecx

; 4100 : {

  00000	83 ec 08	 sub	 esp, 8
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	8b f1		 mov	 esi, ecx

; 4101 : 	// Call FireEngine update. (adds or removes sparks in spark array)
; 4102 : 	FirePaint( appRound(X), appRound(Y), Buttons );

  00008	d9 44 24 20	 fld	 DWORD PTR _Y$[esp+16]
  0000c	db 5c 24 0c	 fistp	 DWORD PTR _I$134901[esp+20]
  00010	d9 44 24 1c	 fld	 DWORD PTR _X$[esp+16]
  00014	db 5c 24 10	 fistp	 DWORD PTR _I$134906[esp+20]
  00018	8b 44 24 18	 mov	 eax, DWORD PTR _Buttons$[esp+16]
  0001c	8b 4c 24 0c	 mov	 ecx, DWORD PTR _I$134901[esp+20]
  00020	8b 54 24 10	 mov	 edx, DWORD PTR _I$134906[esp+20]
  00024	50		 push	 eax
  00025	51		 push	 ecx
  00026	52		 push	 edx
  00027	8b ce		 mov	 ecx, esi
  00029	e8 00 00 00 00	 call	 ?FirePaint@UFireTexture@@AAEXHHK@Z ; UFireTexture::FirePaint

; 4103 : 
; 4104 : 	// Mouse 'torch' animation. Won't work on still cursor.
; 4105 : 	if( 1 )
; 4106 : 	{
; 4107 : 		TempDrawSpark(X  ,Y,255);
; 4108 : 		TempDrawSpark(X+1,Y,255);
; 4109 : 		TempDrawSpark(X-1,Y,255);

  0002e	d9 44 24 20	 fld	 DWORD PTR _Y$[esp+16]
  00032	e8 00 00 00 00	 call	 __ftol
  00037	d9 44 24 1c	 fld	 DWORD PTR _X$[esp+16]
  0003b	8a 4e 30	 mov	 cl, BYTE PTR [esi+48]
  0003e	8b f8		 mov	 edi, eax
  00040	8b 86 cc 00 00
	00		 mov	 eax, DWORD PTR [esi+204]
  00046	8b df		 mov	 ebx, edi
  00048	23 d8		 and	 ebx, eax
  0004a	d3 e3		 shl	 ebx, cl
  0004c	e8 00 00 00 00	 call	 __ftol
  00051	d9 44 24 1c	 fld	 DWORD PTR _X$[esp+16]
  00055	8b 8e c8 00 00
	00		 mov	 ecx, DWORD PTR [esi+200]
  0005b	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@3f800000
  00061	23 c1		 and	 eax, ecx
  00063	03 d8		 add	 ebx, eax
  00065	8b 86 a8 00 00
	00		 mov	 eax, DWORD PTR [esi+168]
  0006b	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  0006e	c6 04 0b ff	 mov	 BYTE PTR [ebx+ecx], 255	; 000000ffH
  00072	8b 8e cc 00 00
	00		 mov	 ecx, DWORD PTR [esi+204]
  00078	8b df		 mov	 ebx, edi
  0007a	23 d9		 and	 ebx, ecx
  0007c	8a 4e 30	 mov	 cl, BYTE PTR [esi+48]
  0007f	d3 e3		 shl	 ebx, cl
  00081	e8 00 00 00 00	 call	 __ftol
  00086	d9 44 24 1c	 fld	 DWORD PTR _X$[esp+16]
  0008a	8b 96 c8 00 00
	00		 mov	 edx, DWORD PTR [esi+200]
  00090	d8 25 00 00 00
	00		 fsub	 DWORD PTR __real@3f800000
  00096	23 c2		 and	 eax, edx
  00098	8b 96 a8 00 00
	00		 mov	 edx, DWORD PTR [esi+168]
  0009e	03 d8		 add	 ebx, eax
  000a0	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  000a3	c6 04 03 ff	 mov	 BYTE PTR [ebx+eax], 255	; 000000ffH
  000a7	8b 86 cc 00 00
	00		 mov	 eax, DWORD PTR [esi+204]
  000ad	8a 4e 30	 mov	 cl, BYTE PTR [esi+48]
  000b0	23 f8		 and	 edi, eax
  000b2	d3 e7		 shl	 edi, cl
  000b4	e8 00 00 00 00	 call	 __ftol
  000b9	8b 96 c8 00 00
	00		 mov	 edx, DWORD PTR [esi+200]
  000bf	8b 8e a8 00 00
	00		 mov	 ecx, DWORD PTR [esi+168]
  000c5	23 c2		 and	 eax, edx
  000c7	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  000ca	03 f8		 add	 edi, eax
  000cc	c6 04 17 ff	 mov	 BYTE PTR [edi+edx], 255	; 000000ffH
  000d0	5f		 pop	 edi
  000d1	5e		 pop	 esi
  000d2	5b		 pop	 ebx

; 4110 : 	}
; 4111 :     else
; 4112 :     {
; 4113 :     }
; 4114 : }

  000d3	83 c4 08	 add	 esp, 8
  000d6	c2 0c 00	 ret	 12			; 0000000cH
?MousePosition@UFireTexture@@UAEXKMM@Z ENDP		; UFireTexture::MousePosition
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?Click@UFireTexture@@UAEXKMM@Z
_TEXT	SEGMENT
_I$134961 = -8
_I$134966 = -4
_Buttons$ = 8
_X$ = 12
_Y$ = 16
?Click@UFireTexture@@UAEXKMM@Z PROC NEAR		; UFireTexture::Click, COMDAT
; _this$ = ecx

; 4119 : {

  00000	83 ec 08	 sub	 esp, 8
  00003	56		 push	 esi
  00004	57		 push	 edi
  00005	8b f1		 mov	 esi, ecx

; 4120 : 	// Call FireEngine update.
; 4121 : 	FirePaint( appRound(X), appRound(Y), Buttons );

  00007	d9 44 24 1c	 fld	 DWORD PTR _Y$[esp+12]
  0000b	db 5c 24 08	 fistp	 DWORD PTR _I$134961[esp+16]
  0000f	d9 44 24 18	 fld	 DWORD PTR _X$[esp+12]
  00013	db 5c 24 0c	 fistp	 DWORD PTR _I$134966[esp+16]
  00017	8b 44 24 14	 mov	 eax, DWORD PTR _Buttons$[esp+12]
  0001b	8b 4c 24 08	 mov	 ecx, DWORD PTR _I$134961[esp+16]
  0001f	8b 54 24 0c	 mov	 edx, DWORD PTR _I$134966[esp+16]
  00023	50		 push	 eax
  00024	51		 push	 ecx
  00025	52		 push	 edx
  00026	8b ce		 mov	 ecx, esi
  00028	e8 00 00 00 00	 call	 ?FirePaint@UFireTexture@@AAEXHHK@Z ; UFireTexture::FirePaint

; 4122 : 
; 4123 : 	// Mouse 'torch' animation.
; 4124 : 	if( 1 )
; 4125 : 	{
; 4126 : 		Mips(0).DataArray((INT)X + (INT)Y * USize) = 255;

  0002d	d9 44 24 1c	 fld	 DWORD PTR _Y$[esp+12]
  00031	e8 00 00 00 00	 call	 __ftol
  00036	d9 44 24 18	 fld	 DWORD PTR _X$[esp+12]
  0003a	8b 7e 34	 mov	 edi, DWORD PTR [esi+52]
  0003d	0f af f8	 imul	 edi, eax
  00040	8b 86 a8 00 00
	00		 mov	 eax, DWORD PTR [esi+168]
  00046	03 78 1c	 add	 edi, DWORD PTR [eax+28]
  00049	e8 00 00 00 00	 call	 __ftol
  0004e	c6 04 07 ff	 mov	 BYTE PTR [edi+eax], 255	; 000000ffH
  00052	5f		 pop	 edi
  00053	5e		 pop	 esi

; 4127 : 	}
; 4128 :     else
; 4129 :     {
; 4130 :         //SparkType = TouchType;
; 4131 :         //AddSpark( X, Y);
; 4132 :     }
; 4133 : }

  00054	83 c4 08	 add	 esp, 8
  00057	c2 0c 00	 ret	 12			; 0000000cH
?Click@UFireTexture@@UAEXKMM@Z ENDP			; UFireTexture::Click
_TEXT	ENDS
PUBLIC	??6@YAAAVFArchive@@AAV0@AAVFSpark@@@Z		; operator<<
EXTRN	__imp_??6@YAAAVFArchive@@AAV0@AAVFCompactIndex@@@Z:NEAR
EXTRN	__imp_?Add@FArray@@QAEHHH@Z:NEAR
EXTRN	__imp_?Empty@FArray@@QAEXHH@Z:NEAR
EXTRN	__imp_?CountBytes@FArray@@QAEXAAVFArchive@@H@Z:NEAR
EXTRN	__imp_?Serialize@UTexture@@UAEXAAVFArchive@@@Z:NEAR
; Function compile flags: /Ogty
;	COMDAT ?Serialize@UFireTexture@@UAEXAAVFArchive@@@Z
_TEXT	SEGMENT
$T135017 = 8
_Ar$ = 8
_NewNum$135069 = 8
?Serialize@UFireTexture@@UAEXAAVFArchive@@@Z PROC NEAR	; UFireTexture::Serialize, COMDAT
; _this$ = ecx

; 4136 : {

  00000	53		 push	 ebx
  00001	55		 push	 ebp

; 4137 : 	Super::Serialize( Ar );

  00002	8b 6c 24 0c	 mov	 ebp, DWORD PTR _Ar$[esp+4]
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	55		 push	 ebp
  00009	8b f9		 mov	 edi, ecx
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Serialize@UTexture@@UAEXAAVFArchive@@@Z

; 4138 : 
; 4139 :     // Clean up & minimize our spark array for saving to disk:
; 4140 : 	if( Ar.IsSaving() ) 

  00011	8b 45 18	 mov	 eax, DWORD PTR [ebp+24]
  00014	85 c0		 test	 eax, eax
  00016	0f 84 bc 00 00
	00		 je	 $L135003

; 4141 : 	{
; 4142 : 		// Delete the transients, compact the spark array.
; 4143 : 		for( INT t=ActiveSparkNum-1; t>=0; t-- )

  0001c	8b 8f f8 00 00
	00		 mov	 ecx, DWORD PTR [edi+248]
  00022	49		 dec	 ecx
  00023	78 2a		 js	 SHORT $L124887
$L124885:

; 4144 : 			if( Sparks(t).Type >= ISPARK_TRANSIENTS ) 

  00025	8b 87 fc 00 00
	00		 mov	 eax, DWORD PTR [edi+252]
  0002b	80 3c c8 1f	 cmp	 BYTE PTR [eax+ecx*8], 31 ; 0000001fH
  0002f	72 1b		 jb	 SHORT $L124886

; 4145 : 				Sparks(t) = Sparks(--ActiveSparkNum);	

  00031	8b 97 f8 00 00
	00		 mov	 edx, DWORD PTR [edi+248]
  00037	4a		 dec	 edx
  00038	89 97 f8 00 00
	00		 mov	 DWORD PTR [edi+248], edx
  0003e	8b 34 d0	 mov	 esi, DWORD PTR [eax+edx*8]
  00041	89 34 c8	 mov	 DWORD PTR [eax+ecx*8], esi
  00044	8b 54 d0 04	 mov	 edx, DWORD PTR [eax+edx*8+4]
  00048	89 54 c8 04	 mov	 DWORD PTR [eax+ecx*8+4], edx
$L124886:

; 4141 : 	{
; 4142 : 		// Delete the transients, compact the spark array.
; 4143 : 		for( INT t=ActiveSparkNum-1; t>=0; t-- )

  0004c	49		 dec	 ecx
  0004d	79 d6		 jns	 SHORT $L124885
$L124887:

; 4146 : 
; 4147 : 		// Deflate the empty tail.
; 4148 : 		if( ActiveSparkNum < Sparks.Num() )

  0004f	8b 87 00 01 00
	00		 mov	 eax, DWORD PTR [edi+256]
  00055	8b b7 f8 00 00
	00		 mov	 esi, DWORD PTR [edi+248]
  0005b	3b f0		 cmp	 esi, eax
  0005d	7d 79		 jge	 SHORT $L135003

; 4149 : 			Sparks.Remove( ActiveSparkNum, Sparks.Num()-ActiveSparkNum ); 

  0005f	2b c6		 sub	 eax, esi
  00061	85 f6		 test	 esi, esi
  00063	89 44 24 14	 mov	 DWORD PTR $T135017[esp+12], eax
  00067	8d 9f fc 00 00
	00		 lea	 ebx, DWORD PTR [edi+252]
  0006d	7d 18		 jge	 SHORT $L135004
  0006f	68 fc 01 00 00	 push	 508			; 000001fcH
  00074	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@MLGP@?4?4?2?4?4?2Core?2Inc?2UnTemplate?4h?$AA@ ; `string'
  00079	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08GCAE@Index?$DO?$DN0?$AA@ ; `string'
  0007e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?appFailAssert@@YAXPBD0H@Z
  00084	83 c4 0c	 add	 esp, 12			; 0000000cH
$L135004:
  00087	3b 73 04	 cmp	 esi, DWORD PTR [ebx+4]
  0008a	7e 18		 jle	 SHORT $L135005
  0008c	68 fd 01 00 00	 push	 509			; 000001fdH
  00091	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@MLGP@?4?4?2?4?4?2Core?2Inc?2UnTemplate?4h?$AA@ ; `string'
  00096	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BA@FEMP@Index?$DM?$DNArrayNum?$AA@ ; `string'
  0009b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?appFailAssert@@YAXPBD0H@Z
  000a1	83 c4 0c	 add	 esp, 12			; 0000000cH
$L135005:
  000a4	8b 44 24 14	 mov	 eax, DWORD PTR $T135017[esp+12]
  000a8	8d 0c 06	 lea	 ecx, DWORD PTR [esi+eax]
  000ab	3b 4b 04	 cmp	 ecx, DWORD PTR [ebx+4]
  000ae	7e 18		 jle	 SHORT $L135006
  000b0	68 fe 01 00 00	 push	 510			; 000001feH
  000b5	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@MLGP@?4?4?2?4?4?2Core?2Inc?2UnTemplate?4h?$AA@ ; `string'
  000ba	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BG@BEDF@Index?$CLCount?$DM?$DNArrayNum?$AA@ ; `string'
  000bf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?appFailAssert@@YAXPBD0H@Z
  000c5	83 c4 0c	 add	 esp, 12			; 0000000cH
$L135006:
  000c8	8b 54 24 14	 mov	 edx, DWORD PTR $T135017[esp+12]
  000cc	6a 08		 push	 8
  000ce	52		 push	 edx
  000cf	56		 push	 esi
  000d0	8b cb		 mov	 ecx, ebx
  000d2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Remove@FArray@@QAEXHHH@Z
$L135003:

; 4150 : 	}
; 4151 : 	Ar << Sparks;

  000d8	6a 08		 push	 8
  000da	8d b7 fc 00 00
	00		 lea	 esi, DWORD PTR [edi+252]
  000e0	55		 push	 ebp
  000e1	8b ce		 mov	 ecx, esi
  000e3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?CountBytes@FArray@@QAEXAAVFArchive@@H@Z
  000e9	8b 45 14	 mov	 eax, DWORD PTR [ebp+20]
  000ec	85 c0		 test	 eax, eax
  000ee	74 4e		 je	 SHORT $L135068
  000f0	8d 44 24 14	 lea	 eax, DWORD PTR _NewNum$135069[esp+12]
  000f4	50		 push	 eax
  000f5	55		 push	 ebp
  000f6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6@YAAAVFArchive@@AAV0@AAVFCompactIndex@@@Z
  000fc	8b 4c 24 1c	 mov	 ecx, DWORD PTR _NewNum$135069[esp+20]
  00100	83 c4 08	 add	 esp, 8
  00103	51		 push	 ecx
  00104	6a 08		 push	 8
  00106	8b ce		 mov	 ecx, esi
  00108	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Empty@FArray@@QAEXHH@Z
  0010e	8b 44 24 14	 mov	 eax, DWORD PTR _NewNum$135069[esp+12]
  00112	33 db		 xor	 ebx, ebx
  00114	85 c0		 test	 eax, eax
  00116	7e 54		 jle	 SHORT $L135078
$L135071:
  00118	6a 08		 push	 8
  0011a	6a 01		 push	 1
  0011c	8b ce		 mov	 ecx, esi
  0011e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Add@FArray@@QAEHHH@Z
  00124	8b 16		 mov	 edx, DWORD PTR [esi]
  00126	8d 04 c2	 lea	 eax, DWORD PTR [edx+eax*8]
  00129	50		 push	 eax
  0012a	55		 push	 ebp
  0012b	e8 00 00 00 00	 call	 ??6@YAAAVFArchive@@AAV0@AAVFSpark@@@Z ; operator<<
  00130	8b 44 24 1c	 mov	 eax, DWORD PTR _NewNum$135069[esp+20]
  00134	83 c4 08	 add	 esp, 8
  00137	43		 inc	 ebx
  00138	3b d8		 cmp	 ebx, eax
  0013a	7c dc		 jl	 SHORT $L135071
  0013c	eb 2e		 jmp	 SHORT $L135078
$L135068:
  0013e	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00141	50		 push	 eax
  00142	55		 push	 ebp
  00143	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6@YAAAVFArchive@@AAV0@AAVFCompactIndex@@@Z
  00149	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0014c	83 c4 08	 add	 esp, 8
  0014f	33 db		 xor	 ebx, ebx
  00151	85 c0		 test	 eax, eax
  00153	7e 17		 jle	 SHORT $L135078
$L135076:
  00155	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00157	8d 14 d9	 lea	 edx, DWORD PTR [ecx+ebx*8]
  0015a	52		 push	 edx
  0015b	55		 push	 ebp
  0015c	e8 00 00 00 00	 call	 ??6@YAAAVFArchive@@AAV0@AAVFSpark@@@Z ; operator<<
  00161	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00164	83 c4 08	 add	 esp, 8
  00167	43		 inc	 ebx
  00168	3b d8		 cmp	 ebx, eax
  0016a	7c e9		 jl	 SHORT $L135076
$L135078:

; 4152 : 
; 4153 : 	// Expand the compacted array again. Sparks.Num() should always be equal to SparksLimit !
; 4154 : 	if( Sparks.Num() < SparksLimit )

  0016c	8b 87 00 01 00
	00		 mov	 eax, DWORD PTR [edi+256]
  00172	8b bf f4 00 00
	00		 mov	 edi, DWORD PTR [edi+244]
  00178	3b c7		 cmp	 eax, edi
  0017a	7d 2e		 jge	 SHORT $L135141

; 4155 : 		Sparks.Add( SparksLimit - Sparks.Num() );

  0017c	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0017f	2b f8		 sub	 edi, eax
  00181	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00184	03 cf		 add	 ecx, edi
  00186	3b c8		 cmp	 ecx, eax
  00188	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  0018b	7e 1d		 jle	 SHORT $L135141
  0018d	8d 04 49	 lea	 eax, DWORD PTR [ecx+ecx*2]
  00190	99		 cdq
  00191	83 e2 07	 and	 edx, 7
  00194	03 c2		 add	 eax, edx
  00196	c1 f8 03	 sar	 eax, 3
  00199	8d 44 08 20	 lea	 eax, DWORD PTR [eax+ecx+32]
  0019d	6a 08		 push	 8
  0019f	8b ce		 mov	 ecx, esi
  001a1	89 46 08	 mov	 DWORD PTR [esi+8], eax
  001a4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Realloc@FArray@@IAEXH@Z
$L135141:
  001aa	5f		 pop	 edi
  001ab	5e		 pop	 esi
  001ac	5d		 pop	 ebp
  001ad	5b		 pop	 ebx

; 4156 : }

  001ae	c2 04 00	 ret	 4
?Serialize@UFireTexture@@UAEXAAVFArchive@@@Z ENDP	; UFireTexture::Serialize
_TEXT	ENDS
PUBLIC	??_C@_1BK@KFIN@?$AAU?$AAF?$AAi?$AAr?$AAe?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@ ; `string'
PUBLIC	?InternalConstructor@UFireTexture@@SAXPAX@Z	; UFireTexture::InternalConstructor
;	COMDAT ??_C@_1BK@KFIN@?$AAU?$AAF?$AAi?$AAr?$AAe?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@
_DATA	SEGMENT
??_C@_1BK@KFIN@?$AAU?$AAF?$AAi?$AAr?$AAe?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@ DB 'U'
	DB	00H, 'F', 00H, 'i', 00H, 'r', 00H, 'e', 00H, 'T', 00H, 'e', 00H
	DB	'x', 00H, 't', 00H, 'u', 00H, 'r', 00H, 'e', 00H, 00H, 00H ; `string'
; Function compile flags: /Ogty
_DATA	ENDS
;	COMDAT _$E197
_TEXT	SEGMENT
_$E197	PROC NEAR					; COMDAT
  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?StaticConstructor@UObject@@QAEXXZ
  00005	53		 push	 ebx
  00006	55		 push	 ebp
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	83 ec 10	 sub	 esp, 16			; 00000010H
  0000c	8b ec		 mov	 ebp, esp
  0000e	68 00 00 00 00	 push	 OFFSET FLAT:?InternalConstructor@UFireTexture@@SAXPAX@Z ; UFireTexture::InternalConstructor
  00013	68 04 40 08 04	 push	 67649540		; 04084004H
  00018	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1O@KHFL@?$AAS?$AAy?$AAs?$AAt?$AAe?$AAm?$AA?$AA@ ; `string'
  0001d	89 45 00	 mov	 DWORD PTR [ebp], eax
  00020	68 00 00 00 00	 push	 OFFSET FLAT:_GPackage
  00025	33 c9		 xor	 ecx, ecx
  00027	89 4d 04	 mov	 DWORD PTR [ebp+4], ecx
  0002a	68 02 00 00 00	 push	 OFFSET FLAT:??_C@_1BK@KFIN@?$AAU?$AAF?$AAi?$AAr?$AAe?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@+2
  0002f	83 ec 10	 sub	 esp, 16			; 00000010H
  00032	33 d2		 xor	 edx, edx
  00034	89 55 08	 mov	 DWORD PTR [ebp+8], edx
  00037	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR __imp_?PrivateStaticClass@UObject@@0VUClass@@A
  0003d	8b cc		 mov	 ecx, esp
  0003f	52		 push	 edx
  00040	33 f6		 xor	 esi, esi
  00042	89 75 0c	 mov	 DWORD PTR [ebp+12], esi
  00045	33 c0		 xor	 eax, eax
  00047	33 ff		 xor	 edi, edi
  00049	89 39		 mov	 DWORD PTR [ecx], edi
  0004b	68 00 00 00 00	 push	 OFFSET FLAT:?PrivateStaticClass@UFractalTexture@@0VUClass@@A ; UFractalTexture::PrivateStaticClass
  00050	33 db		 xor	 ebx, ebx
  00052	89 59 04	 mov	 DWORD PTR [ecx+4], ebx
  00055	50		 push	 eax
  00056	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00059	68 14 05 00 00	 push	 1300			; 00000514H
  0005e	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  00061	50		 push	 eax
  00062	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?PrivateStaticClass@UFireTexture@@0VUClass@@A
  00067	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0UClass@@QAE@W4ENativeConstructor@@KKPAV0@1VFGuid@@PBG33KP6AXPAX@ZP8UObject@@AEXXZ@Z
  0006d	68 00 00 00 00	 push	 OFFSET FLAT:_$E194
  00072	e8 00 00 00 00	 call	 _atexit
  00077	83 c4 04	 add	 esp, 4
  0007a	5f		 pop	 edi
  0007b	5e		 pop	 esi
  0007c	5d		 pop	 ebp
  0007d	5b		 pop	 ebx
  0007e	c3		 ret	 0
_$E197	ENDP
_TEXT	ENDS
_BSS	SEGMENT
	ALIGN	4

_$S195	DB	01H DUP (?)
; Function compile flags: /Ogty
_BSS	ENDS
;	COMDAT _$E194
_TEXT	SEGMENT
_$E194	PROC NEAR					; COMDAT
  00000	8a 0d 00 00 00
	00		 mov	 cl, BYTE PTR _$S195
  00006	b0 01		 mov	 al, 1
  00008	84 c8		 test	 cl, al
  0000a	75 13		 jne	 SHORT $L124903
  0000c	0a c8		 or	 cl, al
  0000e	88 0d 00 00 00
	00		 mov	 BYTE PTR _$S195, cl
  00014	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?PrivateStaticClass@UFireTexture@@0VUClass@@A
  00019	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1UClass@@UAE@XZ
$L124903:
  0001f	c3		 ret	 0
_$E194	ENDP
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT _$E200
_TEXT	SEGMENT
_$E200	PROC NEAR					; COMDAT
  00000	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _autoclassUFireTexture, OFFSET FLAT:?PrivateStaticClass@UFireTexture@@0VUClass@@A ; UFireTexture::PrivateStaticClass
  0000a	c3		 ret	 0
_$E200	ENDP
_TEXT	ENDS
PUBLIC	??0UWaterTexture@@QAE@XZ			; UWaterTexture::UWaterTexture
PUBLIC	?PostLoad@UWaterTexture@@UAEXXZ			; UWaterTexture::PostLoad
PUBLIC	?Destroy@UWaterTexture@@UAEXXZ			; UWaterTexture::Destroy
PUBLIC	?Init@UWaterTexture@@UAEXHH@Z			; UWaterTexture::Init
PUBLIC	?Clear@UWaterTexture@@UAEXK@Z			; UWaterTexture::Clear
PUBLIC	?MousePosition@UWaterTexture@@UAEXKMM@Z		; UWaterTexture::MousePosition
PUBLIC	?Click@UWaterTexture@@UAEXKMM@Z			; UWaterTexture::Click
PUBLIC	?TouchTexture@UWaterTexture@@UAEXHHM@Z		; UWaterTexture::TouchTexture
PUBLIC	??_7UWaterTexture@@6B@				; UWaterTexture::`vftable'
PUBLIC	??_EUWaterTexture@@UAEPAXI@Z			; UWaterTexture::`vector deleting destructor'
;	COMDAT ??_7UWaterTexture@@6B@
; File ..\..\Core\Inc\UnTemplate.h
CONST	SEGMENT
??_7UWaterTexture@@6B@ DD FLAT:??_EUWaterTexture@@UAEPAXI@Z ; UWaterTexture::`vftable'
	DD	FLAT:?ProcessEvent@UObject@@UAEXPAVUFunction@@PAX1@Z
	DD	FLAT:?ProcessState@UObject@@UAEXM@Z
	DD	FLAT:?ProcessRemoteFunction@UObject@@UAEHPAVUFunction@@PAXPAUFFrame@@@Z
	DD	FLAT:?Modify@UObject@@UAEXXZ
	DD	FLAT:?PostLoad@UWaterTexture@@UAEXXZ
	DD	FLAT:?Destroy@UWaterTexture@@UAEXXZ
	DD	FLAT:?Serialize@UTexture@@UAEXAAVFArchive@@@Z
	DD	FLAT:?IsPendingKill@UObject@@UAEHXZ
	DD	FLAT:?GotoLabel@UObject@@UAEHVFName@@@Z
	DD	FLAT:?InitExecution@UObject@@UAEXXZ
	DD	FLAT:?ShutdownAfterError@UObject@@UAEXXZ
	DD	FLAT:?PostEditChange@UFractalTexture@@UAEXXZ
	DD	FLAT:?CallFunction@UObject@@UAEXAAUFFrame@@QAXPAVUFunction@@@Z
	DD	FLAT:?ScriptConsoleExec@UObject@@UAEHPBGAAVFOutputDevice@@PAV1@@Z
	DD	FLAT:?Register@UObject@@UAEXXZ
	DD	FLAT:?LanguageChange@UObject@@UAEXXZ
	DD	FLAT:?GetName@UObject@@UBEPBGXZ
	DD	FLAT:?Lock@UTexture@@UAIXAAUFTextureInfo@@NHPAVURenderDevice@@@Z
	DD	FLAT:?Unlock@UTexture@@UAIXAAUFTextureInfo@@@Z
	DD	FLAT:?GetMip@UTexture@@UAEPAUFMipmapBase@@H@Z
	DD	FLAT:?Clear@UWaterTexture@@UAEXK@Z
	DD	FLAT:?Init@UWaterTexture@@UAEXHH@Z
	DD	FLAT:?Tick@UTexture@@UAIXM@Z
	DD	FLAT:?ConstantTimeTick@UTexture@@UAEXXZ
	DD	FLAT:?MousePosition@UWaterTexture@@UAEXKMM@Z
	DD	FLAT:?Click@UWaterTexture@@UAEXKMM@Z
	DD	FLAT:?Update@UTexture@@UAEXN@Z
	DD	FLAT:?TouchTexture@UWaterTexture@@UAEXHHM@Z
; Function compile flags: /Ogty
; File C:\duke4\Fire\Src\UnFractal.cpp
CONST	ENDS
;	COMDAT ??0UWaterTexture@@QAE@XZ
_TEXT	SEGMENT
??0UWaterTexture@@QAE@XZ PROC NEAR			; UWaterTexture::UWaterTexture, COMDAT
; _this$ = ecx

; 4167 : {

  00000	53		 push	 ebx
  00001	55		 push	 ebp
  00002	56		 push	 esi
  00003	57		 push	 edi
  00004	8b f1		 mov	 esi, ecx
  00006	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0UTexture@@QAE@XZ
  0000c	8b 8e 88 00 00
	00		 mov	 ecx, DWORD PTR [esi+136]
  00012	83 c9 0c	 or	 ecx, 12			; 0000000cH
  00015	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7UFractalTexture@@6B@ ; UFractalTexture::`vftable'
  0001b	89 8e 88 00 00
	00		 mov	 DWORD PTR [esi+136], ecx
  00021	e8 00 00 00 00	 call	 ?InitTables@@YAXXZ	; InitTables
  00026	33 c0		 xor	 eax, eax

; 4168 : 	// Fill the algorithm lookup table.
; 4169 :     for( INT t=0; t<(1024+512); t++ )

  00028	b9 08 f1 ff ff	 mov	 ecx, -3832		; fffff108H
  0002d	33 ff		 xor	 edi, edi
  0002f	88 86 dc 00 00
	00		 mov	 BYTE PTR [esi+220], al
  00035	88 86 dd 00 00
	00		 mov	 BYTE PTR [esi+221], al
  0003b	89 86 d8 00 00
	00		 mov	 DWORD PTR [esi+216], eax
  00041	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7UWaterTexture@@6B@ ; UWaterTexture::`vftable'
  00047	8d ae f8 0c 00
	00		 lea	 ebp, DWORD PTR [esi+3320]
  0004d	2b ce		 sub	 ecx, esi

; 4175 : }

  0004f	90		 npad	 1

; 4168 : 	// Fill the algorithm lookup table.
; 4169 :     for( INT t=0; t<(1024+512); t++ )

$L124919:

; 4170 : 		WaveTable[t] = Clamp( (t/2 - 256) + ( (t-512)< 256), 0, 255 );

  00050	33 db		 xor	 ebx, ebx
  00052	8d 04 29	 lea	 eax, DWORD PTR [ecx+ebp]
  00055	3d 00 01 00 00	 cmp	 eax, 256		; 00000100H
  0005a	0f 9c c3	 setl	 bl
  0005d	8b c7		 mov	 eax, edi
  0005f	99		 cdq
  00060	2b c2		 sub	 eax, edx
  00062	d1 f8		 sar	 eax, 1
  00064	8d 84 03 00 ff
	ff ff		 lea	 eax, DWORD PTR [ebx+eax-256]
  0006b	85 c0		 test	 eax, eax
  0006d	7d 04		 jge	 SHORT $L135230
  0006f	33 c0		 xor	 eax, eax
  00071	eb 0c		 jmp	 SHORT $L135229
$L135230:
  00073	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00078	7c 05		 jl	 SHORT $L135229
  0007a	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
$L135229:
  0007f	47		 inc	 edi
  00080	88 45 00	 mov	 BYTE PTR [ebp], al
  00083	45		 inc	 ebp
  00084	81 ff 00 06 00
	00		 cmp	 edi, 1536		; 00000600H
  0008a	7c c4		 jl	 SHORT $L124919
  0008c	5f		 pop	 edi

; 4171 : 
; 4172 : 	// Init most non-serialized vars.
; 4173 : 	OldWaveAmp     = -1; 

  0008d	c7 86 fc 12 00
	00 ff ff ff ff	 mov	 DWORD PTR [esi+4860], -1

; 4174 : 	WaveParity     =  0;

  00097	c6 86 f8 12 00
	00 00		 mov	 BYTE PTR [esi+4856], 0

; 4175 : }

  0009e	8b c6		 mov	 eax, esi
  000a0	5e		 pop	 esi
  000a1	5d		 pop	 ebp
  000a2	5b		 pop	 ebx
  000a3	c3		 ret	 0
??0UWaterTexture@@QAE@XZ ENDP				; UWaterTexture::UWaterTexture
_TEXT	ENDS
PUBLIC	??_C@_1BK@KFM@?$AAW?$AAa?$AAt?$AAe?$AAr?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BC@DDHO@?$AAD?$AAr?$AAo?$AAp?$AAT?$AAy?$AAp?$AAe?$AA?$AA@ ; `string'
;	COMDAT ??_C@_1BK@KFM@?$AAW?$AAa?$AAt?$AAe?$AAr?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@
; File ..\..\Core\Inc\UnClass.h
_DATA	SEGMENT
??_C@_1BK@KFM@?$AAW?$AAa?$AAt?$AAe?$AAr?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@ DB 'W'
	DB	00H, 'a', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'T', 00H, 'e', 00H
	DB	'x', 00H, 't', 00H, 'u', 00H, 'r', 00H, 'e', 00H, 00H, 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_1BC@DDHO@?$AAD?$AAr?$AAo?$AAp?$AAT?$AAy?$AAp?$AAe?$AA?$AA@
_DATA	SEGMENT
??_C@_1BC@DDHO@?$AAD?$AAr?$AAo?$AAp?$AAT?$AAy?$AAp?$AAe?$AA?$AA@ DB 'D', 00H
	DB	'r', 00H, 'o', 00H, 'p', 00H, 'T', 00H, 'y', 00H, 'p', 00H, 'e'
	DB	00H, 00H, 00H				; `string'
; Function compile flags: /Ogty
; File C:\duke4\Fire\Src\UnFractal.cpp
_DATA	ENDS
;	COMDAT ?Init@UWaterTexture@@UAEXHH@Z
_TEXT	SEGMENT
_InUSize$ = 8
_InVSize$ = 12
?Init@UWaterTexture@@UAEXHH@Z PROC NEAR			; UWaterTexture::Init, COMDAT
; _this$ = ecx

; 4182 : 	VERIFY_CLASS_OFFSET(U,WaterTexture,DropType);

  00000	a1 18 00 00 00	 mov	 eax, DWORD PTR ?PrivateStaticClass@UWaterTexture@@0VUClass@@A+24
  00005	53		 push	 ebx
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	6a 00		 push	 0
  0000a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1BK@KFM@?$AAW?$AAa?$AAt?$AAe?$AAr?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@ ; `string'
  0000f	50		 push	 eax
  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?PrivateStaticClass@UClass@@0V1@A
  00015	50		 push	 eax
  00016	8b d9		 mov	 ebx, ecx
  00018	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?StaticFindObjectChecked@UObject@@SAPAV1@PAVUClass@@PAV1@PBGH@Z
  0001e	8b f8		 mov	 edi, eax
  00020	83 c4 10	 add	 esp, 16			; 00000010H
  00023	85 ff		 test	 edi, edi
  00025	74 05		 je	 SHORT $L135288
  00027	8b 77 40	 mov	 esi, DWORD PTR [edi+64]
  0002a	eb 02		 jmp	 SHORT $L135289
$L135288:
  0002c	33 f6		 xor	 esi, esi
$L135289:
  0002e	85 ff		 test	 edi, edi
  00030	74 44		 je	 SHORT $L135381
$L135301:
  00032	85 f6		 test	 esi, esi
  00034	74 2e		 je	 SHORT $L135304
  00036	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?PrivateStaticClass@UProperty@@0VUClass@@A

; 4201 : }

  0003c	8d 64 24 00	 npad	 4

; 4182 : 	VERIFY_CLASS_OFFSET(U,WaterTexture,DropType);

$L135303:
  00040	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  00043	85 c0		 test	 eax, eax
  00045	74 0b		 je	 SHORT $L135297
$L135295:
  00047	3b c1		 cmp	 eax, ecx
  00049	74 2b		 je	 SHORT $L135381
  0004b	8b 40 28	 mov	 eax, DWORD PTR [eax+40]
  0004e	85 c0		 test	 eax, eax
  00050	75 f5		 jne	 SHORT $L135295
$L135297:
  00052	33 c0		 xor	 eax, eax
  00054	85 c9		 test	 ecx, ecx
  00056	0f 94 c0	 sete	 al
  00059	85 c0		 test	 eax, eax
  0005b	75 19		 jne	 SHORT $L135381
  0005d	8b 76 2c	 mov	 esi, DWORD PTR [esi+44]
  00060	85 f6		 test	 esi, esi
  00062	75 dc		 jne	 SHORT $L135303
$L135304:
  00064	8b 17		 mov	 edx, DWORD PTR [edi]
  00066	8b cf		 mov	 ecx, edi
  00068	ff 52 5c	 call	 DWORD PTR [edx+92]
  0006b	8b f8		 mov	 edi, eax
  0006d	85 ff		 test	 edi, edi
  0006f	74 05		 je	 SHORT $L135381
  00071	8b 77 40	 mov	 esi, DWORD PTR [edi+64]
  00074	eb bc		 jmp	 SHORT $L135301
$L135381:
  00076	85 f6		 test	 esi, esi
  00078	0f 84 a1 00 00
	00		 je	 $L124941
  0007e	55		 push	 ebp
  0007f	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp_?Logf@FOutputDevice@@QAAXPBGZZ
$L135358:
  00085	8b 06		 mov	 eax, DWORD PTR [esi]
  00087	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1BC@DDHO@?$AAD?$AAr?$AAo?$AAp?$AAT?$AAy?$AAp?$AAe?$AA?$AA@ ; `string'
  0008c	8b ce		 mov	 ecx, esi
  0008e	ff 50 44	 call	 DWORD PTR [eax+68]
  00091	50		 push	 eax
  00092	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?appStricmp@@YAHPBG0@Z
  00098	83 c4 08	 add	 esp, 8
  0009b	85 c0		 test	 eax, eax
  0009d	75 2d		 jne	 SHORT $L124940
  0009f	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  000a2	3d e0 00 00 00	 cmp	 eax, 224		; 000000e0H
  000a7	74 23		 je	 SHORT $L124940
  000a9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?GError@@3PAVFOutputDeviceError@@A
  000af	8b 11		 mov	 edx, DWORD PTR [ecx]
  000b1	68 e0 00 00 00	 push	 224			; 000000e0H
  000b6	50		 push	 eax
  000b7	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1BC@DDHO@?$AAD?$AAr?$AAo?$AAp?$AAT?$AAy?$AAp?$AAe?$AA?$AA@ ; `string'
  000bc	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1BK@KFM@?$AAW?$AAa?$AAt?$AAe?$AAr?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@ ; `string'
  000c1	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1FK@OIBJ@?$AAC?$AAl?$AAa?$AAs?$AAs?$AA?5?$AA?$CF?$AAs?$AA?5?$AAM?$AAe?$AAm?$AAb?$AAe?$AAr?$AA?5?$AA?$CF?$AAs?$AA?5?$AAp@ ; `string'
  000c6	52		 push	 edx
  000c7	ff d5		 call	 ebp
  000c9	83 c4 18	 add	 esp, 24			; 00000018H
$L124940:
  000cc	85 ff		 test	 edi, edi
  000ce	8b 76 2c	 mov	 esi, DWORD PTR [esi+44]
  000d1	74 43		 je	 SHORT $L135383
$L135352:
  000d3	85 f6		 test	 esi, esi
  000d5	74 2d		 je	 SHORT $L135355
  000d7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?PrivateStaticClass@UProperty@@0VUClass@@A

; 4201 : }

  000dd	8d 49 00	 npad	 3

; 4182 : 	VERIFY_CLASS_OFFSET(U,WaterTexture,DropType);

$L135354:
  000e0	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  000e3	85 c0		 test	 eax, eax
  000e5	74 0b		 je	 SHORT $L135348
$L135346:
  000e7	3b c1		 cmp	 eax, ecx
  000e9	74 2b		 je	 SHORT $L135383
  000eb	8b 40 28	 mov	 eax, DWORD PTR [eax+40]
  000ee	85 c0		 test	 eax, eax
  000f0	75 f5		 jne	 SHORT $L135346
$L135348:
  000f2	33 c0		 xor	 eax, eax
  000f4	85 c9		 test	 ecx, ecx
  000f6	0f 94 c0	 sete	 al
  000f9	85 c0		 test	 eax, eax
  000fb	75 19		 jne	 SHORT $L135383
  000fd	8b 76 2c	 mov	 esi, DWORD PTR [esi+44]
  00100	85 f6		 test	 esi, esi
  00102	75 dc		 jne	 SHORT $L135354
$L135355:
  00104	8b 07		 mov	 eax, DWORD PTR [edi]
  00106	8b cf		 mov	 ecx, edi
  00108	ff 50 5c	 call	 DWORD PTR [eax+92]
  0010b	8b f8		 mov	 edi, eax
  0010d	85 ff		 test	 edi, edi
  0010f	74 05		 je	 SHORT $L135383
  00111	8b 77 40	 mov	 esi, DWORD PTR [edi+64]
  00114	eb bd		 jmp	 SHORT $L135352
$L135383:
  00116	85 f6		 test	 esi, esi
  00118	0f 85 67 ff ff
	ff		 jne	 $L135358
  0011e	5d		 pop	 ebp
$L124941:

; 4183 : 
; 4184 : 	// Init base class.
; 4185 : 	UFractalTexture::Init( InUSize, InVSize );

  0011f	8b 4c 24 14	 mov	 ecx, DWORD PTR _InVSize$[esp+8]
  00123	8b 54 24 10	 mov	 edx, DWORD PTR _InUSize$[esp+8]
  00127	51		 push	 ecx
  00128	52		 push	 edx
  00129	8b cb		 mov	 ecx, ebx
  0012b	e8 00 00 00 00	 call	 ?Init@UFractalTexture@@UAEXHH@Z ; UFractalTexture::Init

; 4186 : 
; 4187 : 	// One-time initialization of *serialized* parameters.
; 4188 :     NumDrops =   0;
; 4189 :     DropType =   1;        
; 4190 : 	WaveAmp  = 128;

  00130	b1 80		 mov	 cl, 128			; 00000080H

; 4191 : 
; 4192 : 	// FX specifics
; 4193 : 	FX_Frequency	= 010;

  00132	b0 08		 mov	 al, 8
  00134	88 8b e1 00 00
	00		 mov	 BYTE PTR [ebx+225], cl
  0013a	88 83 e2 00 00
	00		 mov	 BYTE PTR [ebx+226], al

; 4194 : 	FX_Phase		= 010;

  00140	88 83 e3 00 00
	00		 mov	 BYTE PTR [ebx+227], al

; 4195 : 	FX_Amplitude	= 255;

  00146	b0 ff		 mov	 al, 255			; 000000ffH

; 4196 : 	FX_Speed		= 255;
; 4197 : 	FX_Radius		= 128;

  00148	88 8b e6 00 00
	00		 mov	 BYTE PTR [ebx+230], cl
  0014e	5f		 pop	 edi

; 4198 : 	FX_Size			= 30;

  0014f	b1 1e		 mov	 cl, 30			; 0000001eH
  00151	5e		 pop	 esi
  00152	c7 83 ec 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ebx+236], 0
  0015c	c6 83 e0 00 00
	00 01		 mov	 BYTE PTR [ebx+224], 1
  00163	88 83 e4 00 00
	00		 mov	 BYTE PTR [ebx+228], al
  00169	88 83 e5 00 00
	00		 mov	 BYTE PTR [ebx+229], al
  0016f	88 8b e7 00 00
	00		 mov	 BYTE PTR [ebx+231], cl

; 4199 : 	FX_Depth		= 255;

  00175	88 83 e8 00 00
	00		 mov	 BYTE PTR [ebx+232], al

; 4200 : 	FX_Time         = 30;

  0017b	88 8b e9 00 00
	00		 mov	 BYTE PTR [ebx+233], cl
  00181	5b		 pop	 ebx

; 4201 : }

  00182	c2 08 00	 ret	 8
?Init@UWaterTexture@@UAEXHH@Z ENDP			; UWaterTexture::Init
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?PostLoad@UWaterTexture@@UAEXXZ
_TEXT	SEGMENT
?PostLoad@UWaterTexture@@UAEXXZ PROC NEAR		; UWaterTexture::PostLoad, COMDAT
; _this$ = ecx

; 4205 : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 4206 : 	Super::PostLoad();

  00003	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?PostLoad@UTexture@@UAEXXZ
  00009	8b 4e 34	 mov	 ecx, DWORD PTR [esi+52]
  0000c	8d 41 ff	 lea	 eax, DWORD PTR [ecx-1]
  0000f	89 86 c8 00 00
	00		 mov	 DWORD PTR [esi+200], eax
  00015	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  00018	8d 50 ff	 lea	 edx, DWORD PTR [eax-1]
  0001b	89 96 cc 00 00
	00		 mov	 DWORD PTR [esi+204], edx

; 4207 : 
; 4208 : 	if( SourceFields == NULL )

  00021	8b 96 f0 08 00
	00		 mov	 edx, DWORD PTR [esi+2288]
  00027	85 d2		 test	 edx, edx
  00029	75 50		 jne	 SHORT $L124958

; 4209 : 	{
; 4210 : 		// Allocate the two wave height fields.
; 4211 : 		SourceFields = new BYTE[ USize * VSize / 2 ]; 

  0002b	0f af c1	 imul	 eax, ecx
  0002e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?GMalloc@@3PAVFMalloc@@A
  00034	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00036	99		 cdq
  00037	2b c2		 sub	 eax, edx
  00039	8b 11		 mov	 edx, DWORD PTR [ecx]
  0003b	d1 f8		 sar	 eax, 1
  0003d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_17JBDG@?$AAn?$AAe?$AAw?$AA?$AA@ ; `string'
  00042	50		 push	 eax
  00043	ff 12		 call	 DWORD PTR [edx]
  00045	89 86 f0 08 00
	00		 mov	 DWORD PTR [esi+2288], eax

; 4212 : 		// initialize water to average height.
; 4213 : 		for( INT i=0; i< USize * VSize / 2; i++ )

  0004b	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  0004e	0f af 46 34	 imul	 eax, DWORD PTR [esi+52]
  00052	99		 cdq
  00053	2b c2		 sub	 eax, edx
  00055	d1 f8		 sar	 eax, 1
  00057	33 c9		 xor	 ecx, ecx
  00059	85 c0		 test	 eax, eax
  0005b	7e 1e		 jle	 SHORT $L124958

; 4215 : 	}
; 4216 : }

  0005d	8d 49 00	 npad	 3
$L124956:

; 4214 : 			SourceFields[i] = 128;

  00060	8b 86 f0 08 00
	00		 mov	 eax, DWORD PTR [esi+2288]
  00066	c6 04 01 80	 mov	 BYTE PTR [ecx+eax], 128	; 00000080H
  0006a	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  0006d	0f af 46 34	 imul	 eax, DWORD PTR [esi+52]
  00071	99		 cdq
  00072	2b c2		 sub	 eax, edx
  00074	41		 inc	 ecx
  00075	d1 f8		 sar	 eax, 1
  00077	3b c8		 cmp	 ecx, eax
  00079	7c e5		 jl	 SHORT $L124956
$L124958:
  0007b	5e		 pop	 esi

; 4215 : 	}
; 4216 : }

  0007c	c3		 ret	 0
?PostLoad@UWaterTexture@@UAEXXZ ENDP			; UWaterTexture::PostLoad
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?TouchTexture@UWaterTexture@@UAEXHHM@Z
_TEXT	SEGMENT
_UPos$ = 8
_VPos$ = 12
_Magnitude$ = 16
?TouchTexture@UWaterTexture@@UAEXHHM@Z PROC NEAR	; UWaterTexture::TouchTexture, COMDAT
; _this$ = ecx

; 4222 : 	BYTE* WaveFieldA = SourceFields;
; 4223 :     BYTE* WaveFieldB = SourceFields + USize;
; 4224 : 
; 4225 :     DWORD DropDest   = (DWORD)( ( VPos << UBits ) + UPos);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _UPos$[esp-4]

; 4226 : 
; 4227 :     // Depress a circular gradual area, radius = Magnitude.
; 4228 : 
; 4229 : 	BYTE Depth = (BYTE) Magnitude;       

  00004	d9 44 24 0c	 fld	 DWORD PTR _Magnitude$[esp-4]
  00008	53		 push	 ebx
  00009	8b 99 f0 08 00
	00		 mov	 ebx, DWORD PTR [ecx+2288]
  0000f	56		 push	 esi
  00010	8b 74 24 10	 mov	 esi, DWORD PTR _VPos$[esp+4]
  00014	57		 push	 edi
  00015	8b 79 34	 mov	 edi, DWORD PTR [ecx+52]
  00018	8a 49 30	 mov	 cl, BYTE PTR [ecx+48]
  0001b	d3 e6		 shl	 esi, cl
  0001d	03 fb		 add	 edi, ebx
  0001f	03 f0		 add	 esi, eax
  00021	e8 00 00 00 00	 call	 __ftol

; 4230 : 
; 4231 :     WaveFieldA[ DropDest ]  =  Depth;

  00026	88 04 33	 mov	 BYTE PTR [ebx+esi], al

; 4232 :     WaveFieldB[ DropDest ]  =  Depth;

  00029	88 04 3e	 mov	 BYTE PTR [esi+edi], al
  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi
  0002e	5b		 pop	 ebx

; 4233 : }

  0002f	c2 0c 00	 ret	 12			; 0000000cH
?TouchTexture@UWaterTexture@@UAEXHHM@Z ENDP		; UWaterTexture::TouchTexture
_TEXT	ENDS
EXTRN	__imp_?Destroy@UTexture@@UAEXXZ:NEAR
; Function compile flags: /Ogty
;	COMDAT ?Destroy@UWaterTexture@@UAEXXZ
_TEXT	SEGMENT
?Destroy@UWaterTexture@@UAEXXZ PROC NEAR		; UWaterTexture::Destroy, COMDAT
; _this$ = ecx

; 4239 : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 4240 : 	// Free memory.
; 4241 : 	if( SourceFields )

  00003	8b 86 f0 08 00
	00		 mov	 eax, DWORD PTR [esi+2288]
  00009	85 c0		 test	 eax, eax
  0000b	74 0e		 je	 SHORT $L135412

; 4242 : 		delete SourceFields;

  0000d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?GMalloc@@3PAVFMalloc@@A
  00013	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00015	8b 11		 mov	 edx, DWORD PTR [ecx]
  00017	50		 push	 eax
  00018	ff 52 08	 call	 DWORD PTR [edx+8]
$L135412:

; 4243 : 
; 4244 : 	Super::Destroy(); // must call base class' destroy.

  0001b	8b ce		 mov	 ecx, esi
  0001d	5e		 pop	 esi
  0001e	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_?Destroy@UTexture@@UAEXXZ
?Destroy@UWaterTexture@@UAEXXZ ENDP			; UWaterTexture::Destroy
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?Clear@UWaterTexture@@UAEXK@Z
_TEXT	SEGMENT
_ClearFlags$ = 8
?Clear@UWaterTexture@@UAEXK@Z PROC NEAR			; UWaterTexture::Clear, COMDAT
; _this$ = ecx

; 4249 : {

  00000	53		 push	 ebx

; 4250 : 	// Init to zero.
; 4251 : 	UFractalTexture::Clear( ClearFlags );

  00001	8b 5c 24 08	 mov	 ebx, DWORD PTR _ClearFlags$[esp]
  00005	56		 push	 esi
  00006	53		 push	 ebx
  00007	8b f1		 mov	 esi, ecx
  00009	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Clear@UTexture@@UAEXK@Z

; 4252 : 
; 4253 : 	// Clear fields.
; 4254 : 	if( ClearFlags & TCLEAR_Bitmap )

  0000f	f6 c3 02	 test	 bl, 2
  00012	74 2d		 je	 SHORT $L124984

; 4255 : 		for( INT i=0; i< USize * VSize / 2; i++ )

  00014	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  00017	0f af 46 38	 imul	 eax, DWORD PTR [esi+56]
  0001b	99		 cdq
  0001c	2b c2		 sub	 eax, edx
  0001e	d1 f8		 sar	 eax, 1
  00020	33 c9		 xor	 ecx, ecx
  00022	85 c0		 test	 eax, eax
  00024	7e 1b		 jle	 SHORT $L124984
$L124982:

; 4256 : 			SourceFields[i] = 128;

  00026	8b 86 f0 08 00
	00		 mov	 eax, DWORD PTR [esi+2288]
  0002c	c6 04 01 80	 mov	 BYTE PTR [ecx+eax], 128	; 00000080H
  00030	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  00033	0f af 46 38	 imul	 eax, DWORD PTR [esi+56]
  00037	99		 cdq
  00038	2b c2		 sub	 eax, edx
  0003a	41		 inc	 ecx
  0003b	d1 f8		 sar	 eax, 1
  0003d	3b c8		 cmp	 ecx, eax
  0003f	7c e5		 jl	 SHORT $L124982
$L124984:

; 4257 : 
; 4258 : 	// Clear drops.
; 4259 : 	if( ClearFlags & TCLEAR_Temporal )

  00041	f6 c3 01	 test	 bl, 1
  00044	74 0a		 je	 SHORT $L124985

; 4260 : 		NumDrops=0;

  00046	c7 86 ec 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+236], 0
$L124985:
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx

; 4261 : }

  00052	c2 04 00	 ret	 4
?Clear@UWaterTexture@@UAEXK@Z ENDP			; UWaterTexture::Clear
_TEXT	ENDS
PUBLIC	?WaterPaint@UWaterTexture@@AAEXHHK@Z		; UWaterTexture::WaterPaint
; Function compile flags: /Ogty
;	COMDAT ?WaterPaint@UWaterTexture@@AAEXHHK@Z
_TEXT	SEGMENT
_X$ = 8
_Y$ = 12
_Buttons$ = 16
?WaterPaint@UWaterTexture@@AAEXHHK@Z PROC NEAR		; UWaterTexture::WaterPaint, COMDAT
; _this$ = ecx

; 4266 : 	INT MouseX=X, MouseY=Y;
; 4267 : 
; 4268 : 	// Water drawing
; 4269 : 	
; 4270 : 	UBOOL  LeftButton = (Buttons & MOUSE_Left);

  00000	8b 44 24 0c	 mov	 eax, DWORD PTR _Buttons$[esp-4]
  00004	53		 push	 ebx

; 4271 : 
; 4272 : 	// Perform painting.
; 4273 :     static INT  LastMouseX=0, LastMouseY=0, LastLeftButton=0, LastRightButton=0;
; 4274 : 
; 4275 :     UBOOL  PosChanged   =  ((LastMouseX != MouseX) || (LastMouseY != MouseY));

  00005	8b 5c 24 08	 mov	 ebx, DWORD PTR _X$[esp]
  00009	55		 push	 ebp
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?LastMouseX@?1??WaterPaint@UWaterTexture@@AAEXHHK@Z@4HA
  00013	83 e0 01	 and	 eax, 1
  00016	3b cb		 cmp	 ecx, ebx
  00018	57		 push	 edi
  00019	75 10		 jne	 SHORT $L135422
  0001b	8b 4c 24 18	 mov	 ecx, DWORD PTR _Y$[esp+12]
  0001f	39 0d 00 00 00
	00		 cmp	 DWORD PTR ?LastMouseY@?1??WaterPaint@UWaterTexture@@AAEXHHK@Z@4HA, ecx
  00025	75 04		 jne	 SHORT $L135422
  00027	33 ed		 xor	 ebp, ebp
  00029	eb 05		 jmp	 SHORT $L135423
$L135422:
  0002b	bd 01 00 00 00	 mov	 ebp, 1
$L135423:

; 4276 :     UBOOL  LeftChanged  =   (LastLeftButton  != LeftButton );

  00030	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?LastLeftButton@?1??WaterPaint@UWaterTexture@@AAEXHHK@Z@4HA
  00036	33 d2		 xor	 edx, edx
  00038	3b c8		 cmp	 ecx, eax

; 4277 : 
; 4278 : 	UBOOL Continuous = true; 
; 4279 : 
; 4280 : 	// Check types that don't require continuous drawing
; 4281 : 	switch (DropType)
; 4282 : 	{

  0003a	8a 8e e0 00 00
	00		 mov	 cl, BYTE PTR [esi+224]
  00040	0f 95 c2	 setne	 dl
  00043	80 f9 08	 cmp	 cl, 8
  00046	8b fa		 mov	 edi, edx
  00048	ba 01 00 00 00	 mov	 edx, 1
  0004d	72 0c		 jb	 SHORT $L125007
  0004f	80 f9 0f	 cmp	 cl, 15			; 0000000fH
  00052	76 05		 jbe	 SHORT $L125010
  00054	80 f9 11	 cmp	 cl, 17			; 00000011H
  00057	75 02		 jne	 SHORT $L125007
$L125010:

; 4283 : 		case DROP_HorizontalLine:
; 4284 : 		case DROP_VerticalLine:
; 4285 : 		case DROP_DiagonalLine1:
; 4286 : 		case DROP_DiagonalLine2:
; 4287 : 		case DROP_HorizontalOsc:
; 4288 : 		case DROP_VerticalOsc:
; 4289 : 		case DROP_DiagonalOsc1:
; 4290 : 		case DROP_DiagonalOsc2:
; 4291 : 		case DROP_AreaClamp:
; 4292 : 			Continuous = false;

  00059	33 d2		 xor	 edx, edx
$L125007:

; 4293 : 		break;
; 4294 : 	};
; 4295 : 
; 4296 : 	// Paint on the water.
; 4297 :     if( (Buttons & MOUSE_Left) && ( Continuous && (PosChanged  || LeftChanged ) ) )

  0005b	85 c0		 test	 eax, eax
  0005d	74 19		 je	 SHORT $L125011
  0005f	85 d2		 test	 edx, edx
  00061	74 15		 je	 SHORT $L125011
  00063	85 ed		 test	 ebp, ebp
  00065	75 04		 jne	 SHORT $L125012
  00067	85 ff		 test	 edi, edi
  00069	74 0d		 je	 SHORT $L125011
$L125012:

; 4298 :         AddDrop( MouseX, MouseY);

  0006b	8b 44 24 18	 mov	 eax, DWORD PTR _Y$[esp+12]
  0006f	50		 push	 eax
  00070	53		 push	 ebx
  00071	8b ce		 mov	 ecx, esi
  00073	e8 00 00 00 00	 call	 ?AddDrop@UWaterTexture@@AAEXHH@Z ; UWaterTexture::AddDrop
$L125011:

; 4299 : 
; 4300 :     if( Buttons & MOUSE_Right )

  00078	f6 44 24 1c 02	 test	 BYTE PTR _Buttons$[esp+12], 2
  0007d	74 6f		 je	 SHORT $L135454

; 4301 :         DeleteDrops( MouseX, MouseY, DEL_RANGE);

  0007f	8b 96 ec 00 00
	00		 mov	 edx, DWORD PTR [esi+236]
  00085	33 ed		 xor	 ebp, ebp
  00087	85 d2		 test	 edx, edx
  00089	7e 63		 jle	 SHORT $L135454
  0008b	8d 8e f3 00 00
	00		 lea	 ecx, DWORD PTR [esi+243]
  00091	eb 04		 jmp	 SHORT $L135452
$L135459:
  00093	8b 5c 24 14	 mov	 ebx, DWORD PTR _X$[esp+12]
$L135452:
  00097	33 c0		 xor	 eax, eax
  00099	8a 41 ff	 mov	 al, BYTE PTR [ecx-1]
  0009c	d1 e0		 shl	 eax, 1
  0009e	8b f8		 mov	 edi, eax
  000a0	8b c3		 mov	 eax, ebx
  000a2	2b c7		 sub	 eax, edi
  000a4	79 02		 jns	 SHORT $L135462
  000a6	f7 d8		 neg	 eax
$L135462:
  000a8	8b f8		 mov	 edi, eax
  000aa	33 c0		 xor	 eax, eax
  000ac	8a 01		 mov	 al, BYTE PTR [ecx]
  000ae	d1 e0		 shl	 eax, 1
  000b0	8b d8		 mov	 ebx, eax
  000b2	8b 44 24 18	 mov	 eax, DWORD PTR _Y$[esp+12]
  000b6	2b c3		 sub	 eax, ebx
  000b8	79 02		 jns	 SHORT $L135449
  000ba	f7 d8		 neg	 eax
$L135449:
  000bc	03 c7		 add	 eax, edi
  000be	83 f8 0c	 cmp	 eax, 12			; 0000000cH
  000c1	7f 1d		 jg	 SHORT $L135453
  000c3	8d 42 ff	 lea	 eax, DWORD PTR [edx-1]
  000c6	89 86 ec 00 00
	00		 mov	 DWORD PTR [esi+236], eax
  000cc	8b 94 c6 f0 00
	00 00		 mov	 edx, DWORD PTR [esi+eax*8+240]
  000d3	89 51 fd	 mov	 DWORD PTR [ecx-3], edx
  000d6	8b 84 c6 f4 00
	00 00		 mov	 eax, DWORD PTR [esi+eax*8+244]
  000dd	89 41 01	 mov	 DWORD PTR [ecx+1], eax
$L135453:
  000e0	8b 96 ec 00 00
	00		 mov	 edx, DWORD PTR [esi+236]
  000e6	45		 inc	 ebp
  000e7	83 c1 08	 add	 ecx, 8
  000ea	3b ea		 cmp	 ebp, edx
  000ec	7c a5		 jl	 SHORT $L135459
$L135454:
  000ee	5f		 pop	 edi
  000ef	5e		 pop	 esi
  000f0	5d		 pop	 ebp
  000f1	5b		 pop	 ebx

; 4302 : }

  000f2	c2 0c 00	 ret	 12			; 0000000cH
?WaterPaint@UWaterTexture@@AAEXHHK@Z ENDP		; UWaterTexture::WaterPaint
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?MousePosition@UWaterTexture@@UAEXKMM@Z
_TEXT	SEGMENT
_Buttons$ = 8
_X$ = 12
_Y$ = 16
_I$135469 = -4
_I$135474 = 16
?MousePosition@UWaterTexture@@UAEXKMM@Z PROC NEAR	; UWaterTexture::MousePosition, COMDAT
; _this$ = ecx

; 4306 : {

  00000	51		 push	 ecx
  00001	53		 push	 ebx
  00002	55		 push	 ebp
  00003	56		 push	 esi
  00004	57		 push	 edi
  00005	8b f1		 mov	 esi, ecx

; 4307 : 	WaterPaint(appRound(X),appRound(Y),Buttons);

  00007	d9 44 24 20	 fld	 DWORD PTR _Y$[esp+16]
  0000b	db 5c 24 10	 fistp	 DWORD PTR _I$135469[esp+20]
  0000f	d9 44 24 1c	 fld	 DWORD PTR _X$[esp+16]
  00013	db 5c 24 20	 fistp	 DWORD PTR _I$135474[esp+16]
  00017	8b 44 24 18	 mov	 eax, DWORD PTR _Buttons$[esp+16]
  0001b	8b 5c 24 20	 mov	 ebx, DWORD PTR _I$135474[esp+16]
  0001f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?LastMouseX@?1??WaterPaint@UWaterTexture@@AAEXHHK@Z@4HA
  00025	83 e0 01	 and	 eax, 1
  00028	3b cb		 cmp	 ecx, ebx
  0002a	75 10		 jne	 SHORT $L135530
  0002c	8b 4c 24 10	 mov	 ecx, DWORD PTR _I$135469[esp+20]
  00030	39 0d 00 00 00
	00		 cmp	 DWORD PTR ?LastMouseY@?1??WaterPaint@UWaterTexture@@AAEXHHK@Z@4HA, ecx
  00036	75 04		 jne	 SHORT $L135530
  00038	33 ed		 xor	 ebp, ebp
  0003a	eb 05		 jmp	 SHORT $L135531
$L135530:
  0003c	bd 01 00 00 00	 mov	 ebp, 1
$L135531:
  00041	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?LastLeftButton@?1??WaterPaint@UWaterTexture@@AAEXHHK@Z@4HA
  00047	33 d2		 xor	 edx, edx
  00049	3b c8		 cmp	 ecx, eax
  0004b	8a 8e e0 00 00
	00		 mov	 cl, BYTE PTR [esi+224]
  00051	0f 95 c2	 setne	 dl
  00054	80 f9 08	 cmp	 cl, 8
  00057	8b fa		 mov	 edi, edx
  00059	ba 01 00 00 00	 mov	 edx, 1
  0005e	72 0c		 jb	 SHORT $L135524
  00060	80 f9 0f	 cmp	 cl, 15			; 0000000fH
  00063	76 05		 jbe	 SHORT $L135525
  00065	80 f9 11	 cmp	 cl, 17			; 00000011H
  00068	75 02		 jne	 SHORT $L135524
$L135525:
  0006a	33 d2		 xor	 edx, edx
$L135524:
  0006c	85 c0		 test	 eax, eax
  0006e	74 19		 je	 SHORT $L135526
  00070	85 d2		 test	 edx, edx
  00072	74 15		 je	 SHORT $L135526
  00074	85 ed		 test	 ebp, ebp
  00076	75 04		 jne	 SHORT $L135527
  00078	85 ff		 test	 edi, edi
  0007a	74 0d		 je	 SHORT $L135526
$L135527:
  0007c	8b 44 24 10	 mov	 eax, DWORD PTR _I$135469[esp+20]
  00080	50		 push	 eax
  00081	53		 push	 ebx
  00082	8b ce		 mov	 ecx, esi
  00084	e8 00 00 00 00	 call	 ?AddDrop@UWaterTexture@@AAEXHH@Z ; UWaterTexture::AddDrop
$L135526:
  00089	f6 44 24 18 02	 test	 BYTE PTR _Buttons$[esp+16], 2
  0008e	74 6f		 je	 SHORT $L135545
  00090	8b 96 ec 00 00
	00		 mov	 edx, DWORD PTR [esi+236]
  00096	33 ed		 xor	 ebp, ebp
  00098	85 d2		 test	 edx, edx
  0009a	7e 63		 jle	 SHORT $L135545
  0009c	8d 8e f3 00 00
	00		 lea	 ecx, DWORD PTR [esi+243]
  000a2	eb 04		 jmp	 SHORT $L135543
$L135550:
  000a4	8b 5c 24 20	 mov	 ebx, DWORD PTR _I$135474[esp+16]
$L135543:
  000a8	33 c0		 xor	 eax, eax
  000aa	8a 41 ff	 mov	 al, BYTE PTR [ecx-1]
  000ad	d1 e0		 shl	 eax, 1
  000af	8b f8		 mov	 edi, eax
  000b1	8b c3		 mov	 eax, ebx
  000b3	2b c7		 sub	 eax, edi
  000b5	79 02		 jns	 SHORT $L135553
  000b7	f7 d8		 neg	 eax
$L135553:
  000b9	8b f8		 mov	 edi, eax
  000bb	33 c0		 xor	 eax, eax
  000bd	8a 01		 mov	 al, BYTE PTR [ecx]
  000bf	d1 e0		 shl	 eax, 1
  000c1	8b d8		 mov	 ebx, eax
  000c3	8b 44 24 10	 mov	 eax, DWORD PTR _I$135469[esp+20]
  000c7	2b c3		 sub	 eax, ebx
  000c9	79 02		 jns	 SHORT $L135540
  000cb	f7 d8		 neg	 eax
$L135540:
  000cd	03 c7		 add	 eax, edi
  000cf	83 f8 0c	 cmp	 eax, 12			; 0000000cH
  000d2	7f 1d		 jg	 SHORT $L135544
  000d4	8d 42 ff	 lea	 eax, DWORD PTR [edx-1]
  000d7	89 86 ec 00 00
	00		 mov	 DWORD PTR [esi+236], eax
  000dd	8b 94 c6 f0 00
	00 00		 mov	 edx, DWORD PTR [esi+eax*8+240]
  000e4	89 51 fd	 mov	 DWORD PTR [ecx-3], edx
  000e7	8b 84 c6 f4 00
	00 00		 mov	 eax, DWORD PTR [esi+eax*8+244]
  000ee	89 41 01	 mov	 DWORD PTR [ecx+1], eax
$L135544:
  000f1	8b 96 ec 00 00
	00		 mov	 edx, DWORD PTR [esi+236]
  000f7	45		 inc	 ebp
  000f8	83 c1 08	 add	 ecx, 8
  000fb	3b ea		 cmp	 ebp, edx
  000fd	7c a5		 jl	 SHORT $L135550
$L135545:
  000ff	5f		 pop	 edi
  00100	5e		 pop	 esi
  00101	5d		 pop	 ebp
  00102	5b		 pop	 ebx

; 4308 : }

  00103	59		 pop	 ecx
  00104	c2 0c 00	 ret	 12			; 0000000cH
?MousePosition@UWaterTexture@@UAEXKMM@Z ENDP		; UWaterTexture::MousePosition
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?Click@UWaterTexture@@UAEXKMM@Z
_TEXT	SEGMENT
_Buttons$ = 8
_X$ = 12
_Y$ = 16
_MouseX$ = 12
_MouseY$ = 16
?Click@UWaterTexture@@UAEXKMM@Z PROC NEAR		; UWaterTexture::Click, COMDAT
; _this$ = ecx

; 4314 : 	INT MouseX=(INT) X, MouseY=(INT) Y;

  00000	d9 44 24 08	 fld	 DWORD PTR _X$[esp-4]
  00004	53		 push	 ebx
  00005	55		 push	 ebp
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8b f1		 mov	 esi, ecx
  0000a	e8 00 00 00 00	 call	 __ftol
  0000f	d9 44 24 1c	 fld	 DWORD PTR _Y$[esp+12]
  00013	8b f8		 mov	 edi, eax
  00015	89 7c 24 18	 mov	 DWORD PTR _MouseX$[esp+12], edi
  00019	e8 00 00 00 00	 call	 __ftol

; 4315 : 
; 4316 : 	// Paint on the water.
; 4317 :     if( Buttons & MOUSE_Left )

  0001e	8a 5c 24 14	 mov	 bl, BYTE PTR _Buttons$[esp+12]
  00022	f6 c3 01	 test	 bl, 1
  00025	89 44 24 1c	 mov	 DWORD PTR _MouseY$[esp+12], eax
  00029	74 09		 je	 SHORT $L125030

; 4318 : 	{
; 4319 :         AddDrop( MouseX, MouseY);

  0002b	50		 push	 eax
  0002c	57		 push	 edi
  0002d	8b ce		 mov	 ecx, esi
  0002f	e8 00 00 00 00	 call	 ?AddDrop@UWaterTexture@@AAEXHH@Z ; UWaterTexture::AddDrop
$L125030:

; 4320 : 	}
; 4321 : 
; 4322 :     if( Buttons & MOUSE_Right )

  00034	f6 c3 02	 test	 bl, 2
  00037	74 6f		 je	 SHORT $L135587

; 4323 :         DeleteDrops( MouseX, MouseY, DEL_RANGE);

  00039	8b 96 ec 00 00
	00		 mov	 edx, DWORD PTR [esi+236]
  0003f	33 ed		 xor	 ebp, ebp
  00041	85 d2		 test	 edx, edx
  00043	7e 63		 jle	 SHORT $L135587
  00045	8d 8e f3 00 00
	00		 lea	 ecx, DWORD PTR [esi+243]
  0004b	eb 04		 jmp	 SHORT $L135585
$L135592:
  0004d	8b 7c 24 18	 mov	 edi, DWORD PTR _MouseX$[esp+12]
$L135585:
  00051	33 c0		 xor	 eax, eax
  00053	8a 41 ff	 mov	 al, BYTE PTR [ecx-1]
  00056	d1 e0		 shl	 eax, 1
  00058	8b d8		 mov	 ebx, eax
  0005a	8b c7		 mov	 eax, edi
  0005c	2b c3		 sub	 eax, ebx
  0005e	79 02		 jns	 SHORT $L135593
  00060	f7 d8		 neg	 eax
$L135593:
  00062	8b f8		 mov	 edi, eax
  00064	33 c0		 xor	 eax, eax
  00066	8a 01		 mov	 al, BYTE PTR [ecx]
  00068	d1 e0		 shl	 eax, 1
  0006a	8b d8		 mov	 ebx, eax
  0006c	8b 44 24 1c	 mov	 eax, DWORD PTR _MouseY$[esp+12]
  00070	2b c3		 sub	 eax, ebx
  00072	79 02		 jns	 SHORT $L135582
  00074	f7 d8		 neg	 eax
$L135582:
  00076	03 c7		 add	 eax, edi
  00078	83 f8 0c	 cmp	 eax, 12			; 0000000cH
  0007b	7f 1d		 jg	 SHORT $L135586
  0007d	8d 42 ff	 lea	 eax, DWORD PTR [edx-1]
  00080	89 86 ec 00 00
	00		 mov	 DWORD PTR [esi+236], eax
  00086	8b 94 c6 f0 00
	00 00		 mov	 edx, DWORD PTR [esi+eax*8+240]
  0008d	89 51 fd	 mov	 DWORD PTR [ecx-3], edx
  00090	8b 84 c6 f4 00
	00 00		 mov	 eax, DWORD PTR [esi+eax*8+244]
  00097	89 41 01	 mov	 DWORD PTR [ecx+1], eax
$L135586:
  0009a	8b 96 ec 00 00
	00		 mov	 edx, DWORD PTR [esi+236]
  000a0	45		 inc	 ebp
  000a1	83 c1 08	 add	 ecx, 8
  000a4	3b ea		 cmp	 ebp, edx
  000a6	7c a5		 jl	 SHORT $L135592
$L135587:
  000a8	5f		 pop	 edi
  000a9	5e		 pop	 esi
  000aa	5d		 pop	 ebp
  000ab	5b		 pop	 ebx

; 4324 : }

  000ac	c2 0c 00	 ret	 12			; 0000000cH
?Click@UWaterTexture@@UAEXKMM@Z ENDP			; UWaterTexture::Click
_TEXT	ENDS
PUBLIC	??_C@_1BM@IGJG@?$AAU?$AAW?$AAa?$AAt?$AAe?$AAr?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@ ; `string'
;	COMDAT ??_C@_1BM@IGJG@?$AAU?$AAW?$AAa?$AAt?$AAe?$AAr?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@
_DATA	SEGMENT
??_C@_1BM@IGJG@?$AAU?$AAW?$AAa?$AAt?$AAe?$AAr?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@ DB 'U'
	DB	00H, 'W', 00H, 'a', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'T', 00H
	DB	'e', 00H, 'x', 00H, 't', 00H, 'u', 00H, 'r', 00H, 'e', 00H, 00H
	DB	00H						; `string'
; Function compile flags: /Ogty
_DATA	ENDS
;	COMDAT _$E206
_TEXT	SEGMENT
_$E206	PROC NEAR					; COMDAT
  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?StaticConstructor@UObject@@QAEXXZ
  00005	53		 push	 ebx
  00006	55		 push	 ebp
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	83 ec 10	 sub	 esp, 16			; 00000010H
  0000c	8b ec		 mov	 ebp, esp
  0000e	89 45 00	 mov	 DWORD PTR [ebp], eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?InternalConstructor@UTexture@@SAXPAX@Z
  00016	50		 push	 eax
  00017	68 04 40 08 04	 push	 67649540		; 04084004H
  0001c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1O@KHFL@?$AAS?$AAy?$AAs?$AAt?$AAe?$AAm?$AA?$AA@ ; `string'
  00021	68 00 00 00 00	 push	 OFFSET FLAT:_GPackage
  00026	33 c9		 xor	 ecx, ecx
  00028	89 4d 04	 mov	 DWORD PTR [ebp+4], ecx
  0002b	68 02 00 00 00	 push	 OFFSET FLAT:??_C@_1BM@IGJG@?$AAU?$AAW?$AAa?$AAt?$AAe?$AAr?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@+2
  00030	83 ec 10	 sub	 esp, 16			; 00000010H
  00033	33 d2		 xor	 edx, edx
  00035	89 55 08	 mov	 DWORD PTR [ebp+8], edx
  00038	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR __imp_?PrivateStaticClass@UObject@@0VUClass@@A
  0003e	8b cc		 mov	 ecx, esp
  00040	52		 push	 edx
  00041	33 f6		 xor	 esi, esi
  00043	89 75 0c	 mov	 DWORD PTR [ebp+12], esi
  00046	33 ff		 xor	 edi, edi
  00048	89 39		 mov	 DWORD PTR [ecx], edi
  0004a	68 00 00 00 00	 push	 OFFSET FLAT:?PrivateStaticClass@UFractalTexture@@0VUClass@@A ; UFractalTexture::PrivateStaticClass
  0004f	33 c0		 xor	 eax, eax
  00051	33 db		 xor	 ebx, ebx
  00053	89 59 04	 mov	 DWORD PTR [ecx+4], ebx
  00056	6a 01		 push	 1
  00058	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  0005b	68 00 13 00 00	 push	 4864			; 00001300H
  00060	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  00063	50		 push	 eax
  00064	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?PrivateStaticClass@UWaterTexture@@0VUClass@@A
  00069	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0UClass@@QAE@W4ENativeConstructor@@KKPAV0@1VFGuid@@PBG33KP6AXPAX@ZP8UObject@@AEXXZ@Z
  0006f	68 00 00 00 00	 push	 OFFSET FLAT:_$E203
  00074	e8 00 00 00 00	 call	 _atexit
  00079	83 c4 04	 add	 esp, 4
  0007c	5f		 pop	 edi
  0007d	5e		 pop	 esi
  0007e	5d		 pop	 ebp
  0007f	5b		 pop	 ebx
  00080	c3		 ret	 0
_$E206	ENDP
_TEXT	ENDS
_BSS	SEGMENT
	ALIGN	4

_$S204	DB	01H DUP (?)
; Function compile flags: /Ogty
_BSS	ENDS
;	COMDAT _$E203
_TEXT	SEGMENT
_$E203	PROC NEAR					; COMDAT
  00000	8a 0d 00 00 00
	00		 mov	 cl, BYTE PTR _$S204
  00006	b0 01		 mov	 al, 1
  00008	84 c8		 test	 cl, al
  0000a	75 13		 jne	 SHORT $L125044
  0000c	0a c8		 or	 cl, al
  0000e	88 0d 00 00 00
	00		 mov	 BYTE PTR _$S204, cl
  00014	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?PrivateStaticClass@UWaterTexture@@0VUClass@@A
  00019	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1UClass@@UAE@XZ
$L125044:
  0001f	c3		 ret	 0
_$E203	ENDP
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT _$E209
_TEXT	SEGMENT
_$E209	PROC NEAR					; COMDAT
  00000	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _autoclassUWaterTexture, OFFSET FLAT:?PrivateStaticClass@UWaterTexture@@0VUClass@@A ; UWaterTexture::PrivateStaticClass
  0000a	c3		 ret	 0
_$E209	ENDP
_TEXT	ENDS
PUBLIC	??0UWaveTexture@@QAE@XZ				; UWaveTexture::UWaveTexture
PUBLIC	?PostLoad@UWaveTexture@@UAEXXZ			; UWaveTexture::PostLoad
PUBLIC	?Init@UWaveTexture@@UAEXHH@Z			; UWaveTexture::Init
PUBLIC	?Clear@UWaveTexture@@UAEXK@Z			; UWaveTexture::Clear
PUBLIC	?ConstantTimeTick@UWaveTexture@@UAEXXZ		; UWaveTexture::ConstantTimeTick
PUBLIC	??_7UWaveTexture@@6B@				; UWaveTexture::`vftable'
PUBLIC	??_EUWaveTexture@@UAEPAXI@Z			; UWaveTexture::`vector deleting destructor'
;	COMDAT ??_7UWaveTexture@@6B@
; File ..\..\Core\Inc\UnTemplate.h
CONST	SEGMENT
??_7UWaveTexture@@6B@ DD FLAT:??_EUWaveTexture@@UAEPAXI@Z ; UWaveTexture::`vftable'
	DD	FLAT:?ProcessEvent@UObject@@UAEXPAVUFunction@@PAX1@Z
	DD	FLAT:?ProcessState@UObject@@UAEXM@Z
	DD	FLAT:?ProcessRemoteFunction@UObject@@UAEHPAVUFunction@@PAXPAUFFrame@@@Z
	DD	FLAT:?Modify@UObject@@UAEXXZ
	DD	FLAT:?PostLoad@UWaveTexture@@UAEXXZ
	DD	FLAT:?Destroy@UWaterTexture@@UAEXXZ
	DD	FLAT:?Serialize@UTexture@@UAEXAAVFArchive@@@Z
	DD	FLAT:?IsPendingKill@UObject@@UAEHXZ
	DD	FLAT:?GotoLabel@UObject@@UAEHVFName@@@Z
	DD	FLAT:?InitExecution@UObject@@UAEXXZ
	DD	FLAT:?ShutdownAfterError@UObject@@UAEXXZ
	DD	FLAT:?PostEditChange@UFractalTexture@@UAEXXZ
	DD	FLAT:?CallFunction@UObject@@UAEXAAUFFrame@@QAXPAVUFunction@@@Z
	DD	FLAT:?ScriptConsoleExec@UObject@@UAEHPBGAAVFOutputDevice@@PAV1@@Z
	DD	FLAT:?Register@UObject@@UAEXXZ
	DD	FLAT:?LanguageChange@UObject@@UAEXXZ
	DD	FLAT:?GetName@UObject@@UBEPBGXZ
	DD	FLAT:?Lock@UTexture@@UAIXAAUFTextureInfo@@NHPAVURenderDevice@@@Z
	DD	FLAT:?Unlock@UTexture@@UAIXAAUFTextureInfo@@@Z
	DD	FLAT:?GetMip@UTexture@@UAEPAUFMipmapBase@@H@Z
	DD	FLAT:?Clear@UWaveTexture@@UAEXK@Z
	DD	FLAT:?Init@UWaveTexture@@UAEXHH@Z
	DD	FLAT:?Tick@UTexture@@UAIXM@Z
	DD	FLAT:?ConstantTimeTick@UWaveTexture@@UAEXXZ
	DD	FLAT:?MousePosition@UWaterTexture@@UAEXKMM@Z
	DD	FLAT:?Click@UWaterTexture@@UAEXKMM@Z
	DD	FLAT:?Update@UTexture@@UAEXN@Z
	DD	FLAT:?TouchTexture@UWaterTexture@@UAEXHHM@Z
; Function compile flags: /Ogty
; File C:\duke4\Fire\Src\UnFractal.cpp
CONST	ENDS
;	COMDAT ??0UWaveTexture@@QAE@XZ
_TEXT	SEGMENT
??0UWaveTexture@@QAE@XZ PROC NEAR			; UWaveTexture::UWaveTexture, COMDAT
; _this$ = ecx

; 4336 : {

  00000	53		 push	 ebx
  00001	55		 push	 ebp
  00002	56		 push	 esi
  00003	57		 push	 edi
  00004	8b f1		 mov	 esi, ecx
  00006	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0UTexture@@QAE@XZ
  0000c	8b 8e 88 00 00
	00		 mov	 ecx, DWORD PTR [esi+136]
  00012	83 c9 0c	 or	 ecx, 12			; 0000000cH
  00015	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7UFractalTexture@@6B@ ; UFractalTexture::`vftable'
  0001b	89 8e 88 00 00
	00		 mov	 DWORD PTR [esi+136], ecx
  00021	e8 00 00 00 00	 call	 ?InitTables@@YAXXZ	; InitTables
  00026	33 c0		 xor	 eax, eax
  00028	b9 08 f1 ff ff	 mov	 ecx, -3832		; fffff108H
  0002d	33 ff		 xor	 edi, edi
  0002f	88 86 dc 00 00
	00		 mov	 BYTE PTR [esi+220], al
  00035	88 86 dd 00 00
	00		 mov	 BYTE PTR [esi+221], al
  0003b	89 86 d8 00 00
	00		 mov	 DWORD PTR [esi+216], eax
  00041	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7UWaterTexture@@6B@ ; UWaterTexture::`vftable'
  00047	8d ae f8 0c 00
	00		 lea	 ebp, DWORD PTR [esi+3320]
  0004d	2b ce		 sub	 ecx, esi

; 4337 : }

  0004f	90		 npad	 1

; 4336 : {

$L135682:
  00050	33 db		 xor	 ebx, ebx
  00052	8d 04 29	 lea	 eax, DWORD PTR [ecx+ebp]
  00055	3d 00 01 00 00	 cmp	 eax, 256		; 00000100H
  0005a	0f 9c c3	 setl	 bl
  0005d	8b c7		 mov	 eax, edi
  0005f	99		 cdq
  00060	2b c2		 sub	 eax, edx
  00062	d1 f8		 sar	 eax, 1
  00064	8d 84 03 00 ff
	ff ff		 lea	 eax, DWORD PTR [ebx+eax-256]
  0006b	85 c0		 test	 eax, eax
  0006d	7d 04		 jge	 SHORT $L135678
  0006f	33 c0		 xor	 eax, eax
  00071	eb 0c		 jmp	 SHORT $L135677
$L135678:
  00073	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00078	7c 05		 jl	 SHORT $L135677
  0007a	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
$L135677:
  0007f	47		 inc	 edi
  00080	88 45 00	 mov	 BYTE PTR [ebp], al
  00083	45		 inc	 ebp
  00084	81 ff 00 06 00
	00		 cmp	 edi, 1536		; 00000600H
  0008a	7c c4		 jl	 SHORT $L135682
  0008c	5f		 pop	 edi
  0008d	c7 86 fc 12 00
	00 ff ff ff ff	 mov	 DWORD PTR [esi+4860], -1
  00097	c6 86 f8 12 00
	00 00		 mov	 BYTE PTR [esi+4856], 0
  0009e	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7UWaveTexture@@6B@ ; UWaveTexture::`vftable'

; 4337 : }

  000a4	8b c6		 mov	 eax, esi
  000a6	5e		 pop	 esi
  000a7	5d		 pop	 ebp
  000a8	5b		 pop	 ebx
  000a9	c3		 ret	 0
??0UWaveTexture@@QAE@XZ ENDP				; UWaveTexture::UWaveTexture
_TEXT	ENDS
PUBLIC	??_C@_1BI@GIPJ@?$AAW?$AAa?$AAv?$AAe?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BK@BJIE@?$AAB?$AAu?$AAm?$AAp?$AAM?$AAa?$AAp?$AAA?$AAn?$AAg?$AAl?$AAe?$AA?$AA@ ; `string'
;	COMDAT ??_C@_1BI@GIPJ@?$AAW?$AAa?$AAv?$AAe?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@
; File ..\..\Core\Inc\UnTemplate.h
_DATA	SEGMENT
??_C@_1BI@GIPJ@?$AAW?$AAa?$AAv?$AAe?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@ DB 'W'
	DB	00H, 'a', 00H, 'v', 00H, 'e', 00H, 'T', 00H, 'e', 00H, 'x', 00H
	DB	't', 00H, 'u', 00H, 'r', 00H, 'e', 00H, 00H, 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_1BK@BJIE@?$AAB?$AAu?$AAm?$AAp?$AAM?$AAa?$AAp?$AAA?$AAn?$AAg?$AAl?$AAe?$AA?$AA@
_DATA	SEGMENT
??_C@_1BK@BJIE@?$AAB?$AAu?$AAm?$AAp?$AAM?$AAa?$AAp?$AAA?$AAn?$AAg?$AAl?$AAe?$AA?$AA@ DB 'B'
	DB	00H, 'u', 00H, 'm', 00H, 'p', 00H, 'M', 00H, 'a', 00H, 'p', 00H
	DB	'A', 00H, 'n', 00H, 'g', 00H, 'l', 00H, 'e', 00H, 00H, 00H ; `string'
; Function compile flags: /Ogty
; File C:\duke4\Fire\Src\UnFractal.cpp
_DATA	ENDS
;	COMDAT ?Init@UWaveTexture@@UAEXHH@Z
_TEXT	SEGMENT
_InUSize$ = 8
_InVSize$ = 12
_this$ = -4
$T135840 = 12
?Init@UWaveTexture@@UAEXHH@Z PROC NEAR			; UWaveTexture::Init, COMDAT
; _this$ = ecx

; 4340 : {

  00000	51		 push	 ecx

; 4341 : 	VERIFY_CLASS_OFFSET(U,WaveTexture,BumpMapAngle);

  00001	a1 18 00 00 00	 mov	 eax, DWORD PTR ?PrivateStaticClass@UWaveTexture@@0VUClass@@A+24
  00006	53		 push	 ebx
  00007	55		 push	 ebp
  00008	56		 push	 esi
  00009	57		 push	 edi
  0000a	6a 00		 push	 0
  0000c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1BI@GIPJ@?$AAW?$AAa?$AAv?$AAe?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@ ; `string'
  00011	50		 push	 eax
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?PrivateStaticClass@UClass@@0V1@A
  00017	8b f9		 mov	 edi, ecx
  00019	50		 push	 eax
  0001a	89 7c 24 20	 mov	 DWORD PTR _this$[esp+36], edi
  0001e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?StaticFindObjectChecked@UObject@@SAPAV1@PAVUClass@@PAV1@PBGH@Z
  00024	8b d8		 mov	 ebx, eax
  00026	83 c4 10	 add	 esp, 16			; 00000010H
  00029	85 db		 test	 ebx, ebx
  0002b	74 05		 je	 SHORT $L135746
  0002d	8b 73 40	 mov	 esi, DWORD PTR [ebx+64]
  00030	eb 02		 jmp	 SHORT $L135747
$L135746:
  00032	33 f6		 xor	 esi, esi
$L135747:
  00034	85 db		 test	 ebx, ebx
  00036	74 47		 je	 SHORT $L135875
$L135749:
  00038	85 f6		 test	 esi, esi
  0003a	74 31		 je	 SHORT $L135752
  0003c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?PrivateStaticClass@UProperty@@0VUClass@@A
$L135751:
  00042	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  00045	85 c0		 test	 eax, eax
  00047	74 12		 je	 SHORT $L135762

; 4358 : }

  00049	8d a4 24 00 00
	00 00		 npad	 7

; 4341 : 	VERIFY_CLASS_OFFSET(U,WaveTexture,BumpMapAngle);

$L135760:
  00050	3b c1		 cmp	 eax, ecx
  00052	74 2b		 je	 SHORT $L135875
  00054	8b 40 28	 mov	 eax, DWORD PTR [eax+40]
  00057	85 c0		 test	 eax, eax
  00059	75 f5		 jne	 SHORT $L135760
$L135762:
  0005b	33 c0		 xor	 eax, eax
  0005d	85 c9		 test	 ecx, ecx
  0005f	0f 94 c0	 sete	 al
  00062	85 c0		 test	 eax, eax
  00064	75 19		 jne	 SHORT $L135875
  00066	8b 76 2c	 mov	 esi, DWORD PTR [esi+44]
  00069	85 f6		 test	 esi, esi
  0006b	75 d5		 jne	 SHORT $L135751
$L135752:
  0006d	8b 13		 mov	 edx, DWORD PTR [ebx]
  0006f	8b cb		 mov	 ecx, ebx
  00071	ff 52 5c	 call	 DWORD PTR [edx+92]
  00074	8b d8		 mov	 ebx, eax
  00076	85 db		 test	 ebx, ebx
  00078	74 05		 je	 SHORT $L135875
  0007a	8b 73 40	 mov	 esi, DWORD PTR [ebx+64]
  0007d	eb b9		 jmp	 SHORT $L135749
$L135875:
  0007f	85 f6		 test	 esi, esi
  00081	0f 84 ab 00 00
	00		 je	 $L125073
  00087	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp_?appStricmp@@YAHPBG0@Z
  0008d	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp_?Logf@FOutputDevice@@QAAXPBGZZ
$L135798:
  00093	8b 06		 mov	 eax, DWORD PTR [esi]
  00095	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1BK@BJIE@?$AAB?$AAu?$AAm?$AAp?$AAM?$AAa?$AAp?$AAA?$AAn?$AAg?$AAl?$AAe?$AA?$AA@ ; `string'
  0009a	8b ce		 mov	 ecx, esi
  0009c	ff 50 44	 call	 DWORD PTR [eax+68]
  0009f	50		 push	 eax
  000a0	ff d7		 call	 edi
  000a2	83 c4 08	 add	 esp, 8
  000a5	85 c0		 test	 eax, eax
  000a7	75 2d		 jne	 SHORT $L125072
  000a9	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  000ac	3d 01 13 00 00	 cmp	 eax, 4865		; 00001301H
  000b1	74 23		 je	 SHORT $L125072
  000b3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?GError@@3PAVFOutputDeviceError@@A
  000b9	8b 11		 mov	 edx, DWORD PTR [ecx]
  000bb	68 01 13 00 00	 push	 4865			; 00001301H
  000c0	50		 push	 eax
  000c1	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1BK@BJIE@?$AAB?$AAu?$AAm?$AAp?$AAM?$AAa?$AAp?$AAA?$AAn?$AAg?$AAl?$AAe?$AA?$AA@ ; `string'
  000c6	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1BI@GIPJ@?$AAW?$AAa?$AAv?$AAe?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@ ; `string'
  000cb	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1FK@OIBJ@?$AAC?$AAl?$AAa?$AAs?$AAs?$AA?5?$AA?$CF?$AAs?$AA?5?$AAM?$AAe?$AAm?$AAb?$AAe?$AAr?$AA?5?$AA?$CF?$AAs?$AA?5?$AAp@ ; `string'
  000d0	52		 push	 edx
  000d1	ff d5		 call	 ebp
  000d3	83 c4 18	 add	 esp, 24			; 00000018H
$L125072:
  000d6	85 db		 test	 ebx, ebx
  000d8	8b 76 2c	 mov	 esi, DWORD PTR [esi+44]
  000db	74 49		 je	 SHORT $L135877

; 4358 : }

  000dd	8d 49 00	 npad	 3

; 4341 : 	VERIFY_CLASS_OFFSET(U,WaveTexture,BumpMapAngle);

$L135801:
  000e0	85 f6		 test	 esi, esi
  000e2	74 30		 je	 SHORT $L135804
  000e4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?PrivateStaticClass@UProperty@@0VUClass@@A

; 4358 : }

  000ea	8d 9b 00 00 00
	00		 npad	 6

; 4341 : 	VERIFY_CLASS_OFFSET(U,WaveTexture,BumpMapAngle);

$L135803:
  000f0	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  000f3	85 c0		 test	 eax, eax
  000f5	74 0b		 je	 SHORT $L135814
$L135812:
  000f7	3b c1		 cmp	 eax, ecx
  000f9	74 2b		 je	 SHORT $L135877
  000fb	8b 40 28	 mov	 eax, DWORD PTR [eax+40]
  000fe	85 c0		 test	 eax, eax
  00100	75 f5		 jne	 SHORT $L135812
$L135814:
  00102	33 c0		 xor	 eax, eax
  00104	85 c9		 test	 ecx, ecx
  00106	0f 94 c0	 sete	 al
  00109	85 c0		 test	 eax, eax
  0010b	75 19		 jne	 SHORT $L135877
  0010d	8b 76 2c	 mov	 esi, DWORD PTR [esi+44]
  00110	85 f6		 test	 esi, esi
  00112	75 dc		 jne	 SHORT $L135803
$L135804:
  00114	8b 03		 mov	 eax, DWORD PTR [ebx]
  00116	8b cb		 mov	 ecx, ebx
  00118	ff 50 5c	 call	 DWORD PTR [eax+92]
  0011b	8b d8		 mov	 ebx, eax
  0011d	85 db		 test	 ebx, ebx
  0011f	74 05		 je	 SHORT $L135877
  00121	8b 73 40	 mov	 esi, DWORD PTR [ebx+64]
  00124	eb ba		 jmp	 SHORT $L135801
$L135877:
  00126	85 f6		 test	 esi, esi
  00128	0f 85 65 ff ff
	ff		 jne	 $L135798
  0012e	8b 7c 24 10	 mov	 edi, DWORD PTR _this$[esp+20]
$L125073:

; 4342 : 
; 4343 : 	// Init base class.
; 4344 : 	UWaterTexture::Init( InUSize, InVSize );

  00132	8b 4c 24 1c	 mov	 ecx, DWORD PTR _InVSize$[esp+16]
  00136	8b 54 24 18	 mov	 edx, DWORD PTR _InUSize$[esp+16]
  0013a	51		 push	 ecx
  0013b	52		 push	 edx
  0013c	8b cf		 mov	 ecx, edi
  0013e	e8 00 00 00 00	 call	 ?Init@UWaterTexture@@UAEXHH@Z ; UWaterTexture::Init

; 4345 : 
; 4346 : 	BumpMapAngle = 170;
; 4347 : 	BumpMapLight = 50;
; 4348 : 
; 4349 : 	PhongRange = 180;
; 4350 : 	PhongSize  = 32;
; 4351 : 
; 4352 : 	// Create a custom palette.	
; 4353 : 	Palette = new( GetOuter() )UPalette;

  00143	6a 00		 push	 0
  00145	8d 4c 24 20	 lea	 ecx, DWORD PTR $T135840[esp+20]
  00149	c6 87 01 13 00
	00 aa		 mov	 BYTE PTR [edi+4865], 170 ; 000000aaH
  00150	c6 87 00 13 00
	00 32		 mov	 BYTE PTR [edi+4864], 50	; 00000032H
  00157	c6 87 02 13 00
	00 b4		 mov	 BYTE PTR [edi+4866], 180 ; 000000b4H
  0015e	c6 87 03 13 00
	00 20		 mov	 BYTE PTR [edi+4867], 32	; 00000020H
  00165	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0FName@@QAE@W4EName@@@Z
  0016b	8b cf		 mov	 ecx, edi
  0016d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetOuter@UObject@@QBEPAV1@XZ
  00173	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?GError@@3PAVFOutputDeviceError@@A
  00179	8b 11		 mov	 edx, DWORD PTR [ecx]
  0017b	8b 4c 24 1c	 mov	 ecx, DWORD PTR $T135840[esp+16]
  0017f	6a 00		 push	 0
  00181	52		 push	 edx
  00182	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR __imp_?PrivateStaticClass@UPalette@@0VUClass@@A
  00188	6a 00		 push	 0
  0018a	6a 00		 push	 0
  0018c	51		 push	 ecx
  0018d	50		 push	 eax
  0018e	52		 push	 edx
  0018f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?StaticAllocateObject@UObject@@SAPAV1@PAVUClass@@PAV1@VFName@@K1PAVFOutputDevice@@1@Z
  00195	8b f0		 mov	 esi, eax
  00197	83 c4 1c	 add	 esp, 28			; 0000001cH
  0019a	85 f6		 test	 esi, esi
  0019c	74 1e		 je	 SHORT $L135692
  0019e	8b ce		 mov	 ecx, esi
  001a0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0UPalette@@QAE@XZ
  001a6	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp_?Realloc@FArray@@IAEXH@Z
  001ac	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_SUPalette@@6B@ ; UPalette::`local vftable'
  001b2	89 77 2c	 mov	 DWORD PTR [edi+44], esi
  001b5	bb 00 01 00 00	 mov	 ebx, 256		; 00000100H
  001ba	eb 16		 jmp	 SHORT $L125089
$L135692:
  001bc	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp_?Realloc@FArray@@IAEXH@Z
  001c2	33 f6		 xor	 esi, esi
  001c4	89 77 2c	 mov	 DWORD PTR [edi+44], esi
  001c7	bb 00 01 00 00	 mov	 ebx, 256		; 00000100H
  001cc	eb 04		 jmp	 SHORT $L125089
$L135884:
  001ce	8b 7c 24 10	 mov	 edi, DWORD PTR _this$[esp+20]
$L125089:

; 4355 : 		new(Palette->Colors)FColor(0,0,0);

  001d2	8b 77 2c	 mov	 esi, DWORD PTR [edi+44]
  001d5	8b 7e 2c	 mov	 edi, DWORD PTR [esi+44]
  001d8	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  001db	83 c6 28	 add	 esi, 40			; 00000028H
  001de	8d 4f 01	 lea	 ecx, DWORD PTR [edi+1]
  001e1	3b c8		 cmp	 ecx, eax
  001e3	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  001e6	7e 19		 jle	 SHORT $L135856
  001e8	8d 04 49	 lea	 eax, DWORD PTR [ecx+ecx*2]
  001eb	99		 cdq
  001ec	83 e2 07	 and	 edx, 7
  001ef	03 c2		 add	 eax, edx
  001f1	c1 f8 03	 sar	 eax, 3
  001f4	8d 44 08 20	 lea	 eax, DWORD PTR [eax+ecx+32]
  001f8	6a 04		 push	 4
  001fa	8b ce		 mov	 ecx, esi
  001fc	89 46 08	 mov	 DWORD PTR [esi+8], eax
  001ff	ff d5		 call	 ebp
$L135856:
  00201	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00203	8d 04 b9	 lea	 eax, DWORD PTR [ecx+edi*4]
  00206	85 c0		 test	 eax, eax
  00208	74 0b		 je	 SHORT $L125090
  0020a	c6 00 00	 mov	 BYTE PTR [eax], 0
  0020d	c6 40 01 00	 mov	 BYTE PTR [eax+1], 0
  00211	c6 40 02 00	 mov	 BYTE PTR [eax+2], 0
$L125090:

; 4354 : 	for( INT i=0; i<256; i++ )

  00215	4b		 dec	 ebx
  00216	75 b6		 jne	 SHORT $L135884

; 4356 : 	BlueLagunaPalette(Palette);

  00218	8b 74 24 10	 mov	 esi, DWORD PTR _this$[esp+20]
  0021c	8b 56 2c	 mov	 edx, DWORD PTR [esi+44]
  0021f	52		 push	 edx
  00220	e8 00 00 00 00	 call	 ?BlueLagunaPalette@@YAXPAVUPalette@@@Z ; BlueLagunaPalette

; 4357 : 	MipZero = Palette->Colors(128);

  00225	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  00228	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  0022b	8b 91 00 02 00
	00		 mov	 edx, DWORD PTR [ecx+512]
  00231	83 c4 04	 add	 esp, 4
  00234	5f		 pop	 edi
  00235	89 56 44	 mov	 DWORD PTR [esi+68], edx
  00238	5e		 pop	 esi
  00239	5d		 pop	 ebp
  0023a	5b		 pop	 ebx

; 4358 : }

  0023b	59		 pop	 ecx
  0023c	c2 08 00	 ret	 8
?Init@UWaveTexture@@UAEXHH@Z ENDP			; UWaveTexture::Init
_TEXT	ENDS
PUBLIC	?SetWaveLight@UWaveTexture@@QAEXXZ		; UWaveTexture::SetWaveLight
; Function compile flags: /Ogty
;	COMDAT ?PostLoad@UWaveTexture@@UAEXXZ
_TEXT	SEGMENT
_NewPalette$125104 = -8
$T135933 = -4
?PostLoad@UWaveTexture@@UAEXXZ PROC NEAR		; UWaveTexture::PostLoad, COMDAT
; _this$ = ecx

; 4361 : {

  00000	83 ec 08	 sub	 esp, 8
  00003	55		 push	 ebp
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx

; 4362 : 	Super::PostLoad();

  00007	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?PostLoad@UTexture@@UAEXXZ
  0000d	8b 4e 34	 mov	 ecx, DWORD PTR [esi+52]
  00010	8d 41 ff	 lea	 eax, DWORD PTR [ecx-1]
  00013	89 86 c8 00 00
	00		 mov	 DWORD PTR [esi+200], eax
  00019	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  0001c	8d 50 ff	 lea	 edx, DWORD PTR [eax-1]
  0001f	89 96 cc 00 00
	00		 mov	 DWORD PTR [esi+204], edx
  00025	8b 96 f0 08 00
	00		 mov	 edx, DWORD PTR [esi+2288]
  0002b	33 ed		 xor	 ebp, ebp
  0002d	3b d5		 cmp	 edx, ebp
  0002f	75 4d		 jne	 SHORT $L135916
  00031	0f af c1	 imul	 eax, ecx
  00034	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?GMalloc@@3PAVFMalloc@@A
  0003a	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0003c	99		 cdq
  0003d	2b c2		 sub	 eax, edx
  0003f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00041	d1 f8		 sar	 eax, 1
  00043	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_17JBDG@?$AAn?$AAe?$AAw?$AA?$AA@ ; `string'
  00048	50		 push	 eax
  00049	ff 12		 call	 DWORD PTR [edx]
  0004b	89 86 f0 08 00
	00		 mov	 DWORD PTR [esi+2288], eax
  00051	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  00054	0f af 46 34	 imul	 eax, DWORD PTR [esi+52]
  00058	99		 cdq
  00059	2b c2		 sub	 eax, edx
  0005b	d1 f8		 sar	 eax, 1
  0005d	33 c9		 xor	 ecx, ecx
  0005f	85 c0		 test	 eax, eax
  00061	7e 1b		 jle	 SHORT $L135916
$L135914:
  00063	8b 86 f0 08 00
	00		 mov	 eax, DWORD PTR [esi+2288]
  00069	c6 04 01 80	 mov	 BYTE PTR [ecx+eax], 128	; 00000080H
  0006d	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  00070	0f af 46 34	 imul	 eax, DWORD PTR [esi+52]
  00074	99		 cdq
  00075	2b c2		 sub	 eax, edx
  00077	41		 inc	 ecx
  00078	d1 f8		 sar	 eax, 1
  0007a	3b c8		 cmp	 ecx, eax
  0007c	7c e5		 jl	 SHORT $L135914
$L135916:

; 4363 : 
; 4364 : 	// Make sure the texture has its _own_ copy of the palette.
; 4365 : #if COPYPALETTE	
; 4366 : 	if( ( Palette!=NULL ) && ( GetOuter()!=Palette->GetOuter() ) )

  0007e	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  00081	3b c5		 cmp	 eax, ebp
  00083	0f 84 f2 00 00
	00		 je	 $L125103
  00089	8b 4e 18	 mov	 ecx, DWORD PTR [esi+24]
  0008c	3b 48 18	 cmp	 ecx, DWORD PTR [eax+24]
  0008f	0f 84 e6 00 00
	00		 je	 $L125103

; 4367 : 	{
; 4368 : 		UPalette* NewPalette = new( GetOuter(), GetName() )UPalette;

  00095	8b 16		 mov	 edx, DWORD PTR [esi]
  00097	53		 push	 ebx
  00098	57		 push	 edi
  00099	6a 01		 push	 1
  0009b	8b ce		 mov	 ecx, esi
  0009d	ff 52 44	 call	 DWORD PTR [edx+68]
  000a0	50		 push	 eax
  000a1	8d 4c 24 1c	 lea	 ecx, DWORD PTR $T135933[esp+32]
  000a5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0FName@@QAE@PBGW4EFindName@@@Z
  000ab	8b ce		 mov	 ecx, esi
  000ad	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetOuter@UObject@@QBEPAV1@XZ
  000b3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?GError@@3PAVFOutputDeviceError@@A
  000b9	8b 11		 mov	 edx, DWORD PTR [ecx]
  000bb	8b 4c 24 14	 mov	 ecx, DWORD PTR $T135933[esp+24]
  000bf	55		 push	 ebp
  000c0	52		 push	 edx
  000c1	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR __imp_?PrivateStaticClass@UPalette@@0VUClass@@A
  000c7	55		 push	 ebp
  000c8	55		 push	 ebp
  000c9	51		 push	 ecx
  000ca	50		 push	 eax
  000cb	52		 push	 edx
  000cc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?StaticAllocateObject@UObject@@SAPAV1@PAVUClass@@PAV1@VFName@@K1PAVFOutputDevice@@1@Z
  000d2	8b f8		 mov	 edi, eax
  000d4	83 c4 1c	 add	 esp, 28			; 0000001cH
  000d7	3b fd		 cmp	 edi, ebp
  000d9	74 14		 je	 SHORT $L135891
  000db	8b cf		 mov	 ecx, edi
  000dd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0UPalette@@QAE@XZ
  000e3	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET FLAT:??_SUPalette@@6B@ ; UPalette::`local vftable'
  000e9	89 7c 24 10	 mov	 DWORD PTR _NewPalette$125104[esp+24], edi
  000ed	eb 04		 jmp	 SHORT $L135892
$L135891:
  000ef	89 6c 24 10	 mov	 DWORD PTR _NewPalette$125104[esp+24], ebp
$L135892:
  000f3	8b 44 24 10	 mov	 eax, DWORD PTR _NewPalette$125104[esp+24]
  000f7	8d 78 28	 lea	 edi, DWORD PTR [eax+40]

; 4381 : }

  000fa	8d 9b 00 00 00
	00		 npad	 6

; 4367 : 	{
; 4368 : 		UPalette* NewPalette = new( GetOuter(), GetName() )UPalette;

$L125113:

; 4369 : 		//NewPalette->Colors = Palette->Colors;
; 4370 : 		for( INT i=0; i<256; i++ )
; 4371 : 			new(NewPalette->Colors)FColor( Palette->Colors(i) );

  00100	8b 5f 04	 mov	 ebx, DWORD PTR [edi+4]
  00103	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00106	8d 4b 01	 lea	 ecx, DWORD PTR [ebx+1]
  00109	3b c8		 cmp	 ecx, eax
  0010b	89 4f 04	 mov	 DWORD PTR [edi+4], ecx
  0010e	7e 1d		 jle	 SHORT $L135949
  00110	8d 04 49	 lea	 eax, DWORD PTR [ecx+ecx*2]
  00113	99		 cdq
  00114	83 e2 07	 and	 edx, 7
  00117	03 c2		 add	 eax, edx
  00119	c1 f8 03	 sar	 eax, 3
  0011c	8d 4c 08 20	 lea	 ecx, DWORD PTR [eax+ecx+32]
  00120	89 4f 08	 mov	 DWORD PTR [edi+8], ecx
  00123	6a 04		 push	 4
  00125	8b cf		 mov	 ecx, edi
  00127	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Realloc@FArray@@IAEXH@Z
$L135949:
  0012d	8b 17		 mov	 edx, DWORD PTR [edi]
  0012f	8d 04 9a	 lea	 eax, DWORD PTR [edx+ebx*4]
  00132	85 c0		 test	 eax, eax
  00134	74 0b		 je	 SHORT $L125114
  00136	8b 4e 2c	 mov	 ecx, DWORD PTR [esi+44]
  00139	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  0013c	8b 0c 2a	 mov	 ecx, DWORD PTR [edx+ebp]
  0013f	89 08		 mov	 DWORD PTR [eax], ecx
$L125114:
  00141	83 c5 04	 add	 ebp, 4
  00144	81 fd 00 04 00
	00		 cmp	 ebp, 1024		; 00000400H
  0014a	7c b4		 jl	 SHORT $L125113

; 4372 : 		Palette = NewPalette->ReplaceWithExisting();

  0014c	8b 4c 24 10	 mov	 ecx, DWORD PTR _NewPalette$125104[esp+24]
  00150	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?ReplaceWithExisting@UPalette@@QAEPAV1@XZ
  00156	89 46 2c	 mov	 DWORD PTR [esi+44], eax

; 4373 : 		MipZero = Palette->Colors(128);

  00159	8b 50 28	 mov	 edx, DWORD PTR [eax+40]
  0015c	8b 82 00 02 00
	00		 mov	 eax, DWORD PTR [edx+512]

; 4374 : 		GCache.Flush();

  00162	6a 00		 push	 0
  00164	6a ff		 push	 -1
  00166	6a 00		 push	 0
  00168	89 46 44	 mov	 DWORD PTR [esi+68], eax
  0016b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?GCache@@3VFMemCache@@A
  00171	6a 00		 push	 0
  00173	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Flush@FMemCache@@QAEX_KKH@Z
  00179	5f		 pop	 edi
  0017a	5b		 pop	 ebx
$L125103:

; 4375 : 	}
; 4376 : #endif
; 4377 : 	
; 4378 : 	// Recalculate the rendering LUT
; 4379 : 	// Depends on: WaveAmp, PhongRange, and PhongSize.
; 4380 : 	SetWaveLight(); //TODO: Check params before superfluous updates ??

  0017b	8b ce		 mov	 ecx, esi
  0017d	e8 00 00 00 00	 call	 ?SetWaveLight@UWaveTexture@@QAEXXZ ; UWaveTexture::SetWaveLight
  00182	5e		 pop	 esi
  00183	5d		 pop	 ebp

; 4381 : }

  00184	83 c4 08	 add	 esp, 8
  00187	c3		 ret	 0
?PostLoad@UWaveTexture@@UAEXXZ ENDP			; UWaveTexture::PostLoad
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?Clear@UWaveTexture@@UAEXK@Z
_TEXT	SEGMENT
_ClearFlags$ = 8
?Clear@UWaveTexture@@UAEXK@Z PROC NEAR			; UWaveTexture::Clear, COMDAT
; _this$ = ecx

; 4384 : {

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	57		 push	 edi

; 4385 : 	// Init to zero.
; 4386 : 	UWaterTexture::Clear( ClearFlags );

  00003	8b 7c 24 10	 mov	 edi, DWORD PTR _ClearFlags$[esp+8]
  00007	57		 push	 edi
  00008	8b f1		 mov	 esi, ecx
  0000a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Clear@UTexture@@UAEXK@Z
  00010	8b df		 mov	 ebx, edi
  00012	83 e3 02	 and	 ebx, 2
  00015	74 34		 je	 SHORT $L135973
  00017	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  0001a	0f af 46 38	 imul	 eax, DWORD PTR [esi+56]
  0001e	99		 cdq
  0001f	2b c2		 sub	 eax, edx
  00021	d1 f8		 sar	 eax, 1
  00023	33 c9		 xor	 ecx, ecx
  00025	85 c0		 test	 eax, eax
  00027	7e 22		 jle	 SHORT $L135973

; 4396 : }

  00029	8d a4 24 00 00
	00 00		 npad	 7

; 4385 : 	// Init to zero.
; 4386 : 	UWaterTexture::Clear( ClearFlags );

$L135971:
  00030	8b 86 f0 08 00
	00		 mov	 eax, DWORD PTR [esi+2288]
  00036	c6 04 01 80	 mov	 BYTE PTR [ecx+eax], 128	; 00000080H
  0003a	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  0003d	0f af 46 38	 imul	 eax, DWORD PTR [esi+56]
  00041	99		 cdq
  00042	2b c2		 sub	 eax, edx
  00044	41		 inc	 ecx
  00045	d1 f8		 sar	 eax, 1
  00047	3b c8		 cmp	 ecx, eax
  00049	7c e5		 jl	 SHORT $L135971
$L135973:
  0004b	83 e7 01	 and	 edi, 1
  0004e	74 0a		 je	 SHORT $L135974
  00050	c7 86 ec 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+236], 0
$L135974:

; 4387 : 
; 4388 : 	// Clear fields.
; 4389 : 	if( ClearFlags & TCLEAR_Bitmap )

  0005a	85 db		 test	 ebx, ebx
  0005c	74 2d		 je	 SHORT $L125132

; 4390 : 		for( INT i=0; i< USize * VSize / 2; i++ )

  0005e	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  00061	0f af 46 38	 imul	 eax, DWORD PTR [esi+56]
  00065	99		 cdq
  00066	2b c2		 sub	 eax, edx
  00068	d1 f8		 sar	 eax, 1
  0006a	33 c9		 xor	 ecx, ecx
  0006c	85 c0		 test	 eax, eax
  0006e	7e 1b		 jle	 SHORT $L125132
$L125130:

; 4391 : 			SourceFields[i] = 128;

  00070	8b 96 f0 08 00
	00		 mov	 edx, DWORD PTR [esi+2288]
  00076	c6 04 11 80	 mov	 BYTE PTR [ecx+edx], 128	; 00000080H
  0007a	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  0007d	0f af 46 38	 imul	 eax, DWORD PTR [esi+56]
  00081	99		 cdq
  00082	2b c2		 sub	 eax, edx
  00084	41		 inc	 ecx
  00085	d1 f8		 sar	 eax, 1
  00087	3b c8		 cmp	 ecx, eax
  00089	7c e5		 jl	 SHORT $L125130
$L125132:

; 4392 : 
; 4393 : 	// Clear drops.
; 4394 : 	if( ClearFlags & TCLEAR_Temporal )

  0008b	85 ff		 test	 edi, edi
  0008d	74 0a		 je	 SHORT $L125133

; 4395 : 		NumDrops=0;

  0008f	c7 86 ec 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+236], 0
$L125133:
  00099	5f		 pop	 edi
  0009a	5e		 pop	 esi
  0009b	5b		 pop	 ebx

; 4396 : }

  0009c	c2 04 00	 ret	 4
?Clear@UWaveTexture@@UAEXK@Z ENDP			; UWaveTexture::Clear
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?ConstantTimeTick@UWaveTexture@@UAEXXZ
_TEXT	SEGMENT
?ConstantTimeTick@UWaveTexture@@UAEXXZ PROC NEAR	; UWaveTexture::ConstantTimeTick, COMDAT
; _this$ = ecx

; 4399 : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 4400 : 	if( (USize>=8) && (VSize>=8) ) // safe sizes ?

  00003	8b 4e 34	 mov	 ecx, DWORD PTR [esi+52]
  00006	b8 08 00 00 00	 mov	 eax, 8
  0000b	3b c8		 cmp	 ecx, eax
  0000d	7c 14		 jl	 SHORT $L125137
  0000f	39 46 38	 cmp	 DWORD PTR [esi+56], eax
  00012	7c 0f		 jl	 SHORT $L125137

; 4401 : 	{
; 4402 : 		WaterRedrawDrops();

  00014	8b ce		 mov	 ecx, esi
  00016	e8 00 00 00 00	 call	 ?WaterRedrawDrops@UWaterTexture@@QAEXXZ ; UWaterTexture::WaterRedrawDrops

; 4403 : 		CalculateWater(); 

  0001b	8b ce		 mov	 ecx, esi
  0001d	5e		 pop	 esi
  0001e	e9 00 00 00 00	 jmp	 ?CalculateWater@UWaterTexture@@QAEXXZ ; UWaterTexture::CalculateWater
$L125137:
  00023	5e		 pop	 esi

; 4404 : 	}
; 4405 : }

  00024	c3		 ret	 0
?ConstantTimeTick@UWaveTexture@@UAEXXZ ENDP		; UWaveTexture::ConstantTimeTick
_TEXT	ENDS
PUBLIC	__real@3f893b368acefc14
PUBLIC	__real@3b808081
PUBLIC	__real@44000000
PUBLIC	__real@3ba72f05
PUBLIC	__real@3ff921fb54442d18
PUBLIC	__real@3b000000
;	COMDAT __real@3f893b368acefc14
; File ..\..\Core\Inc\UnTemplate.h
CONST	SEGMENT
__real@3f893b368acefc14 DQ 03f893b368acefc14r	; 0.01232
CONST	ENDS
;	COMDAT __real@3b808081
CONST	SEGMENT
__real@3b808081 DD 03b808081r			; 0.00392157
CONST	ENDS
;	COMDAT __real@44000000
CONST	SEGMENT
__real@44000000 DD 044000000r			; 512
CONST	ENDS
;	COMDAT __real@3ba72f05
CONST	SEGMENT
__real@3ba72f05 DD 03ba72f05r			; 0.00510204
CONST	ENDS
;	COMDAT __real@3ff921fb54442d18
CONST	SEGMENT
__real@3ff921fb54442d18 DQ 03ff921fb54442d18r	; 1.5708
CONST	ENDS
;	COMDAT __real@3b000000
CONST	SEGMENT
__real@3b000000 DD 03b000000r			; 0.00195313
; Function compile flags: /Ogty
; File C:\duke4\Fire\Src\UnFractal.cpp
CONST	ENDS
;	COMDAT ?SetWaveLight@UWaveTexture@@QAEXXZ
_TEXT	SEGMENT
_i$ = -8
_PhongRadius$125152 = -8
?SetWaveLight@UWaveTexture@@QAEXXZ PROC NEAR		; UWaveTexture::SetWaveLight, COMDAT
; _this$ = ecx

; 4409 : {

  00000	83 ec 08	 sub	 esp, 8
  00003	53		 push	 ebx
  00004	55		 push	 ebp
  00005	56		 push	 esi

; 4410 : 	// Compute shades for surface normals.
; 4411 :     FLOAT Lamp   = PI * BumpMapLight / 255.0;

  00006	33 c0		 xor	 eax, eax
  00008	57		 push	 edi
  00009	8b f9		 mov	 edi, ecx
  0000b	8a 87 00 13 00
	00		 mov	 al, BYTE PTR [edi+4864]

; 4412 :     FLOAT Viewer = PI * BumpMapAngle / 255.0;

  00011	33 c9		 xor	 ecx, ecx
  00013	8a 8f 01 13 00
	00		 mov	 cl, BYTE PTR [edi+4865]

; 4413 : 
; 4414 :     for( INT i=0; i<1024 ; i++ )

  00019	33 ed		 xor	 ebp, ebp
  0001b	89 44 24 10	 mov	 DWORD PTR -8+[esp+24], eax
  0001f	db 44 24 10	 fild	 DWORD PTR -8+[esp+24]
  00023	89 4c 24 10	 mov	 DWORD PTR -8+[esp+24], ecx
  00027	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@3f893b368acefc14
  0002d	db 44 24 10	 fild	 DWORD PTR -8+[esp+24]
  00031	89 6c 24 10	 mov	 DWORD PTR _i$[esp+24], ebp
  00035	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@3f893b368acefc14

; 4432 :     }
; 4433 : }

  0003b	90 8d 64 24 00	 npad	 5

; 4413 : 
; 4414 :     for( INT i=0; i<1024 ; i++ )

$L125144:

; 4415 :     {
; 4416 : 		// Get reflection magnitude.
; 4417 :         FLOAT Normal = FakeAtan(  ((FLOAT)WaveAmp/255.0F) * (512.0F - (float)i) / 196.0F )  + (PI * 0.5F);

  00040	33 d2		 xor	 edx, edx
  00042	8a 97 e1 00 00
	00		 mov	 dl, BYTE PTR [edi+225]
  00048	89 54 24 14	 mov	 DWORD PTR -4+[esp+24], edx
  0004c	db 44 24 14	 fild	 DWORD PTR -4+[esp+24]
  00050	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3b808081
  00056	db 44 24 10	 fild	 DWORD PTR _i$[esp+24]
  0005a	d8 2d 00 00 00
	00		 fsubr	 DWORD PTR __real@44000000
  00060	de c9		 fmulp	 ST(1), ST(0)
  00062	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3ba72f05
  00068	d9 c0		 fld	 ST(0)
  0006a	d8 15 00 00 00
	00		 fcom	 DWORD PTR __real@00000000
  00070	df e0		 fnstsw	 ax
  00072	f6 c4 01	 test	 ah, 1
  00075	74 02		 je	 SHORT $L136001
  00077	d9 e0		 fchs
$L136001:
  00079	d9 c9		 fxch	 ST(1)
  0007b	33 db		 xor	 ebx, ebx
  0007d	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@3ff921cac0000000
  00083	8a 9f 02 13 00
	00		 mov	 bl, BYTE PTR [edi+4866]
  00089	d9 c9		 fxch	 ST(1)

; 4418 : 
; 4419 :         // Max in this palette is 255, diffuse light reaches to 256-(PhongRange/2). 
; 4420 :         INT  TempLight = (INT) ( (256-(PhongRange/2)) * appCos ( Normal- Lamp ) );   //* ((FLOAT)WaveAmp/256.0F) );

  0008b	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  00090	dc 05 00 00 00
	00		 fadd	 QWORD PTR __real@3ff0000000000000
  00096	de f9		 fdivp	 ST(1), ST(0)
  00098	8b c3		 mov	 eax, ebx
  0009a	d1 e8		 shr	 eax, 1
  0009c	2b c8		 sub	 ecx, eax
  0009e	89 4c 24 14	 mov	 DWORD PTR -4+[esp+24], ecx
  000a2	dc 05 00 00 00
	00		 fadd	 QWORD PTR __real@3ff921fb54442d18
  000a8	d9 c0		 fld	 ST(0)
  000aa	d8 e3		 fsub	 ST(0), ST(3)
  000ac	d9 ff		 fcos
  000ae	db 44 24 14	 fild	 DWORD PTR -4+[esp+24]
  000b2	de c9		 fmulp	 ST(1), ST(0)
  000b4	e8 00 00 00 00	 call	 __ftol

; 4421 : 
; 4422 :         // Create a phong-ish highlight.
; 4423 :         // Based on angle between viewer direction and reflected light:
; 4424 :         // Reflected light angle : = Normal*2 - Lamp.
; 4425 : 		// Old defaults: PhongRange = 75; PhongRadius=0.11;
; 4426 : 		FLOAT PhongRadius = (FLOAT) PhongSize / 512.0f; 

  000b9	33 d2		 xor	 edx, edx
  000bb	8a 97 03 13 00
	00		 mov	 dl, BYTE PTR [edi+4867]
  000c1	8b f0		 mov	 esi, eax
  000c3	89 54 24 14	 mov	 DWORD PTR -4+[esp+24], edx
  000c7	db 44 24 14	 fild	 DWORD PTR -4+[esp+24]
  000cb	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3b000000
  000d1	d9 5c 24 10	 fstp	 DWORD PTR _PhongRadius$125152[esp+24]

; 4427 :         FLOAT Reflected = (Normal*2 - Lamp);

  000d5	dc c0		 fadd	 ST(0), ST(0)
  000d7	d8 e2		 fsub	 ST(0), ST(2)

; 4428 :         if( Square(Reflected-Viewer) < Square(PhongRadius) )

  000d9	d8 e1		 fsub	 ST(0), ST(1)
  000db	d9 c0		 fld	 ST(0)
  000dd	d9 c0		 fld	 ST(0)
  000df	d8 c9		 fmul	 ST(0), ST(1)
  000e1	d9 44 24 10	 fld	 DWORD PTR _PhongRadius$125152[esp+24]
  000e5	d8 4c 24 10	 fmul	 DWORD PTR _PhongRadius$125152[esp+24]
  000e9	de d9		 fcompp
  000eb	df e0		 fnstsw	 ax
  000ed	dd d8		 fstp	 ST(0)
  000ef	f6 c4 41	 test	 ah, 65			; 00000041H
  000f2	75 2b		 jne	 SHORT $L136047

; 4429 :             TempLight +=  (INT) ((PhongRange * 2 ) * (PhongRadius - Abs(Reflected-Viewer)) / PhongRadius);

  000f4	d8 15 00 00 00
	00		 fcom	 DWORD PTR __real@00000000
  000fa	df e0		 fnstsw	 ax
  000fc	f6 c4 01	 test	 ah, 1
  000ff	74 02		 je	 SHORT $L136020
  00101	d9 e0		 fchs
$L136020:
  00103	d9 44 24 10	 fld	 DWORD PTR _PhongRadius$125152[esp+24]
  00107	8d 04 1b	 lea	 eax, DWORD PTR [ebx+ebx]
  0010a	d8 e1		 fsub	 ST(0), ST(1)
  0010c	89 44 24 14	 mov	 DWORD PTR -4+[esp+24], eax
  00110	d8 74 24 10	 fdiv	 DWORD PTR _PhongRadius$125152[esp+24]
  00114	da 4c 24 14	 fimul	 DWORD PTR -4+[esp+24]
  00118	e8 00 00 00 00	 call	 __ftol
  0011d	03 f0		 add	 esi, eax
$L136047:

; 4430 : 
; 4431 :         RenderTable[i] = Clamp( TempLight, 0, 255 );

  0011f	85 f6		 test	 esi, esi
  00121	dd d8		 fstp	 ST(0)
  00123	7d 04		 jge	 SHORT $L136031
  00125	33 c0		 xor	 eax, eax
  00127	eb 0f		 jmp	 SHORT $L136030
$L136031:
  00129	81 fe ff 00 00
	00		 cmp	 esi, 255		; 000000ffH
  0012f	8b c6		 mov	 eax, esi
  00131	7c 05		 jl	 SHORT $L136030
  00133	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
$L136030:
  00138	88 84 2f f4 08
	00 00		 mov	 BYTE PTR [edi+ebp+2292], al
  0013f	45		 inc	 ebp
  00140	81 fd 00 04 00
	00		 cmp	 ebp, 1024		; 00000400H
  00146	89 6c 24 10	 mov	 DWORD PTR _i$[esp+24], ebp
  0014a	0f 8c f0 fe ff
	ff		 jl	 $L125144
  00150	5f		 pop	 edi
  00151	dd d8		 fstp	 ST(0)
  00153	5e		 pop	 esi
  00154	dd d8		 fstp	 ST(0)
  00156	5d		 pop	 ebp
  00157	5b		 pop	 ebx

; 4432 :     }
; 4433 : }

  00158	83 c4 08	 add	 esp, 8
  0015b	c3		 ret	 0
?SetWaveLight@UWaveTexture@@QAEXXZ ENDP			; UWaveTexture::SetWaveLight
_TEXT	ENDS
PUBLIC	??_C@_1BK@BLG@?$AAU?$AAW?$AAa?$AAv?$AAe?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@ ; `string'
PUBLIC	?InternalConstructor@UWaveTexture@@SAXPAX@Z	; UWaveTexture::InternalConstructor
;	COMDAT ??_C@_1BK@BLG@?$AAU?$AAW?$AAa?$AAv?$AAe?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@
_DATA	SEGMENT
??_C@_1BK@BLG@?$AAU?$AAW?$AAa?$AAv?$AAe?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@ DB 'U'
	DB	00H, 'W', 00H, 'a', 00H, 'v', 00H, 'e', 00H, 'T', 00H, 'e', 00H
	DB	'x', 00H, 't', 00H, 'u', 00H, 'r', 00H, 'e', 00H, 00H, 00H ; `string'
; Function compile flags: /Ogty
_DATA	ENDS
;	COMDAT _$E215
_TEXT	SEGMENT
_$E215	PROC NEAR					; COMDAT
  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?StaticConstructor@UObject@@QAEXXZ
  00005	53		 push	 ebx
  00006	55		 push	 ebp
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	83 ec 10	 sub	 esp, 16			; 00000010H
  0000c	8b ec		 mov	 ebp, esp
  0000e	68 00 00 00 00	 push	 OFFSET FLAT:?InternalConstructor@UWaveTexture@@SAXPAX@Z ; UWaveTexture::InternalConstructor
  00013	68 04 40 08 04	 push	 67649540		; 04084004H
  00018	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1O@KHFL@?$AAS?$AAy?$AAs?$AAt?$AAe?$AAm?$AA?$AA@ ; `string'
  0001d	89 45 00	 mov	 DWORD PTR [ebp], eax
  00020	68 00 00 00 00	 push	 OFFSET FLAT:_GPackage
  00025	33 c9		 xor	 ecx, ecx
  00027	89 4d 04	 mov	 DWORD PTR [ebp+4], ecx
  0002a	68 02 00 00 00	 push	 OFFSET FLAT:??_C@_1BK@BLG@?$AAU?$AAW?$AAa?$AAv?$AAe?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@+2
  0002f	83 ec 10	 sub	 esp, 16			; 00000010H
  00032	33 d2		 xor	 edx, edx
  00034	89 55 08	 mov	 DWORD PTR [ebp+8], edx
  00037	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR __imp_?PrivateStaticClass@UObject@@0VUClass@@A
  0003d	8b cc		 mov	 ecx, esp
  0003f	52		 push	 edx
  00040	33 f6		 xor	 esi, esi
  00042	89 75 0c	 mov	 DWORD PTR [ebp+12], esi
  00045	33 c0		 xor	 eax, eax
  00047	33 ff		 xor	 edi, edi
  00049	89 39		 mov	 DWORD PTR [ecx], edi
  0004b	68 00 00 00 00	 push	 OFFSET FLAT:?PrivateStaticClass@UWaterTexture@@0VUClass@@A ; UWaterTexture::PrivateStaticClass
  00050	33 db		 xor	 ebx, ebx
  00052	89 59 04	 mov	 DWORD PTR [ecx+4], ebx
  00055	50		 push	 eax
  00056	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00059	68 04 13 00 00	 push	 4868			; 00001304H
  0005e	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  00061	50		 push	 eax
  00062	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?PrivateStaticClass@UWaveTexture@@0VUClass@@A
  00067	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0UClass@@QAE@W4ENativeConstructor@@KKPAV0@1VFGuid@@PBG33KP6AXPAX@ZP8UObject@@AEXXZ@Z
  0006d	68 00 00 00 00	 push	 OFFSET FLAT:_$E212
  00072	e8 00 00 00 00	 call	 _atexit
  00077	83 c4 04	 add	 esp, 4
  0007a	5f		 pop	 edi
  0007b	5e		 pop	 esi
  0007c	5d		 pop	 ebp
  0007d	5b		 pop	 ebx
  0007e	c3		 ret	 0
_$E215	ENDP
_TEXT	ENDS
_BSS	SEGMENT
	ALIGN	4

_$S213	DB	01H DUP (?)
; Function compile flags: /Ogty
_BSS	ENDS
;	COMDAT _$E212
_TEXT	SEGMENT
_$E212	PROC NEAR					; COMDAT
  00000	8a 0d 00 00 00
	00		 mov	 cl, BYTE PTR _$S213
  00006	b0 01		 mov	 al, 1
  00008	84 c8		 test	 cl, al
  0000a	75 13		 jne	 SHORT $L125183
  0000c	0a c8		 or	 cl, al
  0000e	88 0d 00 00 00
	00		 mov	 BYTE PTR _$S213, cl
  00014	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?PrivateStaticClass@UWaveTexture@@0VUClass@@A
  00019	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1UClass@@UAE@XZ
$L125183:
  0001f	c3		 ret	 0
_$E212	ENDP
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT _$E218
_TEXT	SEGMENT
_$E218	PROC NEAR					; COMDAT
  00000	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _autoclassUWaveTexture, OFFSET FLAT:?PrivateStaticClass@UWaveTexture@@0VUClass@@A ; UWaveTexture::PrivateStaticClass
  0000a	c3		 ret	 0
_$E218	ENDP
_TEXT	ENDS
PUBLIC	??0UWetTexture@@QAE@XZ				; UWetTexture::UWetTexture
PUBLIC	?PostLoad@UWetTexture@@UAEXXZ			; UWetTexture::PostLoad
PUBLIC	?Destroy@UWetTexture@@UAEXXZ			; UWetTexture::Destroy
PUBLIC	?Init@UWetTexture@@UAEXHH@Z			; UWetTexture::Init
PUBLIC	?Clear@UWetTexture@@UAEXK@Z			; UWetTexture::Clear
PUBLIC	?ConstantTimeTick@UWetTexture@@UAEXXZ		; UWetTexture::ConstantTimeTick
PUBLIC	?Lock@UWetTexture@@UAIXAAUFTextureInfo@@NHPAVURenderDevice@@@Z ; UWetTexture::Lock
PUBLIC	??_7UWetTexture@@6B@				; UWetTexture::`vftable'
PUBLIC	??_EUWetTexture@@UAEPAXI@Z			; UWetTexture::`vector deleting destructor'
;	COMDAT ??_7UWetTexture@@6B@
; File ..\..\Core\Inc\UnTemplate.h
CONST	SEGMENT
??_7UWetTexture@@6B@ DD FLAT:??_EUWetTexture@@UAEPAXI@Z	; UWetTexture::`vftable'
	DD	FLAT:?ProcessEvent@UObject@@UAEXPAVUFunction@@PAX1@Z
	DD	FLAT:?ProcessState@UObject@@UAEXM@Z
	DD	FLAT:?ProcessRemoteFunction@UObject@@UAEHPAVUFunction@@PAXPAUFFrame@@@Z
	DD	FLAT:?Modify@UObject@@UAEXXZ
	DD	FLAT:?PostLoad@UWetTexture@@UAEXXZ
	DD	FLAT:?Destroy@UWetTexture@@UAEXXZ
	DD	FLAT:?Serialize@UTexture@@UAEXAAVFArchive@@@Z
	DD	FLAT:?IsPendingKill@UObject@@UAEHXZ
	DD	FLAT:?GotoLabel@UObject@@UAEHVFName@@@Z
	DD	FLAT:?InitExecution@UObject@@UAEXXZ
	DD	FLAT:?ShutdownAfterError@UObject@@UAEXXZ
	DD	FLAT:?PostEditChange@UFractalTexture@@UAEXXZ
	DD	FLAT:?CallFunction@UObject@@UAEXAAUFFrame@@QAXPAVUFunction@@@Z
	DD	FLAT:?ScriptConsoleExec@UObject@@UAEHPBGAAVFOutputDevice@@PAV1@@Z
	DD	FLAT:?Register@UObject@@UAEXXZ
	DD	FLAT:?LanguageChange@UObject@@UAEXXZ
	DD	FLAT:?GetName@UObject@@UBEPBGXZ
	DD	FLAT:?Lock@UWetTexture@@UAIXAAUFTextureInfo@@NHPAVURenderDevice@@@Z
	DD	FLAT:?Unlock@UTexture@@UAIXAAUFTextureInfo@@@Z
	DD	FLAT:?GetMip@UTexture@@UAEPAUFMipmapBase@@H@Z
	DD	FLAT:?Clear@UWetTexture@@UAEXK@Z
	DD	FLAT:?Init@UWetTexture@@UAEXHH@Z
	DD	FLAT:?Tick@UTexture@@UAIXM@Z
	DD	FLAT:?ConstantTimeTick@UWetTexture@@UAEXXZ
	DD	FLAT:?MousePosition@UWaterTexture@@UAEXKMM@Z
	DD	FLAT:?Click@UWaterTexture@@UAEXKMM@Z
	DD	FLAT:?Update@UTexture@@UAEXN@Z
	DD	FLAT:?TouchTexture@UWaterTexture@@UAEXHHM@Z
; Function compile flags: /Ogty
; File C:\duke4\Fire\Src\UnFractal.cpp
CONST	ENDS
;	COMDAT ??0UWetTexture@@QAE@XZ
_TEXT	SEGMENT
??0UWetTexture@@QAE@XZ PROC NEAR			; UWetTexture::UWetTexture, COMDAT
; _this$ = ecx

; 4445 : {

  00000	53		 push	 ebx
  00001	55		 push	 ebp
  00002	56		 push	 esi
  00003	57		 push	 edi
  00004	8b f1		 mov	 esi, ecx
  00006	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0UTexture@@QAE@XZ
  0000c	8b 8e 88 00 00
	00		 mov	 ecx, DWORD PTR [esi+136]
  00012	83 c9 0c	 or	 ecx, 12			; 0000000cH
  00015	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7UFractalTexture@@6B@ ; UFractalTexture::`vftable'
  0001b	89 8e 88 00 00
	00		 mov	 DWORD PTR [esi+136], ecx
  00021	e8 00 00 00 00	 call	 ?InitTables@@YAXXZ	; InitTables
  00026	33 c0		 xor	 eax, eax
  00028	b9 08 f1 ff ff	 mov	 ecx, -3832		; fffff108H
  0002d	33 ff		 xor	 edi, edi
  0002f	88 86 dc 00 00
	00		 mov	 BYTE PTR [esi+220], al
  00035	88 86 dd 00 00
	00		 mov	 BYTE PTR [esi+221], al
  0003b	89 86 d8 00 00
	00		 mov	 DWORD PTR [esi+216], eax
  00041	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7UWaterTexture@@6B@ ; UWaterTexture::`vftable'
  00047	8d ae f8 0c 00
	00		 lea	 ebp, DWORD PTR [esi+3320]
  0004d	2b ce		 sub	 ecx, esi

; 4448 : }

  0004f	90		 npad	 1

; 4445 : {

$L136125:
  00050	33 db		 xor	 ebx, ebx
  00052	8d 04 29	 lea	 eax, DWORD PTR [ecx+ebp]
  00055	3d 00 01 00 00	 cmp	 eax, 256		; 00000100H
  0005a	0f 9c c3	 setl	 bl
  0005d	8b c7		 mov	 eax, edi
  0005f	99		 cdq
  00060	2b c2		 sub	 eax, edx
  00062	d1 f8		 sar	 eax, 1
  00064	33 d2		 xor	 edx, edx
  00066	8d 84 03 00 ff
	ff ff		 lea	 eax, DWORD PTR [ebx+eax-256]
  0006d	3b c2		 cmp	 eax, edx
  0006f	7d 04		 jge	 SHORT $L136137
  00071	33 c0		 xor	 eax, eax
  00073	eb 0c		 jmp	 SHORT $L136136
$L136137:
  00075	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  0007a	7c 05		 jl	 SHORT $L136136
  0007c	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
$L136136:
  00081	47		 inc	 edi
  00082	88 45 00	 mov	 BYTE PTR [ebp], al
  00085	45		 inc	 ebp
  00086	81 ff 00 06 00
	00		 cmp	 edi, 1536		; 00000600H
  0008c	7c c2		 jl	 SHORT $L136125
  0008e	5f		 pop	 edi
  0008f	c7 86 fc 12 00
	00 ff ff ff ff	 mov	 DWORD PTR [esi+4860], -1
  00099	88 96 f8 12 00
	00		 mov	 BYTE PTR [esi+4856], dl
  0009f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7UWetTexture@@6B@ ; UWetTexture::`vftable'

; 4446 : 	OldSourceTex = NULL;

  000a5	89 96 04 13 00
	00		 mov	 DWORD PTR [esi+4868], edx

; 4447 : 	LocalSourceBitmap = NULL;

  000ab	89 96 08 13 00
	00		 mov	 DWORD PTR [esi+4872], edx

; 4448 : }

  000b1	8b c6		 mov	 eax, esi
  000b3	5e		 pop	 esi
  000b4	5d		 pop	 ebp
  000b5	5b		 pop	 ebx
  000b6	c3		 ret	 0
??0UWetTexture@@QAE@XZ ENDP				; UWetTexture::UWetTexture
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?Init@UWetTexture@@UAEXHH@Z
_TEXT	SEGMENT
$T136159 = 12
_InUSize$ = 8
_InVSize$ = 12
?Init@UWetTexture@@UAEXHH@Z PROC NEAR			; UWetTexture::Init, COMDAT
; _this$ = ecx

; 4452 : 	// Init base class.
; 4453 : 	UWaterTexture::Init( InUSize, InVSize );

  00000	8b 44 24 08	 mov	 eax, DWORD PTR _InVSize$[esp-4]
  00004	53		 push	 ebx
  00005	55		 push	 ebp
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8b e9		 mov	 ebp, ecx
  0000a	8b 4c 24 14	 mov	 ecx, DWORD PTR _InUSize$[esp+12]
  0000e	50		 push	 eax
  0000f	51		 push	 ecx
  00010	8b cd		 mov	 ecx, ebp
  00012	e8 00 00 00 00	 call	 ?Init@UWaterTexture@@UAEXHH@Z ; UWaterTexture::Init

; 4454 : 
; 4455 : 	// Create a custom palette.
; 4456 : 	Palette = new( GetOuter() )UPalette;

  00017	6a 00		 push	 0
  00019	8d 4c 24 1c	 lea	 ecx, DWORD PTR $T136159[esp+16]
  0001d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0FName@@QAE@W4EName@@@Z
  00023	8b cd		 mov	 ecx, ebp
  00025	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetOuter@UObject@@QBEPAV1@XZ
  0002b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR __imp_?GError@@3PAVFOutputDeviceError@@A
  00031	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00033	8b 54 24 18	 mov	 edx, DWORD PTR $T136159[esp+12]
  00037	6a 00		 push	 0
  00039	51		 push	 ecx
  0003a	6a 00		 push	 0
  0003c	6a 00		 push	 0
  0003e	52		 push	 edx
  0003f	50		 push	 eax
  00040	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?PrivateStaticClass@UPalette@@0VUClass@@A
  00045	50		 push	 eax
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?StaticAllocateObject@UObject@@SAPAV1@PAVUClass@@PAV1@VFName@@K1PAVFOutputDevice@@1@Z
  0004c	8b f0		 mov	 esi, eax
  0004e	83 c4 1c	 add	 esp, 28			; 0000001cH
  00051	85 f6		 test	 esi, esi
  00053	74 10		 je	 SHORT $L136146
  00055	8b ce		 mov	 ecx, esi
  00057	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0UPalette@@QAE@XZ
  0005d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_SUPalette@@6B@ ; UPalette::`local vftable'
  00063	eb 02		 jmp	 SHORT $L136147
$L136146:
  00065	33 f6		 xor	 esi, esi
$L136147:
  00067	89 75 2c	 mov	 DWORD PTR [ebp+44], esi

; 4457 : 	for( INT i=0; i<256; i++ )

  0006a	33 db		 xor	 ebx, ebx

; 4461 : }

  0006c	8d 64 24 00	 npad	 4

; 4457 : 	for( INT i=0; i<256; i++ )

$L125211:

; 4458 : 		new(Palette->Colors)FColor(i,i,i);

  00070	8b 75 2c	 mov	 esi, DWORD PTR [ebp+44]
  00073	8b 7e 2c	 mov	 edi, DWORD PTR [esi+44]
  00076	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  00079	83 c6 28	 add	 esi, 40			; 00000028H
  0007c	8d 4f 01	 lea	 ecx, DWORD PTR [edi+1]
  0007f	3b c8		 cmp	 ecx, eax
  00081	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  00084	7e 1d		 jle	 SHORT $L136174
  00086	8d 04 49	 lea	 eax, DWORD PTR [ecx+ecx*2]
  00089	99		 cdq
  0008a	83 e2 07	 and	 edx, 7
  0008d	03 c2		 add	 eax, edx
  0008f	c1 f8 03	 sar	 eax, 3
  00092	8d 4c 08 20	 lea	 ecx, DWORD PTR [eax+ecx+32]
  00096	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  00099	6a 04		 push	 4
  0009b	8b ce		 mov	 ecx, esi
  0009d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Realloc@FArray@@IAEXH@Z
$L136174:
  000a3	8b 16		 mov	 edx, DWORD PTR [esi]
  000a5	8d 04 ba	 lea	 eax, DWORD PTR [edx+edi*4]
  000a8	85 c0		 test	 eax, eax
  000aa	74 08		 je	 SHORT $L125212
  000ac	88 18		 mov	 BYTE PTR [eax], bl
  000ae	88 58 01	 mov	 BYTE PTR [eax+1], bl
  000b1	88 58 02	 mov	 BYTE PTR [eax+2], bl
$L125212:
  000b4	43		 inc	 ebx
  000b5	81 fb 00 01 00
	00		 cmp	 ebx, 256		; 00000100H
  000bb	7c b3		 jl	 SHORT $L125211

; 4459 : 	BlueLagunaPalette(Palette);

  000bd	8b 45 2c	 mov	 eax, DWORD PTR [ebp+44]
  000c0	50		 push	 eax
  000c1	e8 00 00 00 00	 call	 ?BlueLagunaPalette@@YAXPAVUPalette@@@Z ; BlueLagunaPalette

; 4460 : 	MipZero = Palette->Colors(128);

  000c6	8b 4d 2c	 mov	 ecx, DWORD PTR [ebp+44]
  000c9	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  000cc	8b 82 00 02 00
	00		 mov	 eax, DWORD PTR [edx+512]
  000d2	83 c4 04	 add	 esp, 4
  000d5	5f		 pop	 edi
  000d6	5e		 pop	 esi
  000d7	89 45 44	 mov	 DWORD PTR [ebp+68], eax
  000da	5d		 pop	 ebp
  000db	5b		 pop	 ebx

; 4461 : }

  000dc	c2 08 00	 ret	 8
?Init@UWetTexture@@UAEXHH@Z ENDP			; UWetTexture::Init
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?PostLoad@UWetTexture@@UAEXXZ
_TEXT	SEGMENT
_Info$ = -128
_UScaler$125230 = -136
_VScaler$125231 = -144
_SourceMapAddr$125237 = -140
?PostLoad@UWetTexture@@UAEXXZ PROC NEAR			; UWetTexture::PostLoad, COMDAT
; _this$ = ecx

; 4464 : {

  00000	81 ec 90 00 00
	00		 sub	 esp, 144		; 00000090H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx

; 4465 : 	Super::PostLoad();

  0000a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?PostLoad@UTexture@@UAEXXZ
  00010	8b 4e 34	 mov	 ecx, DWORD PTR [esi+52]
  00013	8d 41 ff	 lea	 eax, DWORD PTR [ecx-1]
  00016	89 86 c8 00 00
	00		 mov	 DWORD PTR [esi+200], eax
  0001c	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  0001f	8d 50 ff	 lea	 edx, DWORD PTR [eax-1]
  00022	89 96 cc 00 00
	00		 mov	 DWORD PTR [esi+204], edx
  00028	8b 96 f0 08 00
	00		 mov	 edx, DWORD PTR [esi+2288]
  0002e	33 db		 xor	 ebx, ebx
  00030	3b d3		 cmp	 edx, ebx
  00032	75 4d		 jne	 SHORT $L136214
  00034	0f af c1	 imul	 eax, ecx
  00037	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?GMalloc@@3PAVFMalloc@@A
  0003d	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0003f	99		 cdq
  00040	2b c2		 sub	 eax, edx
  00042	8b 11		 mov	 edx, DWORD PTR [ecx]
  00044	d1 f8		 sar	 eax, 1
  00046	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_17JBDG@?$AAn?$AAe?$AAw?$AA?$AA@ ; `string'
  0004b	50		 push	 eax
  0004c	ff 12		 call	 DWORD PTR [edx]
  0004e	89 86 f0 08 00
	00		 mov	 DWORD PTR [esi+2288], eax
  00054	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  00057	0f af 46 34	 imul	 eax, DWORD PTR [esi+52]
  0005b	99		 cdq
  0005c	2b c2		 sub	 eax, edx
  0005e	d1 f8		 sar	 eax, 1
  00060	33 c9		 xor	 ecx, ecx
  00062	85 c0		 test	 eax, eax
  00064	7e 1b		 jle	 SHORT $L136214
$L136212:
  00066	8b 86 f0 08 00
	00		 mov	 eax, DWORD PTR [esi+2288]
  0006c	c6 04 01 80	 mov	 BYTE PTR [ecx+eax], 128	; 00000080H
  00070	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  00073	0f af 46 34	 imul	 eax, DWORD PTR [esi+52]
  00077	99		 cdq
  00078	2b c2		 sub	 eax, edx
  0007a	41		 inc	 ecx
  0007b	d1 f8		 sar	 eax, 1
  0007d	3b c8		 cmp	 ecx, eax
  0007f	7c e5		 jl	 SHORT $L136212
$L136214:

; 4466 : 
; 4467 : 	if( !SourceTexture ) return;

  00081	8b 8e 00 13 00
	00		 mov	 ecx, DWORD PTR [esi+4864]
  00087	3b cb		 cmp	 ecx, ebx
  00089	0f 84 ea 01 00
	00		 je	 $L125224

; 4468 : 
; 4469 : 	// Make sure the source texture data is in memory !
; 4470 : 	FTextureInfo Info; 
; 4471 : 	if( SourceTexture != this ) 

  0008f	3b ce		 cmp	 ecx, esi
  00091	74 1c		 je	 SHORT $L125227

; 4472 : 	{
; 4473 : 		 SourceTexture->Lock( Info, 0.0, 0, NULL );

  00093	8b 01		 mov	 eax, DWORD PTR [ecx]
  00095	53		 push	 ebx
  00096	53		 push	 ebx
  00097	53		 push	 ebx
  00098	53		 push	 ebx
  00099	8d 54 24 28	 lea	 edx, DWORD PTR _Info$[esp+168]
  0009d	ff 50 48	 call	 DWORD PTR [eax+72]

; 4474 : 		 SourceTexture->Unlock( Info );

  000a0	8b 8e 00 13 00
	00		 mov	 ecx, DWORD PTR [esi+4864]
  000a6	8b 01		 mov	 eax, DWORD PTR [ecx]
  000a8	8d 54 24 18	 lea	 edx, DWORD PTR _Info$[esp+152]
  000ac	ff 50 4c	 call	 DWORD PTR [eax+76]
$L125227:

; 4475 : 	}
; 4476 : 
; 4477 : 	// Make sure this is the same size as our displacement-waves texture.
; 4478 : 	if( ( SourceTexture->UBits  != UBits) || (SourceTexture->VBits  != VBits)  )

  000af	8a 46 30	 mov	 al, BYTE PTR [esi+48]
  000b2	55		 push	 ebp
  000b3	57		 push	 edi
  000b4	8b be 00 13 00
	00		 mov	 edi, DWORD PTR [esi+4864]
  000ba	8a 4f 30	 mov	 cl, BYTE PTR [edi+48]
  000bd	3a c8		 cmp	 cl, al
  000bf	75 2f		 jne	 SHORT $L125229
  000c1	8a 57 31	 mov	 dl, BYTE PTR [edi+49]
  000c4	3a 56 31	 cmp	 dl, BYTE PTR [esi+49]
  000c7	75 27		 jne	 SHORT $L125229

; 4503 : 		}
; 4504 : 	}
; 4505 : 	else
; 4506 : 	{
; 4507 : 		// Sizes match, may have changed to a fullsized sourcetexture.
; 4508 : 		if( LocalSourceBitmap ) 

  000c9	8b 86 08 13 00
	00		 mov	 eax, DWORD PTR [esi+4872]
  000cf	3b c3		 cmp	 eax, ebx
  000d1	0f 84 05 01 00
	00		 je	 $L125246

; 4509 : 		{
; 4510 : 			delete LocalSourceBitmap;

  000d7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?GMalloc@@3PAVFMalloc@@A
  000dd	8b 09		 mov	 ecx, DWORD PTR [ecx]
  000df	8b 11		 mov	 edx, DWORD PTR [ecx]
  000e1	50		 push	 eax
  000e2	ff 52 08	 call	 DWORD PTR [edx+8]

; 4511 : 			LocalSourceBitmap = NULL;

  000e5	89 9e 08 13 00
	00		 mov	 DWORD PTR [esi+4872], ebx
  000eb	e9 ec 00 00 00	 jmp	 $L125246
$L125229:

; 4479 : 	{
; 4480 : 
; 4481 : 		// Size discrepancy; try to recover a source texture by upsampling..
; 4482 : 		INT UScaler = UBits - SourceTexture->UBits;

  000f0	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  000f6	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000fb	2b c1		 sub	 eax, ecx

; 4483 : 		INT VScaler = VBits - SourceTexture->VBits;

  000fd	33 d2		 xor	 edx, edx
  000ff	8a 56 31	 mov	 dl, BYTE PTR [esi+49]
  00102	33 c9		 xor	 ecx, ecx
  00104	8a 4f 31	 mov	 cl, BYTE PTR [edi+49]
  00107	89 44 24 18	 mov	 DWORD PTR _UScaler$125230[esp+160], eax
  0010b	8b ea		 mov	 ebp, edx
  0010d	2b e9		 sub	 ebp, ecx

; 4484 : 
; 4485 : 		if( (UScaler>=0 ) && (VScaler>=0) )

  0010f	3b c3		 cmp	 eax, ebx
  00111	89 6c 24 10	 mov	 DWORD PTR _VScaler$125231[esp+160], ebp
  00115	0f 8c bb 00 00
	00		 jl	 $L125232
  0011b	3b eb		 cmp	 ebp, ebx
  0011d	0f 8c b3 00 00
	00		 jl	 $L125232

; 4486 : 		{
; 4487 : 			if( LocalSourceBitmap ) delete LocalSourceBitmap;

  00123	8b 86 08 13 00
	00		 mov	 eax, DWORD PTR [esi+4872]
  00129	3b c3		 cmp	 eax, ebx
  0012b	74 0e		 je	 SHORT $L136225
  0012d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?GMalloc@@3PAVFMalloc@@A
  00133	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00135	8b 11		 mov	 edx, DWORD PTR [ecx]
  00137	50		 push	 eax
  00138	ff 52 08	 call	 DWORD PTR [edx+8]
$L136225:

; 4488 : 			LocalSourceBitmap = new BYTE[ USize * VSize ]; 

  0013b	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  0013e	0f af 46 34	 imul	 eax, DWORD PTR [esi+52]
  00142	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?GMalloc@@3PAVFMalloc@@A
  00148	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0014a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0014c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_17JBDG@?$AAn?$AAe?$AAw?$AA?$AA@ ; `string'
  00151	50		 push	 eax
  00152	ff 12		 call	 DWORD PTR [edx]
  00154	89 86 08 13 00
	00		 mov	 DWORD PTR [esi+4872], eax

; 4489 : 			BYTE* SourceMapAddr  = &SourceTexture->Mips(0).DataArray(0);

  0015a	8b 86 00 13 00
	00		 mov	 eax, DWORD PTR [esi+4864]
  00160	8b 88 a8 00 00
	00		 mov	 ecx, DWORD PTR [eax+168]

; 4490 : 			
; 4491 : 			for( INT V=0; V<VSize; V++)

  00166	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  00169	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  0016c	33 ff		 xor	 edi, edi
  0016e	3b c3		 cmp	 eax, ebx
  00170	89 54 24 14	 mov	 DWORD PTR _SourceMapAddr$125237[esp+160], edx
  00174	7e 66		 jle	 SHORT $L125246
  00176	8b 56 34	 mov	 edx, DWORD PTR [esi+52]

; 4528 : }

  00179	8d a4 24 00 00
	00 00		 npad	 7
$L125239:

; 4492 : 			{
; 4493 : 				for( INT U=0; U<USize; U++)

  00180	33 c0		 xor	 eax, eax
  00182	85 d2		 test	 edx, edx
  00184	7e 46		 jle	 SHORT $L125240
  00186	8b df		 mov	 ebx, edi
  00188	8b cd		 mov	 ecx, ebp
  0018a	d3 fb		 sar	 ebx, cl
  0018c	89 5c 24 1c	 mov	 DWORD PTR -132+[esp+160], ebx
  00190	eb 04		 jmp	 SHORT $L125243
$L136272:

; 4489 : 			BYTE* SourceMapAddr  = &SourceTexture->Mips(0).DataArray(0);

  00192	8b 5c 24 1c	 mov	 ebx, DWORD PTR -132+[esp+160]
$L125243:

; 4494 : 				{	
; 4495 : 					LocalSourceBitmap[ U + ( V * USize )] = 
; 4496 : 						SourceMapAddr[ ( U >> UScaler ) + ((V >> VScaler) << SourceTexture->UBits) ]; 

  00196	8b 8e 00 13 00
	00		 mov	 ecx, DWORD PTR [esi+4864]
  0019c	0f af d7	 imul	 edx, edi
  0019f	8a 49 30	 mov	 cl, BYTE PTR [ecx+48]
  001a2	d3 e3		 shl	 ebx, cl
  001a4	8b 4c 24 18	 mov	 ecx, DWORD PTR _UScaler$125230[esp+160]
  001a8	8b e8		 mov	 ebp, eax
  001aa	d3 fd		 sar	 ebp, cl
  001ac	8b 4c 24 14	 mov	 ecx, DWORD PTR _SourceMapAddr$125237[esp+160]
  001b0	03 cb		 add	 ecx, ebx
  001b2	8b 9e 08 13 00
	00		 mov	 ebx, DWORD PTR [esi+4872]
  001b8	8a 0c 29	 mov	 cl, BYTE PTR [ecx+ebp]
  001bb	03 d0		 add	 edx, eax
  001bd	88 0c 1a	 mov	 BYTE PTR [edx+ebx], cl
  001c0	8b 56 34	 mov	 edx, DWORD PTR [esi+52]
  001c3	40		 inc	 eax
  001c4	3b c2		 cmp	 eax, edx
  001c6	7c ca		 jl	 SHORT $L136272

; 4492 : 			{
; 4493 : 				for( INT U=0; U<USize; U++)

  001c8	8b 6c 24 10	 mov	 ebp, DWORD PTR _VScaler$125231[esp+160]
$L125240:

; 4490 : 			
; 4491 : 			for( INT V=0; V<VSize; V++)

  001cc	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  001cf	47		 inc	 edi
  001d0	3b f8		 cmp	 edi, eax
  001d2	7c ac		 jl	 SHORT $L125239

; 4497 : 				}
; 4498 : 			}		
; 4499 : 		}
; 4500 : 		else 

  001d4	eb 06		 jmp	 SHORT $L125246
$L125232:

; 4501 : 		{
; 4502 : 			SourceTexture = NULL; // Give up trying to recover a valid sourcetexture.

  001d6	89 9e 00 13 00
	00		 mov	 DWORD PTR [esi+4864], ebx
$L125246:

; 4512 : 		}
; 4513 : 	}
; 4514 : 
; 4515 : 	if( (SourceTexture) && ( SourceTexture != OldSourceTex ) )

  001dc	8b 86 00 13 00
	00		 mov	 eax, DWORD PTR [esi+4864]
  001e2	85 c0		 test	 eax, eax
  001e4	74 0e		 je	 SHORT $L125250
  001e6	3b 86 04 13 00
	00		 cmp	 eax, DWORD PTR [esi+4868]
  001ec	74 06		 je	 SHORT $L125250

; 4516 : 	{
; 4517 : 		// Update palette if new source texture selected.
; 4518 : 		Palette = SourceTexture->Palette; 

  001ee	8b 50 2c	 mov	 edx, DWORD PTR [eax+44]
  001f1	89 56 2c	 mov	 DWORD PTR [esi+44], edx
$L125250:

; 4519 : 	}
; 4520 : 	OldSourceTex = SourceTexture;
; 4521 : 
; 4522 : 	// Recalculate the rendering LUT if needed.
; 4523 : 	if( WaveAmp != OldWaveAmp )

  001f4	8b 8e fc 12 00
	00		 mov	 ecx, DWORD PTR [esi+4860]
  001fa	89 86 04 13 00
	00		 mov	 DWORD PTR [esi+4868], eax
  00200	33 c0		 xor	 eax, eax
  00202	8a 86 e1 00 00
	00		 mov	 al, BYTE PTR [esi+225]
  00208	3b c1		 cmp	 eax, ecx
  0020a	74 5d		 je	 SHORT $L136262

; 4524 : 	{
; 4525 : 		SetRefractionTable();

  0020c	bb 0d f5 ff ff	 mov	 ebx, -2803		; fffff50dH
  00211	bd 0c f7 ff ff	 mov	 ebp, -2292		; fffff70cH
  00216	2b de		 sub	 ebx, esi
  00218	8d be f4 08 00
	00		 lea	 edi, DWORD PTR [esi+2292]
  0021e	2b ee		 sub	 ebp, esi
$L136260:
  00220	33 c9		 xor	 ecx, ecx
  00222	8a 8e e1 00 00
	00		 mov	 cl, BYTE PTR [esi+225]
  00228	8d 14 3b	 lea	 edx, DWORD PTR [ebx+edi]
  0022b	89 4c 24 10	 mov	 DWORD PTR -144+[esp+160], ecx
  0022f	db 44 24 10	 fild	 DWORD PTR -144+[esp+160]
  00233	89 54 24 10	 mov	 DWORD PTR -144+[esp+160], edx
  00237	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3b000000
  0023d	da 4c 24 10	 fimul	 DWORD PTR -144+[esp+160]
  00241	e8 00 00 00 00	 call	 __ftol
  00246	83 f8 80	 cmp	 eax, -128		; ffffff80H
  00249	7d 07		 jge	 SHORT $L136255
  0024b	b8 80 ff ff ff	 mov	 eax, -128		; ffffff80H
  00250	eb 0a		 jmp	 SHORT $L136254
$L136255:
  00252	83 f8 7f	 cmp	 eax, 127		; 0000007fH
  00255	7c 05		 jl	 SHORT $L136254
  00257	b8 7f 00 00 00	 mov	 eax, 127		; 0000007fH
$L136254:
  0025c	88 07		 mov	 BYTE PTR [edi], al
  0025e	47		 inc	 edi
  0025f	8d 04 2f	 lea	 eax, DWORD PTR [edi+ebp]
  00262	3d 00 04 00 00	 cmp	 eax, 1024		; 00000400H
  00267	7c b7		 jl	 SHORT $L136260
$L136262:

; 4526 : 	}
; 4527 : 	OldWaveAmp = WaveAmp;

  00269	33 c9		 xor	 ecx, ecx
  0026b	8a 8e e1 00 00
	00		 mov	 cl, BYTE PTR [esi+225]
  00271	5f		 pop	 edi
  00272	5d		 pop	 ebp
  00273	89 8e fc 12 00
	00		 mov	 DWORD PTR [esi+4860], ecx
$L125224:
  00279	5e		 pop	 esi
  0027a	5b		 pop	 ebx

; 4528 : }

  0027b	81 c4 90 00 00
	00		 add	 esp, 144		; 00000090H
  00281	c3		 ret	 0
?PostLoad@UWetTexture@@UAEXXZ ENDP			; UWetTexture::PostLoad
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?Clear@UWetTexture@@UAEXK@Z
_TEXT	SEGMENT
_ClearFlags$ = 8
?Clear@UWetTexture@@UAEXK@Z PROC NEAR			; UWetTexture::Clear, COMDAT
; _this$ = ecx

; 4532 : {

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	57		 push	 edi

; 4533 : 	// Init to zero.
; 4534 : 	UWaterTexture::Clear( ClearFlags );

  00003	8b 7c 24 10	 mov	 edi, DWORD PTR _ClearFlags$[esp+8]
  00007	57		 push	 edi
  00008	8b f1		 mov	 esi, ecx
  0000a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Clear@UTexture@@UAEXK@Z
  00010	8b df		 mov	 ebx, edi
  00012	83 e3 02	 and	 ebx, 2
  00015	74 34		 je	 SHORT $L136283
  00017	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  0001a	0f af 46 38	 imul	 eax, DWORD PTR [esi+56]
  0001e	99		 cdq
  0001f	2b c2		 sub	 eax, edx
  00021	d1 f8		 sar	 eax, 1
  00023	33 c9		 xor	 ecx, ecx
  00025	85 c0		 test	 eax, eax
  00027	7e 22		 jle	 SHORT $L136283

; 4544 : }

  00029	8d a4 24 00 00
	00 00		 npad	 7

; 4533 : 	// Init to zero.
; 4534 : 	UWaterTexture::Clear( ClearFlags );

$L136281:
  00030	8b 86 f0 08 00
	00		 mov	 eax, DWORD PTR [esi+2288]
  00036	c6 04 01 80	 mov	 BYTE PTR [ecx+eax], 128	; 00000080H
  0003a	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  0003d	0f af 46 38	 imul	 eax, DWORD PTR [esi+56]
  00041	99		 cdq
  00042	2b c2		 sub	 eax, edx
  00044	41		 inc	 ecx
  00045	d1 f8		 sar	 eax, 1
  00047	3b c8		 cmp	 ecx, eax
  00049	7c e5		 jl	 SHORT $L136281
$L136283:
  0004b	83 e7 01	 and	 edi, 1
  0004e	74 0a		 je	 SHORT $L136284
  00050	c7 86 ec 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+236], 0
$L136284:

; 4535 : 
; 4536 : 	// Clear fields.
; 4537 : 	if( ClearFlags & TCLEAR_Bitmap )

  0005a	85 db		 test	 ebx, ebx
  0005c	74 2d		 je	 SHORT $L125260

; 4538 : 		for( INT i=0; i< USize * VSize / 2; i++ )

  0005e	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  00061	0f af 46 38	 imul	 eax, DWORD PTR [esi+56]
  00065	99		 cdq
  00066	2b c2		 sub	 eax, edx
  00068	d1 f8		 sar	 eax, 1
  0006a	33 c9		 xor	 ecx, ecx
  0006c	85 c0		 test	 eax, eax
  0006e	7e 1b		 jle	 SHORT $L125260
$L125258:

; 4539 : 			SourceFields[i] = 128;

  00070	8b 96 f0 08 00
	00		 mov	 edx, DWORD PTR [esi+2288]
  00076	c6 04 11 80	 mov	 BYTE PTR [ecx+edx], 128	; 00000080H
  0007a	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  0007d	0f af 46 38	 imul	 eax, DWORD PTR [esi+56]
  00081	99		 cdq
  00082	2b c2		 sub	 eax, edx
  00084	41		 inc	 ecx
  00085	d1 f8		 sar	 eax, 1
  00087	3b c8		 cmp	 ecx, eax
  00089	7c e5		 jl	 SHORT $L125258
$L125260:

; 4540 : 
; 4541 : 	// Clear drops.
; 4542 : 	if( ClearFlags & TCLEAR_Temporal )

  0008b	85 ff		 test	 edi, edi
  0008d	74 0a		 je	 SHORT $L125261

; 4543 : 		NumDrops=0;

  0008f	c7 86 ec 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+236], 0
$L125261:
  00099	5f		 pop	 edi
  0009a	5e		 pop	 esi
  0009b	5b		 pop	 ebx

; 4544 : }

  0009c	c2 04 00	 ret	 4
?Clear@UWetTexture@@UAEXK@Z ENDP			; UWetTexture::Clear
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?ConstantTimeTick@UWetTexture@@UAEXXZ
_TEXT	SEGMENT
_Info$125266 = -128
?ConstantTimeTick@UWetTexture@@UAEXXZ PROC NEAR		; UWetTexture::ConstantTimeTick, COMDAT
; _this$ = ecx

; 4547 : {

  00000	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx

; 4548 : 	if( SourceTexture && USize>=8 && VSize>=8 ) // safe sizes ?

  00009	8b 8e 00 13 00
	00		 mov	 ecx, DWORD PTR [esi+4864]
  0000f	85 c9		 test	 ecx, ecx
  00011	74 4e		 je	 SHORT $L125265
  00013	8b 56 34	 mov	 edx, DWORD PTR [esi+52]
  00016	b8 08 00 00 00	 mov	 eax, 8
  0001b	3b d0		 cmp	 edx, eax
  0001d	7c 42		 jl	 SHORT $L125265
  0001f	39 46 38	 cmp	 DWORD PTR [esi+56], eax
  00022	7c 3d		 jl	 SHORT $L125265

; 4549 : 	{
; 4550 : 		// Make sure referred textures are updated also.
; 4551 : 		FTextureInfo Info; 
; 4552 : 		if( SourceTexture != this )  

  00024	3b ce		 cmp	 ecx, esi
  00026	74 24		 je	 SHORT $L125267

; 4553 : 		{
; 4554 : 			SourceTexture->Lock( Info, LastUpdateTime, 0, NULL );

  00028	8b 56 50	 mov	 edx, DWORD PTR [esi+80]
  0002b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0002d	6a 00		 push	 0
  0002f	6a 00		 push	 0
  00031	52		 push	 edx
  00032	8b 56 4c	 mov	 edx, DWORD PTR [esi+76]
  00035	52		 push	 edx
  00036	8d 54 24 14	 lea	 edx, DWORD PTR _Info$125266[esp+148]
  0003a	ff 50 48	 call	 DWORD PTR [eax+72]

; 4555 : 			SourceTexture->Unlock( Info );

  0003d	8b 8e 00 13 00
	00		 mov	 ecx, DWORD PTR [esi+4864]
  00043	8b 01		 mov	 eax, DWORD PTR [ecx]
  00045	8d 54 24 04	 lea	 edx, DWORD PTR _Info$125266[esp+132]
  00049	ff 50 4c	 call	 DWORD PTR [eax+76]
$L125267:

; 4556 : 			//SourceTexture->Update(LastUpdateTime);
; 4557 : 		}
; 4558 : 
; 4559 : 		//Update the water.
; 4560 : 		WaterRedrawDrops();

  0004c	8b ce		 mov	 ecx, esi
  0004e	e8 00 00 00 00	 call	 ?WaterRedrawDrops@UWaterTexture@@QAEXXZ ; UWaterTexture::WaterRedrawDrops

; 4561 : 		CalculateWater();  

  00053	8b ce		 mov	 ecx, esi
  00055	e8 00 00 00 00	 call	 ?CalculateWater@UWaterTexture@@QAEXXZ ; UWaterTexture::CalculateWater

; 4562 :         ApplyWetTexture(); 

  0005a	8b ce		 mov	 ecx, esi
  0005c	e8 00 00 00 00	 call	 ?ApplyWetTexture@UWetTexture@@AAEXXZ ; UWetTexture::ApplyWetTexture
$L125265:
  00061	5e		 pop	 esi

; 4563 : 	}
; 4564 : }

  00062	81 c4 80 00 00
	00		 add	 esp, 128		; 00000080H
  00068	c3		 ret	 0
?ConstantTimeTick@UWetTexture@@UAEXXZ ENDP		; UWetTexture::ConstantTimeTick
_TEXT	ENDS
PUBLIC	?SetRefractionTable@UWetTexture@@AAEXXZ		; UWetTexture::SetRefractionTable
; Function compile flags: /Ogty
;	COMDAT ?SetRefractionTable@UWetTexture@@AAEXXZ
_TEXT	SEGMENT
?SetRefractionTable@UWetTexture@@AAEXXZ PROC NEAR	; UWetTexture::SetRefractionTable, COMDAT
; _this$ = ecx

; 4571 : {

  00000	51		 push	 ecx
  00001	53		 push	 ebx
  00002	55		 push	 ebp
  00003	56		 push	 esi
  00004	57		 push	 edi
  00005	8b f9		 mov	 edi, ecx

; 4572 : 	// 'zero' is 512
; 4573 : 	for( INT i=0; i<1024 ; i++ )

  00007	bb 0d f5 ff ff	 mov	 ebx, -2803		; fffff50dH
  0000c	bd 0c f7 ff ff	 mov	 ebp, -2292		; fffff70cH
  00011	2b df		 sub	 ebx, edi
  00013	8d b7 f4 08 00
	00		 lea	 esi, DWORD PTR [edi+2292]
  00019	2b ef		 sub	 ebp, edi

; 4577 :     }
; 4578 : }

  0001b	90 8d 64 24 00	 npad	 5

; 4572 : 	// 'zero' is 512
; 4573 : 	for( INT i=0; i<1024 ; i++ )

$L125272:

; 4574 :     {
; 4575 : 		INT TempLight = (INT) ((+i-511) * ((FLOAT)WaveAmp/512.0F));

  00020	33 c9		 xor	 ecx, ecx
  00022	8a 8f e1 00 00
	00		 mov	 cl, BYTE PTR [edi+225]
  00028	8d 04 33	 lea	 eax, DWORD PTR [ebx+esi]
  0002b	89 44 24 10	 mov	 DWORD PTR -4+[esp+20], eax
  0002f	db 44 24 10	 fild	 DWORD PTR -4+[esp+20]
  00033	89 4c 24 10	 mov	 DWORD PTR -4+[esp+20], ecx
  00037	db 44 24 10	 fild	 DWORD PTR -4+[esp+20]
  0003b	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3b000000
  00041	de c9		 fmulp	 ST(1), ST(0)
  00043	e8 00 00 00 00	 call	 __ftol

; 4576 : 		RenderTable[i] = Clamp( TempLight, -128, 127 );

  00048	83 f8 80	 cmp	 eax, -128		; ffffff80H
  0004b	7d 07		 jge	 SHORT $L136312
  0004d	b8 80 ff ff ff	 mov	 eax, -128		; ffffff80H
  00052	eb 0a		 jmp	 SHORT $L136311
$L136312:
  00054	83 f8 7f	 cmp	 eax, 127		; 0000007fH
  00057	7c 05		 jl	 SHORT $L136311
  00059	b8 7f 00 00 00	 mov	 eax, 127		; 0000007fH
$L136311:
  0005e	88 06		 mov	 BYTE PTR [esi], al
  00060	46		 inc	 esi
  00061	8d 14 2e	 lea	 edx, DWORD PTR [esi+ebp]
  00064	81 fa 00 04 00
	00		 cmp	 edx, 1024		; 00000400H
  0006a	7c b4		 jl	 SHORT $L125272
  0006c	5f		 pop	 edi
  0006d	5e		 pop	 esi
  0006e	5d		 pop	 ebp
  0006f	5b		 pop	 ebx

; 4577 :     }
; 4578 : }

  00070	59		 pop	 ecx
  00071	c3		 ret	 0
?SetRefractionTable@UWetTexture@@AAEXXZ ENDP		; UWetTexture::SetRefractionTable
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?Destroy@UWetTexture@@UAEXXZ
_TEXT	SEGMENT
?Destroy@UWetTexture@@UAEXXZ PROC NEAR			; UWetTexture::Destroy, COMDAT
; _this$ = ecx

; 4581 : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 4582 : 	// Free memory.
; 4583 : 	if( LocalSourceBitmap )

  00003	8b 86 08 13 00
	00		 mov	 eax, DWORD PTR [esi+4872]
  00009	85 c0		 test	 eax, eax
  0000b	74 0e		 je	 SHORT $L136323

; 4584 : 		delete LocalSourceBitmap;

  0000d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?GMalloc@@3PAVFMalloc@@A
  00013	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00015	8b 11		 mov	 edx, DWORD PTR [ecx]
  00017	50		 push	 eax
  00018	ff 52 08	 call	 DWORD PTR [edx+8]
$L136323:

; 4585 : 
; 4586 : 	// Must call direct parents' class destroy.	
; 4587 : 	Super::Destroy();

  0001b	8b 86 f0 08 00
	00		 mov	 eax, DWORD PTR [esi+2288]
  00021	85 c0		 test	 eax, eax
  00023	74 0e		 je	 SHORT $L136334
  00025	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?GMalloc@@3PAVFMalloc@@A
  0002b	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0002d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0002f	50		 push	 eax
  00030	ff 52 08	 call	 DWORD PTR [edx+8]
$L136334:
  00033	8b ce		 mov	 ecx, esi
  00035	5e		 pop	 esi
  00036	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_?Destroy@UTexture@@UAEXXZ
?Destroy@UWetTexture@@UAEXXZ ENDP			; UWetTexture::Destroy
_TEXT	ENDS
PUBLIC	??_C@_1BI@JHNI@?$AAU?$AAW?$AAe?$AAt?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@ ; `string'
PUBLIC	?InternalConstructor@UWetTexture@@SAXPAX@Z	; UWetTexture::InternalConstructor
;	COMDAT ??_C@_1BI@JHNI@?$AAU?$AAW?$AAe?$AAt?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@
_DATA	SEGMENT
??_C@_1BI@JHNI@?$AAU?$AAW?$AAe?$AAt?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@ DB 'U'
	DB	00H, 'W', 00H, 'e', 00H, 't', 00H, 'T', 00H, 'e', 00H, 'x', 00H
	DB	't', 00H, 'u', 00H, 'r', 00H, 'e', 00H, 00H, 00H ; `string'
; Function compile flags: /Ogty
_DATA	ENDS
;	COMDAT _$E224
_TEXT	SEGMENT
_$E224	PROC NEAR					; COMDAT
  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?StaticConstructor@UObject@@QAEXXZ
  00005	53		 push	 ebx
  00006	55		 push	 ebp
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	83 ec 10	 sub	 esp, 16			; 00000010H
  0000c	8b ec		 mov	 ebp, esp
  0000e	68 00 00 00 00	 push	 OFFSET FLAT:?InternalConstructor@UWetTexture@@SAXPAX@Z ; UWetTexture::InternalConstructor
  00013	68 04 40 08 04	 push	 67649540		; 04084004H
  00018	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1O@KHFL@?$AAS?$AAy?$AAs?$AAt?$AAe?$AAm?$AA?$AA@ ; `string'
  0001d	89 45 00	 mov	 DWORD PTR [ebp], eax
  00020	68 00 00 00 00	 push	 OFFSET FLAT:_GPackage
  00025	33 c9		 xor	 ecx, ecx
  00027	89 4d 04	 mov	 DWORD PTR [ebp+4], ecx
  0002a	68 02 00 00 00	 push	 OFFSET FLAT:??_C@_1BI@JHNI@?$AAU?$AAW?$AAe?$AAt?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@+2
  0002f	83 ec 10	 sub	 esp, 16			; 00000010H
  00032	33 d2		 xor	 edx, edx
  00034	89 55 08	 mov	 DWORD PTR [ebp+8], edx
  00037	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR __imp_?PrivateStaticClass@UObject@@0VUClass@@A
  0003d	8b cc		 mov	 ecx, esp
  0003f	52		 push	 edx
  00040	33 f6		 xor	 esi, esi
  00042	89 75 0c	 mov	 DWORD PTR [ebp+12], esi
  00045	33 c0		 xor	 eax, eax
  00047	33 ff		 xor	 edi, edi
  00049	89 39		 mov	 DWORD PTR [ecx], edi
  0004b	68 00 00 00 00	 push	 OFFSET FLAT:?PrivateStaticClass@UWaterTexture@@0VUClass@@A ; UWaterTexture::PrivateStaticClass
  00050	33 db		 xor	 ebx, ebx
  00052	89 59 04	 mov	 DWORD PTR [ecx+4], ebx
  00055	50		 push	 eax
  00056	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00059	68 0c 13 00 00	 push	 4876			; 0000130cH
  0005e	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  00061	50		 push	 eax
  00062	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?PrivateStaticClass@UWetTexture@@0VUClass@@A
  00067	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0UClass@@QAE@W4ENativeConstructor@@KKPAV0@1VFGuid@@PBG33KP6AXPAX@ZP8UObject@@AEXXZ@Z
  0006d	68 00 00 00 00	 push	 OFFSET FLAT:_$E221
  00072	e8 00 00 00 00	 call	 _atexit
  00077	83 c4 04	 add	 esp, 4
  0007a	5f		 pop	 edi
  0007b	5e		 pop	 esi
  0007c	5d		 pop	 ebp
  0007d	5b		 pop	 ebx
  0007e	c3		 ret	 0
_$E224	ENDP
_TEXT	ENDS
_BSS	SEGMENT
	ALIGN	4

_$S222	DB	01H DUP (?)
; Function compile flags: /Ogty
_BSS	ENDS
;	COMDAT _$E221
_TEXT	SEGMENT
_$E221	PROC NEAR					; COMDAT
  00000	8a 0d 00 00 00
	00		 mov	 cl, BYTE PTR _$S222
  00006	b0 01		 mov	 al, 1
  00008	84 c8		 test	 cl, al
  0000a	75 13		 jne	 SHORT $L125300
  0000c	0a c8		 or	 cl, al
  0000e	88 0d 00 00 00
	00		 mov	 BYTE PTR _$S222, cl
  00014	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?PrivateStaticClass@UWetTexture@@0VUClass@@A
  00019	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1UClass@@UAE@XZ
$L125300:
  0001f	c3		 ret	 0
_$E221	ENDP
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT _$E227
_TEXT	SEGMENT
_$E227	PROC NEAR					; COMDAT
  00000	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _autoclassUWetTexture, OFFSET FLAT:?PrivateStaticClass@UWetTexture@@0VUClass@@A ; UWetTexture::PrivateStaticClass
  0000a	c3		 ret	 0
_$E227	ENDP
_TEXT	ENDS
PUBLIC	??0UIceTexture@@QAE@XZ				; UIceTexture::UIceTexture
PUBLIC	?PostLoad@UIceTexture@@UAEXXZ			; UIceTexture::PostLoad
PUBLIC	?Destroy@UIceTexture@@UAEXXZ			; UIceTexture::Destroy
PUBLIC	?Init@UIceTexture@@UAEXHH@Z			; UIceTexture::Init
PUBLIC	?Clear@UIceTexture@@UAEXK@Z			; UIceTexture::Clear
PUBLIC	?ConstantTimeTick@UIceTexture@@UAEXXZ		; UIceTexture::ConstantTimeTick
PUBLIC	?Tick@UIceTexture@@UAIXM@Z			; UIceTexture::Tick
PUBLIC	?MousePosition@UIceTexture@@UAEXKMM@Z		; UIceTexture::MousePosition
PUBLIC	?Click@UIceTexture@@UAEXKMM@Z			; UIceTexture::Click
PUBLIC	?Lock@UIceTexture@@UAIXAAUFTextureInfo@@NHPAVURenderDevice@@@Z ; UIceTexture::Lock
PUBLIC	??_7UIceTexture@@6B@				; UIceTexture::`vftable'
PUBLIC	??_EUIceTexture@@UAEPAXI@Z			; UIceTexture::`vector deleting destructor'
;	COMDAT ??_7UIceTexture@@6B@
CONST	SEGMENT
??_7UIceTexture@@6B@ DD FLAT:??_EUIceTexture@@UAEPAXI@Z	; UIceTexture::`vftable'
	DD	FLAT:?ProcessEvent@UObject@@UAEXPAVUFunction@@PAX1@Z
	DD	FLAT:?ProcessState@UObject@@UAEXM@Z
	DD	FLAT:?ProcessRemoteFunction@UObject@@UAEHPAVUFunction@@PAXPAUFFrame@@@Z
	DD	FLAT:?Modify@UObject@@UAEXXZ
	DD	FLAT:?PostLoad@UIceTexture@@UAEXXZ
	DD	FLAT:?Destroy@UIceTexture@@UAEXXZ
	DD	FLAT:?Serialize@UTexture@@UAEXAAVFArchive@@@Z
	DD	FLAT:?IsPendingKill@UObject@@UAEHXZ
	DD	FLAT:?GotoLabel@UObject@@UAEHVFName@@@Z
	DD	FLAT:?InitExecution@UObject@@UAEXXZ
	DD	FLAT:?ShutdownAfterError@UObject@@UAEXXZ
	DD	FLAT:?PostEditChange@UFractalTexture@@UAEXXZ
	DD	FLAT:?CallFunction@UObject@@UAEXAAUFFrame@@QAXPAVUFunction@@@Z
	DD	FLAT:?ScriptConsoleExec@UObject@@UAEHPBGAAVFOutputDevice@@PAV1@@Z
	DD	FLAT:?Register@UObject@@UAEXXZ
	DD	FLAT:?LanguageChange@UObject@@UAEXXZ
	DD	FLAT:?GetName@UObject@@UBEPBGXZ
	DD	FLAT:?Lock@UIceTexture@@UAIXAAUFTextureInfo@@NHPAVURenderDevice@@@Z
	DD	FLAT:?Unlock@UTexture@@UAIXAAUFTextureInfo@@@Z
	DD	FLAT:?GetMip@UTexture@@UAEPAUFMipmapBase@@H@Z
	DD	FLAT:?Clear@UIceTexture@@UAEXK@Z
	DD	FLAT:?Init@UIceTexture@@UAEXHH@Z
	DD	FLAT:?Tick@UIceTexture@@UAIXM@Z
	DD	FLAT:?ConstantTimeTick@UIceTexture@@UAEXXZ
	DD	FLAT:?MousePosition@UIceTexture@@UAEXKMM@Z
	DD	FLAT:?Click@UIceTexture@@UAEXKMM@Z
	DD	FLAT:?Update@UTexture@@UAEXN@Z
	DD	FLAT:?TouchTexture@UFractalTexture@@UAEXHHM@Z
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ??0UIceTexture@@QAE@XZ
_TEXT	SEGMENT
??0UIceTexture@@QAE@XZ PROC NEAR			; UIceTexture::UIceTexture, COMDAT
; _this$ = ecx

; 4599 : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0UTexture@@QAE@XZ
  00009	8b 86 88 00 00
	00		 mov	 eax, DWORD PTR [esi+136]
  0000f	83 c8 0c	 or	 eax, 12			; 0000000cH
  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7UFractalTexture@@6B@ ; UFractalTexture::`vftable'
  00018	89 86 88 00 00
	00		 mov	 DWORD PTR [esi+136], eax
  0001e	e8 00 00 00 00	 call	 ?InitTables@@YAXXZ	; InitTables
  00023	33 c0		 xor	 eax, eax

; 4600 : 	MasterCount=0.0f;
; 4601 : 	OldUDisp =   -1;

  00025	83 c9 ff	 or	 ecx, -1
  00028	88 86 dc 00 00
	00		 mov	 BYTE PTR [esi+220], al
  0002e	88 86 dd 00 00
	00		 mov	 BYTE PTR [esi+221], al
  00034	89 86 d8 00 00
	00		 mov	 DWORD PTR [esi+216], eax
  0003a	89 86 f4 00 00
	00		 mov	 DWORD PTR [esi+244], eax

; 4602 : 	OldVDisp =   -1;
; 4603 : 
; 4604 : 	OldSourceTex = NULL;

  00040	89 86 18 01 00
	00		 mov	 DWORD PTR [esi+280], eax

; 4605 : 	OldGlassTex = NULL;

  00046	89 86 14 01 00
	00		 mov	 DWORD PTR [esi+276], eax

; 4606 : 
; 4607 : 	LocalSourceBitmap = NULL;

  0004c	89 86 1c 01 00
	00		 mov	 DWORD PTR [esi+284], eax
  00052	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7UIceTexture@@6B@ ; UIceTexture::`vftable'
  00058	89 8e 0c 01 00
	00		 mov	 DWORD PTR [esi+268], ecx
  0005e	89 8e 10 01 00
	00		 mov	 DWORD PTR [esi+272], ecx

; 4608 : 
; 4609 : 	ForceRefresh = 1;

  00064	c7 86 20 01 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+288], 1

; 4610 : }

  0006e	8b c6		 mov	 eax, esi
  00070	5e		 pop	 esi
  00071	c3		 ret	 0
??0UIceTexture@@QAE@XZ ENDP				; UIceTexture::UIceTexture
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?PostLoad@UIceTexture@@UAEXXZ
_TEXT	SEGMENT
_Info$125319 = -128
_UScaler$125330 = -148
_VScaler$125331 = -136
_SourceMapAddr$125333 = -140
?PostLoad@UIceTexture@@UAEXXZ PROC NEAR			; UIceTexture::PostLoad, COMDAT
; _this$ = ecx

; 4613 : {

  00000	81 ec 94 00 00
	00		 sub	 esp, 148		; 00000094H
  00006	53		 push	 ebx
  00007	55		 push	 ebp
  00008	56		 push	 esi
  00009	57		 push	 edi
  0000a	8b f1		 mov	 esi, ecx

; 4614 : 	Super::PostLoad();

  0000c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?PostLoad@UTexture@@UAEXXZ
  00012	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  00015	8b 4e 38	 mov	 ecx, DWORD PTR [esi+56]
  00018	48		 dec	 eax
  00019	49		 dec	 ecx
  0001a	89 8e cc 00 00
	00		 mov	 DWORD PTR [esi+204], ecx

; 4615 : 
; 4616 : 	// Validate all sizes: minima & matching requirements.
; 4617 : 	if( SourceTexture )  

  00020	8b 8e e4 00 00
	00		 mov	 ecx, DWORD PTR [esi+228]
  00026	33 ed		 xor	 ebp, ebp
  00028	3b cd		 cmp	 ecx, ebp
  0002a	89 86 c8 00 00
	00		 mov	 DWORD PTR [esi+200], eax
  00030	0f 84 52 01 00
	00		 je	 $L125342

; 4618 : 	{
; 4619 : 		// Make sure the source texture data is loaded.
; 4620 : 		FTextureInfo Info; 
; 4621 : 		if( SourceTexture != this ) 

  00036	3b ce		 cmp	 ecx, esi
  00038	74 1c		 je	 SHORT $L125320

; 4622 : 		{
; 4623 : 			SourceTexture->Lock( Info, 0.0, 0, NULL );

  0003a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0003c	55		 push	 ebp
  0003d	55		 push	 ebp
  0003e	55		 push	 ebp
  0003f	55		 push	 ebp
  00040	8d 54 24 34	 lea	 edx, DWORD PTR _Info$125319[esp+180]
  00044	ff 50 48	 call	 DWORD PTR [eax+72]

; 4624 : 			SourceTexture->Unlock( Info );

  00047	8b 8e e4 00 00
	00		 mov	 ecx, DWORD PTR [esi+228]
  0004d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0004f	8d 54 24 24	 lea	 edx, DWORD PTR _Info$125319[esp+164]
  00053	ff 50 4c	 call	 DWORD PTR [eax+76]
$L125320:

; 4625 : 		}
; 4626 : 
; 4627 : 		if  (  ((USize<8) || (VSize<8))  )

  00056	8b 56 34	 mov	 edx, DWORD PTR [esi+52]
  00059	83 fa 08	 cmp	 edx, 8
  0005c	0f 8c 1a 01 00
	00		 jl	 $L125322
  00062	8b 5e 38	 mov	 ebx, DWORD PTR [esi+56]
  00065	83 fb 08	 cmp	 ebx, 8
  00068	0f 8c 0e 01 00
	00		 jl	 $L125322

; 4631 : 		}
; 4632 : 		else
; 4633 : 		{
; 4634 : 			UBOOL  WrongSizedSource = ((  SourceTexture->USize != USize ) || (  SourceTexture->VSize != VSize ) );

  0006e	8b be e4 00 00
	00		 mov	 edi, DWORD PTR [esi+228]
  00074	39 57 34	 cmp	 DWORD PTR [edi+52], edx
  00077	75 05		 jne	 SHORT $L136400
  00079	39 5f 38	 cmp	 DWORD PTR [edi+56], ebx
  0007c	74 05		 je	 SHORT $L136401
$L136400:
  0007e	bd 01 00 00 00	 mov	 ebp, 1
$L136401:

; 4635 : 			UBOOL  WrongSizedGlass = true;
; 4636 : 			if( GlassTexture ) 

  00083	8b 86 e0 00 00
	00		 mov	 eax, DWORD PTR [esi+224]
  00089	85 c0		 test	 eax, eax
  0008b	b9 01 00 00 00	 mov	 ecx, 1
  00090	74 1d		 je	 SHORT $L125327

; 4637 : 			{
; 4638 : 				WrongSizedGlass = ((  GlassTexture->USize  != USize ) || (  GlassTexture->VSize  != VSize ) );

  00092	39 50 34	 cmp	 DWORD PTR [eax+52], edx
  00095	75 09		 jne	 SHORT $L136402
  00097	39 58 38	 cmp	 DWORD PTR [eax+56], ebx
  0009a	75 04		 jne	 SHORT $L136402
  0009c	33 c9		 xor	 ecx, ecx
  0009e	eb 0f		 jmp	 SHORT $L125327
$L136402:
  000a0	b9 01 00 00 00	 mov	 ecx, 1

; 4639 : 				if( WrongSizedGlass ) GlassTexture = NULL;

  000a5	c7 86 e0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+224], 0
$L125327:

; 4640 : 			}
; 4641 : 
; 4642 : 			if( ( (!WrongSizedSource) && (!WrongSizedGlass) ) )

  000af	85 ed		 test	 ebp, ebp
  000b1	75 0f		 jne	 SHORT $L125328
  000b3	85 c9		 test	 ecx, ecx
  000b5	75 0b		 jne	 SHORT $L125328

; 4643 : 			{
; 4644 : 				LocalSourceBitmap = NULL;

  000b7	89 8e 1c 01 00
	00		 mov	 DWORD PTR [esi+284], ecx

; 4645 : 			}
; 4646 : 			else //	Static fake texture created if( WrongSizedSource || WrongSizedGlass ) 

  000bd	e9 c6 00 00 00	 jmp	 $L125342
$L125328:

; 4647 : 			{
; 4648 : 				// If either glass or source texture size is invalid, no longer animate 
; 4649 : 				// but do copy whatever's in the source texture to be sure there's 
; 4650 : 				// something valid on display..... and upsample if necessary.
; 4651 : 				// Try to copy source texture to current texture.
; 4652 : 				// Size changed? Try to recover a source texture by upsampling.
; 4653 : 			
; 4654 : 				INT UScaler = UBits - SourceTexture->UBits;

  000c2	33 c9		 xor	 ecx, ecx
  000c4	8a 4f 30	 mov	 cl, BYTE PTR [edi+48]
  000c7	33 c0		 xor	 eax, eax
  000c9	8a 46 30	 mov	 al, BYTE PTR [esi+48]
  000cc	8b e8		 mov	 ebp, eax
  000ce	2b e9		 sub	 ebp, ecx

; 4655 : 				INT VScaler = VBits - SourceTexture->VBits;

  000d0	33 c9		 xor	 ecx, ecx
  000d2	8a 4f 31	 mov	 cl, BYTE PTR [edi+49]
  000d5	89 6c 24 10	 mov	 DWORD PTR _UScaler$125330[esp+164], ebp
  000d9	8b c1		 mov	 eax, ecx
  000db	33 c9		 xor	 ecx, ecx
  000dd	8a 4e 31	 mov	 cl, BYTE PTR [esi+49]
  000e0	2b c8		 sub	 ecx, eax

; 4656 : 
; 4657 : 				if( (UScaler >=0) && (VScaler>=0) )

  000e2	85 ed		 test	 ebp, ebp
  000e4	89 4c 24 1c	 mov	 DWORD PTR _VScaler$125331[esp+164], ecx
  000e8	0f 8c 82 00 00
	00		 jl	 $L125332
  000ee	85 c9		 test	 ecx, ecx
  000f0	7c 7e		 jl	 SHORT $L125332

; 4658 : 				{
; 4659 : 					LocalSourceBitmap = &Mips(0).DataArray(0);  // Our static output image.

  000f2	8b 86 a8 00 00
	00		 mov	 eax, DWORD PTR [esi+168]
  000f8	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  000fb	89 86 1c 01 00
	00		 mov	 DWORD PTR [esi+284], eax

; 4660 : 					BYTE* SourceMapAddr = &SourceTexture->Mips(0).DataArray(0);

  00101	8b 87 a8 00 00
	00		 mov	 eax, DWORD PTR [edi+168]
  00107	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]

; 4661 : 						
; 4662 : 					// Copy, with optional scaling, to our first mipmap.
; 4663 : 					for( INT V=0; V< VSize; V++)

  0010a	33 ff		 xor	 edi, edi
  0010c	85 db		 test	 ebx, ebx
  0010e	89 44 24 18	 mov	 DWORD PTR _SourceMapAddr$125333[esp+164], eax
  00112	7e 74		 jle	 SHORT $L125342
$L125335:

; 4664 : 					{
; 4665 : 						for( INT U=0; U< USize; U++)

  00114	33 c0		 xor	 eax, eax
  00116	85 d2		 test	 edx, edx
  00118	7e 4c		 jle	 SHORT $L125336
  0011a	8b df		 mov	 ebx, edi
  0011c	d3 fb		 sar	 ebx, cl
  0011e	89 5c 24 20	 mov	 DWORD PTR -132+[esp+164], ebx
  00122	eb 04		 jmp	 SHORT $L125339
$L136433:

; 4660 : 					BYTE* SourceMapAddr = &SourceTexture->Mips(0).DataArray(0);

  00124	8b 5c 24 20	 mov	 ebx, DWORD PTR -132+[esp+164]
$L125339:

; 4666 : 						{	
; 4667 : 							LocalSourceBitmap[ U + ( V * USize )] = 
; 4668 : 								SourceMapAddr[ ( U >> UScaler ) + ((V >> VScaler) << SourceTexture->UBits) ];

  00128	8b 8e e4 00 00
	00		 mov	 ecx, DWORD PTR [esi+228]
  0012e	0f af d7	 imul	 edx, edi
  00131	8a 49 30	 mov	 cl, BYTE PTR [ecx+48]
  00134	d3 e3		 shl	 ebx, cl
  00136	8b c8		 mov	 ecx, eax
  00138	89 4c 24 14	 mov	 DWORD PTR -144+[esp+164], ecx
  0013c	8b cd		 mov	 ecx, ebp
  0013e	8b e8		 mov	 ebp, eax
  00140	d3 fd		 sar	 ebp, cl
  00142	8b 4c 24 18	 mov	 ecx, DWORD PTR _SourceMapAddr$125333[esp+164]
  00146	03 cb		 add	 ecx, ebx
  00148	8b 9e 1c 01 00
	00		 mov	 ebx, DWORD PTR [esi+284]
  0014e	8a 0c 29	 mov	 cl, BYTE PTR [ecx+ebp]
  00151	8b 6c 24 10	 mov	 ebp, DWORD PTR _UScaler$125330[esp+164]
  00155	03 d3		 add	 edx, ebx
  00157	88 0c 02	 mov	 BYTE PTR [edx+eax], cl
  0015a	8b 56 34	 mov	 edx, DWORD PTR [esi+52]
  0015d	40		 inc	 eax
  0015e	3b c2		 cmp	 eax, edx
  00160	7c c2		 jl	 SHORT $L136433

; 4664 : 					{
; 4665 : 						for( INT U=0; U< USize; U++)

  00162	8b 4c 24 1c	 mov	 ecx, DWORD PTR _VScaler$125331[esp+164]
$L125336:

; 4661 : 						
; 4662 : 					// Copy, with optional scaling, to our first mipmap.
; 4663 : 					for( INT V=0; V< VSize; V++)

  00166	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  00169	47		 inc	 edi
  0016a	3b f8		 cmp	 edi, eax
  0016c	7c a6		 jl	 SHORT $L125335

; 4669 : 						}
; 4670 : 					}					
; 4671 : 				}
; 4672 : 				else

  0016e	eb 18		 jmp	 SHORT $L125342
$L125332:

; 4673 : 				{
; 4674 : 					SourceTexture = NULL; // Give up trying to rebuild a sourcetexture.

  00170	c7 86 e4 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+228], 0
  0017a	eb 0c		 jmp	 SHORT $L125342
$L125322:

; 4628 : 		{
; 4629 : 			SourceTexture = NULL;

  0017c	89 ae e4 00 00
	00		 mov	 DWORD PTR [esi+228], ebp

; 4630 : 			GlassTexture =  NULL;

  00182	89 ae e0 00 00
	00		 mov	 DWORD PTR [esi+224], ebp
$L125342:

; 4675 : 				}
; 4676 : 			}
; 4677 : 		}
; 4678 : 	}
; 4679 : 
; 4680 : 	if( (SourceTexture) && ( SourceTexture != OldSourceTex ) )

  00188	8b 86 e4 00 00
	00		 mov	 eax, DWORD PTR [esi+228]
  0018e	85 c0		 test	 eax, eax
  00190	74 18		 je	 SHORT $L125343
  00192	3b 86 18 01 00
	00		 cmp	 eax, DWORD PTR [esi+280]
  00198	74 10		 je	 SHORT $L125343

; 4681 : 	{
; 4682 : 		Palette = SourceTexture->Palette; // Make sure palette pointer gets updated.

  0019a	8b 50 2c	 mov	 edx, DWORD PTR [eax+44]
  0019d	89 56 2c	 mov	 DWORD PTR [esi+44], edx

; 4683 : 		ForceRefresh = 1;

  001a0	c7 86 20 01 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+288], 1
$L125343:

; 4684 : 	}
; 4685 : 	OldSourceTex = SourceTexture;
; 4686 : 
; 4687 : 	if( GlassTexture != OldGlassTex ) 

  001aa	8b 8e 14 01 00
	00		 mov	 ecx, DWORD PTR [esi+276]
  001b0	89 86 18 01 00
	00		 mov	 DWORD PTR [esi+280], eax
  001b6	8b 86 e0 00 00
	00		 mov	 eax, DWORD PTR [esi+224]
  001bc	3b c1		 cmp	 eax, ecx

; 4689 : 	OldGlassTex = GlassTexture;

  001be	89 86 14 01 00
	00		 mov	 DWORD PTR [esi+276], eax
  001c4	74 0a		 je	 SHORT $L125344

; 4688 : 		ForceRefresh = 1;

  001c6	c7 86 20 01 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+288], 1
$L125344:
  001d0	5f		 pop	 edi
  001d1	5e		 pop	 esi
  001d2	5d		 pop	 ebp
  001d3	5b		 pop	 ebx

; 4690 : }

  001d4	81 c4 94 00 00
	00		 add	 esp, 148		; 00000094H
  001da	c3		 ret	 0
?PostLoad@UIceTexture@@UAEXXZ ENDP			; UIceTexture::PostLoad
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?Init@UIceTexture@@UAEXHH@Z
_TEXT	SEGMENT
$T136456 = 12
_InUSize$ = 8
_InVSize$ = 12
?Init@UIceTexture@@UAEXHH@Z PROC NEAR			; UIceTexture::Init, COMDAT
; _this$ = ecx

; 4694 : 	// Init base class.
; 4695 : 	UFractalTexture::Init( InUSize, InVSize );

  00000	8b 44 24 08	 mov	 eax, DWORD PTR _InVSize$[esp-4]
  00004	53		 push	 ebx
  00005	55		 push	 ebp
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx
  0000a	8b 4c 24 14	 mov	 ecx, DWORD PTR _InUSize$[esp+12]
  0000e	50		 push	 eax
  0000f	51		 push	 ecx
  00010	8b cf		 mov	 ecx, edi
  00012	e8 00 00 00 00	 call	 ?Init@UFractalTexture@@UAEXHH@Z ; UFractalTexture::Init

; 4696 : 
; 4697 : 	UDisplace=0;
; 4698 : 	VDisplace=0;
; 4699 : 
; 4700 : 	HorizPanSpeed = 128;
; 4701 : 	VertPanSpeed  = 128;
; 4702 : 
; 4703 : 	PanningStyle = SLIDE_Linear;
; 4704 : 	Frequency    = 11;
; 4705 : 	Amplitude    = 44;
; 4706 : 
; 4707 : 	MoveIce=1;  // Move around the ICE if 1, TEXTURE if 0.

  00017	8b 8f f0 00 00
	00		 mov	 ecx, DWORD PTR [edi+240]
  0001d	33 db		 xor	 ebx, ebx
  0001f	83 c9 01	 or	 ecx, 1
  00022	b0 80		 mov	 al, 128			; 00000080H
  00024	89 8f f0 00 00
	00		 mov	 DWORD PTR [edi+240], ecx

; 4708 : 
; 4709 : 	// Create a dummy palette.
; 4710 : 	Palette = new( GetOuter() )UPalette;

  0002a	53		 push	 ebx
  0002b	8d 4c 24 1c	 lea	 ecx, DWORD PTR $T136456[esp+16]
  0002f	89 9f f8 00 00
	00		 mov	 DWORD PTR [edi+248], ebx
  00035	89 9f fc 00 00
	00		 mov	 DWORD PTR [edi+252], ebx
  0003b	88 87 ea 00 00
	00		 mov	 BYTE PTR [edi+234], al
  00041	88 87 eb 00 00
	00		 mov	 BYTE PTR [edi+235], al
  00047	88 9f e8 00 00
	00		 mov	 BYTE PTR [edi+232], bl
  0004d	c6 87 ec 00 00
	00 0b		 mov	 BYTE PTR [edi+236], 11	; 0000000bH
  00054	c6 87 ed 00 00
	00 2c		 mov	 BYTE PTR [edi+237], 44	; 0000002cH
  0005b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0FName@@QAE@W4EName@@@Z
  00061	8b cf		 mov	 ecx, edi
  00063	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetOuter@UObject@@QBEPAV1@XZ
  00069	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR __imp_?GError@@3PAVFOutputDeviceError@@A
  0006f	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00071	8b 54 24 18	 mov	 edx, DWORD PTR $T136456[esp+12]
  00075	53		 push	 ebx
  00076	51		 push	 ecx
  00077	53		 push	 ebx
  00078	53		 push	 ebx
  00079	52		 push	 edx
  0007a	50		 push	 eax
  0007b	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?PrivateStaticClass@UPalette@@0VUClass@@A
  00080	50		 push	 eax
  00081	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?StaticAllocateObject@UObject@@SAPAV1@PAVUClass@@PAV1@VFName@@K1PAVFOutputDevice@@1@Z
  00087	8b f0		 mov	 esi, eax
  00089	83 c4 1c	 add	 esp, 28			; 0000001cH
  0008c	3b f3		 cmp	 esi, ebx
  0008e	74 10		 je	 SHORT $L136443
  00090	8b ce		 mov	 ecx, esi
  00092	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0UPalette@@QAE@XZ
  00098	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_SUPalette@@6B@ ; UPalette::`local vftable'
  0009e	eb 02		 jmp	 SHORT $L136444
$L136443:
  000a0	33 f6		 xor	 esi, esi
$L136444:
  000a2	89 77 2c	 mov	 DWORD PTR [edi+44], esi
$L125358:

; 4711 : 	for( INT i=0; i<256; i++ )
; 4712 : 		new(Palette->Colors)FColor(i,i,i);

  000a5	8b 77 2c	 mov	 esi, DWORD PTR [edi+44]
  000a8	8b 6e 2c	 mov	 ebp, DWORD PTR [esi+44]
  000ab	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  000ae	83 c6 28	 add	 esi, 40			; 00000028H
  000b1	8d 4d 01	 lea	 ecx, DWORD PTR [ebp+1]
  000b4	3b c8		 cmp	 ecx, eax
  000b6	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  000b9	7e 1d		 jle	 SHORT $L136473
  000bb	8d 04 49	 lea	 eax, DWORD PTR [ecx+ecx*2]
  000be	99		 cdq
  000bf	83 e2 07	 and	 edx, 7
  000c2	03 c2		 add	 eax, edx
  000c4	c1 f8 03	 sar	 eax, 3
  000c7	8d 4c 08 20	 lea	 ecx, DWORD PTR [eax+ecx+32]
  000cb	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  000ce	6a 04		 push	 4
  000d0	8b ce		 mov	 ecx, esi
  000d2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Realloc@FArray@@IAEXH@Z
$L136473:
  000d8	8b 16		 mov	 edx, DWORD PTR [esi]
  000da	8d 04 aa	 lea	 eax, DWORD PTR [edx+ebp*4]
  000dd	85 c0		 test	 eax, eax
  000df	74 08		 je	 SHORT $L125359
  000e1	88 18		 mov	 BYTE PTR [eax], bl
  000e3	88 58 01	 mov	 BYTE PTR [eax+1], bl
  000e6	88 58 02	 mov	 BYTE PTR [eax+2], bl
$L125359:
  000e9	43		 inc	 ebx
  000ea	81 fb 00 01 00
	00		 cmp	 ebx, 256		; 00000100H
  000f0	7c b3		 jl	 SHORT $L125358

; 4713 : 	MipZero = Palette->Colors(128);

  000f2	8b 47 2c	 mov	 eax, DWORD PTR [edi+44]
  000f5	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  000f8	8b 91 00 02 00
	00		 mov	 edx, DWORD PTR [ecx+512]
  000fe	89 57 44	 mov	 DWORD PTR [edi+68], edx
  00101	5f		 pop	 edi
  00102	5e		 pop	 esi
  00103	5d		 pop	 ebp
  00104	5b		 pop	 ebx

; 4714 : }

  00105	c2 08 00	 ret	 8
?Init@UIceTexture@@UAEXHH@Z ENDP			; UIceTexture::Init
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?Clear@UIceTexture@@UAEXK@Z
_TEXT	SEGMENT
_ClearFlags$ = 8
?Clear@UIceTexture@@UAEXK@Z PROC NEAR			; UIceTexture::Clear, COMDAT
; _this$ = ecx

; 4718 : 	// Init to zero.
; 4719 : 	UFractalTexture::Clear( ClearFlags );

  00000	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_?Clear@UTexture@@UAEXK@Z
?Clear@UIceTexture@@UAEXK@Z ENDP			; UIceTexture::Clear
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?ConstantTimeTick@UIceTexture@@UAEXXZ
_TEXT	SEGMENT
$T136512 = -132
$T136518 = -136
$T136524 = -136
$T136530 = -136
_I$136535 = -136
_I$136538 = -132
_I$136541 = -132
_I$136544 = -132
_Info$125377 = -128
_Info$125380 = -128
?ConstantTimeTick@UIceTexture@@UAEXXZ PROC NEAR		; UIceTexture::ConstantTimeTick, COMDAT
; _this$ = ecx

; 4723 : {

  00000	81 ec 88 00 00
	00		 sub	 esp, 136		; 00000088H
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx

; 4724 : 	// Make sure referred textures are updated/loaded also.
; 4725 : 	if( SourceTexture )

  00009	8b 8e e4 00 00
	00		 mov	 ecx, DWORD PTR [esi+228]
  0000f	85 c9		 test	 ecx, ecx
  00011	74 28		 je	 SHORT $L125378

; 4726 : 	{
; 4727 : 		FTextureInfo Info; 
; 4728 : 		if( SourceTexture != this ) 

  00013	3b ce		 cmp	 ecx, esi
  00015	74 24		 je	 SHORT $L125378

; 4729 : 		{
; 4730 : 			SourceTexture->Lock( Info, LastUpdateTime, 0, NULL );

  00017	8b 56 50	 mov	 edx, DWORD PTR [esi+80]
  0001a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0001c	6a 00		 push	 0
  0001e	6a 00		 push	 0
  00020	52		 push	 edx
  00021	8b 56 4c	 mov	 edx, DWORD PTR [esi+76]
  00024	52		 push	 edx
  00025	8d 54 24 1c	 lea	 edx, DWORD PTR _Info$125377[esp+156]
  00029	ff 50 48	 call	 DWORD PTR [eax+72]

; 4731 : 			SourceTexture->Unlock( Info );

  0002c	8b 8e e4 00 00
	00		 mov	 ecx, DWORD PTR [esi+228]
  00032	8b 01		 mov	 eax, DWORD PTR [ecx]
  00034	8d 54 24 0c	 lea	 edx, DWORD PTR _Info$125377[esp+140]
  00038	ff 50 4c	 call	 DWORD PTR [eax+76]
$L125378:

; 4732 : 			//SourceTexture->Update(LastUpdateTime);
; 4733 : 		}
; 4734 : 	}
; 4735 : 	if( GlassTexture )

  0003b	8b 8e e0 00 00
	00		 mov	 ecx, DWORD PTR [esi+224]
  00041	85 c9		 test	 ecx, ecx
  00043	74 28		 je	 SHORT $L125381

; 4736 : 	{
; 4737 : 		FTextureInfo Info; 
; 4738 : 		if( GlassTexture != this ) 

  00045	3b ce		 cmp	 ecx, esi
  00047	74 24		 je	 SHORT $L125381

; 4739 : 		{
; 4740 : 			GlassTexture->Lock( Info, LastUpdateTime, 0, NULL );

  00049	8b 56 50	 mov	 edx, DWORD PTR [esi+80]
  0004c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0004e	6a 00		 push	 0
  00050	6a 00		 push	 0
  00052	52		 push	 edx
  00053	8b 56 4c	 mov	 edx, DWORD PTR [esi+76]
  00056	52		 push	 edx
  00057	8d 54 24 1c	 lea	 edx, DWORD PTR _Info$125380[esp+156]
  0005b	ff 50 48	 call	 DWORD PTR [eax+72]

; 4741 : 			GlassTexture->Unlock( Info );

  0005e	8b 8e e0 00 00
	00		 mov	 ecx, DWORD PTR [esi+224]
  00064	8b 01		 mov	 eax, DWORD PTR [ecx]
  00066	8d 54 24 0c	 lea	 edx, DWORD PTR _Info$125380[esp+140]
  0006a	ff 50 4c	 call	 DWORD PTR [eax+76]
$L125381:

; 4742 : 			//GlassTexture->Update(LastUpdateTime);
; 4743 : 		}
; 4744 : 	}
; 4745 : 	// Simulated 'deltaseconds' for 120 fps.
; 4746 : 	RenderIce(1.0f/120.0f );

  0006d	8b 86 e0 00 00
	00		 mov	 eax, DWORD PTR [esi+224]
  00073	85 c0		 test	 eax, eax
  00075	0f 84 c9 00 00
	00		 je	 $L136547
  0007b	8b 86 e4 00 00
	00		 mov	 eax, DWORD PTR [esi+228]
  00081	85 c0		 test	 eax, eax
  00083	0f 84 bb 00 00
	00		 je	 $L136547
  00089	68 89 88 08 3c	 push	 1007192201		; 3c088889H
  0008e	8b ce		 mov	 ecx, esi
  00090	e8 00 00 00 00	 call	 ?MoveIcePosition@UIceTexture@@AAEXM@Z ; UIceTexture::MoveIcePosition
  00095	8b 8e 00 01 00
	00		 mov	 ecx, DWORD PTR [esi+256]
  0009b	89 4c 24 08	 mov	 DWORD PTR $T136512[esp+140], ecx
  0009f	d9 44 24 08	 fld	 DWORD PTR $T136512[esp+140]
  000a3	db 5c 24 04	 fistp	 DWORD PTR _I$136535[esp+140]
  000a7	8b 54 24 04	 mov	 edx, DWORD PTR _I$136535[esp+140]
  000ab	3b 96 0c 01 00
	00		 cmp	 edx, DWORD PTR [esi+268]
  000b1	75 28		 jne	 SHORT $L136548
  000b3	8b 86 04 01 00
	00		 mov	 eax, DWORD PTR [esi+260]
  000b9	89 44 24 04	 mov	 DWORD PTR $T136518[esp+140], eax
  000bd	d9 44 24 04	 fld	 DWORD PTR $T136518[esp+140]
  000c1	db 5c 24 08	 fistp	 DWORD PTR _I$136538[esp+140]
  000c5	8b 4c 24 08	 mov	 ecx, DWORD PTR _I$136538[esp+140]
  000c9	3b 8e 10 01 00
	00		 cmp	 ecx, DWORD PTR [esi+272]
  000cf	75 0a		 jne	 SHORT $L136548
  000d1	8b 86 20 01 00
	00		 mov	 eax, DWORD PTR [esi+288]
  000d7	85 c0		 test	 eax, eax
  000d9	74 69		 je	 SHORT $L136547
$L136548:
  000db	8b 96 00 01 00
	00		 mov	 edx, DWORD PTR [esi+256]
  000e1	89 54 24 04	 mov	 DWORD PTR $T136524[esp+140], edx
  000e5	d9 44 24 04	 fld	 DWORD PTR $T136524[esp+140]
  000e9	db 5c 24 08	 fistp	 DWORD PTR _I$136541[esp+140]
  000ed	8b 44 24 08	 mov	 eax, DWORD PTR _I$136541[esp+140]
  000f1	8b 8e 04 01 00
	00		 mov	 ecx, DWORD PTR [esi+260]
  000f7	89 86 0c 01 00
	00		 mov	 DWORD PTR [esi+268], eax
  000fd	89 4c 24 04	 mov	 DWORD PTR $T136530[esp+140], ecx
  00101	d9 44 24 04	 fld	 DWORD PTR $T136530[esp+140]
  00105	db 5c 24 08	 fistp	 DWORD PTR _I$136544[esp+140]
  00109	f6 86 f0 00 00
	00 01		 test	 BYTE PTR [esi+240], 1
  00110	8b 54 24 08	 mov	 edx, DWORD PTR _I$136544[esp+140]
  00114	89 96 10 01 00
	00		 mov	 DWORD PTR [esi+272], edx
  0011a	8b ce		 mov	 ecx, esi
  0011c	75 17		 jne	 SHORT $L136549
  0011e	e8 00 00 00 00	 call	 ?BlitIceTex@UIceTexture@@AAEXXZ ; UIceTexture::BlitIceTex
  00123	c7 86 20 01 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+288], 0
  0012d	5e		 pop	 esi

; 4747 : }

  0012e	81 c4 88 00 00
	00		 add	 esp, 136		; 00000088H
  00134	c3		 ret	 0

; 4742 : 			//GlassTexture->Update(LastUpdateTime);
; 4743 : 		}
; 4744 : 	}
; 4745 : 	// Simulated 'deltaseconds' for 120 fps.
; 4746 : 	RenderIce(1.0f/120.0f );

$L136549:
  00135	e8 00 00 00 00	 call	 ?BlitTexIce@UIceTexture@@AAEXXZ ; UIceTexture::BlitTexIce
  0013a	c7 86 20 01 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+288], 0
$L136547:
  00144	5e		 pop	 esi

; 4747 : }

  00145	81 c4 88 00 00
	00		 add	 esp, 136		; 00000088H
  0014b	c3		 ret	 0
?ConstantTimeTick@UIceTexture@@UAEXXZ ENDP		; UIceTexture::ConstantTimeTick
_TEXT	ENDS
EXTRN	__imp_?Tick@UTexture@@UAIXM@Z:NEAR
; Function compile flags: /Ogty
;	COMDAT ?Tick@UIceTexture@@UAIXM@Z
_TEXT	SEGMENT
_DeltaSeconds$ = 8
_Info$125388 = -128
_Info$125391 = -128
$T136575 = -132
$T136581 = -136
$T136587 = -136
$T136593 = -136
_I$136598 = -136
_I$136606 = -132
_I$136609 = -132
_I$136612 = -132
?Tick@UIceTexture@@UAIXM@Z PROC NEAR			; UIceTexture::Tick, COMDAT
; _this$ = ecx

; 4754 : {

  00000	81 ec 88 00 00
	00		 sub	 esp, 136		; 00000088H
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx

; 4755 : 	// Revert to parent Tick() if panning stile is 'FrameSynced'. 
; 4756 : 	if( TimeMethod == 0 ) 

  00009	8a 86 e9 00 00
	00		 mov	 al, BYTE PTR [esi+233]
  0000f	84 c0		 test	 al, al
  00011	75 18		 jne	 SHORT $L125386

; 4757 : 	{	
; 4758 : 		// Call parent, which might call UIceTexture::ConstantTimeTick 
; 4759 : 		UFractalTexture::Tick(DeltaSeconds); 

  00013	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR _DeltaSeconds$[esp+136]
  0001a	50		 push	 eax
  0001b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Tick@UTexture@@UAIXM@Z
  00021	5e		 pop	 esi

; 4783 : }

  00022	81 c4 88 00 00
	00		 add	 esp, 136		; 00000088H
  00028	c2 04 00	 ret	 4
$L125386:

; 4760 : 		return;
; 4761 : 	}
; 4762 : 
; 4763 : 	// Make sure referred textures are updated/loaded also.
; 4764 : 	if( SourceTexture )

  0002b	8b 8e e4 00 00
	00		 mov	 ecx, DWORD PTR [esi+228]
  00031	85 c9		 test	 ecx, ecx
  00033	74 24		 je	 SHORT $L125389

; 4765 : 	{
; 4766 : 		FTextureInfo Info; 
; 4767 : 		if( SourceTexture != this ) 

  00035	3b ce		 cmp	 ecx, esi
  00037	74 20		 je	 SHORT $L125389

; 4768 : 		{
; 4769 : 			SourceTexture->Lock( Info, 0.0, 0, NULL );

  00039	8b 01		 mov	 eax, DWORD PTR [ecx]
  0003b	6a 00		 push	 0
  0003d	6a 00		 push	 0
  0003f	6a 00		 push	 0
  00041	6a 00		 push	 0
  00043	8d 54 24 1c	 lea	 edx, DWORD PTR _Info$125388[esp+156]
  00047	ff 50 48	 call	 DWORD PTR [eax+72]

; 4770 : 			SourceTexture->Unlock( Info );

  0004a	8b 8e e4 00 00
	00		 mov	 ecx, DWORD PTR [esi+228]
  00050	8b 01		 mov	 eax, DWORD PTR [ecx]
  00052	8d 54 24 0c	 lea	 edx, DWORD PTR _Info$125388[esp+140]
  00056	ff 50 4c	 call	 DWORD PTR [eax+76]
$L125389:

; 4771 : 		}
; 4772 : 	}
; 4773 : 	if( GlassTexture )

  00059	8b 8e e0 00 00
	00		 mov	 ecx, DWORD PTR [esi+224]
  0005f	85 c9		 test	 ecx, ecx
  00061	74 24		 je	 SHORT $L125392

; 4774 : 	{
; 4775 : 		FTextureInfo Info; 
; 4776 : 		if( GlassTexture != this )

  00063	3b ce		 cmp	 ecx, esi
  00065	74 20		 je	 SHORT $L125392

; 4777 : 		{
; 4778 : 			GlassTexture->Lock( Info, 0.0, 0, NULL );

  00067	8b 01		 mov	 eax, DWORD PTR [ecx]
  00069	6a 00		 push	 0
  0006b	6a 00		 push	 0
  0006d	6a 00		 push	 0
  0006f	6a 00		 push	 0
  00071	8d 54 24 1c	 lea	 edx, DWORD PTR _Info$125391[esp+156]
  00075	ff 50 48	 call	 DWORD PTR [eax+72]

; 4779 : 			GlassTexture->Unlock( Info );

  00078	8b 8e e0 00 00
	00		 mov	 ecx, DWORD PTR [esi+224]
  0007e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00080	8d 54 24 0c	 lea	 edx, DWORD PTR _Info$125391[esp+140]
  00084	ff 50 4c	 call	 DWORD PTR [eax+76]
$L125392:

; 4780 : 		}
; 4781 : 	}
; 4782 : 	RenderIce(DeltaSeconds);	

  00087	8b 86 e0 00 00
	00		 mov	 eax, DWORD PTR [esi+224]
  0008d	85 c0		 test	 eax, eax
  0008f	0f 84 ce 00 00
	00		 je	 $L136601
  00095	8b 86 e4 00 00
	00		 mov	 eax, DWORD PTR [esi+228]
  0009b	85 c0		 test	 eax, eax
  0009d	0f 84 c0 00 00
	00		 je	 $L136601
  000a3	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR _DeltaSeconds$[esp+136]
  000aa	51		 push	 ecx
  000ab	8b ce		 mov	 ecx, esi
  000ad	e8 00 00 00 00	 call	 ?MoveIcePosition@UIceTexture@@AAEXM@Z ; UIceTexture::MoveIcePosition
  000b2	8b 96 00 01 00
	00		 mov	 edx, DWORD PTR [esi+256]
  000b8	89 54 24 08	 mov	 DWORD PTR $T136575[esp+140], edx
  000bc	d9 44 24 08	 fld	 DWORD PTR $T136575[esp+140]
  000c0	db 5c 24 04	 fistp	 DWORD PTR _I$136598[esp+140]
  000c4	8b 44 24 04	 mov	 eax, DWORD PTR _I$136598[esp+140]
  000c8	3b 86 0c 01 00
	00		 cmp	 eax, DWORD PTR [esi+268]
  000ce	75 28		 jne	 SHORT $L136602
  000d0	8b 8e 04 01 00
	00		 mov	 ecx, DWORD PTR [esi+260]
  000d6	89 4c 24 04	 mov	 DWORD PTR $T136581[esp+140], ecx
  000da	d9 44 24 04	 fld	 DWORD PTR $T136581[esp+140]
  000de	db 5c 24 08	 fistp	 DWORD PTR _I$136606[esp+140]
  000e2	8b 54 24 08	 mov	 edx, DWORD PTR _I$136606[esp+140]
  000e6	3b 96 10 01 00
	00		 cmp	 edx, DWORD PTR [esi+272]
  000ec	75 0a		 jne	 SHORT $L136602
  000ee	8b 86 20 01 00
	00		 mov	 eax, DWORD PTR [esi+288]
  000f4	85 c0		 test	 eax, eax
  000f6	74 6b		 je	 SHORT $L136601
$L136602:
  000f8	8b 86 00 01 00
	00		 mov	 eax, DWORD PTR [esi+256]
  000fe	89 44 24 04	 mov	 DWORD PTR $T136587[esp+140], eax
  00102	d9 44 24 04	 fld	 DWORD PTR $T136587[esp+140]
  00106	db 5c 24 08	 fistp	 DWORD PTR _I$136609[esp+140]
  0010a	8b 4c 24 08	 mov	 ecx, DWORD PTR _I$136609[esp+140]
  0010e	8b 96 04 01 00
	00		 mov	 edx, DWORD PTR [esi+260]
  00114	89 8e 0c 01 00
	00		 mov	 DWORD PTR [esi+268], ecx
  0011a	89 54 24 04	 mov	 DWORD PTR $T136593[esp+140], edx
  0011e	d9 44 24 04	 fld	 DWORD PTR $T136593[esp+140]
  00122	db 5c 24 08	 fistp	 DWORD PTR _I$136612[esp+140]
  00126	8b 44 24 08	 mov	 eax, DWORD PTR _I$136612[esp+140]
  0012a	89 86 10 01 00
	00		 mov	 DWORD PTR [esi+272], eax
  00130	f6 86 f0 00 00
	00 01		 test	 BYTE PTR [esi+240], 1
  00137	8b ce		 mov	 ecx, esi
  00139	75 19		 jne	 SHORT $L136603
  0013b	e8 00 00 00 00	 call	 ?BlitIceTex@UIceTexture@@AAEXXZ ; UIceTexture::BlitIceTex
  00140	c7 86 20 01 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+288], 0
  0014a	5e		 pop	 esi

; 4783 : }

  0014b	81 c4 88 00 00
	00		 add	 esp, 136		; 00000088H
  00151	c2 04 00	 ret	 4

; 4780 : 		}
; 4781 : 	}
; 4782 : 	RenderIce(DeltaSeconds);	

$L136603:
  00154	e8 00 00 00 00	 call	 ?BlitTexIce@UIceTexture@@AAEXXZ ; UIceTexture::BlitTexIce
  00159	c7 86 20 01 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+288], 0
$L136601:
  00163	5e		 pop	 esi

; 4783 : }

  00164	81 c4 88 00 00
	00		 add	 esp, 136		; 00000088H
  0016a	c2 04 00	 ret	 4
?Tick@UIceTexture@@UAIXM@Z ENDP				; UIceTexture::Tick
_TEXT	ENDS
PUBLIC	?RenderIce@UIceTexture@@AAEXM@Z			; UIceTexture::RenderIce
; Function compile flags: /Ogty
;	COMDAT ?RenderIce@UIceTexture@@AAEXM@Z
_TEXT	SEGMENT
_DeltaTime$ = 8
_I$136619 = -4
$T136621 = 8
_I$136625 = -4
$T136627 = 8
_I$136631 = -4
$T136633 = 8
_I$136637 = -4
$T136639 = 8
?RenderIce@UIceTexture@@AAEXM@Z PROC NEAR		; UIceTexture::RenderIce, COMDAT
; _this$ = ecx

; 4786 : {

  00000	51		 push	 ecx
  00001	56		 push	 esi
  00002	8b f1		 mov	 esi, ecx

; 4787 :     // Safety & update checks. 
; 4788 : 	if( (GlassTexture == NULL) || (SourceTexture == NULL) ) return;

  00004	8b 86 e0 00 00
	00		 mov	 eax, DWORD PTR [esi+224]
  0000a	85 c0		 test	 eax, eax
  0000c	0f 84 c4 00 00
	00		 je	 $L125398
  00012	8b 86 e4 00 00
	00		 mov	 eax, DWORD PTR [esi+228]
  00018	85 c0		 test	 eax, eax
  0001a	0f 84 b6 00 00
	00		 je	 $L125398

; 4789 : 
; 4790 : 	MoveIcePosition(DeltaTime);

  00020	8b 44 24 0c	 mov	 eax, DWORD PTR _DeltaTime$[esp+4]
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ?MoveIcePosition@UIceTexture@@AAEXM@Z ; UIceTexture::MoveIcePosition

; 4791 : 
; 4792 : 	// Skip update if last position == new position.
; 4793 : 	if( (appRound(UPosition) == OldUDisp) 
; 4794 : 		&& (appRound(VPosition) == OldVDisp)
; 4795 : 		&& (! ForceRefresh) ) 

  0002a	8b 8e 00 01 00
	00		 mov	 ecx, DWORD PTR [esi+256]
  00030	89 4c 24 0c	 mov	 DWORD PTR $T136621[esp+4], ecx
  00034	d9 44 24 0c	 fld	 DWORD PTR $T136621[esp+4]
  00038	db 5c 24 04	 fistp	 DWORD PTR _I$136619[esp+8]
  0003c	8b 54 24 04	 mov	 edx, DWORD PTR _I$136619[esp+8]
  00040	3b 96 0c 01 00
	00		 cmp	 edx, DWORD PTR [esi+268]
  00046	75 28		 jne	 SHORT $L125399
  00048	8b 86 04 01 00
	00		 mov	 eax, DWORD PTR [esi+260]
  0004e	89 44 24 0c	 mov	 DWORD PTR $T136627[esp+4], eax
  00052	d9 44 24 0c	 fld	 DWORD PTR $T136627[esp+4]
  00056	db 5c 24 04	 fistp	 DWORD PTR _I$136625[esp+8]
  0005a	8b 4c 24 04	 mov	 ecx, DWORD PTR _I$136625[esp+8]
  0005e	3b 8e 10 01 00
	00		 cmp	 ecx, DWORD PTR [esi+272]
  00064	75 0a		 jne	 SHORT $L125399
  00066	8b 86 20 01 00
	00		 mov	 eax, DWORD PTR [esi+288]
  0006c	85 c0		 test	 eax, eax
  0006e	74 66		 je	 SHORT $L125398
$L125399:

; 4796 : 		return;
; 4797 : 
; 4798 : 	OldUDisp = appRound( UPosition );

  00070	8b 96 00 01 00
	00		 mov	 edx, DWORD PTR [esi+256]
  00076	89 54 24 0c	 mov	 DWORD PTR $T136633[esp+4], edx
  0007a	d9 44 24 0c	 fld	 DWORD PTR $T136633[esp+4]
  0007e	db 5c 24 04	 fistp	 DWORD PTR _I$136631[esp+8]
  00082	8b 44 24 04	 mov	 eax, DWORD PTR _I$136631[esp+8]

; 4799 : 	OldVDisp = appRound( VPosition );

  00086	8b 8e 04 01 00
	00		 mov	 ecx, DWORD PTR [esi+260]
  0008c	89 86 0c 01 00
	00		 mov	 DWORD PTR [esi+268], eax
  00092	89 4c 24 0c	 mov	 DWORD PTR $T136639[esp+4], ecx
  00096	d9 44 24 0c	 fld	 DWORD PTR $T136639[esp+4]
  0009a	db 5c 24 04	 fistp	 DWORD PTR _I$136637[esp+8]

; 4800 : 
; 4801 : 	// Actual redrawing.
; 4802 : 	if  (! MoveIce ) BlitIceTex();

  0009e	f6 86 f0 00 00
	00 01		 test	 BYTE PTR [esi+240], 1
  000a5	8b 54 24 04	 mov	 edx, DWORD PTR _I$136637[esp+8]
  000a9	89 96 10 01 00
	00		 mov	 DWORD PTR [esi+272], edx
  000af	8b ce		 mov	 ecx, esi
  000b1	75 14		 jne	 SHORT $L125400
  000b3	e8 00 00 00 00	 call	 ?BlitIceTex@UIceTexture@@AAEXXZ ; UIceTexture::BlitIceTex

; 4804 : 
; 4805 : 	ForceRefresh=0;

  000b8	c7 86 20 01 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+288], 0
  000c2	5e		 pop	 esi

; 4806 : }

  000c3	59		 pop	 ecx
  000c4	c2 04 00	 ret	 4
$L125400:

; 4803 : 		 else        BlitTexIce();

  000c7	e8 00 00 00 00	 call	 ?BlitTexIce@UIceTexture@@AAEXXZ ; UIceTexture::BlitTexIce

; 4804 : 
; 4805 : 	ForceRefresh=0;

  000cc	c7 86 20 01 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+288], 0
$L125398:
  000d6	5e		 pop	 esi

; 4806 : }

  000d7	59		 pop	 ecx
  000d8	c2 04 00	 ret	 4
?RenderIce@UIceTexture@@AAEXM@Z ENDP			; UIceTexture::RenderIce
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?MousePosition@UIceTexture@@UAEXKMM@Z
_TEXT	SEGMENT
_Buttons$ = 8
_X$ = 12
_Y$ = 16
?MousePosition@UIceTexture@@UAEXKMM@Z PROC NEAR		; UIceTexture::MousePosition, COMDAT
; _this$ = ecx

; 4810 : 	static FLOAT  MouseLastU=0.0f;
; 4811 : 	static FLOAT  MouseLastV=0.0f;
; 4812 : 
; 4813 : 	if( Buttons & MOUSE_Left )

  00000	f6 44 24 04 01	 test	 BYTE PTR _Buttons$[esp-4], 1
  00005	74 44		 je	 SHORT $L125412

; 4814 : 	{ 
; 4815 : 		UDisplace +=(MouseLastU - X);

  00007	d9 05 00 00 00
	00		 fld	 DWORD PTR ?MouseLastU@?1??MousePosition@UIceTexture@@UAEXKMM@Z@4MA
  0000d	d8 64 24 08	 fsub	 DWORD PTR _X$[esp-4]
  00011	d8 81 f8 00 00
	00		 fadd	 DWORD PTR [ecx+248]
  00017	d9 99 f8 00 00
	00		 fstp	 DWORD PTR [ecx+248]

; 4816 : 		VDisplace +=(MouseLastV - Y);
; 4817 : 
; 4818 : 		UPosition = UDisplace;

  0001d	8b 81 f8 00 00
	00		 mov	 eax, DWORD PTR [ecx+248]
  00023	d9 05 00 00 00
	00		 fld	 DWORD PTR ?MouseLastV@?1??MousePosition@UIceTexture@@UAEXKMM@Z@4MA
  00029	89 81 00 01 00
	00		 mov	 DWORD PTR [ecx+256], eax
  0002f	d8 64 24 0c	 fsub	 DWORD PTR _Y$[esp-4]
  00033	d8 81 fc 00 00
	00		 fadd	 DWORD PTR [ecx+252]
  00039	d9 99 fc 00 00
	00		 fstp	 DWORD PTR [ecx+252]

; 4819 : 		VPosition = VDisplace;

  0003f	8b 91 fc 00 00
	00		 mov	 edx, DWORD PTR [ecx+252]
  00045	89 91 04 01 00
	00		 mov	 DWORD PTR [ecx+260], edx
$L125412:

; 4820 : 	}
; 4821 : 
; 4822 : 	MouseLastU = X;

  0004b	8b 44 24 08	 mov	 eax, DWORD PTR _X$[esp-4]

; 4823 : 	MouseLastV = Y;

  0004f	8b 4c 24 0c	 mov	 ecx, DWORD PTR _Y$[esp-4]
  00053	a3 00 00 00 00	 mov	 DWORD PTR ?MouseLastU@?1??MousePosition@UIceTexture@@UAEXKMM@Z@4MA, eax
  00058	89 0d 00 00 00
	00		 mov	 DWORD PTR ?MouseLastV@?1??MousePosition@UIceTexture@@UAEXKMM@Z@4MA, ecx

; 4824 : }

  0005e	c2 0c 00	 ret	 12			; 0000000cH
?MousePosition@UIceTexture@@UAEXKMM@Z ENDP		; UIceTexture::MousePosition
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?Click@UIceTexture@@UAEXKMM@Z
_TEXT	SEGMENT
?Click@UIceTexture@@UAEXKMM@Z PROC NEAR			; UIceTexture::Click, COMDAT
; _this$ = ecx

; 4828 : }

  00000	c2 0c 00	 ret	 12			; 0000000cH
?Click@UIceTexture@@UAEXKMM@Z ENDP			; UIceTexture::Click
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?Destroy@UIceTexture@@UAEXXZ
_TEXT	SEGMENT
?Destroy@UIceTexture@@UAEXXZ PROC NEAR			; UIceTexture::Destroy, COMDAT
; _this$ = ecx

; 4832 : 	// Must call base class' destroy.
; 4833 : 	Super::Destroy();

  00000	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_?Destroy@UTexture@@UAEXXZ
?Destroy@UIceTexture@@UAEXXZ ENDP			; UIceTexture::Destroy
_TEXT	ENDS
PUBLIC	??_C@_1BI@MCDB@?$AAU?$AAI?$AAc?$AAe?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@ ; `string'
PUBLIC	?InternalConstructor@UIceTexture@@SAXPAX@Z	; UIceTexture::InternalConstructor
;	COMDAT ??_C@_1BI@MCDB@?$AAU?$AAI?$AAc?$AAe?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@
_DATA	SEGMENT
??_C@_1BI@MCDB@?$AAU?$AAI?$AAc?$AAe?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@ DB 'U'
	DB	00H, 'I', 00H, 'c', 00H, 'e', 00H, 'T', 00H, 'e', 00H, 'x', 00H
	DB	't', 00H, 'u', 00H, 'r', 00H, 'e', 00H, 00H, 00H ; `string'
; Function compile flags: /Ogty
_DATA	ENDS
;	COMDAT _$E233
_TEXT	SEGMENT
_$E233	PROC NEAR					; COMDAT
  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?StaticConstructor@UObject@@QAEXXZ
  00005	53		 push	 ebx
  00006	55		 push	 ebp
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	83 ec 10	 sub	 esp, 16			; 00000010H
  0000c	8b ec		 mov	 ebp, esp
  0000e	68 00 00 00 00	 push	 OFFSET FLAT:?InternalConstructor@UIceTexture@@SAXPAX@Z ; UIceTexture::InternalConstructor
  00013	68 04 40 08 04	 push	 67649540		; 04084004H
  00018	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1O@KHFL@?$AAS?$AAy?$AAs?$AAt?$AAe?$AAm?$AA?$AA@ ; `string'
  0001d	89 45 00	 mov	 DWORD PTR [ebp], eax
  00020	68 00 00 00 00	 push	 OFFSET FLAT:_GPackage
  00025	33 c9		 xor	 ecx, ecx
  00027	89 4d 04	 mov	 DWORD PTR [ebp+4], ecx
  0002a	68 02 00 00 00	 push	 OFFSET FLAT:??_C@_1BI@MCDB@?$AAU?$AAI?$AAc?$AAe?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@+2
  0002f	83 ec 10	 sub	 esp, 16			; 00000010H
  00032	33 d2		 xor	 edx, edx
  00034	89 55 08	 mov	 DWORD PTR [ebp+8], edx
  00037	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR __imp_?PrivateStaticClass@UObject@@0VUClass@@A
  0003d	8b cc		 mov	 ecx, esp
  0003f	52		 push	 edx
  00040	33 f6		 xor	 esi, esi
  00042	89 75 0c	 mov	 DWORD PTR [ebp+12], esi
  00045	33 c0		 xor	 eax, eax
  00047	33 ff		 xor	 edi, edi
  00049	89 39		 mov	 DWORD PTR [ecx], edi
  0004b	68 00 00 00 00	 push	 OFFSET FLAT:?PrivateStaticClass@UFractalTexture@@0VUClass@@A ; UFractalTexture::PrivateStaticClass
  00050	33 db		 xor	 ebx, ebx
  00052	89 59 04	 mov	 DWORD PTR [ecx+4], ebx
  00055	50		 push	 eax
  00056	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00059	68 24 01 00 00	 push	 292			; 00000124H
  0005e	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  00061	50		 push	 eax
  00062	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?PrivateStaticClass@UIceTexture@@0VUClass@@A
  00067	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0UClass@@QAE@W4ENativeConstructor@@KKPAV0@1VFGuid@@PBG33KP6AXPAX@ZP8UObject@@AEXXZ@Z
  0006d	68 00 00 00 00	 push	 OFFSET FLAT:_$E230
  00072	e8 00 00 00 00	 call	 _atexit
  00077	83 c4 04	 add	 esp, 4
  0007a	5f		 pop	 edi
  0007b	5e		 pop	 esi
  0007c	5d		 pop	 ebp
  0007d	5b		 pop	 ebx
  0007e	c3		 ret	 0
_$E233	ENDP
_TEXT	ENDS
_BSS	SEGMENT
	ALIGN	4

_$S231	DB	01H DUP (?)
; Function compile flags: /Ogty
_BSS	ENDS
;	COMDAT _$E230
_TEXT	SEGMENT
_$E230	PROC NEAR					; COMDAT
  00000	8a 0d 00 00 00
	00		 mov	 cl, BYTE PTR _$S231
  00006	b0 01		 mov	 al, 1
  00008	84 c8		 test	 cl, al
  0000a	75 13		 jne	 SHORT $L125434
  0000c	0a c8		 or	 cl, al
  0000e	88 0d 00 00 00
	00		 mov	 BYTE PTR _$S231, cl
  00014	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?PrivateStaticClass@UIceTexture@@0VUClass@@A
  00019	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1UClass@@UAE@XZ
$L125434:
  0001f	c3		 ret	 0
_$E230	ENDP
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT _$E236
_TEXT	SEGMENT
_$E236	PROC NEAR					; COMDAT
  00000	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _autoclassUIceTexture, OFFSET FLAT:?PrivateStaticClass@UIceTexture@@0VUClass@@A ; UIceTexture::PrivateStaticClass
  0000a	c3		 ret	 0
_$E236	ENDP
_TEXT	ENDS
PUBLIC	??_H@YGXPAXIHP6EX0@Z@Z				; `vector constructor iterator'
; Function compile flags: /Ogty
;	COMDAT ??_H@YGXPAXIHP6EX0@Z@Z
_TEXT	SEGMENT
___t$ = 8
___s$ = 12
___n$ = 16
___f$ = 20
??_H@YGXPAXIHP6EX0@Z@Z PROC NEAR			; `vector constructor iterator', COMDAT
  00000	8b 44 24 0c	 mov	 eax, DWORD PTR ___n$[esp-4]
  00004	48		 dec	 eax
  00005	78 26		 js	 SHORT $L100113
  00007	53		 push	 ebx
  00008	8b 5c 24 14	 mov	 ebx, DWORD PTR ___f$[esp]
  0000c	55		 push	 ebp
  0000d	8b 6c 24 10	 mov	 ebp, DWORD PTR ___s$[esp+4]
  00011	56		 push	 esi
  00012	8b 74 24 10	 mov	 esi, DWORD PTR ___t$[esp+8]
  00016	57		 push	 edi
  00017	8d 78 01	 lea	 edi, DWORD PTR [eax+1]
  0001a	8d 9b 00 00 00
	00		 npad	 6
$L100112:
  00020	8b ce		 mov	 ecx, esi
  00022	ff d3		 call	 ebx
  00024	03 f5		 add	 esi, ebp
  00026	4f		 dec	 edi
  00027	75 f7		 jne	 SHORT $L100112
  00029	5f		 pop	 edi
  0002a	5e		 pop	 esi
  0002b	5d		 pop	 ebp
  0002c	5b		 pop	 ebx
$L100113:
  0002d	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIHP6EX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
EXTRN	__imp_??1UPalette@@UAE@XZ:NEAR
; Function compile flags: /Ogty
;	COMDAT ??_GUPalette@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_GUPalette@@UAEPAXI@Z PROC NEAR			; UPalette::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1UPalette@@UAE@XZ
  00009	f6 44 24 08 01	 test	 BYTE PTR ___flags$[esp], 1
  0000e	74 0d		 je	 SHORT $L136708
  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?GMalloc@@3PAVFMalloc@@A
  00015	8b 08		 mov	 ecx, DWORD PTR [eax]
  00017	8b 11		 mov	 edx, DWORD PTR [ecx]
  00019	56		 push	 esi
  0001a	ff 52 08	 call	 DWORD PTR [edx+8]
$L136708:
  0001d	8b c6		 mov	 eax, esi
  0001f	5e		 pop	 esi
  00020	c2 04 00	 ret	 4
??_GUPalette@@UAEPAXI@Z ENDP				; UPalette::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?CycleCount@@YAHXZ				; CycleCount
; Function compile flags: /Ogty
; File C:\duke4\Fire\Src\FractalPrivate.h
;	COMDAT ?CycleCount@@YAHXZ
_TEXT	SEGMENT
_OutCyc$ = -4
?CycleCount@@YAHXZ PROC NEAR				; CycleCount, COMDAT

; 48   : {

  00000	51		 push	 ecx

; 49   : #if ASM
; 50   :     INT OutCyc;
; 51   :     __asm
; 52   :    {
; 53   :         xor edx,edx

  00001	33 d2		 xor	 edx, edx

; 54   : 		xor eax,eax

  00003	33 c0		 xor	 eax, eax

; 55   :         //RDTSC;     // Moves Pentium+ time stamp register to EDX:EAX
; 56   :         _emit 0x0F;

  00005	0f		 DB	 15			; 0000000fH

; 57   :         _emit 0x31;

  00006	31		 DB	 49			; 00000031H

; 58   :         //
; 59   :         mov OutCyc,EAX //only low-order 32-bits needed

  00007	89 44 24 00	 mov	 DWORD PTR _OutCyc$[esp+4], eax

; 60   :     }
; 61   :     return (OutCyc);

  0000b	8b 44 24 00	 mov	 eax, DWORD PTR _OutCyc$[esp+4]

; 62   : #else
; 63   : 	return 0;
; 64   : #endif
; 65   : }

  0000f	59		 pop	 ecx
  00010	c3		 ret	 0
?CycleCount@@YAHXZ ENDP					; CycleCount
_TEXT	ENDS
PUBLIC	?StaticClass@UFractalTexture@@SAPAVUClass@@XZ	; UFractalTexture::StaticClass
; Function compile flags: /Ogty
;	COMDAT ?StaticClass@UFractalTexture@@SAPAVUClass@@XZ
_TEXT	SEGMENT
?StaticClass@UFractalTexture@@SAPAVUClass@@XZ PROC NEAR	; UFractalTexture::StaticClass, COMDAT

; 78   : 	DECLARE_ABSTRACT_CLASS(UFractalTexture,UProceduralTexture,0)

  00000	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?PrivateStaticClass@UFractalTexture@@0VUClass@@A ; UFractalTexture::PrivateStaticClass
  00005	c3		 ret	 0
?StaticClass@UFractalTexture@@SAPAVUClass@@XZ ENDP	; UFractalTexture::StaticClass
_TEXT	ENDS
PUBLIC	??2UFractalTexture@@SAPAXIPAVUObject@@VFName@@K@Z ; UFractalTexture::operator new
; Function compile flags: /Ogty
;	COMDAT ??2UFractalTexture@@SAPAXIPAVUObject@@VFName@@K@Z
_TEXT	SEGMENT
_Outer$ = 12
_Name$ = 16
_SetFlags$ = 20
??2UFractalTexture@@SAPAXIPAVUObject@@VFName@@K@Z PROC NEAR ; UFractalTexture::operator new, COMDAT

; 78   : 	DECLARE_ABSTRACT_CLASS(UFractalTexture,UProceduralTexture,0)

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?GError@@3PAVFOutputDeviceError@@A
  00005	8b 08		 mov	 ecx, DWORD PTR [eax]
  00007	8b 54 24 10	 mov	 edx, DWORD PTR _SetFlags$[esp-4]
  0000b	8b 44 24 0c	 mov	 eax, DWORD PTR _Name$[esp-4]
  0000f	6a 00		 push	 0
  00011	51		 push	 ecx
  00012	8b 4c 24 10	 mov	 ecx, DWORD PTR _Outer$[esp+4]
  00016	6a 00		 push	 0
  00018	52		 push	 edx
  00019	50		 push	 eax
  0001a	51		 push	 ecx
  0001b	68 00 00 00 00	 push	 OFFSET FLAT:?PrivateStaticClass@UFractalTexture@@0VUClass@@A ; UFractalTexture::PrivateStaticClass
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?StaticAllocateObject@UObject@@SAPAV1@PAVUClass@@PAV1@VFName@@K1PAVFOutputDevice@@1@Z
  00026	83 c4 1c	 add	 esp, 28			; 0000001cH
  00029	c3		 ret	 0
??2UFractalTexture@@SAPAXIPAVUObject@@VFName@@K@Z ENDP	; UFractalTexture::operator new
_TEXT	ENDS
PUBLIC	??2UFractalTexture@@SAPAXIPAW4EInternal@@@Z	; UFractalTexture::operator new
; Function compile flags: /Ogty
;	COMDAT ??2UFractalTexture@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT
_Mem$ = 12
??2UFractalTexture@@SAPAXIPAW4EInternal@@@Z PROC NEAR	; UFractalTexture::operator new, COMDAT

; 78   : 	DECLARE_ABSTRACT_CLASS(UFractalTexture,UProceduralTexture,0)

  00000	8b 44 24 08	 mov	 eax, DWORD PTR _Mem$[esp-4]
  00004	c3		 ret	 0
??2UFractalTexture@@SAPAXIPAW4EInternal@@@Z ENDP	; UFractalTexture::operator new
_TEXT	ENDS
PUBLIC	??_GFMipmap@@QAEPAXI@Z				; FMipmap::`scalar deleting destructor'
PUBLIC	??1UFractalTexture@@UAE@XZ			; UFractalTexture::~UFractalTexture
PUBLIC	??1?$TArray@UFMipmap@@@@QAE@XZ			; TArray<FMipmap>::~TArray<FMipmap>
EXTRN	__imp_??_7UTexture@@6B@:BYTE
EXTRN	__imp_?ConditionalDestroy@UObject@@QAEHXZ:NEAR
EXTRN	__imp_??1FArray@@QAE@XZ:NEAR
EXTRN	__imp_??1UProceduralTexture@@UAE@XZ:NEAR
EXTRN	__imp_??_7UProceduralTexture@@6B@:BYTE
EXTRN	__imp_??1UBitmap@@UAE@XZ:NEAR
EXTRN	__imp_??_7UBitmap@@6B@:BYTE
EXTRN	__except_list:DWORD
EXTRN	___CxxFrameHandler:NEAR
EXTRN	__imp_??1UTexture@@UAE@XZ:NEAR
EXTRN	__imp_??1UObject@@UAE@XZ:NEAR
;	COMDAT xdata$x
; File ..\..\Engine\Inc\UnTex.h
xdata$x	SEGMENT
$T136931 DD	0ffffffffH
	DD	FLAT:$L136727
	DD	0ffffffffH
	DD	FLAT:$L136729
	DD	0ffffffffH
	DD	FLAT:$L136731
	DD	02H
	DD	FLAT:$L136732
	DD	03H
	DD	FLAT:$L136733
	DD	03H
	DD	FLAT:$L136735
	DD	02H
	DD	FLAT:$L136783
	DD	0ffffffffH
	DD	FLAT:$L136831
$T136921 DD	019930520H
	DD	08H
	DD	FLAT:$T136931
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File C:\duke4\Fire\Src\FractalPrivate.h
xdata$x	ENDS
;	COMDAT ??1UFractalTexture@@UAE@XZ
_TEXT	SEGMENT
$T136781 = -16
$T136829 = -16
__$EHRec$ = -12
_this$ = -20
??1UFractalTexture@@UAE@XZ PROC NEAR			; UFractalTexture::~UFractalTexture, COMDAT
; _this$ = ecx

; 78   : 	DECLARE_ABSTRACT_CLASS(UFractalTexture,UProceduralTexture,0)

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 $L136929
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00018	53		 push	 ebx
  00019	55		 push	 ebp
  0001a	56		 push	 esi
  0001b	8b f1		 mov	 esi, ecx
  0001d	57		 push	 edi
  0001e	89 74 24 14	 mov	 DWORD PTR _this$[esp+40], esi
  00022	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7UFractalTexture@@6B@ ; UFractalTexture::`vftable'
  00028	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp_?ConditionalDestroy@UObject@@QAEHXZ
  0002e	33 ed		 xor	 ebp, ebp
  00030	89 6c 24 24	 mov	 DWORD PTR __$EHRec$[esp+48], ebp
  00034	ff d7		 call	 edi
  00036	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_??_7UProceduralTexture@@6B@
  0003b	89 06		 mov	 DWORD PTR [esi], eax
  0003d	8b ce		 mov	 ecx, esi
  0003f	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+48], 1
  00047	ff d7		 call	 edi
  00049	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_??_7UTexture@@6B@
  0004f	89 0e		 mov	 DWORD PTR [esi], ecx
  00051	8b ce		 mov	 ecx, esi
  00053	c7 44 24 24 04
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+48], 4
  0005b	ff d7		 call	 edi
  0005d	8d be b4 00 00
	00		 lea	 edi, DWORD PTR [esi+180]
  00063	89 7c 24 18	 mov	 DWORD PTR $T136781[esp+40], edi
  00067	8b 5f 04	 mov	 ebx, DWORD PTR [edi+4]
  0006a	3b dd		 cmp	 ebx, ebp
  0006c	c6 44 24 24 05	 mov	 BYTE PTR __$EHRec$[esp+48], 5
  00071	7d 18		 jge	 SHORT $L136888
  00073	68 fd 01 00 00	 push	 509			; 000001fdH
  00078	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@MLGP@?4?4?2?4?4?2Core?2Inc?2UnTemplate?4h?$AA@ ; `string'
  0007d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BA@FEMP@Index?$DM?$DNArrayNum?$AA@ ; `string'
  00082	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?appFailAssert@@YAXPBD0H@Z
  00088	83 c4 0c	 add	 esp, 12			; 0000000cH
$L136888:
  0008b	3b 5f 04	 cmp	 ebx, DWORD PTR [edi+4]
  0008e	7e 18		 jle	 SHORT $L136889
  00090	68 fe 01 00 00	 push	 510			; 000001feH
  00095	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@MLGP@?4?4?2?4?4?2Core?2Inc?2UnTemplate?4h?$AA@ ; `string'
  0009a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BG@BEDF@Index?$CLCount?$DM?$DNArrayNum?$AA@ ; `string'
  0009f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?appFailAssert@@YAXPBD0H@Z
  000a5	83 c4 0c	 add	 esp, 12			; 0000000cH
$L136889:
  000a8	3b dd		 cmp	 ebx, ebp
  000aa	7e 1f		 jle	 SHORT $L136894
  000ac	89 5c 24 10	 mov	 DWORD PTR -24+[esp+40], ebx
$L136892:
  000b0	8b 0f		 mov	 ecx, DWORD PTR [edi]
  000b2	6a 00		 push	 0
  000b4	03 cd		 add	 ecx, ebp
  000b6	e8 00 00 00 00	 call	 ??_GFMipmap@@QAEPAXI@Z	; FMipmap::`scalar deleting destructor'
  000bb	8b 44 24 10	 mov	 eax, DWORD PTR -24+[esp+40]
  000bf	83 c5 28	 add	 ebp, 40			; 00000028H
  000c2	48		 dec	 eax
  000c3	89 44 24 10	 mov	 DWORD PTR -24+[esp+40], eax
  000c7	75 e7		 jne	 SHORT $L136892
  000c9	33 ed		 xor	 ebp, ebp
$L136894:
  000cb	6a 28		 push	 40			; 00000028H
  000cd	53		 push	 ebx
  000ce	55		 push	 ebp
  000cf	8b cf		 mov	 ecx, edi
  000d1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Remove@FArray@@QAEXHHH@Z
  000d7	8b 07		 mov	 eax, DWORD PTR [edi]
  000d9	3b c5		 cmp	 eax, ebp
  000db	c6 44 24 24 03	 mov	 BYTE PTR __$EHRec$[esp+48], 3
  000e0	74 0e		 je	 SHORT $L136896
  000e2	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR __imp_?GMalloc@@3PAVFMalloc@@A
  000e8	8b 0a		 mov	 ecx, DWORD PTR [edx]
  000ea	8b 11		 mov	 edx, DWORD PTR [ecx]
  000ec	50		 push	 eax
  000ed	ff 52 08	 call	 DWORD PTR [edx+8]
$L136896:
  000f0	89 2f		 mov	 DWORD PTR [edi], ebp
  000f2	89 6f 08	 mov	 DWORD PTR [edi+8], ebp
  000f5	89 6f 04	 mov	 DWORD PTR [edi+4], ebp
  000f8	8d be a8 00 00
	00		 lea	 edi, DWORD PTR [esi+168]
  000fe	89 7c 24 18	 mov	 DWORD PTR $T136829[esp+40], edi
  00102	8b 6f 04	 mov	 ebp, DWORD PTR [edi+4]
  00105	85 ed		 test	 ebp, ebp
  00107	c6 44 24 24 06	 mov	 BYTE PTR __$EHRec$[esp+48], 6
  0010c	7d 18		 jge	 SHORT $L136907
  0010e	68 fd 01 00 00	 push	 509			; 000001fdH
  00113	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@MLGP@?4?4?2?4?4?2Core?2Inc?2UnTemplate?4h?$AA@ ; `string'
  00118	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BA@FEMP@Index?$DM?$DNArrayNum?$AA@ ; `string'
  0011d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?appFailAssert@@YAXPBD0H@Z
  00123	83 c4 0c	 add	 esp, 12			; 0000000cH
$L136907:
  00126	3b 6f 04	 cmp	 ebp, DWORD PTR [edi+4]
  00129	7e 18		 jle	 SHORT $L136908
  0012b	68 fe 01 00 00	 push	 510			; 000001feH
  00130	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@MLGP@?4?4?2?4?4?2Core?2Inc?2UnTemplate?4h?$AA@ ; `string'
  00135	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BG@BEDF@Index?$CLCount?$DM?$DNArrayNum?$AA@ ; `string'
  0013a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?appFailAssert@@YAXPBD0H@Z
  00140	83 c4 0c	 add	 esp, 12			; 0000000cH
$L136908:
  00143	85 ed		 test	 ebp, ebp
  00145	7e 22		 jle	 SHORT $L136913
  00147	33 db		 xor	 ebx, ebx
  00149	89 6c 24 10	 mov	 DWORD PTR -24+[esp+40], ebp
  0014d	8d 49 00	 npad	 3
$L136911:
  00150	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00152	6a 00		 push	 0
  00154	03 cb		 add	 ecx, ebx
  00156	e8 00 00 00 00	 call	 ??_GFMipmap@@QAEPAXI@Z	; FMipmap::`scalar deleting destructor'
  0015b	8b 44 24 10	 mov	 eax, DWORD PTR -24+[esp+40]
  0015f	83 c3 28	 add	 ebx, 40			; 00000028H
  00162	48		 dec	 eax
  00163	89 44 24 10	 mov	 DWORD PTR -24+[esp+40], eax
  00167	75 e7		 jne	 SHORT $L136911
$L136913:
  00169	6a 28		 push	 40			; 00000028H
  0016b	55		 push	 ebp
  0016c	33 db		 xor	 ebx, ebx
  0016e	53		 push	 ebx
  0016f	8b cf		 mov	 ecx, edi
  00171	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Remove@FArray@@QAEXHHH@Z
  00177	8b 07		 mov	 eax, DWORD PTR [edi]
  00179	3b c3		 cmp	 eax, ebx
  0017b	c6 44 24 24 02	 mov	 BYTE PTR __$EHRec$[esp+48], 2
  00180	74 0e		 je	 SHORT $L136915
  00182	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?GMalloc@@3PAVFMalloc@@A
  00188	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0018a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0018c	50		 push	 eax
  0018d	ff 52 08	 call	 DWORD PTR [edx+8]
$L136915:
  00190	89 1f		 mov	 DWORD PTR [edi], ebx
  00192	89 5f 08	 mov	 DWORD PTR [edi+8], ebx
  00195	89 5f 04	 mov	 DWORD PTR [edi+4], ebx
  00198	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_??_7UBitmap@@6B@
  0019d	89 06		 mov	 DWORD PTR [esi], eax
  0019f	8b ce		 mov	 ecx, esi
  001a1	c7 44 24 24 07
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+48], 7
  001a9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?ConditionalDestroy@UObject@@QAEHXZ
  001af	8b ce		 mov	 ecx, esi
  001b1	c7 44 24 24 ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+48], -1
  001b9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1UObject@@UAE@XZ
  001bf	8b 4c 24 1c	 mov	 ecx, DWORD PTR __$EHRec$[esp+40]
  001c3	5f		 pop	 edi
  001c4	5e		 pop	 esi
  001c5	5d		 pop	 ebp
  001c6	5b		 pop	 ebx
  001c7	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  001ce	83 c4 18	 add	 esp, 24			; 00000018H
  001d1	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L136727:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1UProceduralTexture@@UAE@XZ
$L136729:
  00009	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1UTexture@@UAE@XZ
$L136731:
  00012	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1UBitmap@@UAE@XZ
$L136732:
  0001b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	81 c1 a8 00 00
	00		 add	 ecx, 168		; 000000a8H
  00024	e9 00 00 00 00	 jmp	 ??1?$TArray@UFMipmap@@@@QAE@XZ ; TArray<FMipmap>::~TArray<FMipmap>
$L136733:
  00029	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	81 c1 b4 00 00
	00		 add	 ecx, 180		; 000000b4H
  00032	e9 00 00 00 00	 jmp	 ??1?$TArray@UFMipmap@@@@QAE@XZ ; TArray<FMipmap>::~TArray<FMipmap>
$L136735:
  00037	8b 4d f0	 mov	 ecx, DWORD PTR $T136781[ebp]
  0003a	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1FArray@@QAE@XZ
$L136783:
  00040	8b 4d f0	 mov	 ecx, DWORD PTR $T136829[ebp]
  00043	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1FArray@@QAE@XZ
$L136831:
  00049	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1UObject@@UAE@XZ
$L136929:
  00052	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T136921
  00057	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??1UFractalTexture@@UAE@XZ ENDP				; UFractalTexture::~UFractalTexture
PUBLIC	??1?$TArray@E@@QAE@XZ				; TArray<unsigned char>::~TArray<unsigned char>
PUBLIC	?Remove@?$TArray@E@@QAEXHH@Z			; TArray<unsigned char>::Remove
PUBLIC	?Load@?$TLazyArray@E@@UAEXXZ			; TLazyArray<unsigned char>::Load
PUBLIC	?Unload@?$TLazyArray@E@@UAEXXZ			; TLazyArray<unsigned char>::Unload
PUBLIC	??_7?$TLazyArray@E@@6B@				; TLazyArray<unsigned char>::`vftable'
;	COMDAT xdata$x
; File ..\..\Core\Inc\UnTemplate.h
xdata$x	SEGMENT
$T137033 DD	0ffffffffH
	DD	FLAT:$L136938
	DD	00H
	DD	FLAT:$L136954
	DD	00H
	DD	FLAT:$L136956
$T137029 DD	019930520H
	DD	03H
	DD	FLAT:$T137033
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_7?$TLazyArray@E@@6B@
CONST	SEGMENT
??_7?$TLazyArray@E@@6B@ DD FLAT:?Load@?$TLazyArray@E@@UAEXXZ ; TLazyArray<unsigned char>::`vftable'
	DD	FLAT:?Unload@?$TLazyArray@E@@UAEXXZ
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ??1?$TArray@UFMipmap@@@@QAE@XZ
_TEXT	SEGMENT
$T136959 = -16
$T136967 = -20
_this$ = -24
__$EHRec$ = -12
??1?$TArray@UFMipmap@@@@QAE@XZ PROC NEAR		; TArray<FMipmap>::~TArray<FMipmap>, COMDAT
; _this$ = ecx

; 371  : 	{

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 $L137032
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	83 ec 10	 sub	 esp, 16			; 00000010H
  00018	53		 push	 ebx
  00019	55		 push	 ebp
  0001a	56		 push	 esi
  0001b	8b e9		 mov	 ebp, ecx
  0001d	57		 push	 edi
  0001e	89 6c 24 14	 mov	 DWORD PTR _this$[esp+44], ebp

; 372  : 		checkSlow(ArrayNum>=0);
; 373  : 		checkSlow(ArrayMax>=ArrayNum);
; 374  : 		Remove( 0, ArrayNum );

  00022	8b 5d 04	 mov	 ebx, DWORD PTR [ebp+4]
  00025	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp_?appFailAssert@@YAXPBD0H@Z
  0002b	33 ff		 xor	 edi, edi
  0002d	3b df		 cmp	 ebx, edi
  0002f	89 7c 24 28	 mov	 DWORD PTR __$EHRec$[esp+52], edi
  00033	89 5c 24 10	 mov	 DWORD PTR -28+[esp+44], ebx
  00037	7d 14		 jge	 SHORT $L137016
  00039	68 fd 01 00 00	 push	 509			; 000001fdH
  0003e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@MLGP@?4?4?2?4?4?2Core?2Inc?2UnTemplate?4h?$AA@ ; `string'
  00043	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BA@FEMP@Index?$DM?$DNArrayNum?$AA@ ; `string'
  00048	ff d6		 call	 esi
  0004a	83 c4 0c	 add	 esp, 12			; 0000000cH
$L137016:
  0004d	3b 5d 04	 cmp	 ebx, DWORD PTR [ebp+4]
  00050	7e 14		 jle	 SHORT $L137017
  00052	68 fe 01 00 00	 push	 510			; 000001feH
  00057	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@MLGP@?4?4?2?4?4?2Core?2Inc?2UnTemplate?4h?$AA@ ; `string'
  0005c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BG@BEDF@Index?$CLCount?$DM?$DNArrayNum?$AA@ ; `string'
  00061	ff d6		 call	 esi
  00063	83 c4 0c	 add	 esp, 12			; 0000000cH
$L137017:
  00066	3b df		 cmp	 ebx, edi
  00068	7e 5c		 jle	 SHORT $L137022

; 375  : 	}

  0006a	8d 9b 00 00 00
	00		 npad	 6

; 372  : 		checkSlow(ArrayNum>=0);
; 373  : 		checkSlow(ArrayMax>=ArrayNum);
; 374  : 		Remove( 0, ArrayNum );

$L137020:
  00070	8b 45 00	 mov	 eax, DWORD PTR [ebp]
  00073	03 c7		 add	 eax, edi
  00075	8d 70 10	 lea	 esi, DWORD PTR [eax+16]
  00078	89 74 24 18	 mov	 DWORD PTR $T136967[esp+44], esi
  0007c	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7?$TLazyArray@E@@6B@ ; TLazyArray<unsigned char>::`vftable'
  00082	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00085	85 c9		 test	 ecx, ecx
  00087	c6 44 24 28 01	 mov	 BYTE PTR __$EHRec$[esp+52], 1
  0008c	74 06		 je	 SHORT $L137006
  0008e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00090	56		 push	 esi
  00091	ff 50 3c	 call	 DWORD PTR [eax+60]
$L137006:
  00094	83 c6 0c	 add	 esi, 12			; 0000000cH
  00097	89 74 24 1c	 mov	 DWORD PTR $T136959[esp+44], esi
  0009b	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0009e	51		 push	 ecx
  0009f	6a 00		 push	 0
  000a1	8b ce		 mov	 ecx, esi
  000a3	c6 44 24 30 02	 mov	 BYTE PTR __$EHRec$[esp+60], 2
  000a8	e8 00 00 00 00	 call	 ?Remove@?$TArray@E@@QAEXHH@Z ; TArray<unsigned char>::Remove
  000ad	8b ce		 mov	 ecx, esi
  000af	c6 44 24 28 00	 mov	 BYTE PTR __$EHRec$[esp+52], 0
  000b4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1FArray@@QAE@XZ
  000ba	83 c7 28	 add	 edi, 40			; 00000028H
  000bd	4b		 dec	 ebx
  000be	75 b0		 jne	 SHORT $L137020
  000c0	8b 5c 24 10	 mov	 ebx, DWORD PTR -28+[esp+44]
  000c4	33 ff		 xor	 edi, edi
$L137022:
  000c6	6a 28		 push	 40			; 00000028H
  000c8	53		 push	 ebx
  000c9	57		 push	 edi
  000ca	8b cd		 mov	 ecx, ebp
  000cc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Remove@FArray@@QAEXHHH@Z

; 375  : 	}

  000d2	8b 45 00	 mov	 eax, DWORD PTR [ebp]
  000d5	3b c7		 cmp	 eax, edi
  000d7	c7 44 24 28 ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+52], -1
  000df	74 0e		 je	 SHORT $L137026
  000e1	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR __imp_?GMalloc@@3PAVFMalloc@@A
  000e7	8b 0a		 mov	 ecx, DWORD PTR [edx]
  000e9	8b 11		 mov	 edx, DWORD PTR [ecx]
  000eb	50		 push	 eax
  000ec	ff 52 08	 call	 DWORD PTR [edx+8]
$L137026:
  000ef	8b 4c 24 20	 mov	 ecx, DWORD PTR __$EHRec$[esp+44]
  000f3	89 7d 00	 mov	 DWORD PTR [ebp], edi
  000f6	89 7d 08	 mov	 DWORD PTR [ebp+8], edi
  000f9	89 7d 04	 mov	 DWORD PTR [ebp+4], edi
  000fc	5f		 pop	 edi
  000fd	5e		 pop	 esi
  000fe	5d		 pop	 ebp
  000ff	5b		 pop	 ebx
  00100	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00107	83 c4 1c	 add	 esp, 28			; 0000001cH
  0010a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L136938:
  00000	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1FArray@@QAE@XZ
$L136954:
  00009	83 7d ec 00	 cmp	 DWORD PTR $T136967[ebp], 0
  0000d	0f 84 0e 00 00
	00		 je	 $L136952
  00013	8b 45 ec	 mov	 eax, DWORD PTR $T136967[ebp]
  00016	83 c0 0c	 add	 eax, 12			; 0000000cH
  00019	89 45 f0	 mov	 DWORD PTR $T136959[ebp], eax
  0001c	e9 07 00 00 00	 jmp	 $L136953
$L136952:
  00021	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T136959[ebp], 0
$L136953:
  00028	8b 4d f0	 mov	 ecx, DWORD PTR $T136959[ebp]
  0002b	e9 00 00 00 00	 jmp	 ??1?$TArray@E@@QAE@XZ	; TArray<unsigned char>::~TArray<unsigned char>
$L136956:
  00030	8b 4d f0	 mov	 ecx, DWORD PTR $T136959[ebp]
  00033	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1FArray@@QAE@XZ
$L137032:
  00039	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T137029
  0003e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??1?$TArray@UFMipmap@@@@QAE@XZ ENDP			; TArray<FMipmap>::~TArray<FMipmap>
;	COMDAT xdata$x
xdata$x	SEGMENT
$T137066 DD	0ffffffffH
	DD	FLAT:$L137039
$T137062 DD	019930520H
	DD	01H
	DD	FLAT:$T137066
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ??1?$TArray@E@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16
__$EHRec$ = -12
??1?$TArray@E@@QAE@XZ PROC NEAR				; TArray<unsigned char>::~TArray<unsigned char>, COMDAT
; _this$ = ecx

; 371  : 	{

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 $L137065
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	51		 push	 ecx
  00016	53		 push	 ebx
  00017	56		 push	 esi
  00018	8b f1		 mov	 esi, ecx
  0001a	57		 push	 edi
  0001b	89 74 24 0c	 mov	 DWORD PTR _this$[esp+28], esi

; 372  : 		checkSlow(ArrayNum>=0);
; 373  : 		checkSlow(ArrayMax>=ArrayNum);
; 374  : 		Remove( 0, ArrayNum );

  0001f	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  00022	85 ff		 test	 edi, edi
  00024	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp_?appFailAssert@@YAXPBD0H@Z
  0002a	c7 44 24 18 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+36], 0
  00032	7d 14		 jge	 SHORT $L137046
  00034	68 fd 01 00 00	 push	 509			; 000001fdH
  00039	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@MLGP@?4?4?2?4?4?2Core?2Inc?2UnTemplate?4h?$AA@ ; `string'
  0003e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BA@FEMP@Index?$DM?$DNArrayNum?$AA@ ; `string'
  00043	ff d3		 call	 ebx
  00045	83 c4 0c	 add	 esp, 12			; 0000000cH
$L137046:
  00048	3b 7e 04	 cmp	 edi, DWORD PTR [esi+4]
  0004b	7e 14		 jle	 SHORT $L137047
  0004d	68 fe 01 00 00	 push	 510			; 000001feH
  00052	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@MLGP@?4?4?2?4?4?2Core?2Inc?2UnTemplate?4h?$AA@ ; `string'
  00057	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BG@BEDF@Index?$CLCount?$DM?$DNArrayNum?$AA@ ; `string'
  0005c	ff d3		 call	 ebx
  0005e	83 c4 0c	 add	 esp, 12			; 0000000cH
$L137047:
  00061	6a 01		 push	 1
  00063	57		 push	 edi
  00064	6a 00		 push	 0
  00066	8b ce		 mov	 ecx, esi
  00068	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Remove@FArray@@QAEXHHH@Z

; 375  : 	}

  0006e	8b 06		 mov	 eax, DWORD PTR [esi]
  00070	85 c0		 test	 eax, eax
  00072	c7 44 24 18 ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+36], -1
  0007a	74 0e		 je	 SHORT $L137059
  0007c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?GMalloc@@3PAVFMalloc@@A
  00082	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00084	8b 11		 mov	 edx, DWORD PTR [ecx]
  00086	50		 push	 eax
  00087	ff 52 08	 call	 DWORD PTR [edx+8]
$L137059:
  0008a	8b 4c 24 10	 mov	 ecx, DWORD PTR __$EHRec$[esp+28]
  0008e	5f		 pop	 edi
  0008f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00095	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  0009c	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  000a3	5e		 pop	 esi
  000a4	5b		 pop	 ebx
  000a5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000ac	83 c4 10	 add	 esp, 16			; 00000010H
  000af	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L137039:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1FArray@@QAE@XZ
$L137065:
  00009	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T137062
  0000e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??1?$TArray@E@@QAE@XZ ENDP				; TArray<unsigned char>::~TArray<unsigned char>
EXTRN	__imp_?GNumLazyLoads@@3HA:DWORD
; Function compile flags: /Ogty
;	COMDAT ?Load@?$TLazyArray@E@@UAEXXZ
_TEXT	SEGMENT
_PushedPos$125736 = -4
?Load@?$TLazyArray@E@@UAEXXZ PROC NEAR			; TLazyArray<unsigned char>::Load, COMDAT
; _this$ = ecx

; 807  : 	{

  00000	51		 push	 ecx
  00001	56		 push	 esi
  00002	8b f1		 mov	 esi, ecx

; 808  : 		// Make sure this array is loaded.
; 809  : 		if( SavedPos>0 )

  00004	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00007	85 c0		 test	 eax, eax
  00009	0f 8e 85 00 00
	00		 jle	 $L125735

; 810  : 		{
; 811  : 			// Lazy load it now.
; 812  : 			INT PushedPos = SavedAr->Tell();

  0000f	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00012	8b 01		 mov	 eax, DWORD PTR [ecx]
  00014	53		 push	 ebx
  00015	55		 push	 ebp
  00016	57		 push	 edi
  00017	ff 50 28	 call	 DWORD PTR [eax+40]

; 813  : 			SavedAr->Seek( SavedPos );

  0001a	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0001d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0001f	89 44 24 10	 mov	 DWORD PTR _PushedPos$125736[esp+20], eax
  00023	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00026	50		 push	 eax
  00027	ff 52 34	 call	 DWORD PTR [edx+52]

; 814  : 			*SavedAr << (TArray<T>&)*this;

  0002a	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0002d	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  00030	8b 17		 mov	 edx, DWORD PTR [edi]
  00032	8d 5e 0c	 lea	 ebx, DWORD PTR [esi+12]
  00035	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  00038	8d 6b 04	 lea	 ebp, DWORD PTR [ebx+4]
  0003b	50		 push	 eax
  0003c	51		 push	 ecx
  0003d	8b cf		 mov	 ecx, edi
  0003f	ff 52 14	 call	 DWORD PTR [edx+20]
  00042	55		 push	 ebp
  00043	57		 push	 edi
  00044	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6@YAAAVFArchive@@AAV0@AAVFCompactIndex@@@Z
  0004a	8b 47 14	 mov	 eax, DWORD PTR [edi+20]
  0004d	83 c4 08	 add	 esp, 8
  00050	85 c0		 test	 eax, eax
  00052	74 10		 je	 SHORT $L137148
  00054	8b 55 00	 mov	 edx, DWORD PTR [ebp]
  00057	6a 01		 push	 1
  00059	8b cb		 mov	 ecx, ebx
  0005b	89 53 08	 mov	 DWORD PTR [ebx+8], edx
  0005e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Realloc@FArray@@IAEXH@Z
$L137148:
  00064	8b 4d 00	 mov	 ecx, DWORD PTR [ebp]
  00067	8b 13		 mov	 edx, DWORD PTR [ebx]
  00069	8b 07		 mov	 eax, DWORD PTR [edi]
  0006b	51		 push	 ecx
  0006c	52		 push	 edx
  0006d	8b cf		 mov	 ecx, edi
  0006f	ff 50 04	 call	 DWORD PTR [eax+4]

; 815  : 			SavedPos *= -1;

  00072	8b 46 08	 mov	 eax, DWORD PTR [esi+8]

; 816  : 			SavedAr->Seek( PushedPos );

  00075	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00078	f7 d8		 neg	 eax
  0007a	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0007d	8b 44 24 10	 mov	 eax, DWORD PTR _PushedPos$125736[esp+20]
  00081	8b 11		 mov	 edx, DWORD PTR [ecx]
  00083	50		 push	 eax
  00084	ff 52 34	 call	 DWORD PTR [edx+52]

; 817  : 			GNumLazyLoads++;		// JEP

  00087	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?GNumLazyLoads@@3HA
  0008c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0008e	5f		 pop	 edi
  0008f	41		 inc	 ecx
  00090	5d		 pop	 ebp
  00091	89 08		 mov	 DWORD PTR [eax], ecx
  00093	5b		 pop	 ebx
$L125735:
  00094	5e		 pop	 esi

; 818  : 		}
; 819  : 	}

  00095	59		 pop	 ecx
  00096	c3		 ret	 0
?Load@?$TLazyArray@E@@UAEXXZ ENDP			; TLazyArray<unsigned char>::Load
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?Unload@?$TLazyArray@E@@UAEXXZ
_TEXT	SEGMENT
?Unload@?$TLazyArray@E@@UAEXXZ PROC NEAR		; TLazyArray<unsigned char>::Unload, COMDAT
; _this$ = ecx

; 824  : 	{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 825  : 		// Make sure this array is unloaded.
; 826  : 		if( SavedPos<0 )

  00003	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00006	33 c0		 xor	 eax, eax
  00008	3b c8		 cmp	 ecx, eax
  0000a	7d 19		 jge	 SHORT $L125740

; 827  : 		{
; 828  : 			// Unload it now.
; 829  : 			Empty();

  0000c	8d 4e 0c	 lea	 ecx, DWORD PTR [esi+12]
  0000f	6a 01		 push	 1
  00011	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00014	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00017	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Realloc@FArray@@IAEXH@Z

; 830  : 			SavedPos *= -1;

  0001d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00020	f7 d8		 neg	 eax
  00022	89 46 08	 mov	 DWORD PTR [esi+8], eax
$L125740:
  00025	5e		 pop	 esi

; 831  : 		}
; 832  : 	}

  00026	c3		 ret	 0
?Unload@?$TLazyArray@E@@UAEXXZ ENDP			; TLazyArray<unsigned char>::Unload
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@E@@QAEXHH@Z
_TEXT	SEGMENT
_Index$ = 8
_Count$ = 12
?Remove@?$TArray@E@@QAEXHH@Z PROC NEAR			; TArray<unsigned char>::Remove, COMDAT
; _this$ = ecx

; 507  : 	{

  00000	53		 push	 ebx
  00001	55		 push	 ebp

; 508  : 		check(Index>=0);

  00002	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp_?appFailAssert@@YAXPBD0H@Z
  00008	56		 push	 esi
  00009	57		 push	 edi
  0000a	8b 7c 24 14	 mov	 edi, DWORD PTR _Index$[esp+12]
  0000e	85 ff		 test	 edi, edi
  00010	8b f1		 mov	 esi, ecx
  00012	7d 14		 jge	 SHORT $L126181
  00014	68 fc 01 00 00	 push	 508			; 000001fcH
  00019	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@MLGP@?4?4?2?4?4?2Core?2Inc?2UnTemplate?4h?$AA@ ; `string'
  0001e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08GCAE@Index?$DO?$DN0?$AA@ ; `string'
  00023	ff d5		 call	 ebp
  00025	83 c4 0c	 add	 esp, 12			; 0000000cH
$L126181:

; 509  : 		check(Index<=ArrayNum);

  00028	3b 7e 04	 cmp	 edi, DWORD PTR [esi+4]
  0002b	7e 14		 jle	 SHORT $L126182
  0002d	68 fd 01 00 00	 push	 509			; 000001fdH
  00032	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@MLGP@?4?4?2?4?4?2Core?2Inc?2UnTemplate?4h?$AA@ ; `string'
  00037	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BA@FEMP@Index?$DM?$DNArrayNum?$AA@ ; `string'
  0003c	ff d5		 call	 ebp
  0003e	83 c4 0c	 add	 esp, 12			; 0000000cH
$L126182:

; 510  : 		check(Index+Count<=ArrayNum);

  00041	8b 5c 24 18	 mov	 ebx, DWORD PTR _Count$[esp+12]
  00045	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00048	8d 04 1f	 lea	 eax, DWORD PTR [edi+ebx]
  0004b	3b c1		 cmp	 eax, ecx
  0004d	7e 14		 jle	 SHORT $L126183
  0004f	68 fe 01 00 00	 push	 510			; 000001feH
  00054	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@MLGP@?4?4?2?4?4?2Core?2Inc?2UnTemplate?4h?$AA@ ; `string'
  00059	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BG@BEDF@Index?$CLCount?$DM?$DNArrayNum?$AA@ ; `string'
  0005e	ff d5		 call	 ebp
  00060	83 c4 0c	 add	 esp, 12			; 0000000cH
$L126183:

; 511  : 		if( TTypeInfo<T>::NeedsDestructor() )
; 512  : 			for( INT i=Index; i<Index+Count; i++ )
; 513  : 				(&(*this)(i))->~T();
; 514  : 		FArray::Remove( Index, Count, sizeof(T) );

  00063	6a 01		 push	 1
  00065	53		 push	 ebx
  00066	57		 push	 edi
  00067	8b ce		 mov	 ecx, esi
  00069	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Remove@FArray@@QAEXHHH@Z
  0006f	5f		 pop	 edi
  00070	5e		 pop	 esi
  00071	5d		 pop	 ebp
  00072	5b		 pop	 ebx

; 515  : 	}

  00073	c2 08 00	 ret	 8
?Remove@?$TArray@E@@QAEXHH@Z ENDP			; TArray<unsigned char>::Remove
_TEXT	ENDS
EXTRN	__imp_??1FMipmap@@QAE@XZ:NEAR
; Function compile flags: /Ogty
;	COMDAT ??_GFMipmap@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_GFMipmap@@QAEPAXI@Z PROC NEAR			; FMipmap::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1FMipmap@@QAE@XZ
  00009	f6 44 24 08 01	 test	 BYTE PTR ___flags$[esp], 1
  0000e	74 0d		 je	 SHORT $L137248
  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?GMalloc@@3PAVFMalloc@@A
  00015	8b 08		 mov	 ecx, DWORD PTR [eax]
  00017	8b 11		 mov	 edx, DWORD PTR [ecx]
  00019	56		 push	 esi
  0001a	ff 52 08	 call	 DWORD PTR [edx+8]
$L137248:
  0001d	8b c6		 mov	 eax, esi
  0001f	5e		 pop	 esi
  00020	c2 04 00	 ret	 4
??_GFMipmap@@QAEPAXI@Z ENDP				; FMipmap::`scalar deleting destructor'
; Function compile flags: /Ogty
; File C:\duke4\Fire\Src\FractalPrivate.h
_TEXT	ENDS
;	COMDAT ?PostEditChange@UFractalTexture@@UAEXXZ
_TEXT	SEGMENT
?PostEditChange@UFractalTexture@@UAEXXZ PROC NEAR	; UFractalTexture::PostEditChange, COMDAT
; _this$ = ecx

; 94   : 	void PostEditChange() {PostLoad();}

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	ff 60 14	 jmp	 DWORD PTR [eax+20]
?PostEditChange@UFractalTexture@@UAEXXZ ENDP		; UFractalTexture::PostEditChange
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?TouchTexture@UFractalTexture@@UAEXHHM@Z
_TEXT	SEGMENT
?TouchTexture@UFractalTexture@@UAEXHHM@Z PROC NEAR	; UFractalTexture::TouchTexture, COMDAT
; _this$ = ecx

; 100  : 	virtual void TouchTexture(INT UPos, INT VPos, FLOAT Magnitude) {}

  00000	c2 0c 00	 ret	 12			; 0000000cH
?TouchTexture@UFractalTexture@@UAEXHHM@Z ENDP		; UFractalTexture::TouchTexture
_TEXT	ENDS
PUBLIC	??0UFractalTexture@@QAE@ABV0@@Z			; UFractalTexture::UFractalTexture
PUBLIC	??0?$TArray@UFMipmap@@@@QAE@ABV0@@Z		; TArray<FMipmap>::TArray<FMipmap>
EXTRN	__imp_??0UObject@@QAE@ABV0@@Z:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T137282 DD	0ffffffffH
	DD	FLAT:$L137262
	DD	00H
	DD	FLAT:$L137263
$T137280 DD	019930520H
	DD	02H
	DD	FLAT:$T137282
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ??0UFractalTexture@@QAE@ABV0@@Z
_TEXT	SEGMENT
__$EHRec$ = -12
___that$ = 8
_this$ = -16
??0UFractalTexture@@QAE@ABV0@@Z PROC NEAR		; UFractalTexture::UFractalTexture, COMDAT
; _this$ = ecx
  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 $L137281
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	51		 push	 ecx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	8b 7c 24 1c	 mov	 edi, DWORD PTR ___that$[esp+20]
  0001c	8b f1		 mov	 esi, ecx
  0001e	57		 push	 edi
  0001f	89 74 24 0c	 mov	 DWORD PTR _this$[esp+28], esi
  00023	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0UObject@@QAE@ABV0@@Z
  00029	8a 47 28	 mov	 al, BYTE PTR [edi+40]
  0002c	88 46 28	 mov	 BYTE PTR [esi+40], al
  0002f	8b 4f 2c	 mov	 ecx, DWORD PTR [edi+44]
  00032	89 4e 2c	 mov	 DWORD PTR [esi+44], ecx
  00035	8a 57 30	 mov	 dl, BYTE PTR [edi+48]
  00038	88 56 30	 mov	 BYTE PTR [esi+48], dl
  0003b	8a 47 31	 mov	 al, BYTE PTR [edi+49]
  0003e	88 46 31	 mov	 BYTE PTR [esi+49], al
  00041	8b 4f 34	 mov	 ecx, DWORD PTR [edi+52]
  00044	89 4e 34	 mov	 DWORD PTR [esi+52], ecx
  00047	8b 57 38	 mov	 edx, DWORD PTR [edi+56]
  0004a	89 56 38	 mov	 DWORD PTR [esi+56], edx
  0004d	8b 47 3c	 mov	 eax, DWORD PTR [edi+60]
  00050	89 46 3c	 mov	 DWORD PTR [esi+60], eax
  00053	8b 4f 40	 mov	 ecx, DWORD PTR [edi+64]
  00056	89 4e 40	 mov	 DWORD PTR [esi+64], ecx
  00059	8b 57 44	 mov	 edx, DWORD PTR [edi+68]
  0005c	89 56 44	 mov	 DWORD PTR [esi+68], edx
  0005f	8b 47 48	 mov	 eax, DWORD PTR [edi+72]
  00062	89 46 48	 mov	 DWORD PTR [esi+72], eax
  00065	8b 4f 4c	 mov	 ecx, DWORD PTR [edi+76]
  00068	89 4e 4c	 mov	 DWORD PTR [esi+76], ecx
  0006b	8b 57 50	 mov	 edx, DWORD PTR [edi+80]
  0006e	89 56 50	 mov	 DWORD PTR [esi+80], edx
  00071	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_??_7UBitmap@@6B@
  00076	89 06		 mov	 DWORD PTR [esi], eax
  00078	8b 4f 54	 mov	 ecx, DWORD PTR [edi+84]
  0007b	89 4e 54	 mov	 DWORD PTR [esi+84], ecx
  0007e	8b 57 58	 mov	 edx, DWORD PTR [edi+88]
  00081	89 56 58	 mov	 DWORD PTR [esi+88], edx
  00084	8b 47 5c	 mov	 eax, DWORD PTR [edi+92]
  00087	89 46 5c	 mov	 DWORD PTR [esi+92], eax
  0008a	8b 4f 60	 mov	 ecx, DWORD PTR [edi+96]
  0008d	89 4e 60	 mov	 DWORD PTR [esi+96], ecx
  00090	8b 57 64	 mov	 edx, DWORD PTR [edi+100]
  00093	89 56 64	 mov	 DWORD PTR [esi+100], edx
  00096	8b 47 68	 mov	 eax, DWORD PTR [edi+104]
  00099	89 46 68	 mov	 DWORD PTR [esi+104], eax
  0009c	8b 4f 6c	 mov	 ecx, DWORD PTR [edi+108]
  0009f	89 4e 6c	 mov	 DWORD PTR [esi+108], ecx
  000a2	8b 57 70	 mov	 edx, DWORD PTR [edi+112]
  000a5	89 56 70	 mov	 DWORD PTR [esi+112], edx
  000a8	8b 47 74	 mov	 eax, DWORD PTR [edi+116]
  000ab	89 46 74	 mov	 DWORD PTR [esi+116], eax
  000ae	8b 4f 78	 mov	 ecx, DWORD PTR [edi+120]
  000b1	89 4e 78	 mov	 DWORD PTR [esi+120], ecx
  000b4	8b 57 7c	 mov	 edx, DWORD PTR [edi+124]
  000b7	89 56 7c	 mov	 DWORD PTR [esi+124], edx
  000ba	8b 87 80 00 00
	00		 mov	 eax, DWORD PTR [edi+128]
  000c0	89 86 80 00 00
	00		 mov	 DWORD PTR [esi+128], eax
  000c6	8b 8f 84 00 00
	00		 mov	 ecx, DWORD PTR [edi+132]
  000cc	89 8e 84 00 00
	00		 mov	 DWORD PTR [esi+132], ecx
  000d2	8b 8e 88 00 00
	00		 mov	 ecx, DWORD PTR [esi+136]
  000d8	8b 87 88 00 00
	00		 mov	 eax, DWORD PTR [edi+136]
  000de	33 c1		 xor	 eax, ecx
  000e0	83 e0 01	 and	 eax, 1
  000e3	33 c1		 xor	 eax, ecx
  000e5	89 86 88 00 00
	00		 mov	 DWORD PTR [esi+136], eax
  000eb	8b 8f 88 00 00
	00		 mov	 ecx, DWORD PTR [edi+136]
  000f1	33 c8		 xor	 ecx, eax
  000f3	83 e1 02	 and	 ecx, 2
  000f6	33 c8		 xor	 ecx, eax
  000f8	89 8e 88 00 00
	00		 mov	 DWORD PTR [esi+136], ecx
  000fe	8b 87 88 00 00
	00		 mov	 eax, DWORD PTR [edi+136]
  00104	33 c1		 xor	 eax, ecx
  00106	83 e0 04	 and	 eax, 4
  00109	33 c1		 xor	 eax, ecx
  0010b	89 86 88 00 00
	00		 mov	 DWORD PTR [esi+136], eax
  00111	8b 8f 88 00 00
	00		 mov	 ecx, DWORD PTR [edi+136]
  00117	33 c8		 xor	 ecx, eax
  00119	83 e1 08	 and	 ecx, 8
  0011c	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+32], 0
  00124	33 c8		 xor	 ecx, eax
  00126	89 8e 88 00 00
	00		 mov	 DWORD PTR [esi+136], ecx
  0012c	8b 87 88 00 00
	00		 mov	 eax, DWORD PTR [edi+136]
  00132	33 c1		 xor	 eax, ecx
  00134	83 e0 10	 and	 eax, 16			; 00000010H
  00137	33 c1		 xor	 eax, ecx
  00139	89 86 88 00 00
	00		 mov	 DWORD PTR [esi+136], eax
  0013f	8b 97 88 00 00
	00		 mov	 edx, DWORD PTR [edi+136]
  00145	33 d0		 xor	 edx, eax
  00147	83 e2 20	 and	 edx, 32			; 00000020H
  0014a	33 d0		 xor	 edx, eax
  0014c	89 96 88 00 00
	00		 mov	 DWORD PTR [esi+136], edx
  00152	8a 87 8c 00 00
	00		 mov	 al, BYTE PTR [edi+140]
  00158	88 86 8c 00 00
	00		 mov	 BYTE PTR [esi+140], al
  0015e	8b 8f 90 00 00
	00		 mov	 ecx, DWORD PTR [edi+144]
  00164	89 8e 90 00 00
	00		 mov	 DWORD PTR [esi+144], ecx
  0016a	8b 97 94 00 00
	00		 mov	 edx, DWORD PTR [edi+148]
  00170	89 96 94 00 00
	00		 mov	 DWORD PTR [esi+148], edx
  00176	8a 87 98 00 00
	00		 mov	 al, BYTE PTR [edi+152]
  0017c	88 86 98 00 00
	00		 mov	 BYTE PTR [esi+152], al
  00182	8a 8f 99 00 00
	00		 mov	 cl, BYTE PTR [edi+153]
  00188	88 8e 99 00 00
	00		 mov	 BYTE PTR [esi+153], cl
  0018e	8b 97 9c 00 00
	00		 mov	 edx, DWORD PTR [edi+156]
  00194	89 96 9c 00 00
	00		 mov	 DWORD PTR [esi+156], edx
  0019a	8b 87 a0 00 00
	00		 mov	 eax, DWORD PTR [edi+160]
  001a0	89 86 a0 00 00
	00		 mov	 DWORD PTR [esi+160], eax
  001a6	8b 8f a4 00 00
	00		 mov	 ecx, DWORD PTR [edi+164]
  001ac	8d 97 a8 00 00
	00		 lea	 edx, DWORD PTR [edi+168]
  001b2	89 8e a4 00 00
	00		 mov	 DWORD PTR [esi+164], ecx
  001b8	52		 push	 edx
  001b9	8d 8e a8 00 00
	00		 lea	 ecx, DWORD PTR [esi+168]
  001bf	e8 00 00 00 00	 call	 ??0?$TArray@UFMipmap@@@@QAE@ABV0@@Z ; TArray<FMipmap>::TArray<FMipmap>
  001c4	8d 87 b4 00 00
	00		 lea	 eax, DWORD PTR [edi+180]
  001ca	50		 push	 eax
  001cb	8d 8e b4 00 00
	00		 lea	 ecx, DWORD PTR [esi+180]
  001d1	c6 44 24 18 01	 mov	 BYTE PTR __$EHRec$[esp+36], 1
  001d6	e8 00 00 00 00	 call	 ??0?$TArray@UFMipmap@@@@QAE@ABV0@@Z ; TArray<FMipmap>::TArray<FMipmap>
  001db	8a 8f c0 00 00
	00		 mov	 cl, BYTE PTR [edi+192]
  001e1	88 8e c0 00 00
	00		 mov	 BYTE PTR [esi+192], cl
  001e7	8b 97 c4 00 00
	00		 mov	 edx, DWORD PTR [edi+196]
  001ed	89 96 c4 00 00
	00		 mov	 DWORD PTR [esi+196], edx
  001f3	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_??_7UTexture@@6B@
  001f8	89 06		 mov	 DWORD PTR [esi], eax
  001fa	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_??_7UProceduralTexture@@6B@
  00200	89 0e		 mov	 DWORD PTR [esi], ecx
  00202	8b 97 c8 00 00
	00		 mov	 edx, DWORD PTR [edi+200]
  00208	89 96 c8 00 00
	00		 mov	 DWORD PTR [esi+200], edx
  0020e	8b 87 cc 00 00
	00		 mov	 eax, DWORD PTR [edi+204]
  00214	89 86 cc 00 00
	00		 mov	 DWORD PTR [esi+204], eax
  0021a	8b 8f d0 00 00
	00		 mov	 ecx, DWORD PTR [edi+208]
  00220	89 8e d0 00 00
	00		 mov	 DWORD PTR [esi+208], ecx
  00226	8b 97 d4 00 00
	00		 mov	 edx, DWORD PTR [edi+212]
  0022c	89 96 d4 00 00
	00		 mov	 DWORD PTR [esi+212], edx
  00232	8b 87 d8 00 00
	00		 mov	 eax, DWORD PTR [edi+216]
  00238	89 86 d8 00 00
	00		 mov	 DWORD PTR [esi+216], eax
  0023e	8a 8f dc 00 00
	00		 mov	 cl, BYTE PTR [edi+220]
  00244	88 8e dc 00 00
	00		 mov	 BYTE PTR [esi+220], cl
  0024a	8a 97 dd 00 00
	00		 mov	 dl, BYTE PTR [edi+221]
  00250	8b 4c 24 0c	 mov	 ecx, DWORD PTR __$EHRec$[esp+24]
  00254	88 96 dd 00 00
	00		 mov	 BYTE PTR [esi+221], dl
  0025a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7UFractalTexture@@6B@ ; UFractalTexture::`vftable'
  00260	5f		 pop	 edi
  00261	8b c6		 mov	 eax, esi
  00263	5e		 pop	 esi
  00264	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0026b	83 c4 10	 add	 esp, 16			; 00000010H
  0026e	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L137262:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1UBitmap@@UAE@XZ
$L137263:
  00009	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	81 c1 a8 00 00
	00		 add	 ecx, 168		; 000000a8H
  00012	e9 00 00 00 00	 jmp	 ??1?$TArray@UFMipmap@@@@QAE@XZ ; TArray<FMipmap>::~TArray<FMipmap>
$L137281:
  00017	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T137280
  0001c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0UFractalTexture@@QAE@ABV0@@Z ENDP			; UFractalTexture::UFractalTexture
PUBLIC	??0?$TArray@E@@QAE@ABV0@@Z			; TArray<unsigned char>::TArray<unsigned char>
PUBLIC	??0FLazyLoader@@QAE@ABV0@@Z			; FLazyLoader::FLazyLoader
;	COMDAT xdata$x
; File ..\..\Core\Inc\UnFile.h
xdata$x	SEGMENT
$T137391 DD	0ffffffffH
	DD	FLAT:$L137291
	DD	00H
	DD	FLAT:$L137325
$T137383 DD	019930520H
	DD	02H
	DD	FLAT:$T137391
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File ..\..\Core\Inc\UnTemplate.h
xdata$x	ENDS
;	COMDAT ??0?$TArray@UFMipmap@@@@QAE@ABV0@@Z
_TEXT	SEGMENT
$T137330 = -16
__$EHRec$ = -12
_this$ = -20
_i$125784 = -24
_Other$ = 8
??0?$TArray@UFMipmap@@@@QAE@ABV0@@Z PROC NEAR		; TArray<FMipmap>::TArray<FMipmap>, COMDAT
; _this$ = ecx

; 350  : 	{

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 $L137390
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00018	53		 push	 ebx
  00019	8b 5c 24 20	 mov	 ebx, DWORD PTR _Other$[esp+24]
  0001d	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00020	55		 push	 ebp
  00021	56		 push	 esi
  00022	8b f1		 mov	 esi, ecx
  00024	33 ed		 xor	 ebp, ebp
  00026	6a 28		 push	 40			; 00000028H
  00028	89 74 24 14	 mov	 DWORD PTR _this$[esp+40], esi
  0002c	89 2e		 mov	 DWORD PTR [esi], ebp
  0002e	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00031	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00034	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Realloc@FArray@@IAEXH@Z

; 351  : 		if( TTypeInfo<T>::NeedsDestructor() )
; 352  : 		{
; 353  : 			ArrayNum=0;

  0003a	89 6e 04	 mov	 DWORD PTR [esi+4], ebp

; 354  : 			for( INT i=0; i<Other.ArrayNum; i++ )

  0003d	39 6b 04	 cmp	 DWORD PTR [ebx+4], ebp
  00040	89 6c 24 20	 mov	 DWORD PTR __$EHRec$[esp+44], ebp
  00044	89 6c 24 0c	 mov	 DWORD PTR _i$125784[esp+36], ebp
  00048	0f 8e b6 00 00
	00		 jle	 $L137388
  0004e	57		 push	 edi
  0004f	89 6c 24 2c	 mov	 DWORD PTR 8+[esp+36], ebp
$L125785:

; 355  : 				new(*this)T(Other(i));

  00053	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  00056	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00059	8d 4f 01	 lea	 ecx, DWORD PTR [edi+1]
  0005c	3b c8		 cmp	 ecx, eax
  0005e	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  00061	7e 1d		 jle	 SHORT $L137312
  00063	8d 04 49	 lea	 eax, DWORD PTR [ecx+ecx*2]
  00066	99		 cdq
  00067	83 e2 07	 and	 edx, 7
  0006a	03 c2		 add	 eax, edx
  0006c	c1 f8 03	 sar	 eax, 3
  0006f	8d 44 08 20	 lea	 eax, DWORD PTR [eax+ecx+32]
  00073	6a 28		 push	 40			; 00000028H
  00075	8b ce		 mov	 ecx, esi
  00077	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0007a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Realloc@FArray@@IAEXH@Z
$L137312:
  00080	8b 16		 mov	 edx, DWORD PTR [esi]
  00082	8d 0c bf	 lea	 ecx, DWORD PTR [edi+edi*4]
  00085	8d 0c ca	 lea	 ecx, DWORD PTR [edx+ecx*8]
  00088	3b cd		 cmp	 ecx, ebp
  0008a	74 58		 je	 SHORT $L125786
  0008c	8b 03		 mov	 eax, DWORD PTR [ebx]
  0008e	03 44 24 2c	 add	 eax, DWORD PTR 8+[esp+36]
  00092	8b d0		 mov	 edx, eax
  00094	8b 2a		 mov	 ebp, DWORD PTR [edx]
  00096	8b f9		 mov	 edi, ecx
  00098	89 2f		 mov	 DWORD PTR [edi], ebp
  0009a	8b 6a 04	 mov	 ebp, DWORD PTR [edx+4]
  0009d	89 6f 04	 mov	 DWORD PTR [edi+4], ebp
  000a0	8b 6a 08	 mov	 ebp, DWORD PTR [edx+8]
  000a3	89 6f 08	 mov	 DWORD PTR [edi+8], ebp
  000a6	8b 52 0c	 mov	 edx, DWORD PTR [edx+12]
  000a9	89 57 0c	 mov	 DWORD PTR [edi+12], edx
  000ac	8d 68 10	 lea	 ebp, DWORD PTR [eax+16]
  000af	85 ed		 test	 ebp, ebp
  000b1	8d 79 10	 lea	 edi, DWORD PTR [ecx+16]
  000b4	89 7c 24 18	 mov	 DWORD PTR $T137330[esp+40], edi
  000b8	74 05		 je	 SHORT $L137336
  000ba	8d 45 0c	 lea	 eax, DWORD PTR [ebp+12]
  000bd	eb 02		 jmp	 SHORT $L137337
$L137336:
  000bf	33 c0		 xor	 eax, eax
$L137337:
  000c1	50		 push	 eax
  000c2	8d 4f 0c	 lea	 ecx, DWORD PTR [edi+12]
  000c5	e8 00 00 00 00	 call	 ??0?$TArray@E@@QAE@ABV0@@Z ; TArray<unsigned char>::TArray<unsigned char>
  000ca	55		 push	 ebp
  000cb	8b cf		 mov	 ecx, edi
  000cd	c6 44 24 28 01	 mov	 BYTE PTR __$EHRec$[esp+52], 1
  000d2	e8 00 00 00 00	 call	 ??0FLazyLoader@@QAE@ABV0@@Z ; FLazyLoader::FLazyLoader
  000d7	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET FLAT:??_7?$TLazyArray@E@@6B@ ; TLazyArray<unsigned char>::`vftable'
  000dd	c6 44 24 24 00	 mov	 BYTE PTR __$EHRec$[esp+48], 0
  000e2	33 ed		 xor	 ebp, ebp
$L125786:
  000e4	8b 44 24 10	 mov	 eax, DWORD PTR _i$125784[esp+40]
  000e8	8b 54 24 2c	 mov	 edx, DWORD PTR 8+[esp+36]
  000ec	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  000ef	40		 inc	 eax
  000f0	83 c2 28	 add	 edx, 40			; 00000028H
  000f3	3b c1		 cmp	 eax, ecx
  000f5	89 44 24 10	 mov	 DWORD PTR _i$125784[esp+40], eax
  000f9	89 54 24 2c	 mov	 DWORD PTR 8+[esp+36], edx
  000fd	0f 8c 50 ff ff
	ff		 jl	 $L125785
  00103	5f		 pop	 edi
$L137388:

; 356  : 		}
; 357  : 		else if( sizeof(T)!=1 )
; 358  : 		{
; 359  : 			for( INT i=0; i<ArrayNum; i++ )
; 360  : 				(*this)(i) = Other(i);
; 361  : 		}
; 362  : 		else
; 363  : 		{
; 364  : 			appMemcpy( &(*this)(0), (void *)&Other(0), ArrayNum * sizeof(T) );
; 365  : 		}
; 366  : 	}

  00104	8b 4c 24 18	 mov	 ecx, DWORD PTR __$EHRec$[esp+36]
  00108	8b c6		 mov	 eax, esi
  0010a	5e		 pop	 esi
  0010b	5d		 pop	 ebp
  0010c	5b		 pop	 ebx
  0010d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00114	83 c4 18	 add	 esp, 24			; 00000018H
  00117	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L137291:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1FArray@@QAE@XZ
$L137325:
  00009	8b 4d f0	 mov	 ecx, DWORD PTR $T137330[ebp]
  0000c	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0000f	e9 00 00 00 00	 jmp	 ??1?$TArray@E@@QAE@XZ	; TArray<unsigned char>::~TArray<unsigned char>
$L137390:
  00014	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T137383
  00019	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0?$TArray@UFMipmap@@@@QAE@ABV0@@Z ENDP		; TArray<FMipmap>::TArray<FMipmap>
PUBLIC	??_7FLazyLoader@@6B@				; FLazyLoader::`vftable'
EXTRN	__purecall:NEAR
;	COMDAT ??_7FLazyLoader@@6B@
CONST	SEGMENT
??_7FLazyLoader@@6B@ DD FLAT:__purecall			; FLazyLoader::`vftable'
	DD	FLAT:__purecall
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ??0FLazyLoader@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8
??0FLazyLoader@@QAE@ABV0@@Z PROC NEAR			; FLazyLoader::FLazyLoader, COMDAT
; _this$ = ecx
  00000	8b c1		 mov	 eax, ecx
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR ___that$[esp-4]
  00006	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00009	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0000c	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  0000f	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00012	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7FLazyLoader@@6B@ ; FLazyLoader::`vftable'
  00018	c2 04 00	 ret	 4
??0FLazyLoader@@QAE@ABV0@@Z ENDP			; FLazyLoader::FLazyLoader
_TEXT	ENDS
;	COMDAT xdata$x
; File ..\..\Core\Inc\UnFile.h
xdata$x	SEGMENT
$T137457 DD	0ffffffffH
	DD	FLAT:$L137403
$T137451 DD	019930520H
	DD	01H
	DD	FLAT:$T137457
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File ..\..\Core\Inc\UnTemplate.h
xdata$x	ENDS
;	COMDAT ??0?$TArray@E@@QAE@ABV0@@Z
_TEXT	SEGMENT
_this$ = -52
_Other$ = 8
$T137447 = 8
$T137448 = -20
$T137449 = -16
__$EHRec$ = -12
??0?$TArray@E@@QAE@ABV0@@Z PROC NEAR			; TArray<unsigned char>::TArray<unsigned char>, COMDAT
; _this$ = ecx

; 350  : 	{

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 $L137456
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	83 ec 08	 sub	 esp, 8
  00018	53		 push	 ebx
  00019	55		 push	 ebp
  0001a	56		 push	 esi
  0001b	8b 74 24 24	 mov	 esi, DWORD PTR _Other$[esp+28]
  0001f	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00022	8b e9		 mov	 ebp, ecx
  00024	57		 push	 edi
  00025	6a 01		 push	 1
  00027	c7 45 00 00 00
	00 00		 mov	 DWORD PTR [ebp], 0
  0002e	89 45 04	 mov	 DWORD PTR [ebp+4], eax
  00031	89 45 08	 mov	 DWORD PTR [ebp+8], eax
  00034	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Realloc@FArray@@IAEXH@Z

; 351  : 		if( TTypeInfo<T>::NeedsDestructor() )
; 352  : 		{
; 353  : 			ArrayNum=0;
; 354  : 			for( INT i=0; i<Other.ArrayNum; i++ )
; 355  : 				new(*this)T(Other(i));
; 356  : 		}
; 357  : 		else if( sizeof(T)!=1 )
; 358  : 		{
; 359  : 			for( INT i=0; i<ArrayNum; i++ )
; 360  : 				(*this)(i) = Other(i);
; 361  : 		}
; 362  : 		else
; 363  : 		{
; 364  : 			appMemcpy( &(*this)(0), (void *)&Other(0), ArrayNum * sizeof(T) );

  0003a	8b 45 04	 mov	 eax, DWORD PTR [ebp+4]
  0003d	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0003f	8b 55 00	 mov	 edx, DWORD PTR [ebp]
  00042	89 44 24 14	 mov	 DWORD PTR $T137449[esp+36], eax
  00046	89 4c 24 10	 mov	 DWORD PTR $T137448[esp+36], ecx
  0004a	89 54 24 28	 mov	 DWORD PTR $T137447[esp+32], edx
  0004e	8b 4c 24 14	 mov	 ecx, DWORD PTR $T137449[esp+36]
  00052	8b 74 24 10	 mov	 esi, DWORD PTR $T137448[esp+36]
  00056	8b 7c 24 28	 mov	 edi, DWORD PTR $T137447[esp+32]
  0005a	8b d9		 mov	 ebx, ecx
  0005c	c1 e9 02	 shr	 ecx, 2
  0005f	83 e3 03	 and	 ebx, 3
  00062	f3 a5		 rep	  movsd
  00064	8b cb		 mov	 ecx, ebx
  00066	f3 a4		 rep	  movsb

; 365  : 		}
; 366  : 	}

  00068	8b 4c 24 18	 mov	 ecx, DWORD PTR __$EHRec$[esp+36]
  0006c	5f		 pop	 edi
  0006d	5e		 pop	 esi
  0006e	8b c5		 mov	 eax, ebp
  00070	5d		 pop	 ebp
  00071	5b		 pop	 ebx
  00072	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00079	83 c4 14	 add	 esp, 20			; 00000014H
  0007c	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L137403:
  00000	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1FArray@@QAE@XZ
$L137456:
  00009	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T137451
  0000e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0?$TArray@E@@QAE@ABV0@@Z ENDP				; TArray<unsigned char>::TArray<unsigned char>
PUBLIC	??2@YAPAXIAAV?$TArray@UFMipmap@@@@@Z		; operator new
PUBLIC	??4UFractalTexture@@QAEAAV0@ABV0@@Z		; UFractalTexture::operator=
PUBLIC	??4?$TArray@UFMipmap@@@@QAEAAV0@ABV0@@Z		; TArray<FMipmap>::operator=
EXTRN	__imp_??0FMipmap@@QAE@ABU0@@Z:NEAR
EXTRN	__imp_??4UObject@@QAEAAV0@ABV0@@Z:NEAR
; Function compile flags: /Ogty
;	COMDAT ??4UFractalTexture@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
$T137490 = -4
_i$137561 = -8
_i$137569 = -8
___that$ = 8
??4UFractalTexture@@QAEAAV0@ABV0@@Z PROC NEAR		; UFractalTexture::operator=, COMDAT
; _this$ = ecx
  00000	83 ec 08	 sub	 esp, 8
  00003	53		 push	 ebx
  00004	55		 push	 ebp
  00005	56		 push	 esi
  00006	57		 push	 edi
  00007	8b 7c 24 1c	 mov	 edi, DWORD PTR ___that$[esp+20]
  0000b	57		 push	 edi
  0000c	8b f1		 mov	 esi, ecx
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4UObject@@QAEAAV0@ABV0@@Z
  00014	8a 47 28	 mov	 al, BYTE PTR [edi+40]
  00017	88 46 28	 mov	 BYTE PTR [esi+40], al
  0001a	8b 4f 2c	 mov	 ecx, DWORD PTR [edi+44]
  0001d	89 4e 2c	 mov	 DWORD PTR [esi+44], ecx
  00020	8a 57 30	 mov	 dl, BYTE PTR [edi+48]
  00023	88 56 30	 mov	 BYTE PTR [esi+48], dl
  00026	8a 47 31	 mov	 al, BYTE PTR [edi+49]
  00029	88 46 31	 mov	 BYTE PTR [esi+49], al
  0002c	8b 4f 34	 mov	 ecx, DWORD PTR [edi+52]
  0002f	89 4e 34	 mov	 DWORD PTR [esi+52], ecx
  00032	8b 57 38	 mov	 edx, DWORD PTR [edi+56]
  00035	89 56 38	 mov	 DWORD PTR [esi+56], edx
  00038	8b 47 3c	 mov	 eax, DWORD PTR [edi+60]
  0003b	89 46 3c	 mov	 DWORD PTR [esi+60], eax
  0003e	8b 4f 40	 mov	 ecx, DWORD PTR [edi+64]
  00041	89 4e 40	 mov	 DWORD PTR [esi+64], ecx
  00044	8b 57 44	 mov	 edx, DWORD PTR [edi+68]
  00047	89 56 44	 mov	 DWORD PTR [esi+68], edx
  0004a	8b 47 48	 mov	 eax, DWORD PTR [edi+72]
  0004d	89 46 48	 mov	 DWORD PTR [esi+72], eax
  00050	8b 4f 4c	 mov	 ecx, DWORD PTR [edi+76]
  00053	89 4e 4c	 mov	 DWORD PTR [esi+76], ecx
  00056	8b 57 50	 mov	 edx, DWORD PTR [edi+80]
  00059	89 56 50	 mov	 DWORD PTR [esi+80], edx
  0005c	8b 47 54	 mov	 eax, DWORD PTR [edi+84]
  0005f	89 46 54	 mov	 DWORD PTR [esi+84], eax
  00062	8b 4f 58	 mov	 ecx, DWORD PTR [edi+88]
  00065	89 4e 58	 mov	 DWORD PTR [esi+88], ecx
  00068	8b 57 5c	 mov	 edx, DWORD PTR [edi+92]
  0006b	89 56 5c	 mov	 DWORD PTR [esi+92], edx
  0006e	8b 47 60	 mov	 eax, DWORD PTR [edi+96]
  00071	89 46 60	 mov	 DWORD PTR [esi+96], eax
  00074	8b 4f 64	 mov	 ecx, DWORD PTR [edi+100]
  00077	89 4e 64	 mov	 DWORD PTR [esi+100], ecx
  0007a	8b 57 68	 mov	 edx, DWORD PTR [edi+104]
  0007d	89 56 68	 mov	 DWORD PTR [esi+104], edx
  00080	8b 47 6c	 mov	 eax, DWORD PTR [edi+108]
  00083	89 46 6c	 mov	 DWORD PTR [esi+108], eax
  00086	8b 4f 70	 mov	 ecx, DWORD PTR [edi+112]
  00089	89 4e 70	 mov	 DWORD PTR [esi+112], ecx
  0008c	8b 57 74	 mov	 edx, DWORD PTR [edi+116]
  0008f	89 56 74	 mov	 DWORD PTR [esi+116], edx
  00092	8b 47 78	 mov	 eax, DWORD PTR [edi+120]
  00095	89 46 78	 mov	 DWORD PTR [esi+120], eax
  00098	8b 4f 7c	 mov	 ecx, DWORD PTR [edi+124]
  0009b	89 4e 7c	 mov	 DWORD PTR [esi+124], ecx
  0009e	8b 97 80 00 00
	00		 mov	 edx, DWORD PTR [edi+128]
  000a4	8b 8e 88 00 00
	00		 mov	 ecx, DWORD PTR [esi+136]
  000aa	89 96 80 00 00
	00		 mov	 DWORD PTR [esi+128], edx
  000b0	8b 87 84 00 00
	00		 mov	 eax, DWORD PTR [edi+132]
  000b6	89 86 84 00 00
	00		 mov	 DWORD PTR [esi+132], eax
  000bc	8b 87 88 00 00
	00		 mov	 eax, DWORD PTR [edi+136]
  000c2	33 c1		 xor	 eax, ecx
  000c4	83 e0 01	 and	 eax, 1
  000c7	33 c1		 xor	 eax, ecx
  000c9	89 86 88 00 00
	00		 mov	 DWORD PTR [esi+136], eax
  000cf	8b 8f 88 00 00
	00		 mov	 ecx, DWORD PTR [edi+136]
  000d5	33 c8		 xor	 ecx, eax
  000d7	83 e1 02	 and	 ecx, 2
  000da	33 c8		 xor	 ecx, eax
  000dc	89 8e 88 00 00
	00		 mov	 DWORD PTR [esi+136], ecx
  000e2	8b 87 88 00 00
	00		 mov	 eax, DWORD PTR [edi+136]
  000e8	33 c1		 xor	 eax, ecx
  000ea	83 e0 04	 and	 eax, 4
  000ed	33 c1		 xor	 eax, ecx
  000ef	89 86 88 00 00
	00		 mov	 DWORD PTR [esi+136], eax
  000f5	8b 8f 88 00 00
	00		 mov	 ecx, DWORD PTR [edi+136]
  000fb	33 c8		 xor	 ecx, eax
  000fd	83 e1 08	 and	 ecx, 8
  00100	33 c8		 xor	 ecx, eax
  00102	89 8e 88 00 00
	00		 mov	 DWORD PTR [esi+136], ecx
  00108	8b 87 88 00 00
	00		 mov	 eax, DWORD PTR [edi+136]
  0010e	33 c1		 xor	 eax, ecx
  00110	83 e0 10	 and	 eax, 16			; 00000010H
  00113	33 c1		 xor	 eax, ecx
  00115	89 86 88 00 00
	00		 mov	 DWORD PTR [esi+136], eax
  0011b	8b 8f 88 00 00
	00		 mov	 ecx, DWORD PTR [edi+136]
  00121	33 c8		 xor	 ecx, eax
  00123	83 e1 20	 and	 ecx, 32			; 00000020H
  00126	33 c8		 xor	 ecx, eax
  00128	89 8e 88 00 00
	00		 mov	 DWORD PTR [esi+136], ecx
  0012e	8a 97 8c 00 00
	00		 mov	 dl, BYTE PTR [edi+140]
  00134	88 96 8c 00 00
	00		 mov	 BYTE PTR [esi+140], dl
  0013a	8b 87 90 00 00
	00		 mov	 eax, DWORD PTR [edi+144]
  00140	89 86 90 00 00
	00		 mov	 DWORD PTR [esi+144], eax
  00146	8b 8f 94 00 00
	00		 mov	 ecx, DWORD PTR [edi+148]
  0014c	89 8e 94 00 00
	00		 mov	 DWORD PTR [esi+148], ecx
  00152	8a 97 98 00 00
	00		 mov	 dl, BYTE PTR [edi+152]
  00158	88 96 98 00 00
	00		 mov	 BYTE PTR [esi+152], dl
  0015e	8a 87 99 00 00
	00		 mov	 al, BYTE PTR [edi+153]
  00164	88 86 99 00 00
	00		 mov	 BYTE PTR [esi+153], al
  0016a	8b 8f 9c 00 00
	00		 mov	 ecx, DWORD PTR [edi+156]
  00170	89 8e 9c 00 00
	00		 mov	 DWORD PTR [esi+156], ecx
  00176	8b 97 a0 00 00
	00		 mov	 edx, DWORD PTR [edi+160]
  0017c	89 96 a0 00 00
	00		 mov	 DWORD PTR [esi+160], edx
  00182	8b 87 a4 00 00
	00		 mov	 eax, DWORD PTR [edi+164]
  00188	8d af a8 00 00
	00		 lea	 ebp, DWORD PTR [edi+168]
  0018e	8d 9e a8 00 00
	00		 lea	 ebx, DWORD PTR [esi+168]
  00194	3b dd		 cmp	 ebx, ebp
  00196	89 86 a4 00 00
	00		 mov	 DWORD PTR [esi+164], eax
  0019c	0f 84 a8 00 00
	00		 je	 $L137572
  001a2	8b 4d 04	 mov	 ecx, DWORD PTR [ebp+4]
  001a5	89 4c 24 14	 mov	 DWORD PTR $T137490[esp+24], ecx
  001a9	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  001ac	33 c0		 xor	 eax, eax
  001ae	3b c8		 cmp	 ecx, eax
  001b0	89 44 24 10	 mov	 DWORD PTR _i$137561[esp+24], eax
  001b4	7e 34		 jle	 SHORT $L137564
  001b6	89 44 24 1c	 mov	 DWORD PTR 8+[esp+20], eax
  001ba	8d 9b 00 00 00
	00		 npad	 6
$L137562:
  001c0	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  001c2	8b 54 24 1c	 mov	 edx, DWORD PTR 8+[esp+20]
  001c6	6a 00		 push	 0
  001c8	03 ca		 add	 ecx, edx
  001ca	e8 00 00 00 00	 call	 ??_GFMipmap@@QAEPAXI@Z	; FMipmap::`scalar deleting destructor'
  001cf	8b 44 24 10	 mov	 eax, DWORD PTR _i$137561[esp+24]
  001d3	8b 54 24 1c	 mov	 edx, DWORD PTR 8+[esp+20]
  001d7	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  001da	40		 inc	 eax
  001db	83 c2 28	 add	 edx, 40			; 00000028H
  001de	3b c1		 cmp	 eax, ecx
  001e0	89 44 24 10	 mov	 DWORD PTR _i$137561[esp+24], eax
  001e4	89 54 24 1c	 mov	 DWORD PTR 8+[esp+20], edx
  001e8	7c d6		 jl	 SHORT $L137562
$L137564:
  001ea	8b 54 24 14	 mov	 edx, DWORD PTR $T137490[esp+24]
  001ee	52		 push	 edx
  001ef	6a 28		 push	 40			; 00000028H
  001f1	8b cb		 mov	 ecx, ebx
  001f3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Empty@FArray@@QAEXHH@Z
  001f9	8b 4d 04	 mov	 ecx, DWORD PTR [ebp+4]
  001fc	33 c0		 xor	 eax, eax
  001fe	3b c8		 cmp	 ecx, eax
  00200	89 44 24 10	 mov	 DWORD PTR _i$137569[esp+24], eax
  00204	7e 44		 jle	 SHORT $L137572
  00206	89 44 24 1c	 mov	 DWORD PTR 8+[esp+20], eax
  0020a	8d 9b 00 00 00
	00		 npad	 6
$L137570:
  00210	53		 push	 ebx
  00211	6a 28		 push	 40			; 00000028H
  00213	e8 00 00 00 00	 call	 ??2@YAPAXIAAV?$TArray@UFMipmap@@@@@Z ; operator new
  00218	83 c4 08	 add	 esp, 8
  0021b	85 c0		 test	 eax, eax
  0021d	74 10		 je	 SHORT $L137571
  0021f	8b 4d 00	 mov	 ecx, DWORD PTR [ebp]
  00222	03 4c 24 1c	 add	 ecx, DWORD PTR 8+[esp+20]
  00226	51		 push	 ecx
  00227	8b c8		 mov	 ecx, eax
  00229	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0FMipmap@@QAE@ABU0@@Z
$L137571:
  0022f	8b 44 24 10	 mov	 eax, DWORD PTR _i$137569[esp+24]
  00233	8b 54 24 1c	 mov	 edx, DWORD PTR 8+[esp+20]
  00237	8b 4d 04	 mov	 ecx, DWORD PTR [ebp+4]
  0023a	40		 inc	 eax
  0023b	83 c2 28	 add	 edx, 40			; 00000028H
  0023e	3b c1		 cmp	 eax, ecx
  00240	89 44 24 10	 mov	 DWORD PTR _i$137569[esp+24], eax
  00244	89 54 24 1c	 mov	 DWORD PTR 8+[esp+20], edx
  00248	7c c6		 jl	 SHORT $L137570
$L137572:
  0024a	8d 97 b4 00 00
	00		 lea	 edx, DWORD PTR [edi+180]
  00250	52		 push	 edx
  00251	8d 8e b4 00 00
	00		 lea	 ecx, DWORD PTR [esi+180]
  00257	e8 00 00 00 00	 call	 ??4?$TArray@UFMipmap@@@@QAEAAV0@ABV0@@Z ; TArray<FMipmap>::operator=
  0025c	8a 87 c0 00 00
	00		 mov	 al, BYTE PTR [edi+192]
  00262	88 86 c0 00 00
	00		 mov	 BYTE PTR [esi+192], al
  00268	8b 8f c4 00 00
	00		 mov	 ecx, DWORD PTR [edi+196]
  0026e	89 8e c4 00 00
	00		 mov	 DWORD PTR [esi+196], ecx
  00274	8b 97 c8 00 00
	00		 mov	 edx, DWORD PTR [edi+200]
  0027a	89 96 c8 00 00
	00		 mov	 DWORD PTR [esi+200], edx
  00280	8b 87 cc 00 00
	00		 mov	 eax, DWORD PTR [edi+204]
  00286	89 86 cc 00 00
	00		 mov	 DWORD PTR [esi+204], eax
  0028c	8b 8f d0 00 00
	00		 mov	 ecx, DWORD PTR [edi+208]
  00292	89 8e d0 00 00
	00		 mov	 DWORD PTR [esi+208], ecx
  00298	8b 97 d4 00 00
	00		 mov	 edx, DWORD PTR [edi+212]
  0029e	89 96 d4 00 00
	00		 mov	 DWORD PTR [esi+212], edx
  002a4	8b 87 d8 00 00
	00		 mov	 eax, DWORD PTR [edi+216]
  002aa	89 86 d8 00 00
	00		 mov	 DWORD PTR [esi+216], eax
  002b0	8a 8f dc 00 00
	00		 mov	 cl, BYTE PTR [edi+220]
  002b6	88 8e dc 00 00
	00		 mov	 BYTE PTR [esi+220], cl
  002bc	8a 97 dd 00 00
	00		 mov	 dl, BYTE PTR [edi+221]
  002c2	5f		 pop	 edi
  002c3	88 96 dd 00 00
	00		 mov	 BYTE PTR [esi+221], dl
  002c9	8b c6		 mov	 eax, esi
  002cb	5e		 pop	 esi
  002cc	5d		 pop	 ebp
  002cd	5b		 pop	 ebx
  002ce	83 c4 08	 add	 esp, 8
  002d1	c2 04 00	 ret	 4
??4UFractalTexture@@QAEAAV0@ABV0@@Z ENDP		; UFractalTexture::operator=
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??4?$TArray@UFMipmap@@@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
$T137624 = 8
_Other$ = 8
??4?$TArray@UFMipmap@@@@QAEAAV0@ABV0@@Z PROC NEAR	; TArray<FMipmap>::operator=, COMDAT
; _this$ = ecx

; 526  : 	{

  00000	53		 push	 ebx
  00001	55		 push	 ebp

; 527  : 		if( this != &Other )

  00002	8b 6c 24 0c	 mov	 ebp, DWORD PTR _Other$[esp+4]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	3b f5		 cmp	 esi, ebp
  0000b	57		 push	 edi
  0000c	0f 84 a8 00 00
	00		 je	 $L137651

; 528  : 		{
; 529  : 			Empty( Other.ArrayNum );

  00012	8b 45 04	 mov	 eax, DWORD PTR [ebp+4]
  00015	89 44 24 14	 mov	 DWORD PTR $T137624[esp+12], eax
  00019	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0001c	33 ff		 xor	 edi, edi
  0001e	85 c0		 test	 eax, eax
  00020	7e 17		 jle	 SHORT $L137623
  00022	33 db		 xor	 ebx, ebx
$L137621:
  00024	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00026	03 cb		 add	 ecx, ebx
  00028	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1FMipmap@@QAE@XZ
  0002e	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00031	47		 inc	 edi
  00032	83 c3 28	 add	 ebx, 40			; 00000028H
  00035	3b f8		 cmp	 edi, eax
  00037	7c eb		 jl	 SHORT $L137621
$L137623:
  00039	8b 4c 24 14	 mov	 ecx, DWORD PTR $T137624[esp+12]
  0003d	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  00040	6a 28		 push	 40			; 00000028H
  00042	8b ce		 mov	 ecx, esi
  00044	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0004b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Realloc@FArray@@IAEXH@Z

; 530  : 			for( INT i=0; i<Other.ArrayNum; i++ )

  00051	8b 45 04	 mov	 eax, DWORD PTR [ebp+4]
  00054	33 db		 xor	 ebx, ebx
  00056	3b c3		 cmp	 eax, ebx
  00058	7e 60		 jle	 SHORT $L137651

; 528  : 		{
; 529  : 			Empty( Other.ArrayNum );

  0005a	89 5c 24 14	 mov	 DWORD PTR 8+[esp+12], ebx

; 534  : 	}

  0005e	8b ff		 npad	 2
$L125816:

; 531  : 				new( *this )T( Other(i) );

  00060	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  00063	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00066	8d 4f 01	 lea	 ecx, DWORD PTR [edi+1]
  00069	3b c8		 cmp	 ecx, eax
  0006b	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  0006e	7e 1d		 jle	 SHORT $L137640
  00070	8d 04 49	 lea	 eax, DWORD PTR [ecx+ecx*2]
  00073	99		 cdq
  00074	83 e2 07	 and	 edx, 7
  00077	03 c2		 add	 eax, edx
  00079	c1 f8 03	 sar	 eax, 3
  0007c	8d 54 08 20	 lea	 edx, DWORD PTR [eax+ecx+32]
  00080	6a 28		 push	 40			; 00000028H
  00082	8b ce		 mov	 ecx, esi
  00084	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00087	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Realloc@FArray@@IAEXH@Z
$L137640:
  0008d	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0008f	8d 04 bf	 lea	 eax, DWORD PTR [edi+edi*4]
  00092	8d 0c c1	 lea	 ecx, DWORD PTR [ecx+eax*8]
  00095	85 c9		 test	 ecx, ecx
  00097	74 0e		 je	 SHORT $L125817
  00099	8b 55 00	 mov	 edx, DWORD PTR [ebp]
  0009c	03 54 24 14	 add	 edx, DWORD PTR 8+[esp+12]
  000a0	52		 push	 edx
  000a1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0FMipmap@@QAE@ABU0@@Z
$L125817:
  000a7	8b 4c 24 14	 mov	 ecx, DWORD PTR 8+[esp+12]
  000ab	8b 45 04	 mov	 eax, DWORD PTR [ebp+4]
  000ae	43		 inc	 ebx
  000af	83 c1 28	 add	 ecx, 40			; 00000028H
  000b2	3b d8		 cmp	 ebx, eax
  000b4	89 4c 24 14	 mov	 DWORD PTR 8+[esp+12], ecx
  000b8	7c a6		 jl	 SHORT $L125816
$L137651:
  000ba	5f		 pop	 edi

; 532  : 		}
; 533  : 		return *this;

  000bb	8b c6		 mov	 eax, esi
  000bd	5e		 pop	 esi
  000be	5d		 pop	 ebp
  000bf	5b		 pop	 ebx

; 534  : 	}

  000c0	c2 04 00	 ret	 4
??4?$TArray@UFMipmap@@@@QAEAAV0@ABV0@@Z ENDP		; TArray<FMipmap>::operator=
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??2@YAPAXIAAV?$TArray@UFMipmap@@@@@Z
_TEXT	SEGMENT
_Array$ = 12
??2@YAPAXIAAV?$TArray@UFMipmap@@@@@Z PROC NEAR		; operator new, COMDAT

; 587  : {

  00000	56		 push	 esi

; 588  : 	INT Index = Array.FArray::Add(1,sizeof(T));

  00001	8b 74 24 0c	 mov	 esi, DWORD PTR _Array$[esp]
  00005	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00008	57		 push	 edi
  00009	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  0000c	8d 4f 01	 lea	 ecx, DWORD PTR [edi+1]
  0000f	3b c8		 cmp	 ecx, eax
  00011	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  00014	7e 1d		 jle	 SHORT $L137659
  00016	8d 04 49	 lea	 eax, DWORD PTR [ecx+ecx*2]
  00019	99		 cdq
  0001a	83 e2 07	 and	 edx, 7
  0001d	03 c2		 add	 eax, edx
  0001f	c1 f8 03	 sar	 eax, 3
  00022	8d 44 08 20	 lea	 eax, DWORD PTR [eax+ecx+32]
  00026	6a 28		 push	 40			; 00000028H
  00028	8b ce		 mov	 ecx, esi
  0002a	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Realloc@FArray@@IAEXH@Z
$L137659:

; 589  : 	return &Array(Index);

  00033	8b 16		 mov	 edx, DWORD PTR [esi]
  00035	8d 0c bf	 lea	 ecx, DWORD PTR [edi+edi*4]
  00038	5f		 pop	 edi
  00039	8d 04 ca	 lea	 eax, DWORD PTR [edx+ecx*8]
  0003c	5e		 pop	 esi

; 590  : }

  0003d	c3		 ret	 0
??2@YAPAXIAAV?$TArray@UFMipmap@@@@@Z ENDP		; operator new
_TEXT	ENDS
PUBLIC	??_GUFractalTexture@@UAEPAXI@Z			; UFractalTexture::`scalar deleting destructor'
; Function compile flags: /Ogty
;	COMDAT ??_GUFractalTexture@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_GUFractalTexture@@UAEPAXI@Z PROC NEAR		; UFractalTexture::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	e8 00 00 00 00	 call	 ??1UFractalTexture@@UAE@XZ ; UFractalTexture::~UFractalTexture
  00008	f6 44 24 08 01	 test	 BYTE PTR ___flags$[esp], 1
  0000d	74 0d		 je	 SHORT $L137669
  0000f	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?GMalloc@@3PAVFMalloc@@A
  00014	8b 08		 mov	 ecx, DWORD PTR [eax]
  00016	8b 11		 mov	 edx, DWORD PTR [ecx]
  00018	56		 push	 esi
  00019	ff 52 08	 call	 DWORD PTR [edx+8]
$L137669:
  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi
  0001f	c2 04 00	 ret	 4
??_GUFractalTexture@@UAEPAXI@Z ENDP			; UFractalTexture::`scalar deleting destructor'
_TEXT	ENDS
EXTRN	??_M@YGXPAXIHP6EX0@Z@Z:NEAR			; `eh vector destructor iterator'
; Function compile flags: /Ogty
;	COMDAT ??_EUFractalTexture@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_EUFractalTexture@@UAEPAXI@Z PROC NEAR		; UFractalTexture::`vector deleting destructor', COMDAT
; _this$ = ecx
  00000	53		 push	 ebx
  00001	8a 5c 24 08	 mov	 bl, BYTE PTR ___flags$[esp]
  00005	f6 c3 02	 test	 bl, 2
  00008	56		 push	 esi
  00009	8b f1		 mov	 esi, ecx
  0000b	74 33		 je	 SHORT $L122793
  0000d	8b 46 fc	 mov	 eax, DWORD PTR [esi-4]
  00010	57		 push	 edi
  00011	68 00 00 00 00	 push	 OFFSET FLAT:??1UFractalTexture@@UAE@XZ ; UFractalTexture::~UFractalTexture
  00016	8d 7e fc	 lea	 edi, DWORD PTR [esi-4]
  00019	50		 push	 eax
  0001a	68 e0 00 00 00	 push	 224			; 000000e0H
  0001f	56		 push	 esi
  00020	e8 00 00 00 00	 call	 ??_M@YGXPAXIHP6EX0@Z@Z	; `eh vector destructor iterator'
  00025	f6 c3 01	 test	 bl, 1
  00028	74 0e		 je	 SHORT $L137675
  0002a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?GMalloc@@3PAVFMalloc@@A
  00030	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00032	8b 11		 mov	 edx, DWORD PTR [ecx]
  00034	57		 push	 edi
  00035	ff 52 08	 call	 DWORD PTR [edx+8]
$L137675:
  00038	8b c7		 mov	 eax, edi
  0003a	5f		 pop	 edi
  0003b	5e		 pop	 esi
  0003c	5b		 pop	 ebx
  0003d	c2 04 00	 ret	 4
$L122793:
  00040	8b ce		 mov	 ecx, esi
  00042	e8 00 00 00 00	 call	 ??1UFractalTexture@@UAE@XZ ; UFractalTexture::~UFractalTexture
  00047	f6 c3 01	 test	 bl, 1
  0004a	74 0d		 je	 SHORT $L137677
  0004c	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?GMalloc@@3PAVFMalloc@@A
  00051	8b 08		 mov	 ecx, DWORD PTR [eax]
  00053	8b 11		 mov	 edx, DWORD PTR [ecx]
  00055	56		 push	 esi
  00056	ff 52 08	 call	 DWORD PTR [edx+8]
$L137677:
  00059	8b c6		 mov	 eax, esi
  0005b	5e		 pop	 esi
  0005c	5b		 pop	 ebx
  0005d	c2 04 00	 ret	 4
??_EUFractalTexture@@UAEPAXI@Z ENDP			; UFractalTexture::`vector deleting destructor'
; Function compile flags: /Ogty
; File C:\duke4\Fire\Src\FractalPrivate.h
_TEXT	ENDS
;	COMDAT ??6@YAAAVFArchive@@AAV0@AAVFSpark@@@Z
_TEXT	SEGMENT
_Ar$ = 8
_S$ = 12
??6@YAAAVFArchive@@AAV0@AAVFSpark@@@Z PROC NEAR		; operator<<, COMDAT

; 175  : 	{

  00000	56		 push	 esi

; 176  : 		return  Ar << S.Type << S.Heat << S.X << S.Y << S.ByteA << S.ByteB << S.ByteC << S.ByteD;

  00001	8b 74 24 08	 mov	 esi, DWORD PTR _Ar$[esp]
  00005	8b 06		 mov	 eax, DWORD PTR [esi]
  00007	57		 push	 edi
  00008	8b 7c 24 10	 mov	 edi, DWORD PTR _S$[esp+4]
  0000c	6a 01		 push	 1
  0000e	57		 push	 edi
  0000f	8b ce		 mov	 ecx, esi
  00011	ff 50 04	 call	 DWORD PTR [eax+4]
  00014	8b 16		 mov	 edx, DWORD PTR [esi]
  00016	6a 01		 push	 1
  00018	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  0001b	50		 push	 eax
  0001c	8b ce		 mov	 ecx, esi
  0001e	ff 52 04	 call	 DWORD PTR [edx+4]
  00021	8b 16		 mov	 edx, DWORD PTR [esi]
  00023	6a 01		 push	 1
  00025	8d 47 02	 lea	 eax, DWORD PTR [edi+2]
  00028	50		 push	 eax
  00029	8b ce		 mov	 ecx, esi
  0002b	ff 52 04	 call	 DWORD PTR [edx+4]
  0002e	8b 16		 mov	 edx, DWORD PTR [esi]
  00030	6a 01		 push	 1
  00032	8d 47 03	 lea	 eax, DWORD PTR [edi+3]
  00035	50		 push	 eax
  00036	8b ce		 mov	 ecx, esi
  00038	ff 52 04	 call	 DWORD PTR [edx+4]
  0003b	8b 16		 mov	 edx, DWORD PTR [esi]
  0003d	6a 01		 push	 1
  0003f	8d 47 04	 lea	 eax, DWORD PTR [edi+4]
  00042	50		 push	 eax
  00043	8b ce		 mov	 ecx, esi
  00045	ff 52 04	 call	 DWORD PTR [edx+4]
  00048	8b 16		 mov	 edx, DWORD PTR [esi]
  0004a	6a 01		 push	 1
  0004c	8d 47 05	 lea	 eax, DWORD PTR [edi+5]
  0004f	50		 push	 eax
  00050	8b ce		 mov	 ecx, esi
  00052	ff 52 04	 call	 DWORD PTR [edx+4]
  00055	8b 16		 mov	 edx, DWORD PTR [esi]
  00057	6a 01		 push	 1
  00059	8d 47 06	 lea	 eax, DWORD PTR [edi+6]
  0005c	50		 push	 eax
  0005d	8b ce		 mov	 ecx, esi
  0005f	ff 52 04	 call	 DWORD PTR [edx+4]
  00062	8b 16		 mov	 edx, DWORD PTR [esi]
  00064	6a 01		 push	 1
  00066	83 c7 07	 add	 edi, 7
  00069	57		 push	 edi
  0006a	8b ce		 mov	 ecx, esi
  0006c	ff 52 04	 call	 DWORD PTR [edx+4]
  0006f	5f		 pop	 edi
  00070	8b c6		 mov	 eax, esi
  00072	5e		 pop	 esi

; 177  : 	}

  00073	c3		 ret	 0
??6@YAAAVFArchive@@AAV0@AAVFSpark@@@Z ENDP		; operator<<
_TEXT	ENDS
PUBLIC	??4FSpark@@QAEAAV0@ABV0@@Z			; FSpark::operator=
; Function compile flags: /Ogty
;	COMDAT ??4FSpark@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8
??4FSpark@@QAEAAV0@ABV0@@Z PROC NEAR			; FSpark::operator=, COMDAT
; _this$ = ecx
  00000	8b c1		 mov	 eax, ecx
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR ___that$[esp-4]
  00006	8b 11		 mov	 edx, DWORD PTR [ecx]
  00008	89 10		 mov	 DWORD PTR [eax], edx
  0000a	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0000d	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00010	c2 04 00	 ret	 4
??4FSpark@@QAEAAV0@ABV0@@Z ENDP				; FSpark::operator=
_TEXT	ENDS
PUBLIC	?StaticClass@UFireTexture@@SAPAVUClass@@XZ	; UFireTexture::StaticClass
; Function compile flags: /Ogty
;	COMDAT ?StaticClass@UFireTexture@@SAPAVUClass@@XZ
_TEXT	SEGMENT
?StaticClass@UFireTexture@@SAPAVUClass@@XZ PROC NEAR	; UFireTexture::StaticClass, COMDAT

; 187  : 	DECLARE_CLASS(UFireTexture,UFractalTexture,0)

  00000	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?PrivateStaticClass@UFireTexture@@0VUClass@@A ; UFireTexture::PrivateStaticClass
  00005	c3		 ret	 0
?StaticClass@UFireTexture@@SAPAVUClass@@XZ ENDP		; UFireTexture::StaticClass
_TEXT	ENDS
PUBLIC	??2UFireTexture@@SAPAXIPAVUObject@@VFName@@K@Z	; UFireTexture::operator new
; Function compile flags: /Ogty
;	COMDAT ??2UFireTexture@@SAPAXIPAVUObject@@VFName@@K@Z
_TEXT	SEGMENT
_Outer$ = 12
_Name$ = 16
_SetFlags$ = 20
??2UFireTexture@@SAPAXIPAVUObject@@VFName@@K@Z PROC NEAR ; UFireTexture::operator new, COMDAT

; 187  : 	DECLARE_CLASS(UFireTexture,UFractalTexture,0)

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?GError@@3PAVFOutputDeviceError@@A
  00005	8b 08		 mov	 ecx, DWORD PTR [eax]
  00007	8b 54 24 10	 mov	 edx, DWORD PTR _SetFlags$[esp-4]
  0000b	8b 44 24 0c	 mov	 eax, DWORD PTR _Name$[esp-4]
  0000f	6a 00		 push	 0
  00011	51		 push	 ecx
  00012	8b 4c 24 10	 mov	 ecx, DWORD PTR _Outer$[esp+4]
  00016	6a 00		 push	 0
  00018	52		 push	 edx
  00019	50		 push	 eax
  0001a	51		 push	 ecx
  0001b	68 00 00 00 00	 push	 OFFSET FLAT:?PrivateStaticClass@UFireTexture@@0VUClass@@A ; UFireTexture::PrivateStaticClass
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?StaticAllocateObject@UObject@@SAPAV1@PAVUClass@@PAV1@VFName@@K1PAVFOutputDevice@@1@Z
  00026	83 c4 1c	 add	 esp, 28			; 0000001cH
  00029	c3		 ret	 0
??2UFireTexture@@SAPAXIPAVUObject@@VFName@@K@Z ENDP	; UFireTexture::operator new
_TEXT	ENDS
PUBLIC	??2UFireTexture@@SAPAXIPAW4EInternal@@@Z	; UFireTexture::operator new
; Function compile flags: /Ogty
;	COMDAT ??2UFireTexture@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT
_Mem$ = 12
??2UFireTexture@@SAPAXIPAW4EInternal@@@Z PROC NEAR	; UFireTexture::operator new, COMDAT

; 187  : 	DECLARE_CLASS(UFireTexture,UFractalTexture,0)

  00000	8b 44 24 08	 mov	 eax, DWORD PTR _Mem$[esp-4]
  00004	c3		 ret	 0
??2UFireTexture@@SAPAXIPAW4EInternal@@@Z ENDP		; UFireTexture::operator new
_TEXT	ENDS
PUBLIC	?Remove@?$TArray@UFMipmap@@@@QAEXHH@Z		; TArray<FMipmap>::Remove
PUBLIC	??1UFireTexture@@UAE@XZ				; UFireTexture::~UFireTexture
PUBLIC	??1?$TArray@VFSpark@@@@QAE@XZ			; TArray<FSpark>::~TArray<FSpark>
;	COMDAT xdata$x
; File ..\..\Engine\Inc\UnTex.h
xdata$x	SEGMENT
$T137856 DD	0ffffffffH
	DD	FLAT:$L137724
	DD	00H
	DD	FLAT:$L137725
	DD	00H
	DD	FLAT:$L137727
	DD	0ffffffffH
	DD	FLAT:$L137768
	DD	0ffffffffH
	DD	FLAT:$L137770
	DD	0ffffffffH
	DD	FLAT:$L137772
	DD	05H
	DD	FLAT:$L137773
	DD	06H
	DD	FLAT:$L137774
	DD	06H
	DD	FLAT:$L137776
	DD	05H
	DD	FLAT:$L137788
	DD	0ffffffffH
	DD	FLAT:$L137800
$T137852 DD	019930520H
	DD	0bH
	DD	FLAT:$T137856
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File C:\duke4\Fire\Src\FractalPrivate.h
xdata$x	ENDS
;	COMDAT ??1UFireTexture@@UAE@XZ
_TEXT	SEGMENT
_this$ = -20
$T137766 = -16
$T137786 = -16
$T137798 = -16
__$EHRec$ = -12
??1UFireTexture@@UAE@XZ PROC NEAR			; UFireTexture::~UFireTexture, COMDAT
; _this$ = ecx

; 187  : 	DECLARE_CLASS(UFireTexture,UFractalTexture,0)

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 $L137855
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	83 ec 08	 sub	 esp, 8
  00018	53		 push	 ebx
  00019	55		 push	 ebp
  0001a	56		 push	 esi
  0001b	8b f1		 mov	 esi, ecx
  0001d	57		 push	 edi
  0001e	89 74 24 10	 mov	 DWORD PTR _this$[esp+36], esi
  00022	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7UFireTexture@@6B@ ; UFireTexture::`vftable'
  00028	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp_?ConditionalDestroy@UObject@@QAEHXZ
  0002e	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+44], 1
  00036	ff d5		 call	 ebp
  00038	8d be fc 00 00
	00		 lea	 edi, DWORD PTR [esi+252]
  0003e	89 7c 24 14	 mov	 DWORD PTR $T137766[esp+36], edi
  00042	8b 5f 04	 mov	 ebx, DWORD PTR [edi+4]
  00045	85 db		 test	 ebx, ebx
  00047	c6 44 24 20 02	 mov	 BYTE PTR __$EHRec$[esp+44], 2
  0004c	7d 18		 jge	 SHORT $L137753
  0004e	68 fd 01 00 00	 push	 509			; 000001fdH
  00053	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@MLGP@?4?4?2?4?4?2Core?2Inc?2UnTemplate?4h?$AA@ ; `string'
  00058	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BA@FEMP@Index?$DM?$DNArrayNum?$AA@ ; `string'
  0005d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?appFailAssert@@YAXPBD0H@Z
  00063	83 c4 0c	 add	 esp, 12			; 0000000cH
$L137753:
  00066	3b 5f 04	 cmp	 ebx, DWORD PTR [edi+4]
  00069	7e 18		 jle	 SHORT $L137754
  0006b	68 fe 01 00 00	 push	 510			; 000001feH
  00070	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@MLGP@?4?4?2?4?4?2Core?2Inc?2UnTemplate?4h?$AA@ ; `string'
  00075	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BG@BEDF@Index?$CLCount?$DM?$DNArrayNum?$AA@ ; `string'
  0007a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?appFailAssert@@YAXPBD0H@Z
  00080	83 c4 0c	 add	 esp, 12			; 0000000cH
$L137754:
  00083	6a 08		 push	 8
  00085	53		 push	 ebx
  00086	6a 00		 push	 0
  00088	8b cf		 mov	 ecx, edi
  0008a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Remove@FArray@@QAEXHHH@Z
  00090	8b 07		 mov	 eax, DWORD PTR [edi]
  00092	33 db		 xor	 ebx, ebx
  00094	3b c3		 cmp	 eax, ebx
  00096	c6 44 24 20 00	 mov	 BYTE PTR __$EHRec$[esp+44], 0
  0009b	74 0e		 je	 SHORT $L137764
  0009d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?GMalloc@@3PAVFMalloc@@A
  000a3	8b 09		 mov	 ecx, DWORD PTR [ecx]
  000a5	8b 11		 mov	 edx, DWORD PTR [ecx]
  000a7	50		 push	 eax
  000a8	ff 52 08	 call	 DWORD PTR [edx+8]
$L137764:
  000ab	89 1f		 mov	 DWORD PTR [edi], ebx
  000ad	89 5f 08	 mov	 DWORD PTR [edi+8], ebx
  000b0	89 5f 04	 mov	 DWORD PTR [edi+4], ebx
  000b3	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7UFractalTexture@@6B@ ; UFractalTexture::`vftable'
  000b9	8b ce		 mov	 ecx, esi
  000bb	c7 44 24 20 03
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+44], 3
  000c3	ff d5		 call	 ebp
  000c5	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_??_7UProceduralTexture@@6B@
  000ca	89 06		 mov	 DWORD PTR [esi], eax
  000cc	8b ce		 mov	 ecx, esi
  000ce	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+44], 4
  000d6	ff d5		 call	 ebp
  000d8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_??_7UTexture@@6B@
  000de	89 0e		 mov	 DWORD PTR [esi], ecx
  000e0	8b ce		 mov	 ecx, esi
  000e2	c7 44 24 20 07
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+44], 7
  000ea	ff d5		 call	 ebp
  000ec	8d be b4 00 00
	00		 lea	 edi, DWORD PTR [esi+180]
  000f2	89 7c 24 14	 mov	 DWORD PTR $T137786[esp+36], edi
  000f6	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  000f9	52		 push	 edx
  000fa	53		 push	 ebx
  000fb	8b cf		 mov	 ecx, edi
  000fd	c6 44 24 28 08	 mov	 BYTE PTR __$EHRec$[esp+52], 8
  00102	e8 00 00 00 00	 call	 ?Remove@?$TArray@UFMipmap@@@@QAEXHH@Z ; TArray<FMipmap>::Remove
  00107	8b 07		 mov	 eax, DWORD PTR [edi]
  00109	3b c3		 cmp	 eax, ebx
  0010b	c6 44 24 20 06	 mov	 BYTE PTR __$EHRec$[esp+44], 6
  00110	74 0e		 je	 SHORT $L137840
  00112	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?GMalloc@@3PAVFMalloc@@A
  00118	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0011a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0011c	50		 push	 eax
  0011d	ff 52 08	 call	 DWORD PTR [edx+8]
$L137840:
  00120	89 1f		 mov	 DWORD PTR [edi], ebx
  00122	89 5f 08	 mov	 DWORD PTR [edi+8], ebx
  00125	89 5f 04	 mov	 DWORD PTR [edi+4], ebx
  00128	8d be a8 00 00
	00		 lea	 edi, DWORD PTR [esi+168]
  0012e	89 7c 24 14	 mov	 DWORD PTR $T137798[esp+36], edi
  00132	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00135	50		 push	 eax
  00136	53		 push	 ebx
  00137	8b cf		 mov	 ecx, edi
  00139	c6 44 24 28 09	 mov	 BYTE PTR __$EHRec$[esp+52], 9
  0013e	e8 00 00 00 00	 call	 ?Remove@?$TArray@UFMipmap@@@@QAEXHH@Z ; TArray<FMipmap>::Remove
  00143	8b 07		 mov	 eax, DWORD PTR [edi]
  00145	3b c3		 cmp	 eax, ebx
  00147	c6 44 24 20 05	 mov	 BYTE PTR __$EHRec$[esp+44], 5
  0014c	74 0e		 je	 SHORT $L137845
  0014e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?GMalloc@@3PAVFMalloc@@A
  00154	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00156	8b 11		 mov	 edx, DWORD PTR [ecx]
  00158	50		 push	 eax
  00159	ff 52 08	 call	 DWORD PTR [edx+8]
$L137845:
  0015c	89 1f		 mov	 DWORD PTR [edi], ebx
  0015e	89 5f 08	 mov	 DWORD PTR [edi+8], ebx
  00161	89 5f 04	 mov	 DWORD PTR [edi+4], ebx
  00164	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_??_7UBitmap@@6B@
  00169	89 06		 mov	 DWORD PTR [esi], eax
  0016b	8b ce		 mov	 ecx, esi
  0016d	c7 44 24 20 0a
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+44], 10 ; 0000000aH
  00175	ff d5		 call	 ebp
  00177	8b ce		 mov	 ecx, esi
  00179	c7 44 24 20 ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+44], -1
  00181	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1UObject@@UAE@XZ
  00187	8b 4c 24 18	 mov	 ecx, DWORD PTR __$EHRec$[esp+36]
  0018b	5f		 pop	 edi
  0018c	5e		 pop	 esi
  0018d	5d		 pop	 ebp
  0018e	5b		 pop	 ebx
  0018f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00196	83 c4 14	 add	 esp, 20			; 00000014H
  00199	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L137724:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1UFractalTexture@@UAE@XZ ; UFractalTexture::~UFractalTexture
$L137725:
  00008	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	81 c1 fc 00 00
	00		 add	 ecx, 252		; 000000fcH
  00011	e9 00 00 00 00	 jmp	 ??1?$TArray@VFSpark@@@@QAE@XZ ; TArray<FSpark>::~TArray<FSpark>
$L137727:
  00016	8b 4d f0	 mov	 ecx, DWORD PTR $T137766[ebp]
  00019	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1FArray@@QAE@XZ
$L137768:
  0001f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00022	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1UProceduralTexture@@UAE@XZ
$L137770:
  00028	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0002b	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1UTexture@@UAE@XZ
$L137772:
  00031	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1UBitmap@@UAE@XZ
$L137773:
  0003a	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	81 c1 a8 00 00
	00		 add	 ecx, 168		; 000000a8H
  00043	e9 00 00 00 00	 jmp	 ??1?$TArray@UFMipmap@@@@QAE@XZ ; TArray<FMipmap>::~TArray<FMipmap>
$L137774:
  00048	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0004b	81 c1 b4 00 00
	00		 add	 ecx, 180		; 000000b4H
  00051	e9 00 00 00 00	 jmp	 ??1?$TArray@UFMipmap@@@@QAE@XZ ; TArray<FMipmap>::~TArray<FMipmap>
$L137776:
  00056	8b 4d f0	 mov	 ecx, DWORD PTR $T137786[ebp]
  00059	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1FArray@@QAE@XZ
$L137788:
  0005f	8b 4d f0	 mov	 ecx, DWORD PTR $T137798[ebp]
  00062	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1FArray@@QAE@XZ
$L137800:
  00068	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0006b	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1UObject@@UAE@XZ
$L137855:
  00071	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T137852
  00076	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??1UFireTexture@@UAE@XZ ENDP				; UFireTexture::~UFireTexture
;	COMDAT xdata$x
; File ..\..\Core\Inc\UnTemplate.h
xdata$x	SEGMENT
$T137889 DD	0ffffffffH
	DD	FLAT:$L137862
$T137885 DD	019930520H
	DD	01H
	DD	FLAT:$T137889
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ??1?$TArray@VFSpark@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16
__$EHRec$ = -12
??1?$TArray@VFSpark@@@@QAE@XZ PROC NEAR			; TArray<FSpark>::~TArray<FSpark>, COMDAT
; _this$ = ecx

; 371  : 	{

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 $L137888
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	51		 push	 ecx
  00016	53		 push	 ebx
  00017	56		 push	 esi
  00018	8b f1		 mov	 esi, ecx
  0001a	57		 push	 edi
  0001b	89 74 24 0c	 mov	 DWORD PTR _this$[esp+28], esi

; 372  : 		checkSlow(ArrayNum>=0);
; 373  : 		checkSlow(ArrayMax>=ArrayNum);
; 374  : 		Remove( 0, ArrayNum );

  0001f	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  00022	85 ff		 test	 edi, edi
  00024	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp_?appFailAssert@@YAXPBD0H@Z
  0002a	c7 44 24 18 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+36], 0
  00032	7d 14		 jge	 SHORT $L137869
  00034	68 fd 01 00 00	 push	 509			; 000001fdH
  00039	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@MLGP@?4?4?2?4?4?2Core?2Inc?2UnTemplate?4h?$AA@ ; `string'
  0003e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BA@FEMP@Index?$DM?$DNArrayNum?$AA@ ; `string'
  00043	ff d3		 call	 ebx
  00045	83 c4 0c	 add	 esp, 12			; 0000000cH
$L137869:
  00048	3b 7e 04	 cmp	 edi, DWORD PTR [esi+4]
  0004b	7e 14		 jle	 SHORT $L137870
  0004d	68 fe 01 00 00	 push	 510			; 000001feH
  00052	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@MLGP@?4?4?2?4?4?2Core?2Inc?2UnTemplate?4h?$AA@ ; `string'
  00057	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BG@BEDF@Index?$CLCount?$DM?$DNArrayNum?$AA@ ; `string'
  0005c	ff d3		 call	 ebx
  0005e	83 c4 0c	 add	 esp, 12			; 0000000cH
$L137870:
  00061	6a 08		 push	 8
  00063	57		 push	 edi
  00064	6a 00		 push	 0
  00066	8b ce		 mov	 ecx, esi
  00068	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Remove@FArray@@QAEXHHH@Z

; 375  : 	}

  0006e	8b 06		 mov	 eax, DWORD PTR [esi]
  00070	85 c0		 test	 eax, eax
  00072	c7 44 24 18 ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+36], -1
  0007a	74 0e		 je	 SHORT $L137882
  0007c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?GMalloc@@3PAVFMalloc@@A
  00082	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00084	8b 11		 mov	 edx, DWORD PTR [ecx]
  00086	50		 push	 eax
  00087	ff 52 08	 call	 DWORD PTR [edx+8]
$L137882:
  0008a	8b 4c 24 10	 mov	 ecx, DWORD PTR __$EHRec$[esp+28]
  0008e	5f		 pop	 edi
  0008f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00095	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  0009c	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  000a3	5e		 pop	 esi
  000a4	5b		 pop	 ebx
  000a5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000ac	83 c4 10	 add	 esp, 16			; 00000010H
  000af	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L137862:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1FArray@@QAE@XZ
$L137888:
  00009	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T137885
  0000e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??1?$TArray@VFSpark@@@@QAE@XZ ENDP			; TArray<FSpark>::~TArray<FSpark>
; Function compile flags: /Ogty
;	COMDAT ?Remove@?$TArray@UFMipmap@@@@QAEXHH@Z
_TEXT	SEGMENT
_Index$ = 8
_Count$ = 12
?Remove@?$TArray@UFMipmap@@@@QAEXHH@Z PROC NEAR		; TArray<FMipmap>::Remove, COMDAT
; _this$ = ecx

; 507  : 	{

  00000	53		 push	 ebx

; 508  : 		check(Index>=0);

  00001	8b 5c 24 08	 mov	 ebx, DWORD PTR _Index$[esp]
  00005	85 db		 test	 ebx, ebx
  00007	55		 push	 ebp
  00008	56		 push	 esi
  00009	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp_?appFailAssert@@YAXPBD0H@Z
  0000f	57		 push	 edi
  00010	8b e9		 mov	 ebp, ecx
  00012	7d 14		 jge	 SHORT $L126975
  00014	68 fc 01 00 00	 push	 508			; 000001fcH
  00019	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@MLGP@?4?4?2?4?4?2Core?2Inc?2UnTemplate?4h?$AA@ ; `string'
  0001e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08GCAE@Index?$DO?$DN0?$AA@ ; `string'
  00023	ff d6		 call	 esi
  00025	83 c4 0c	 add	 esp, 12			; 0000000cH
$L126975:

; 509  : 		check(Index<=ArrayNum);

  00028	3b 5d 04	 cmp	 ebx, DWORD PTR [ebp+4]
  0002b	7e 14		 jle	 SHORT $L126976
  0002d	68 fd 01 00 00	 push	 509			; 000001fdH
  00032	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@MLGP@?4?4?2?4?4?2Core?2Inc?2UnTemplate?4h?$AA@ ; `string'
  00037	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BA@FEMP@Index?$DM?$DNArrayNum?$AA@ ; `string'
  0003c	ff d6		 call	 esi
  0003e	83 c4 0c	 add	 esp, 12			; 0000000cH
$L126976:

; 510  : 		check(Index+Count<=ArrayNum);

  00041	8b 44 24 18	 mov	 eax, DWORD PTR _Count$[esp+12]
  00045	8d 3c 03	 lea	 edi, DWORD PTR [ebx+eax]
  00048	3b 7d 04	 cmp	 edi, DWORD PTR [ebp+4]
  0004b	7e 14		 jle	 SHORT $L126977
  0004d	68 fe 01 00 00	 push	 510			; 000001feH
  00052	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@MLGP@?4?4?2?4?4?2Core?2Inc?2UnTemplate?4h?$AA@ ; `string'
  00057	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BG@BEDF@Index?$CLCount?$DM?$DNArrayNum?$AA@ ; `string'
  0005c	ff d6		 call	 esi
  0005e	83 c4 0c	 add	 esp, 12			; 0000000cH
$L126977:

; 511  : 		if( TTypeInfo<T>::NeedsDestructor() )
; 512  : 			for( INT i=Index; i<Index+Count; i++ )

  00061	3b df		 cmp	 ebx, edi
  00063	7d 1c		 jge	 SHORT $L126982
  00065	8d 34 9b	 lea	 esi, DWORD PTR [ebx+ebx*4]
  00068	c1 e6 03	 shl	 esi, 3
  0006b	2b fb		 sub	 edi, ebx

; 515  : 	}

  0006d	8d 49 00	 npad	 3

; 511  : 		if( TTypeInfo<T>::NeedsDestructor() )
; 512  : 			for( INT i=Index; i<Index+Count; i++ )

$L126980:

; 513  : 				(&(*this)(i))->~T();

  00070	8b 4d 00	 mov	 ecx, DWORD PTR [ebp]
  00073	03 ce		 add	 ecx, esi
  00075	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1FMipmap@@QAE@XZ
  0007b	83 c6 28	 add	 esi, 40			; 00000028H
  0007e	4f		 dec	 edi
  0007f	75 ef		 jne	 SHORT $L126980
$L126982:

; 514  : 		FArray::Remove( Index, Count, sizeof(T) );

  00081	8b 4c 24 18	 mov	 ecx, DWORD PTR _Count$[esp+12]
  00085	6a 28		 push	 40			; 00000028H
  00087	51		 push	 ecx
  00088	53		 push	 ebx
  00089	8b cd		 mov	 ecx, ebp
  0008b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Remove@FArray@@QAEXHHH@Z
  00091	5f		 pop	 edi
  00092	5e		 pop	 esi
  00093	5d		 pop	 ebp
  00094	5b		 pop	 ebx

; 515  : 	}

  00095	c2 08 00	 ret	 8
?Remove@?$TArray@UFMipmap@@@@QAEXHH@Z ENDP		; TArray<FMipmap>::Remove
; Function compile flags: /Ogty
; File C:\duke4\Fire\Src\FractalPrivate.h
_TEXT	ENDS
;	COMDAT ?InternalConstructor@UFireTexture@@SAXPAX@Z
_TEXT	SEGMENT
_X$ = 8
?InternalConstructor@UFireTexture@@SAXPAX@Z PROC NEAR	; UFireTexture::InternalConstructor, COMDAT

; 187  : 	DECLARE_CLASS(UFireTexture,UFractalTexture,0)

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR _X$[esp-4]
  00004	85 c9		 test	 ecx, ecx
  00006	74 05		 je	 SHORT $L137918
  00008	e9 00 00 00 00	 jmp	 ??0UFireTexture@@QAE@XZ	; UFireTexture::UFireTexture
$L137918:
  0000d	c3		 ret	 0
?InternalConstructor@UFireTexture@@SAXPAX@Z ENDP	; UFireTexture::InternalConstructor
_TEXT	ENDS
PUBLIC	??0UFireTexture@@QAE@ABV0@@Z			; UFireTexture::UFireTexture
EXTRN	__imp_??0UTexture@@QAE@ABV0@@Z:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T138028 DD	0ffffffffH
	DD	FLAT:$L137926
	DD	00H
	DD	FLAT:$L137942
$T138022 DD	019930520H
	DD	02H
	DD	FLAT:$T138028
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ??0UFireTexture@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8
_this$ = -16
$T138018 = 8
__$EHRec$ = -12
??0UFireTexture@@QAE@ABV0@@Z PROC NEAR			; UFireTexture::UFireTexture, COMDAT
; _this$ = ecx
  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 $L138027
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	51		 push	 ecx
  00016	53		 push	 ebx
  00017	55		 push	 ebp
  00018	8b 6c 24 1c	 mov	 ebp, DWORD PTR ___that$[esp+20]
  0001c	56		 push	 esi
  0001d	57		 push	 edi
  0001e	8b d9		 mov	 ebx, ecx
  00020	55		 push	 ebp
  00021	89 5c 24 14	 mov	 DWORD PTR _this$[esp+36], ebx
  00025	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0UTexture@@QAE@ABV0@@Z
  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_??_7UProceduralTexture@@6B@
  00030	89 03		 mov	 DWORD PTR [ebx], eax
  00032	8b 8d c8 00 00
	00		 mov	 ecx, DWORD PTR [ebp+200]
  00038	89 8b c8 00 00
	00		 mov	 DWORD PTR [ebx+200], ecx
  0003e	8b 95 cc 00 00
	00		 mov	 edx, DWORD PTR [ebp+204]
  00044	89 93 cc 00 00
	00		 mov	 DWORD PTR [ebx+204], edx
  0004a	8b 85 d0 00 00
	00		 mov	 eax, DWORD PTR [ebp+208]
  00050	89 83 d0 00 00
	00		 mov	 DWORD PTR [ebx+208], eax
  00056	8b 8d d4 00 00
	00		 mov	 ecx, DWORD PTR [ebp+212]
  0005c	89 8b d4 00 00
	00		 mov	 DWORD PTR [ebx+212], ecx
  00062	8b 95 d8 00 00
	00		 mov	 edx, DWORD PTR [ebp+216]
  00068	89 93 d8 00 00
	00		 mov	 DWORD PTR [ebx+216], edx
  0006e	8a 85 dc 00 00
	00		 mov	 al, BYTE PTR [ebp+220]
  00074	88 83 dc 00 00
	00		 mov	 BYTE PTR [ebx+220], al
  0007a	8a 8d dd 00 00
	00		 mov	 cl, BYTE PTR [ebp+221]
  00080	88 8b dd 00 00
	00		 mov	 BYTE PTR [ebx+221], cl
  00086	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], OFFSET FLAT:??_7UFractalTexture@@6B@ ; UFractalTexture::`vftable'
  0008c	8a 95 e0 00 00
	00		 mov	 dl, BYTE PTR [ebp+224]
  00092	88 93 e0 00 00
	00		 mov	 BYTE PTR [ebx+224], dl
  00098	8a 85 e1 00 00
	00		 mov	 al, BYTE PTR [ebp+225]
  0009e	88 83 e1 00 00
	00		 mov	 BYTE PTR [ebx+225], al
  000a4	8b 8d e4 00 00
	00		 mov	 ecx, DWORD PTR [ebp+228]
  000aa	8b 83 e4 00 00
	00		 mov	 eax, DWORD PTR [ebx+228]
  000b0	33 c8		 xor	 ecx, eax
  000b2	83 e1 01	 and	 ecx, 1
  000b5	33 c8		 xor	 ecx, eax
  000b7	89 8b e4 00 00
	00		 mov	 DWORD PTR [ebx+228], ecx
  000bd	8a 95 e8 00 00
	00		 mov	 dl, BYTE PTR [ebp+232]
  000c3	88 93 e8 00 00
	00		 mov	 BYTE PTR [ebx+232], dl
  000c9	8a 85 e9 00 00
	00		 mov	 al, BYTE PTR [ebp+233]
  000cf	88 83 e9 00 00
	00		 mov	 BYTE PTR [ebx+233], al
  000d5	8a 8d ea 00 00
	00		 mov	 cl, BYTE PTR [ebp+234]
  000db	88 8b ea 00 00
	00		 mov	 BYTE PTR [ebx+234], cl
  000e1	8a 95 eb 00 00
	00		 mov	 dl, BYTE PTR [ebp+235]
  000e7	88 93 eb 00 00
	00		 mov	 BYTE PTR [ebx+235], dl
  000ed	8a 85 ec 00 00
	00		 mov	 al, BYTE PTR [ebp+236]
  000f3	88 83 ec 00 00
	00		 mov	 BYTE PTR [ebx+236], al
  000f9	8a 8d ed 00 00
	00		 mov	 cl, BYTE PTR [ebp+237]
  000ff	88 8b ed 00 00
	00		 mov	 BYTE PTR [ebx+237], cl
  00105	8a 95 ee 00 00
	00		 mov	 dl, BYTE PTR [ebp+238]
  0010b	88 93 ee 00 00
	00		 mov	 BYTE PTR [ebx+238], dl
  00111	8a 85 ef 00 00
	00		 mov	 al, BYTE PTR [ebp+239]
  00117	88 83 ef 00 00
	00		 mov	 BYTE PTR [ebx+239], al
  0011d	8a 8d f0 00 00
	00		 mov	 cl, BYTE PTR [ebp+240]
  00123	88 8b f0 00 00
	00		 mov	 BYTE PTR [ebx+240], cl
  00129	8b 95 f4 00 00
	00		 mov	 edx, DWORD PTR [ebp+244]
  0012f	89 93 f4 00 00
	00		 mov	 DWORD PTR [ebx+244], edx
  00135	8b 85 f8 00 00
	00		 mov	 eax, DWORD PTR [ebp+248]
  0013b	89 83 f8 00 00
	00		 mov	 DWORD PTR [ebx+248], eax
  00141	8b 85 00 01 00
	00		 mov	 eax, DWORD PTR [ebp+256]
  00147	8d b3 fc 00 00
	00		 lea	 esi, DWORD PTR [ebx+252]
  0014d	33 ff		 xor	 edi, edi
  0014f	6a 08		 push	 8
  00151	8b ce		 mov	 ecx, esi
  00153	89 7c 24 20	 mov	 DWORD PTR __$EHRec$[esp+44], edi
  00157	89 74 24 28	 mov	 DWORD PTR $T138018[esp+32], esi
  0015b	89 3e		 mov	 DWORD PTR [esi], edi
  0015d	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00160	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00163	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Realloc@FArray@@IAEXH@Z
  00169	89 7e 04	 mov	 DWORD PTR [esi+4], edi
  0016c	8b 85 00 01 00
	00		 mov	 eax, DWORD PTR [ebp+256]
  00172	85 c0		 test	 eax, eax
  00174	c6 44 24 1c 01	 mov	 BYTE PTR __$EHRec$[esp+40], 1
  00179	7e 37		 jle	 SHORT $L137985
  0017b	90 8d 64 24 00	 npad	 5
$L137983:
  00180	6a 08		 push	 8
  00182	6a 01		 push	 1
  00184	8b ce		 mov	 ecx, esi
  00186	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Add@FArray@@QAEHHH@Z
  0018c	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0018e	8d 04 c1	 lea	 eax, DWORD PTR [ecx+eax*8]
  00191	85 c0		 test	 eax, eax
  00193	74 12		 je	 SHORT $L137984
  00195	8b 95 fc 00 00
	00		 mov	 edx, DWORD PTR [ebp+252]
  0019b	8b 0c fa	 mov	 ecx, DWORD PTR [edx+edi*8]
  0019e	89 08		 mov	 DWORD PTR [eax], ecx
  001a0	8b 54 fa 04	 mov	 edx, DWORD PTR [edx+edi*8+4]
  001a4	89 50 04	 mov	 DWORD PTR [eax+4], edx
$L137984:
  001a7	8b 85 00 01 00
	00		 mov	 eax, DWORD PTR [ebp+256]
  001ad	47		 inc	 edi
  001ae	3b f8		 cmp	 edi, eax
  001b0	7c ce		 jl	 SHORT $L137983
$L137985:
  001b2	8b 85 08 01 00
	00		 mov	 eax, DWORD PTR [ebp+264]
  001b8	89 83 08 01 00
	00		 mov	 DWORD PTR [ebx+264], eax
  001be	8d b5 0c 01 00
	00		 lea	 esi, DWORD PTR [ebp+268]
  001c4	8d bb 0c 01 00
	00		 lea	 edi, DWORD PTR [ebx+268]
  001ca	b9 01 01 00 00	 mov	 ecx, 257		; 00000101H
  001cf	f3 a5		 rep movsd
  001d1	8a 8d 10 05 00
	00		 mov	 cl, BYTE PTR [ebp+1296]
  001d7	88 8b 10 05 00
	00		 mov	 BYTE PTR [ebx+1296], cl
  001dd	8a 95 11 05 00
	00		 mov	 dl, BYTE PTR [ebp+1297]
  001e3	8b 4c 24 14	 mov	 ecx, DWORD PTR __$EHRec$[esp+32]
  001e7	5f		 pop	 edi
  001e8	88 93 11 05 00
	00		 mov	 BYTE PTR [ebx+1297], dl
  001ee	8a 85 12 05 00
	00		 mov	 al, BYTE PTR [ebp+1298]
  001f4	5e		 pop	 esi
  001f5	88 83 12 05 00
	00		 mov	 BYTE PTR [ebx+1298], al
  001fb	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], OFFSET FLAT:??_7UFireTexture@@6B@ ; UFireTexture::`vftable'
  00201	5d		 pop	 ebp
  00202	8b c3		 mov	 eax, ebx
  00204	5b		 pop	 ebx
  00205	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0020c	83 c4 10	 add	 esp, 16			; 00000010H
  0020f	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L137926:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1UFractalTexture@@UAE@XZ ; UFractalTexture::~UFractalTexture
$L137942:
  00008	8b 4d 04	 mov	 ecx, DWORD PTR $T138018[ebp-4]
  0000b	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1FArray@@QAE@XZ
$L138027:
  00011	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T138022
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0UFireTexture@@QAE@ABV0@@Z ENDP			; UFireTexture::UFireTexture
PUBLIC	??4UFireTexture@@QAEAAV0@ABV0@@Z		; UFireTexture::operator=
EXTRN	__imp_??4UTexture@@QAEAAV0@ABV0@@Z:NEAR
; Function compile flags: /Ogty
;	COMDAT ??4UFireTexture@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8
_i$138088 = 8
??4UFireTexture@@QAEAAV0@ABV0@@Z PROC NEAR		; UFireTexture::operator=, COMDAT
; _this$ = ecx
  00000	51		 push	 ecx
  00001	53		 push	 ebx
  00002	55		 push	 ebp
  00003	56		 push	 esi
  00004	57		 push	 edi
  00005	8b 7c 24 18	 mov	 edi, DWORD PTR ___that$[esp+16]
  00009	57		 push	 edi
  0000a	8b f1		 mov	 esi, ecx
  0000c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4UTexture@@QAEAAV0@ABV0@@Z
  00012	8b 87 c8 00 00
	00		 mov	 eax, DWORD PTR [edi+200]
  00018	89 86 c8 00 00
	00		 mov	 DWORD PTR [esi+200], eax
  0001e	8b 8f cc 00 00
	00		 mov	 ecx, DWORD PTR [edi+204]
  00024	89 8e cc 00 00
	00		 mov	 DWORD PTR [esi+204], ecx
  0002a	8b 97 d0 00 00
	00		 mov	 edx, DWORD PTR [edi+208]
  00030	89 96 d0 00 00
	00		 mov	 DWORD PTR [esi+208], edx
  00036	8b 87 d4 00 00
	00		 mov	 eax, DWORD PTR [edi+212]
  0003c	89 86 d4 00 00
	00		 mov	 DWORD PTR [esi+212], eax
  00042	8b 8f d8 00 00
	00		 mov	 ecx, DWORD PTR [edi+216]
  00048	89 8e d8 00 00
	00		 mov	 DWORD PTR [esi+216], ecx
  0004e	8a 97 dc 00 00
	00		 mov	 dl, BYTE PTR [edi+220]
  00054	88 96 dc 00 00
	00		 mov	 BYTE PTR [esi+220], dl
  0005a	8a 87 dd 00 00
	00		 mov	 al, BYTE PTR [edi+221]
  00060	88 86 dd 00 00
	00		 mov	 BYTE PTR [esi+221], al
  00066	8a 8f e0 00 00
	00		 mov	 cl, BYTE PTR [edi+224]
  0006c	8b 86 e4 00 00
	00		 mov	 eax, DWORD PTR [esi+228]
  00072	88 8e e0 00 00
	00		 mov	 BYTE PTR [esi+224], cl
  00078	8a 97 e1 00 00
	00		 mov	 dl, BYTE PTR [edi+225]
  0007e	88 96 e1 00 00
	00		 mov	 BYTE PTR [esi+225], dl
  00084	8b 8f e4 00 00
	00		 mov	 ecx, DWORD PTR [edi+228]
  0008a	33 c8		 xor	 ecx, eax
  0008c	83 e1 01	 and	 ecx, 1
  0008f	33 c8		 xor	 ecx, eax
  00091	89 8e e4 00 00
	00		 mov	 DWORD PTR [esi+228], ecx
  00097	8a 97 e8 00 00
	00		 mov	 dl, BYTE PTR [edi+232]
  0009d	88 96 e8 00 00
	00		 mov	 BYTE PTR [esi+232], dl
  000a3	8a 87 e9 00 00
	00		 mov	 al, BYTE PTR [edi+233]
  000a9	88 86 e9 00 00
	00		 mov	 BYTE PTR [esi+233], al
  000af	8a 8f ea 00 00
	00		 mov	 cl, BYTE PTR [edi+234]
  000b5	88 8e ea 00 00
	00		 mov	 BYTE PTR [esi+234], cl
  000bb	8a 97 eb 00 00
	00		 mov	 dl, BYTE PTR [edi+235]
  000c1	88 96 eb 00 00
	00		 mov	 BYTE PTR [esi+235], dl
  000c7	8a 87 ec 00 00
	00		 mov	 al, BYTE PTR [edi+236]
  000cd	88 86 ec 00 00
	00		 mov	 BYTE PTR [esi+236], al
  000d3	8a 8f ed 00 00
	00		 mov	 cl, BYTE PTR [edi+237]
  000d9	88 8e ed 00 00
	00		 mov	 BYTE PTR [esi+237], cl
  000df	8a 97 ee 00 00
	00		 mov	 dl, BYTE PTR [edi+238]
  000e5	88 96 ee 00 00
	00		 mov	 BYTE PTR [esi+238], dl
  000eb	8a 87 ef 00 00
	00		 mov	 al, BYTE PTR [edi+239]
  000f1	88 86 ef 00 00
	00		 mov	 BYTE PTR [esi+239], al
  000f7	8a 8f f0 00 00
	00		 mov	 cl, BYTE PTR [edi+240]
  000fd	88 8e f0 00 00
	00		 mov	 BYTE PTR [esi+240], cl
  00103	8b 97 f4 00 00
	00		 mov	 edx, DWORD PTR [edi+244]
  00109	89 96 f4 00 00
	00		 mov	 DWORD PTR [esi+244], edx
  0010f	8b 87 f8 00 00
	00		 mov	 eax, DWORD PTR [edi+248]
  00115	8d af fc 00 00
	00		 lea	 ebp, DWORD PTR [edi+252]
  0011b	8d 9e fc 00 00
	00		 lea	 ebx, DWORD PTR [esi+252]
  00121	3b dd		 cmp	 ebx, ebp
  00123	89 86 f8 00 00
	00		 mov	 DWORD PTR [esi+248], eax
  00129	0f 84 8b 00 00
	00		 je	 $L138091
  0012f	8b 45 04	 mov	 eax, DWORD PTR [ebp+4]
  00132	6a 08		 push	 8
  00134	8b cb		 mov	 ecx, ebx
  00136	c7 43 04 00 00
	00 00		 mov	 DWORD PTR [ebx+4], 0
  0013d	89 43 08	 mov	 DWORD PTR [ebx+8], eax
  00140	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Realloc@FArray@@IAEXH@Z
  00146	8b 45 04	 mov	 eax, DWORD PTR [ebp+4]
  00149	85 c0		 test	 eax, eax
  0014b	c7 44 24 18 00
	00 00 00	 mov	 DWORD PTR _i$138088[esp+16], 0
  00153	7e 65		 jle	 SHORT $L138091
$L138089:
  00155	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00158	8b 53 08	 mov	 edx, DWORD PTR [ebx+8]
  0015b	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  0015e	3b ca		 cmp	 ecx, edx
  00160	89 44 24 10	 mov	 DWORD PTR -4+[esp+20], eax
  00164	89 4b 04	 mov	 DWORD PTR [ebx+4], ecx
  00167	7e 21		 jle	 SHORT $L138112
  00169	8d 04 49	 lea	 eax, DWORD PTR [ecx+ecx*2]
  0016c	99		 cdq
  0016d	83 e2 07	 and	 edx, 7
  00170	03 c2		 add	 eax, edx
  00172	c1 f8 03	 sar	 eax, 3
  00175	8d 4c 08 20	 lea	 ecx, DWORD PTR [eax+ecx+32]
  00179	89 4b 08	 mov	 DWORD PTR [ebx+8], ecx
  0017c	6a 08		 push	 8
  0017e	8b cb		 mov	 ecx, ebx
  00180	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Realloc@FArray@@IAEXH@Z
  00186	8b 44 24 10	 mov	 eax, DWORD PTR -4+[esp+20]
$L138112:
  0018a	8b 13		 mov	 edx, DWORD PTR [ebx]
  0018c	8d 04 c2	 lea	 eax, DWORD PTR [edx+eax*8]
  0018f	85 c0		 test	 eax, eax
  00191	74 17		 je	 SHORT $L138090
  00193	8b 4d 00	 mov	 ecx, DWORD PTR [ebp]
  00196	8b 54 24 18	 mov	 edx, DWORD PTR _i$138088[esp+16]
  0019a	8b 14 d1	 mov	 edx, DWORD PTR [ecx+edx*8]
  0019d	89 10		 mov	 DWORD PTR [eax], edx
  0019f	8b 54 24 18	 mov	 edx, DWORD PTR _i$138088[esp+16]
  001a3	8b 4c d1 04	 mov	 ecx, DWORD PTR [ecx+edx*8+4]
  001a7	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$L138090:
  001aa	8b 44 24 18	 mov	 eax, DWORD PTR _i$138088[esp+16]
  001ae	8b 4d 04	 mov	 ecx, DWORD PTR [ebp+4]
  001b1	40		 inc	 eax
  001b2	3b c1		 cmp	 eax, ecx
  001b4	89 44 24 18	 mov	 DWORD PTR _i$138088[esp+16], eax
  001b8	7c 9b		 jl	 SHORT $L138089
$L138091:
  001ba	8b 97 08 01 00
	00		 mov	 edx, DWORD PTR [edi+264]
  001c0	8b cf		 mov	 ecx, edi
  001c2	bd f4 fe ff ff	 mov	 ebp, -268		; fffffef4H
  001c7	2b ce		 sub	 ecx, esi
  001c9	89 96 08 01 00
	00		 mov	 DWORD PTR [esi+264], edx
  001cf	8d 86 0c 01 00
	00		 lea	 eax, DWORD PTR [esi+268]
  001d5	2b ee		 sub	 ebp, esi
$L123110:
  001d7	8a 14 01	 mov	 dl, BYTE PTR [ecx+eax]
  001da	88 10		 mov	 BYTE PTR [eax], dl
  001dc	40		 inc	 eax
  001dd	8d 14 28	 lea	 edx, DWORD PTR [eax+ebp]
  001e0	81 fa 04 04 00
	00		 cmp	 edx, 1028		; 00000404H
  001e6	72 ef		 jb	 SHORT $L123110
  001e8	8a 87 10 05 00
	00		 mov	 al, BYTE PTR [edi+1296]
  001ee	88 86 10 05 00
	00		 mov	 BYTE PTR [esi+1296], al
  001f4	8a 8f 11 05 00
	00		 mov	 cl, BYTE PTR [edi+1297]
  001fa	88 8e 11 05 00
	00		 mov	 BYTE PTR [esi+1297], cl
  00200	8a 97 12 05 00
	00		 mov	 dl, BYTE PTR [edi+1298]
  00206	5f		 pop	 edi
  00207	88 96 12 05 00
	00		 mov	 BYTE PTR [esi+1298], dl
  0020d	8b c6		 mov	 eax, esi
  0020f	5e		 pop	 esi
  00210	5d		 pop	 ebp
  00211	5b		 pop	 ebx
  00212	59		 pop	 ecx
  00213	c2 04 00	 ret	 4
??4UFireTexture@@QAEAAV0@ABV0@@Z ENDP			; UFireTexture::operator=
_TEXT	ENDS
PUBLIC	??_GUFireTexture@@UAEPAXI@Z			; UFireTexture::`scalar deleting destructor'
; Function compile flags: /Ogty
;	COMDAT ??_GUFireTexture@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_GUFireTexture@@UAEPAXI@Z PROC NEAR			; UFireTexture::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	e8 00 00 00 00	 call	 ??1UFireTexture@@UAE@XZ	; UFireTexture::~UFireTexture
  00008	f6 44 24 08 01	 test	 BYTE PTR ___flags$[esp], 1
  0000d	74 0d		 je	 SHORT $L138132
  0000f	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?GMalloc@@3PAVFMalloc@@A
  00014	8b 08		 mov	 ecx, DWORD PTR [eax]
  00016	8b 11		 mov	 edx, DWORD PTR [ecx]
  00018	56		 push	 esi
  00019	ff 52 08	 call	 DWORD PTR [edx+8]
$L138132:
  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi
  0001f	c2 04 00	 ret	 4
??_GUFireTexture@@UAEPAXI@Z ENDP			; UFireTexture::`scalar deleting destructor'
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??_EUFireTexture@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_EUFireTexture@@UAEPAXI@Z PROC NEAR			; UFireTexture::`vector deleting destructor', COMDAT
; _this$ = ecx
  00000	53		 push	 ebx
  00001	8a 5c 24 08	 mov	 bl, BYTE PTR ___flags$[esp]
  00005	f6 c3 02	 test	 bl, 2
  00008	56		 push	 esi
  00009	8b f1		 mov	 esi, ecx
  0000b	74 33		 je	 SHORT $L123118
  0000d	8b 46 fc	 mov	 eax, DWORD PTR [esi-4]
  00010	57		 push	 edi
  00011	68 00 00 00 00	 push	 OFFSET FLAT:??1UFireTexture@@UAE@XZ ; UFireTexture::~UFireTexture
  00016	8d 7e fc	 lea	 edi, DWORD PTR [esi-4]
  00019	50		 push	 eax
  0001a	68 14 05 00 00	 push	 1300			; 00000514H
  0001f	56		 push	 esi
  00020	e8 00 00 00 00	 call	 ??_M@YGXPAXIHP6EX0@Z@Z	; `eh vector destructor iterator'
  00025	f6 c3 01	 test	 bl, 1
  00028	74 0e		 je	 SHORT $L138137
  0002a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?GMalloc@@3PAVFMalloc@@A
  00030	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00032	8b 11		 mov	 edx, DWORD PTR [ecx]
  00034	57		 push	 edi
  00035	ff 52 08	 call	 DWORD PTR [edx+8]
$L138137:
  00038	8b c7		 mov	 eax, edi
  0003a	5f		 pop	 edi
  0003b	5e		 pop	 esi
  0003c	5b		 pop	 ebx
  0003d	c2 04 00	 ret	 4
$L123118:
  00040	8b ce		 mov	 ecx, esi
  00042	e8 00 00 00 00	 call	 ??1UFireTexture@@UAE@XZ	; UFireTexture::~UFireTexture
  00047	f6 c3 01	 test	 bl, 1
  0004a	74 0d		 je	 SHORT $L138140
  0004c	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?GMalloc@@3PAVFMalloc@@A
  00051	8b 08		 mov	 ecx, DWORD PTR [eax]
  00053	8b 11		 mov	 edx, DWORD PTR [ecx]
  00055	56		 push	 esi
  00056	ff 52 08	 call	 DWORD PTR [edx+8]
$L138140:
  00059	8b c6		 mov	 eax, esi
  0005b	5e		 pop	 esi
  0005c	5b		 pop	 ebx
  0005d	c2 04 00	 ret	 4
??_EUFireTexture@@UAEPAXI@Z ENDP			; UFireTexture::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??4FDrop@@QAEAAU0@ABU0@@Z			; FDrop::operator=
; Function compile flags: /Ogty
;	COMDAT ??4FDrop@@QAEAAU0@ABU0@@Z
_TEXT	SEGMENT
___that$ = 8
??4FDrop@@QAEAAU0@ABU0@@Z PROC NEAR			; FDrop::operator=, COMDAT
; _this$ = ecx
  00000	8b c1		 mov	 eax, ecx
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR ___that$[esp-4]
  00006	8b 11		 mov	 edx, DWORD PTR [ecx]
  00008	89 10		 mov	 DWORD PTR [eax], edx
  0000a	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0000d	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00010	c2 04 00	 ret	 4
??4FDrop@@QAEAAU0@ABU0@@Z ENDP				; FDrop::operator=
_TEXT	ENDS
PUBLIC	?StaticClass@UWaterTexture@@SAPAVUClass@@XZ	; UWaterTexture::StaticClass
; Function compile flags: /Ogty
;	COMDAT ?StaticClass@UWaterTexture@@SAPAVUClass@@XZ
_TEXT	SEGMENT
?StaticClass@UWaterTexture@@SAPAVUClass@@XZ PROC NEAR	; UWaterTexture::StaticClass, COMDAT

; 305  : 	DECLARE_ABSTRACT_CLASS(UWaterTexture,UFractalTexture,0)

  00000	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?PrivateStaticClass@UWaterTexture@@0VUClass@@A ; UWaterTexture::PrivateStaticClass
  00005	c3		 ret	 0
?StaticClass@UWaterTexture@@SAPAVUClass@@XZ ENDP	; UWaterTexture::StaticClass
_TEXT	ENDS
PUBLIC	??2UWaterTexture@@SAPAXIPAVUObject@@VFName@@K@Z	; UWaterTexture::operator new
; Function compile flags: /Ogty
;	COMDAT ??2UWaterTexture@@SAPAXIPAVUObject@@VFName@@K@Z
_TEXT	SEGMENT
_Outer$ = 12
_Name$ = 16
_SetFlags$ = 20
??2UWaterTexture@@SAPAXIPAVUObject@@VFName@@K@Z PROC NEAR ; UWaterTexture::operator new, COMDAT

; 305  : 	DECLARE_ABSTRACT_CLASS(UWaterTexture,UFractalTexture,0)

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?GError@@3PAVFOutputDeviceError@@A
  00005	8b 08		 mov	 ecx, DWORD PTR [eax]
  00007	8b 54 24 10	 mov	 edx, DWORD PTR _SetFlags$[esp-4]
  0000b	8b 44 24 0c	 mov	 eax, DWORD PTR _Name$[esp-4]
  0000f	6a 00		 push	 0
  00011	51		 push	 ecx
  00012	8b 4c 24 10	 mov	 ecx, DWORD PTR _Outer$[esp+4]
  00016	6a 00		 push	 0
  00018	52		 push	 edx
  00019	50		 push	 eax
  0001a	51		 push	 ecx
  0001b	68 00 00 00 00	 push	 OFFSET FLAT:?PrivateStaticClass@UWaterTexture@@0VUClass@@A ; UWaterTexture::PrivateStaticClass
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?StaticAllocateObject@UObject@@SAPAV1@PAVUClass@@PAV1@VFName@@K1PAVFOutputDevice@@1@Z
  00026	83 c4 1c	 add	 esp, 28			; 0000001cH
  00029	c3		 ret	 0
??2UWaterTexture@@SAPAXIPAVUObject@@VFName@@K@Z ENDP	; UWaterTexture::operator new
_TEXT	ENDS
PUBLIC	??2UWaterTexture@@SAPAXIPAW4EInternal@@@Z	; UWaterTexture::operator new
; Function compile flags: /Ogty
;	COMDAT ??2UWaterTexture@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT
_Mem$ = 12
??2UWaterTexture@@SAPAXIPAW4EInternal@@@Z PROC NEAR	; UWaterTexture::operator new, COMDAT

; 305  : 	DECLARE_ABSTRACT_CLASS(UWaterTexture,UFractalTexture,0)

  00000	8b 44 24 08	 mov	 eax, DWORD PTR _Mem$[esp-4]
  00004	c3		 ret	 0
??2UWaterTexture@@SAPAXIPAW4EInternal@@@Z ENDP		; UWaterTexture::operator new
_TEXT	ENDS
PUBLIC	??1UWaterTexture@@UAE@XZ			; UWaterTexture::~UWaterTexture
;	COMDAT xdata$x
; File ..\..\Engine\Inc\UnTex.h
xdata$x	SEGMENT
$T138395 DD	0ffffffffH
	DD	FLAT:$L138160
	DD	0ffffffffH
	DD	FLAT:$L138162
	DD	0ffffffffH
	DD	FLAT:$L138164
	DD	0ffffffffH
	DD	FLAT:$L138166
	DD	03H
	DD	FLAT:$L138167
	DD	04H
	DD	FLAT:$L138168
	DD	04H
	DD	FLAT:$L138170
	DD	03H
	DD	FLAT:$L138218
	DD	0ffffffffH
	DD	FLAT:$L138259
$T138386 DD	019930520H
	DD	09H
	DD	FLAT:$T138395
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File C:\duke4\Fire\Src\FractalPrivate.h
xdata$x	ENDS
;	COMDAT ??1UWaterTexture@@UAE@XZ
_TEXT	SEGMENT
$T138216 = -16
$T138257 = -16
__$EHRec$ = -12
_this$ = -20
??1UWaterTexture@@UAE@XZ PROC NEAR			; UWaterTexture::~UWaterTexture, COMDAT
; _this$ = ecx

; 305  : 	DECLARE_ABSTRACT_CLASS(UWaterTexture,UFractalTexture,0)

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 $L138394
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00018	53		 push	 ebx
  00019	55		 push	 ebp
  0001a	56		 push	 esi
  0001b	8b f1		 mov	 esi, ecx
  0001d	57		 push	 edi
  0001e	89 74 24 14	 mov	 DWORD PTR _this$[esp+40], esi
  00022	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7UWaterTexture@@6B@ ; UWaterTexture::`vftable'
  00028	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp_?ConditionalDestroy@UObject@@QAEHXZ
  0002e	33 ed		 xor	 ebp, ebp
  00030	89 6c 24 24	 mov	 DWORD PTR __$EHRec$[esp+48], ebp
  00034	ff d7		 call	 edi
  00036	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7UFractalTexture@@6B@ ; UFractalTexture::`vftable'
  0003c	8b ce		 mov	 ecx, esi
  0003e	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+48], 1
  00046	ff d7		 call	 edi
  00048	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_??_7UProceduralTexture@@6B@
  0004d	89 06		 mov	 DWORD PTR [esi], eax
  0004f	8b ce		 mov	 ecx, esi
  00051	c7 44 24 24 02
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+48], 2
  00059	ff d7		 call	 edi
  0005b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_??_7UTexture@@6B@
  00061	89 0e		 mov	 DWORD PTR [esi], ecx
  00063	8b ce		 mov	 ecx, esi
  00065	c7 44 24 24 05
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+48], 5
  0006d	ff d7		 call	 edi
  0006f	8d be b4 00 00
	00		 lea	 edi, DWORD PTR [esi+180]
  00075	89 7c 24 18	 mov	 DWORD PTR $T138216[esp+40], edi
  00079	8b 5f 04	 mov	 ebx, DWORD PTR [edi+4]
  0007c	3b dd		 cmp	 ebx, ebp
  0007e	c6 44 24 24 06	 mov	 BYTE PTR __$EHRec$[esp+48], 6
  00083	7d 18		 jge	 SHORT $L138347
  00085	68 fd 01 00 00	 push	 509			; 000001fdH
  0008a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@MLGP@?4?4?2?4?4?2Core?2Inc?2UnTemplate?4h?$AA@ ; `string'
  0008f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BA@FEMP@Index?$DM?$DNArrayNum?$AA@ ; `string'
  00094	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?appFailAssert@@YAXPBD0H@Z
  0009a	83 c4 0c	 add	 esp, 12			; 0000000cH
$L138347:
  0009d	3b 5f 04	 cmp	 ebx, DWORD PTR [edi+4]
  000a0	7e 18		 jle	 SHORT $L138348
  000a2	68 fe 01 00 00	 push	 510			; 000001feH
  000a7	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@MLGP@?4?4?2?4?4?2Core?2Inc?2UnTemplate?4h?$AA@ ; `string'
  000ac	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BG@BEDF@Index?$CLCount?$DM?$DNArrayNum?$AA@ ; `string'
  000b1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?appFailAssert@@YAXPBD0H@Z
  000b7	83 c4 0c	 add	 esp, 12			; 0000000cH
$L138348:
  000ba	3b dd		 cmp	 ebx, ebp
  000bc	7e 1f		 jle	 SHORT $L138353
  000be	89 5c 24 10	 mov	 DWORD PTR -24+[esp+40], ebx
$L138351:
  000c2	8b 0f		 mov	 ecx, DWORD PTR [edi]
  000c4	6a 00		 push	 0
  000c6	03 cd		 add	 ecx, ebp
  000c8	e8 00 00 00 00	 call	 ??_GFMipmap@@QAEPAXI@Z	; FMipmap::`scalar deleting destructor'
  000cd	8b 44 24 10	 mov	 eax, DWORD PTR -24+[esp+40]
  000d1	83 c5 28	 add	 ebp, 40			; 00000028H
  000d4	48		 dec	 eax
  000d5	89 44 24 10	 mov	 DWORD PTR -24+[esp+40], eax
  000d9	75 e7		 jne	 SHORT $L138351
  000db	33 ed		 xor	 ebp, ebp
$L138353:
  000dd	6a 28		 push	 40			; 00000028H
  000df	53		 push	 ebx
  000e0	55		 push	 ebp
  000e1	8b cf		 mov	 ecx, edi
  000e3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Remove@FArray@@QAEXHHH@Z
  000e9	8b 07		 mov	 eax, DWORD PTR [edi]
  000eb	3b c5		 cmp	 eax, ebp
  000ed	c6 44 24 24 04	 mov	 BYTE PTR __$EHRec$[esp+48], 4
  000f2	74 0e		 je	 SHORT $L138359
  000f4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR __imp_?GMalloc@@3PAVFMalloc@@A
  000fa	8b 0a		 mov	 ecx, DWORD PTR [edx]
  000fc	8b 11		 mov	 edx, DWORD PTR [ecx]
  000fe	50		 push	 eax
  000ff	ff 52 08	 call	 DWORD PTR [edx+8]
$L138359:
  00102	89 2f		 mov	 DWORD PTR [edi], ebp
  00104	89 6f 08	 mov	 DWORD PTR [edi+8], ebp
  00107	89 6f 04	 mov	 DWORD PTR [edi+4], ebp
  0010a	8d be a8 00 00
	00		 lea	 edi, DWORD PTR [esi+168]
  00110	89 7c 24 18	 mov	 DWORD PTR $T138257[esp+40], edi
  00114	8b 6f 04	 mov	 ebp, DWORD PTR [edi+4]
  00117	85 ed		 test	 ebp, ebp
  00119	c6 44 24 24 07	 mov	 BYTE PTR __$EHRec$[esp+48], 7
  0011e	7d 18		 jge	 SHORT $L138370
  00120	68 fd 01 00 00	 push	 509			; 000001fdH
  00125	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@MLGP@?4?4?2?4?4?2Core?2Inc?2UnTemplate?4h?$AA@ ; `string'
  0012a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BA@FEMP@Index?$DM?$DNArrayNum?$AA@ ; `string'
  0012f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?appFailAssert@@YAXPBD0H@Z
  00135	83 c4 0c	 add	 esp, 12			; 0000000cH
$L138370:
  00138	3b 6f 04	 cmp	 ebp, DWORD PTR [edi+4]
  0013b	7e 18		 jle	 SHORT $L138371
  0013d	68 fe 01 00 00	 push	 510			; 000001feH
  00142	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@MLGP@?4?4?2?4?4?2Core?2Inc?2UnTemplate?4h?$AA@ ; `string'
  00147	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BG@BEDF@Index?$CLCount?$DM?$DNArrayNum?$AA@ ; `string'
  0014c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?appFailAssert@@YAXPBD0H@Z
  00152	83 c4 0c	 add	 esp, 12			; 0000000cH
$L138371:
  00155	85 ed		 test	 ebp, ebp
  00157	7e 20		 jle	 SHORT $L138376
  00159	33 db		 xor	 ebx, ebx
  0015b	89 6c 24 10	 mov	 DWORD PTR -24+[esp+40], ebp
  0015f	90		 npad	 1
$L138374:
  00160	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00162	6a 00		 push	 0
  00164	03 cb		 add	 ecx, ebx
  00166	e8 00 00 00 00	 call	 ??_GFMipmap@@QAEPAXI@Z	; FMipmap::`scalar deleting destructor'
  0016b	8b 44 24 10	 mov	 eax, DWORD PTR -24+[esp+40]
  0016f	83 c3 28	 add	 ebx, 40			; 00000028H
  00172	48		 dec	 eax
  00173	89 44 24 10	 mov	 DWORD PTR -24+[esp+40], eax
  00177	75 e7		 jne	 SHORT $L138374
$L138376:
  00179	6a 28		 push	 40			; 00000028H
  0017b	55		 push	 ebp
  0017c	6a 00		 push	 0
  0017e	8b cf		 mov	 ecx, edi
  00180	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Remove@FArray@@QAEXHHH@Z
  00186	8b cf		 mov	 ecx, edi
  00188	c6 44 24 24 03	 mov	 BYTE PTR __$EHRec$[esp+48], 3
  0018d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1FArray@@QAE@XZ
  00193	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_??_7UBitmap@@6B@
  00198	89 06		 mov	 DWORD PTR [esi], eax
  0019a	8b ce		 mov	 ecx, esi
  0019c	c7 44 24 24 08
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+48], 8
  001a4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?ConditionalDestroy@UObject@@QAEHXZ
  001aa	8b ce		 mov	 ecx, esi
  001ac	c7 44 24 24 ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+48], -1
  001b4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1UObject@@UAE@XZ
  001ba	8b 4c 24 1c	 mov	 ecx, DWORD PTR __$EHRec$[esp+40]
  001be	5f		 pop	 edi
  001bf	5e		 pop	 esi
  001c0	5d		 pop	 ebp
  001c1	5b		 pop	 ebx
  001c2	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  001c9	83 c4 18	 add	 esp, 24			; 00000018H
  001cc	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L138160:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1UFractalTexture@@UAE@XZ ; UFractalTexture::~UFractalTexture
$L138162:
  00008	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1UProceduralTexture@@UAE@XZ
$L138164:
  00011	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1UTexture@@UAE@XZ
$L138166:
  0001a	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1UBitmap@@UAE@XZ
$L138167:
  00023	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	81 c1 a8 00 00
	00		 add	 ecx, 168		; 000000a8H
  0002c	e9 00 00 00 00	 jmp	 ??1?$TArray@UFMipmap@@@@QAE@XZ ; TArray<FMipmap>::~TArray<FMipmap>
$L138168:
  00031	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	81 c1 b4 00 00
	00		 add	 ecx, 180		; 000000b4H
  0003a	e9 00 00 00 00	 jmp	 ??1?$TArray@UFMipmap@@@@QAE@XZ ; TArray<FMipmap>::~TArray<FMipmap>
$L138170:
  0003f	8b 4d f0	 mov	 ecx, DWORD PTR $T138216[ebp]
  00042	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1FArray@@QAE@XZ
$L138218:
  00048	8b 4d f0	 mov	 ecx, DWORD PTR $T138257[ebp]
  0004b	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1FArray@@QAE@XZ
$L138259:
  00051	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00054	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1UObject@@UAE@XZ
$L138394:
  0005a	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T138386
  0005f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??1UWaterTexture@@UAE@XZ ENDP				; UWaterTexture::~UWaterTexture
PUBLIC	??0UWaterTexture@@QAE@ABV0@@Z			; UWaterTexture::UWaterTexture
;	COMDAT xdata$x
xdata$x	SEGMENT
$T138435 DD	0ffffffffH
	DD	FLAT:$L138407
	DD	00H
	DD	FLAT:$L138408
$T138433 DD	019930520H
	DD	02H
	DD	FLAT:$T138435
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ??0UWaterTexture@@QAE@ABV0@@Z
_TEXT	SEGMENT
__$EHRec$ = -12
___that$ = 8
_this$ = -16
??0UWaterTexture@@QAE@ABV0@@Z PROC NEAR			; UWaterTexture::UWaterTexture, COMDAT
; _this$ = ecx
  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 $L138434
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	51		 push	 ecx
  00016	53		 push	 ebx
  00017	55		 push	 ebp
  00018	8b 6c 24 1c	 mov	 ebp, DWORD PTR ___that$[esp+20]
  0001c	56		 push	 esi
  0001d	57		 push	 edi
  0001e	8b d9		 mov	 ebx, ecx
  00020	55		 push	 ebp
  00021	89 5c 24 14	 mov	 DWORD PTR _this$[esp+36], ebx
  00025	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0UObject@@QAE@ABV0@@Z
  0002b	8a 45 28	 mov	 al, BYTE PTR [ebp+40]
  0002e	88 43 28	 mov	 BYTE PTR [ebx+40], al
  00031	8b 4d 2c	 mov	 ecx, DWORD PTR [ebp+44]
  00034	89 4b 2c	 mov	 DWORD PTR [ebx+44], ecx
  00037	8a 55 30	 mov	 dl, BYTE PTR [ebp+48]
  0003a	88 53 30	 mov	 BYTE PTR [ebx+48], dl
  0003d	8a 45 31	 mov	 al, BYTE PTR [ebp+49]
  00040	88 43 31	 mov	 BYTE PTR [ebx+49], al
  00043	8b 4d 34	 mov	 ecx, DWORD PTR [ebp+52]
  00046	89 4b 34	 mov	 DWORD PTR [ebx+52], ecx
  00049	8b 55 38	 mov	 edx, DWORD PTR [ebp+56]
  0004c	89 53 38	 mov	 DWORD PTR [ebx+56], edx
  0004f	8b 45 3c	 mov	 eax, DWORD PTR [ebp+60]
  00052	89 43 3c	 mov	 DWORD PTR [ebx+60], eax
  00055	8b 4d 40	 mov	 ecx, DWORD PTR [ebp+64]
  00058	89 4b 40	 mov	 DWORD PTR [ebx+64], ecx
  0005b	8b 55 44	 mov	 edx, DWORD PTR [ebp+68]
  0005e	89 53 44	 mov	 DWORD PTR [ebx+68], edx
  00061	8b 45 48	 mov	 eax, DWORD PTR [ebp+72]
  00064	89 43 48	 mov	 DWORD PTR [ebx+72], eax
  00067	8b 4d 4c	 mov	 ecx, DWORD PTR [ebp+76]
  0006a	89 4b 4c	 mov	 DWORD PTR [ebx+76], ecx
  0006d	8b 55 50	 mov	 edx, DWORD PTR [ebp+80]
  00070	89 53 50	 mov	 DWORD PTR [ebx+80], edx
  00073	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_??_7UBitmap@@6B@
  00078	89 03		 mov	 DWORD PTR [ebx], eax
  0007a	8b 4d 54	 mov	 ecx, DWORD PTR [ebp+84]
  0007d	89 4b 54	 mov	 DWORD PTR [ebx+84], ecx
  00080	8b 55 58	 mov	 edx, DWORD PTR [ebp+88]
  00083	89 53 58	 mov	 DWORD PTR [ebx+88], edx
  00086	8b 45 5c	 mov	 eax, DWORD PTR [ebp+92]
  00089	89 43 5c	 mov	 DWORD PTR [ebx+92], eax
  0008c	8b 4d 60	 mov	 ecx, DWORD PTR [ebp+96]
  0008f	89 4b 60	 mov	 DWORD PTR [ebx+96], ecx
  00092	8b 55 64	 mov	 edx, DWORD PTR [ebp+100]
  00095	89 53 64	 mov	 DWORD PTR [ebx+100], edx
  00098	8b 45 68	 mov	 eax, DWORD PTR [ebp+104]
  0009b	89 43 68	 mov	 DWORD PTR [ebx+104], eax
  0009e	8b 4d 6c	 mov	 ecx, DWORD PTR [ebp+108]
  000a1	89 4b 6c	 mov	 DWORD PTR [ebx+108], ecx
  000a4	8b 55 70	 mov	 edx, DWORD PTR [ebp+112]
  000a7	89 53 70	 mov	 DWORD PTR [ebx+112], edx
  000aa	8b 45 74	 mov	 eax, DWORD PTR [ebp+116]
  000ad	89 43 74	 mov	 DWORD PTR [ebx+116], eax
  000b0	8b 4d 78	 mov	 ecx, DWORD PTR [ebp+120]
  000b3	89 4b 78	 mov	 DWORD PTR [ebx+120], ecx
  000b6	8b 55 7c	 mov	 edx, DWORD PTR [ebp+124]
  000b9	89 53 7c	 mov	 DWORD PTR [ebx+124], edx
  000bc	8b 85 80 00 00
	00		 mov	 eax, DWORD PTR [ebp+128]
  000c2	89 83 80 00 00
	00		 mov	 DWORD PTR [ebx+128], eax
  000c8	8b 8d 84 00 00
	00		 mov	 ecx, DWORD PTR [ebp+132]
  000ce	89 8b 84 00 00
	00		 mov	 DWORD PTR [ebx+132], ecx
  000d4	8b 8b 88 00 00
	00		 mov	 ecx, DWORD PTR [ebx+136]
  000da	8b 85 88 00 00
	00		 mov	 eax, DWORD PTR [ebp+136]
  000e0	33 c1		 xor	 eax, ecx
  000e2	83 e0 01	 and	 eax, 1
  000e5	33 c1		 xor	 eax, ecx
  000e7	89 83 88 00 00
	00		 mov	 DWORD PTR [ebx+136], eax
  000ed	8b 8d 88 00 00
	00		 mov	 ecx, DWORD PTR [ebp+136]
  000f3	33 c8		 xor	 ecx, eax
  000f5	83 e1 02	 and	 ecx, 2
  000f8	33 c8		 xor	 ecx, eax
  000fa	89 8b 88 00 00
	00		 mov	 DWORD PTR [ebx+136], ecx
  00100	8b 85 88 00 00
	00		 mov	 eax, DWORD PTR [ebp+136]
  00106	33 c1		 xor	 eax, ecx
  00108	83 e0 04	 and	 eax, 4
  0010b	33 c1		 xor	 eax, ecx
  0010d	89 83 88 00 00
	00		 mov	 DWORD PTR [ebx+136], eax
  00113	8b 8d 88 00 00
	00		 mov	 ecx, DWORD PTR [ebp+136]
  00119	c7 44 24 1c 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+40], 0
  00121	33 c8		 xor	 ecx, eax
  00123	83 e1 08	 and	 ecx, 8
  00126	33 c8		 xor	 ecx, eax
  00128	89 8b 88 00 00
	00		 mov	 DWORD PTR [ebx+136], ecx
  0012e	8b 85 88 00 00
	00		 mov	 eax, DWORD PTR [ebp+136]
  00134	33 c1		 xor	 eax, ecx
  00136	83 e0 10	 and	 eax, 16			; 00000010H
  00139	33 c1		 xor	 eax, ecx
  0013b	89 83 88 00 00
	00		 mov	 DWORD PTR [ebx+136], eax
  00141	8b 95 88 00 00
	00		 mov	 edx, DWORD PTR [ebp+136]
  00147	33 d0		 xor	 edx, eax
  00149	83 e2 20	 and	 edx, 32			; 00000020H
  0014c	33 d0		 xor	 edx, eax
  0014e	89 93 88 00 00
	00		 mov	 DWORD PTR [ebx+136], edx
  00154	8a 85 8c 00 00
	00		 mov	 al, BYTE PTR [ebp+140]
  0015a	88 83 8c 00 00
	00		 mov	 BYTE PTR [ebx+140], al
  00160	8b 8d 90 00 00
	00		 mov	 ecx, DWORD PTR [ebp+144]
  00166	89 8b 90 00 00
	00		 mov	 DWORD PTR [ebx+144], ecx
  0016c	8b 95 94 00 00
	00		 mov	 edx, DWORD PTR [ebp+148]
  00172	89 93 94 00 00
	00		 mov	 DWORD PTR [ebx+148], edx
  00178	8a 85 98 00 00
	00		 mov	 al, BYTE PTR [ebp+152]
  0017e	88 83 98 00 00
	00		 mov	 BYTE PTR [ebx+152], al
  00184	8a 8d 99 00 00
	00		 mov	 cl, BYTE PTR [ebp+153]
  0018a	88 8b 99 00 00
	00		 mov	 BYTE PTR [ebx+153], cl
  00190	8b 95 9c 00 00
	00		 mov	 edx, DWORD PTR [ebp+156]
  00196	89 93 9c 00 00
	00		 mov	 DWORD PTR [ebx+156], edx
  0019c	8b 85 a0 00 00
	00		 mov	 eax, DWORD PTR [ebp+160]
  001a2	89 83 a0 00 00
	00		 mov	 DWORD PTR [ebx+160], eax
  001a8	8b 8d a4 00 00
	00		 mov	 ecx, DWORD PTR [ebp+164]
  001ae	8d 95 a8 00 00
	00		 lea	 edx, DWORD PTR [ebp+168]
  001b4	89 8b a4 00 00
	00		 mov	 DWORD PTR [ebx+164], ecx
  001ba	52		 push	 edx
  001bb	8d 8b a8 00 00
	00		 lea	 ecx, DWORD PTR [ebx+168]
  001c1	e8 00 00 00 00	 call	 ??0?$TArray@UFMipmap@@@@QAE@ABV0@@Z ; TArray<FMipmap>::TArray<FMipmap>
  001c6	8d 85 b4 00 00
	00		 lea	 eax, DWORD PTR [ebp+180]
  001cc	50		 push	 eax
  001cd	8d 8b b4 00 00
	00		 lea	 ecx, DWORD PTR [ebx+180]
  001d3	c6 44 24 20 01	 mov	 BYTE PTR __$EHRec$[esp+44], 1
  001d8	e8 00 00 00 00	 call	 ??0?$TArray@UFMipmap@@@@QAE@ABV0@@Z ; TArray<FMipmap>::TArray<FMipmap>
  001dd	8a 8d c0 00 00
	00		 mov	 cl, BYTE PTR [ebp+192]
  001e3	88 8b c0 00 00
	00		 mov	 BYTE PTR [ebx+192], cl
  001e9	8b 95 c4 00 00
	00		 mov	 edx, DWORD PTR [ebp+196]
  001ef	89 93 c4 00 00
	00		 mov	 DWORD PTR [ebx+196], edx
  001f5	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_??_7UTexture@@6B@
  001fa	89 03		 mov	 DWORD PTR [ebx], eax
  001fc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_??_7UProceduralTexture@@6B@
  00202	89 0b		 mov	 DWORD PTR [ebx], ecx
  00204	8b 95 c8 00 00
	00		 mov	 edx, DWORD PTR [ebp+200]
  0020a	89 93 c8 00 00
	00		 mov	 DWORD PTR [ebx+200], edx
  00210	8b 85 cc 00 00
	00		 mov	 eax, DWORD PTR [ebp+204]
  00216	89 83 cc 00 00
	00		 mov	 DWORD PTR [ebx+204], eax
  0021c	8b 8d d0 00 00
	00		 mov	 ecx, DWORD PTR [ebp+208]
  00222	89 8b d0 00 00
	00		 mov	 DWORD PTR [ebx+208], ecx
  00228	8b 95 d4 00 00
	00		 mov	 edx, DWORD PTR [ebp+212]
  0022e	89 93 d4 00 00
	00		 mov	 DWORD PTR [ebx+212], edx
  00234	8b 85 d8 00 00
	00		 mov	 eax, DWORD PTR [ebp+216]
  0023a	89 83 d8 00 00
	00		 mov	 DWORD PTR [ebx+216], eax
  00240	8a 8d dc 00 00
	00		 mov	 cl, BYTE PTR [ebp+220]
  00246	88 8b dc 00 00
	00		 mov	 BYTE PTR [ebx+220], cl
  0024c	8a 95 dd 00 00
	00		 mov	 dl, BYTE PTR [ebp+221]
  00252	88 93 dd 00 00
	00		 mov	 BYTE PTR [ebx+221], dl
  00258	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], OFFSET FLAT:??_7UFractalTexture@@6B@ ; UFractalTexture::`vftable'
  0025e	8a 85 e0 00 00
	00		 mov	 al, BYTE PTR [ebp+224]
  00264	88 83 e0 00 00
	00		 mov	 BYTE PTR [ebx+224], al
  0026a	8a 8d e1 00 00
	00		 mov	 cl, BYTE PTR [ebp+225]
  00270	88 8b e1 00 00
	00		 mov	 BYTE PTR [ebx+225], cl
  00276	8a 95 e2 00 00
	00		 mov	 dl, BYTE PTR [ebp+226]
  0027c	88 93 e2 00 00
	00		 mov	 BYTE PTR [ebx+226], dl
  00282	8a 85 e3 00 00
	00		 mov	 al, BYTE PTR [ebp+227]
  00288	88 83 e3 00 00
	00		 mov	 BYTE PTR [ebx+227], al
  0028e	8a 8d e4 00 00
	00		 mov	 cl, BYTE PTR [ebp+228]
  00294	88 8b e4 00 00
	00		 mov	 BYTE PTR [ebx+228], cl
  0029a	8a 95 e5 00 00
	00		 mov	 dl, BYTE PTR [ebp+229]
  002a0	88 93 e5 00 00
	00		 mov	 BYTE PTR [ebx+229], dl
  002a6	8a 85 e6 00 00
	00		 mov	 al, BYTE PTR [ebp+230]
  002ac	88 83 e6 00 00
	00		 mov	 BYTE PTR [ebx+230], al
  002b2	8a 8d e7 00 00
	00		 mov	 cl, BYTE PTR [ebp+231]
  002b8	88 8b e7 00 00
	00		 mov	 BYTE PTR [ebx+231], cl
  002be	8a 95 e8 00 00
	00		 mov	 dl, BYTE PTR [ebp+232]
  002c4	88 93 e8 00 00
	00		 mov	 BYTE PTR [ebx+232], dl
  002ca	8a 85 e9 00 00
	00		 mov	 al, BYTE PTR [ebp+233]
  002d0	88 83 e9 00 00
	00		 mov	 BYTE PTR [ebx+233], al
  002d6	8b 8d ec 00 00
	00		 mov	 ecx, DWORD PTR [ebp+236]
  002dc	89 8b ec 00 00
	00		 mov	 DWORD PTR [ebx+236], ecx
  002e2	8d b5 f0 00 00
	00		 lea	 esi, DWORD PTR [ebp+240]
  002e8	8d bb f0 00 00
	00		 lea	 edi, DWORD PTR [ebx+240]
  002ee	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  002f3	f3 a5		 rep movsd
  002f5	8b 95 f0 08 00
	00		 mov	 edx, DWORD PTR [ebp+2288]
  002fb	89 93 f0 08 00
	00		 mov	 DWORD PTR [ebx+2288], edx
  00301	8d b5 f4 08 00
	00		 lea	 esi, DWORD PTR [ebp+2292]
  00307	8d bb f4 08 00
	00		 lea	 edi, DWORD PTR [ebx+2292]
  0030d	b9 01 01 00 00	 mov	 ecx, 257		; 00000101H
  00312	f3 a5		 rep movsd
  00314	8d b5 f8 0c 00
	00		 lea	 esi, DWORD PTR [ebp+3320]
  0031a	8d bb f8 0c 00
	00		 lea	 edi, DWORD PTR [ebx+3320]
  00320	b9 80 01 00 00	 mov	 ecx, 384		; 00000180H
  00325	f3 a5		 rep movsd
  00327	8a 85 f8 12 00
	00		 mov	 al, BYTE PTR [ebp+4856]
  0032d	88 83 f8 12 00
	00		 mov	 BYTE PTR [ebx+4856], al
  00333	8b 8d fc 12 00
	00		 mov	 ecx, DWORD PTR [ebp+4860]
  00339	5f		 pop	 edi
  0033a	89 8b fc 12 00
	00		 mov	 DWORD PTR [ebx+4860], ecx
  00340	8b 4c 24 10	 mov	 ecx, DWORD PTR __$EHRec$[esp+28]
  00344	5e		 pop	 esi
  00345	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], OFFSET FLAT:??_7UWaterTexture@@6B@ ; UWaterTexture::`vftable'
  0034b	5d		 pop	 ebp
  0034c	8b c3		 mov	 eax, ebx
  0034e	5b		 pop	 ebx
  0034f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00356	83 c4 10	 add	 esp, 16			; 00000010H
  00359	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L138407:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1UBitmap@@UAE@XZ
$L138408:
  00009	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	81 c1 a8 00 00
	00		 add	 ecx, 168		; 000000a8H
  00012	e9 00 00 00 00	 jmp	 ??1?$TArray@UFMipmap@@@@QAE@XZ ; TArray<FMipmap>::~TArray<FMipmap>
$L138434:
  00017	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T138433
  0001c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0UWaterTexture@@QAE@ABV0@@Z ENDP			; UWaterTexture::UWaterTexture
PUBLIC	??4UWaterTexture@@QAEAAV0@ABV0@@Z		; UWaterTexture::operator=
PUBLIC	?Empty@?$TArray@UFMipmap@@@@QAEXH@Z		; TArray<FMipmap>::Empty
; Function compile flags: /Ogty
;	COMDAT ??4UWaterTexture@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8
_i$138515 = -4
??4UWaterTexture@@QAEAAV0@ABV0@@Z PROC NEAR		; UWaterTexture::operator=, COMDAT
; _this$ = ecx
  00000	51		 push	 ecx
  00001	53		 push	 ebx
  00002	55		 push	 ebp
  00003	56		 push	 esi
  00004	57		 push	 edi
  00005	8b 7c 24 18	 mov	 edi, DWORD PTR ___that$[esp+16]
  00009	57		 push	 edi
  0000a	8b f1		 mov	 esi, ecx
  0000c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4UObject@@QAEAAV0@ABV0@@Z
  00012	8a 47 28	 mov	 al, BYTE PTR [edi+40]
  00015	88 46 28	 mov	 BYTE PTR [esi+40], al
  00018	8b 4f 2c	 mov	 ecx, DWORD PTR [edi+44]
  0001b	89 4e 2c	 mov	 DWORD PTR [esi+44], ecx
  0001e	8a 57 30	 mov	 dl, BYTE PTR [edi+48]
  00021	88 56 30	 mov	 BYTE PTR [esi+48], dl
  00024	8a 47 31	 mov	 al, BYTE PTR [edi+49]
  00027	88 46 31	 mov	 BYTE PTR [esi+49], al
  0002a	8b 4f 34	 mov	 ecx, DWORD PTR [edi+52]
  0002d	89 4e 34	 mov	 DWORD PTR [esi+52], ecx
  00030	8b 57 38	 mov	 edx, DWORD PTR [edi+56]
  00033	89 56 38	 mov	 DWORD PTR [esi+56], edx
  00036	8b 47 3c	 mov	 eax, DWORD PTR [edi+60]
  00039	89 46 3c	 mov	 DWORD PTR [esi+60], eax
  0003c	8b 4f 40	 mov	 ecx, DWORD PTR [edi+64]
  0003f	89 4e 40	 mov	 DWORD PTR [esi+64], ecx
  00042	8b 57 44	 mov	 edx, DWORD PTR [edi+68]
  00045	89 56 44	 mov	 DWORD PTR [esi+68], edx
  00048	8b 47 48	 mov	 eax, DWORD PTR [edi+72]
  0004b	89 46 48	 mov	 DWORD PTR [esi+72], eax
  0004e	8b 4f 4c	 mov	 ecx, DWORD PTR [edi+76]
  00051	89 4e 4c	 mov	 DWORD PTR [esi+76], ecx
  00054	8b 57 50	 mov	 edx, DWORD PTR [edi+80]
  00057	89 56 50	 mov	 DWORD PTR [esi+80], edx
  0005a	8b 47 54	 mov	 eax, DWORD PTR [edi+84]
  0005d	89 46 54	 mov	 DWORD PTR [esi+84], eax
  00060	8b 4f 58	 mov	 ecx, DWORD PTR [edi+88]
  00063	89 4e 58	 mov	 DWORD PTR [esi+88], ecx
  00066	8b 57 5c	 mov	 edx, DWORD PTR [edi+92]
  00069	89 56 5c	 mov	 DWORD PTR [esi+92], edx
  0006c	8b 47 60	 mov	 eax, DWORD PTR [edi+96]
  0006f	89 46 60	 mov	 DWORD PTR [esi+96], eax
  00072	8b 4f 64	 mov	 ecx, DWORD PTR [edi+100]
  00075	89 4e 64	 mov	 DWORD PTR [esi+100], ecx
  00078	8b 57 68	 mov	 edx, DWORD PTR [edi+104]
  0007b	89 56 68	 mov	 DWORD PTR [esi+104], edx
  0007e	8b 47 6c	 mov	 eax, DWORD PTR [edi+108]
  00081	89 46 6c	 mov	 DWORD PTR [esi+108], eax
  00084	8b 4f 70	 mov	 ecx, DWORD PTR [edi+112]
  00087	89 4e 70	 mov	 DWORD PTR [esi+112], ecx
  0008a	8b 57 74	 mov	 edx, DWORD PTR [edi+116]
  0008d	89 56 74	 mov	 DWORD PTR [esi+116], edx
  00090	8b 47 78	 mov	 eax, DWORD PTR [edi+120]
  00093	89 46 78	 mov	 DWORD PTR [esi+120], eax
  00096	8b 4f 7c	 mov	 ecx, DWORD PTR [edi+124]
  00099	89 4e 7c	 mov	 DWORD PTR [esi+124], ecx
  0009c	8b 97 80 00 00
	00		 mov	 edx, DWORD PTR [edi+128]
  000a2	8b 8e 88 00 00
	00		 mov	 ecx, DWORD PTR [esi+136]
  000a8	89 96 80 00 00
	00		 mov	 DWORD PTR [esi+128], edx
  000ae	8b 87 84 00 00
	00		 mov	 eax, DWORD PTR [edi+132]
  000b4	89 86 84 00 00
	00		 mov	 DWORD PTR [esi+132], eax
  000ba	8b 87 88 00 00
	00		 mov	 eax, DWORD PTR [edi+136]
  000c0	33 c1		 xor	 eax, ecx
  000c2	83 e0 01	 and	 eax, 1
  000c5	33 c1		 xor	 eax, ecx
  000c7	89 86 88 00 00
	00		 mov	 DWORD PTR [esi+136], eax
  000cd	8b 8f 88 00 00
	00		 mov	 ecx, DWORD PTR [edi+136]
  000d3	33 c8		 xor	 ecx, eax
  000d5	83 e1 02	 and	 ecx, 2
  000d8	33 c8		 xor	 ecx, eax
  000da	89 8e 88 00 00
	00		 mov	 DWORD PTR [esi+136], ecx
  000e0	8b 87 88 00 00
	00		 mov	 eax, DWORD PTR [edi+136]
  000e6	33 c1		 xor	 eax, ecx
  000e8	83 e0 04	 and	 eax, 4
  000eb	33 c1		 xor	 eax, ecx
  000ed	89 86 88 00 00
	00		 mov	 DWORD PTR [esi+136], eax
  000f3	8b 8f 88 00 00
	00		 mov	 ecx, DWORD PTR [edi+136]
  000f9	33 c8		 xor	 ecx, eax
  000fb	83 e1 08	 and	 ecx, 8
  000fe	33 c8		 xor	 ecx, eax
  00100	89 8e 88 00 00
	00		 mov	 DWORD PTR [esi+136], ecx
  00106	8b 87 88 00 00
	00		 mov	 eax, DWORD PTR [edi+136]
  0010c	33 c1		 xor	 eax, ecx
  0010e	83 e0 10	 and	 eax, 16			; 00000010H
  00111	33 c1		 xor	 eax, ecx
  00113	89 86 88 00 00
	00		 mov	 DWORD PTR [esi+136], eax
  00119	8b 8f 88 00 00
	00		 mov	 ecx, DWORD PTR [edi+136]
  0011f	33 c8		 xor	 ecx, eax
  00121	83 e1 20	 and	 ecx, 32			; 00000020H
  00124	33 c8		 xor	 ecx, eax
  00126	89 8e 88 00 00
	00		 mov	 DWORD PTR [esi+136], ecx
  0012c	8a 97 8c 00 00
	00		 mov	 dl, BYTE PTR [edi+140]
  00132	88 96 8c 00 00
	00		 mov	 BYTE PTR [esi+140], dl
  00138	8b 87 90 00 00
	00		 mov	 eax, DWORD PTR [edi+144]
  0013e	89 86 90 00 00
	00		 mov	 DWORD PTR [esi+144], eax
  00144	8b 8f 94 00 00
	00		 mov	 ecx, DWORD PTR [edi+148]
  0014a	89 8e 94 00 00
	00		 mov	 DWORD PTR [esi+148], ecx
  00150	8a 97 98 00 00
	00		 mov	 dl, BYTE PTR [edi+152]
  00156	88 96 98 00 00
	00		 mov	 BYTE PTR [esi+152], dl
  0015c	8a 87 99 00 00
	00		 mov	 al, BYTE PTR [edi+153]
  00162	88 86 99 00 00
	00		 mov	 BYTE PTR [esi+153], al
  00168	8b 8f 9c 00 00
	00		 mov	 ecx, DWORD PTR [edi+156]
  0016e	89 8e 9c 00 00
	00		 mov	 DWORD PTR [esi+156], ecx
  00174	8b 97 a0 00 00
	00		 mov	 edx, DWORD PTR [edi+160]
  0017a	89 96 a0 00 00
	00		 mov	 DWORD PTR [esi+160], edx
  00180	8b 87 a4 00 00
	00		 mov	 eax, DWORD PTR [edi+164]
  00186	8d 9f a8 00 00
	00		 lea	 ebx, DWORD PTR [edi+168]
  0018c	8d ae a8 00 00
	00		 lea	 ebp, DWORD PTR [esi+168]
  00192	3b eb		 cmp	 ebp, ebx
  00194	89 86 a4 00 00
	00		 mov	 DWORD PTR [esi+164], eax
  0019a	74 55		 je	 SHORT $L138518
  0019c	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  0019f	51		 push	 ecx
  001a0	8b cd		 mov	 ecx, ebp
  001a2	e8 00 00 00 00	 call	 ?Empty@?$TArray@UFMipmap@@@@QAEXH@Z ; TArray<FMipmap>::Empty
  001a7	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  001aa	33 c0		 xor	 eax, eax
  001ac	3b c8		 cmp	 ecx, eax
  001ae	89 44 24 10	 mov	 DWORD PTR _i$138515[esp+20], eax
  001b2	7e 3d		 jle	 SHORT $L138518
  001b4	89 44 24 18	 mov	 DWORD PTR 8+[esp+16], eax
$L138516:
  001b8	55		 push	 ebp
  001b9	6a 28		 push	 40			; 00000028H
  001bb	e8 00 00 00 00	 call	 ??2@YAPAXIAAV?$TArray@UFMipmap@@@@@Z ; operator new
  001c0	83 c4 08	 add	 esp, 8
  001c3	85 c0		 test	 eax, eax
  001c5	74 0f		 je	 SHORT $L138517
  001c7	8b 13		 mov	 edx, DWORD PTR [ebx]
  001c9	03 54 24 18	 add	 edx, DWORD PTR 8+[esp+16]
  001cd	52		 push	 edx
  001ce	8b c8		 mov	 ecx, eax
  001d0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0FMipmap@@QAE@ABU0@@Z
$L138517:
  001d6	8b 44 24 10	 mov	 eax, DWORD PTR _i$138515[esp+20]
  001da	8b 54 24 18	 mov	 edx, DWORD PTR 8+[esp+16]
  001de	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  001e1	40		 inc	 eax
  001e2	83 c2 28	 add	 edx, 40			; 00000028H
  001e5	3b c1		 cmp	 eax, ecx
  001e7	89 44 24 10	 mov	 DWORD PTR _i$138515[esp+20], eax
  001eb	89 54 24 18	 mov	 DWORD PTR 8+[esp+16], edx
  001ef	7c c7		 jl	 SHORT $L138516
$L138518:
  001f1	8d 87 b4 00 00
	00		 lea	 eax, DWORD PTR [edi+180]
  001f7	50		 push	 eax
  001f8	8d 8e b4 00 00
	00		 lea	 ecx, DWORD PTR [esi+180]
  001fe	e8 00 00 00 00	 call	 ??4?$TArray@UFMipmap@@@@QAEAAV0@ABV0@@Z ; TArray<FMipmap>::operator=
  00203	8a 8f c0 00 00
	00		 mov	 cl, BYTE PTR [edi+192]
  00209	88 8e c0 00 00
	00		 mov	 BYTE PTR [esi+192], cl
  0020f	8b 97 c4 00 00
	00		 mov	 edx, DWORD PTR [edi+196]
  00215	89 96 c4 00 00
	00		 mov	 DWORD PTR [esi+196], edx
  0021b	8b 87 c8 00 00
	00		 mov	 eax, DWORD PTR [edi+200]
  00221	89 86 c8 00 00
	00		 mov	 DWORD PTR [esi+200], eax
  00227	8b 8f cc 00 00
	00		 mov	 ecx, DWORD PTR [edi+204]
  0022d	89 8e cc 00 00
	00		 mov	 DWORD PTR [esi+204], ecx
  00233	8b 97 d0 00 00
	00		 mov	 edx, DWORD PTR [edi+208]
  00239	89 96 d0 00 00
	00		 mov	 DWORD PTR [esi+208], edx
  0023f	8b 87 d4 00 00
	00		 mov	 eax, DWORD PTR [edi+212]
  00245	89 86 d4 00 00
	00		 mov	 DWORD PTR [esi+212], eax
  0024b	8b 8f d8 00 00
	00		 mov	 ecx, DWORD PTR [edi+216]
  00251	89 8e d8 00 00
	00		 mov	 DWORD PTR [esi+216], ecx
  00257	8a 97 dc 00 00
	00		 mov	 dl, BYTE PTR [edi+220]
  0025d	88 96 dc 00 00
	00		 mov	 BYTE PTR [esi+220], dl
  00263	8a 87 dd 00 00
	00		 mov	 al, BYTE PTR [edi+221]
  00269	88 86 dd 00 00
	00		 mov	 BYTE PTR [esi+221], al
  0026f	8a 8f e0 00 00
	00		 mov	 cl, BYTE PTR [edi+224]
  00275	88 8e e0 00 00
	00		 mov	 BYTE PTR [esi+224], cl
  0027b	8a 97 e1 00 00
	00		 mov	 dl, BYTE PTR [edi+225]
  00281	88 96 e1 00 00
	00		 mov	 BYTE PTR [esi+225], dl
  00287	8a 87 e2 00 00
	00		 mov	 al, BYTE PTR [edi+226]
  0028d	88 86 e2 00 00
	00		 mov	 BYTE PTR [esi+226], al
  00293	8a 8f e3 00 00
	00		 mov	 cl, BYTE PTR [edi+227]
  00299	88 8e e3 00 00
	00		 mov	 BYTE PTR [esi+227], cl
  0029f	8a 97 e4 00 00
	00		 mov	 dl, BYTE PTR [edi+228]
  002a5	88 96 e4 00 00
	00		 mov	 BYTE PTR [esi+228], dl
  002ab	8a 87 e5 00 00
	00		 mov	 al, BYTE PTR [edi+229]
  002b1	88 86 e5 00 00
	00		 mov	 BYTE PTR [esi+229], al
  002b7	8a 8f e6 00 00
	00		 mov	 cl, BYTE PTR [edi+230]
  002bd	88 8e e6 00 00
	00		 mov	 BYTE PTR [esi+230], cl
  002c3	8a 97 e7 00 00
	00		 mov	 dl, BYTE PTR [edi+231]
  002c9	88 96 e7 00 00
	00		 mov	 BYTE PTR [esi+231], dl
  002cf	8a 87 e8 00 00
	00		 mov	 al, BYTE PTR [edi+232]
  002d5	88 86 e8 00 00
	00		 mov	 BYTE PTR [esi+232], al
  002db	8a 8f e9 00 00
	00		 mov	 cl, BYTE PTR [edi+233]
  002e1	88 8e e9 00 00
	00		 mov	 BYTE PTR [esi+233], cl
  002e7	8b 97 ec 00 00
	00		 mov	 edx, DWORD PTR [edi+236]
  002ed	8b cf		 mov	 ecx, edi
  002ef	89 96 ec 00 00
	00		 mov	 DWORD PTR [esi+236], edx
  002f5	8d 86 f0 00 00
	00		 lea	 eax, DWORD PTR [esi+240]
  002fb	2b ce		 sub	 ecx, esi
  002fd	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
$L123266:
  00302	8b 1c 01	 mov	 ebx, DWORD PTR [ecx+eax]
  00305	89 18		 mov	 DWORD PTR [eax], ebx
  00307	8b 5c 01 04	 mov	 ebx, DWORD PTR [ecx+eax+4]
  0030b	89 58 04	 mov	 DWORD PTR [eax+4], ebx
  0030e	83 c0 08	 add	 eax, 8
  00311	4a		 dec	 edx
  00312	75 ee		 jne	 SHORT $L123266
  00314	8b 87 f0 08 00
	00		 mov	 eax, DWORD PTR [edi+2288]
  0031a	bd 0c f7 ff ff	 mov	 ebp, -2292		; fffff70cH
  0031f	89 86 f0 08 00
	00		 mov	 DWORD PTR [esi+2288], eax
  00325	8d 86 f4 08 00
	00		 lea	 eax, DWORD PTR [esi+2292]
  0032b	2b ee		 sub	 ebp, esi
  0032d	8d 49 00	 npad	 3
$L123270:
  00330	8a 14 08	 mov	 dl, BYTE PTR [eax+ecx]
  00333	88 10		 mov	 BYTE PTR [eax], dl
  00335	40		 inc	 eax
  00336	8d 14 28	 lea	 edx, DWORD PTR [eax+ebp]
  00339	81 fa 04 04 00
	00		 cmp	 edx, 1028		; 00000404H
  0033f	72 ef		 jb	 SHORT $L123270
  00341	bd 08 f3 ff ff	 mov	 ebp, -3320		; fffff308H
  00346	8d 86 f8 0c 00
	00		 lea	 eax, DWORD PTR [esi+3320]
  0034c	2b ee		 sub	 ebp, esi
  0034e	8b ff		 npad	 2
$L123274:
  00350	8a 14 08	 mov	 dl, BYTE PTR [eax+ecx]
  00353	88 10		 mov	 BYTE PTR [eax], dl
  00355	40		 inc	 eax
  00356	8d 14 28	 lea	 edx, DWORD PTR [eax+ebp]
  00359	81 fa 00 06 00
	00		 cmp	 edx, 1536		; 00000600H
  0035f	72 ef		 jb	 SHORT $L123274
  00361	8a 87 f8 12 00
	00		 mov	 al, BYTE PTR [edi+4856]
  00367	88 86 f8 12 00
	00		 mov	 BYTE PTR [esi+4856], al
  0036d	8b 8f fc 12 00
	00		 mov	 ecx, DWORD PTR [edi+4860]
  00373	5f		 pop	 edi
  00374	89 8e fc 12 00
	00		 mov	 DWORD PTR [esi+4860], ecx
  0037a	8b c6		 mov	 eax, esi
  0037c	5e		 pop	 esi
  0037d	5d		 pop	 ebp
  0037e	5b		 pop	 ebx
  0037f	59		 pop	 ecx
  00380	c2 04 00	 ret	 4
??4UWaterTexture@@QAEAAV0@ABV0@@Z ENDP			; UWaterTexture::operator=
; Function compile flags: /Ogty
; File ..\..\Core\Inc\UnTemplate.h
_TEXT	ENDS
;	COMDAT ?Empty@?$TArray@UFMipmap@@@@QAEXH@Z
_TEXT	SEGMENT
_Slack$ = 8
?Empty@?$TArray@UFMipmap@@@@QAEXH@Z PROC NEAR		; TArray<FMipmap>::Empty, COMDAT
; _this$ = ecx

; 517  : 	{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 518  : 		if( TTypeInfo<T>::NeedsDestructor() )
; 519  : 			for( INT i=0; i<ArrayNum; i++ )

  00003	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00006	57		 push	 edi
  00007	33 ff		 xor	 edi, edi
  00009	85 c0		 test	 eax, eax
  0000b	7e 19		 jle	 SHORT $L126990
  0000d	53		 push	 ebx
  0000e	33 db		 xor	 ebx, ebx
$L126988:

; 520  : 				(&(*this)(i))->~T();

  00010	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00012	03 cb		 add	 ecx, ebx
  00014	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1FMipmap@@QAE@XZ
  0001a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0001d	47		 inc	 edi
  0001e	83 c3 28	 add	 ebx, 40			; 00000028H
  00021	3b f8		 cmp	 edi, eax
  00023	7c eb		 jl	 SHORT $L126988
  00025	5b		 pop	 ebx
$L126990:

; 521  : 		FArray::Empty( sizeof(T), Slack );

  00026	8b 44 24 0c	 mov	 eax, DWORD PTR _Slack$[esp+4]
  0002a	6a 28		 push	 40			; 00000028H
  0002c	8b ce		 mov	 ecx, esi
  0002e	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00035	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00038	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Realloc@FArray@@IAEXH@Z
  0003e	5f		 pop	 edi
  0003f	5e		 pop	 esi

; 522  : 	}

  00040	c2 04 00	 ret	 4
?Empty@?$TArray@UFMipmap@@@@QAEXH@Z ENDP		; TArray<FMipmap>::Empty
_TEXT	ENDS
PUBLIC	??_GUWaterTexture@@UAEPAXI@Z			; UWaterTexture::`scalar deleting destructor'
; Function compile flags: /Ogty
;	COMDAT ??_GUWaterTexture@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_GUWaterTexture@@UAEPAXI@Z PROC NEAR			; UWaterTexture::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	e8 00 00 00 00	 call	 ??1UWaterTexture@@UAE@XZ ; UWaterTexture::~UWaterTexture
  00008	f6 44 24 08 01	 test	 BYTE PTR ___flags$[esp], 1
  0000d	74 0d		 je	 SHORT $L138560
  0000f	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?GMalloc@@3PAVFMalloc@@A
  00014	8b 08		 mov	 ecx, DWORD PTR [eax]
  00016	8b 11		 mov	 edx, DWORD PTR [ecx]
  00018	56		 push	 esi
  00019	ff 52 08	 call	 DWORD PTR [edx+8]
$L138560:
  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi
  0001f	c2 04 00	 ret	 4
??_GUWaterTexture@@UAEPAXI@Z ENDP			; UWaterTexture::`scalar deleting destructor'
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??_EUWaterTexture@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_EUWaterTexture@@UAEPAXI@Z PROC NEAR			; UWaterTexture::`vector deleting destructor', COMDAT
; _this$ = ecx
  00000	53		 push	 ebx
  00001	8a 5c 24 08	 mov	 bl, BYTE PTR ___flags$[esp]
  00005	f6 c3 02	 test	 bl, 2
  00008	56		 push	 esi
  00009	8b f1		 mov	 esi, ecx
  0000b	74 33		 je	 SHORT $L123282
  0000d	8b 46 fc	 mov	 eax, DWORD PTR [esi-4]
  00010	57		 push	 edi
  00011	68 00 00 00 00	 push	 OFFSET FLAT:??1UWaterTexture@@UAE@XZ ; UWaterTexture::~UWaterTexture
  00016	8d 7e fc	 lea	 edi, DWORD PTR [esi-4]
  00019	50		 push	 eax
  0001a	68 00 13 00 00	 push	 4864			; 00001300H
  0001f	56		 push	 esi
  00020	e8 00 00 00 00	 call	 ??_M@YGXPAXIHP6EX0@Z@Z	; `eh vector destructor iterator'
  00025	f6 c3 01	 test	 bl, 1
  00028	74 0e		 je	 SHORT $L138566
  0002a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?GMalloc@@3PAVFMalloc@@A
  00030	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00032	8b 11		 mov	 edx, DWORD PTR [ecx]
  00034	57		 push	 edi
  00035	ff 52 08	 call	 DWORD PTR [edx+8]
$L138566:
  00038	8b c7		 mov	 eax, edi
  0003a	5f		 pop	 edi
  0003b	5e		 pop	 esi
  0003c	5b		 pop	 ebx
  0003d	c2 04 00	 ret	 4
$L123282:
  00040	8b ce		 mov	 ecx, esi
  00042	e8 00 00 00 00	 call	 ??1UWaterTexture@@UAE@XZ ; UWaterTexture::~UWaterTexture
  00047	f6 c3 01	 test	 bl, 1
  0004a	74 0d		 je	 SHORT $L138568
  0004c	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?GMalloc@@3PAVFMalloc@@A
  00051	8b 08		 mov	 ecx, DWORD PTR [eax]
  00053	8b 11		 mov	 edx, DWORD PTR [ecx]
  00055	56		 push	 esi
  00056	ff 52 08	 call	 DWORD PTR [edx+8]
$L138568:
  00059	8b c6		 mov	 eax, esi
  0005b	5e		 pop	 esi
  0005c	5b		 pop	 ebx
  0005d	c2 04 00	 ret	 4
??_EUWaterTexture@@UAEPAXI@Z ENDP			; UWaterTexture::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	?StaticClass@UWaveTexture@@SAPAVUClass@@XZ	; UWaveTexture::StaticClass
; Function compile flags: /Ogty
; File C:\duke4\Fire\Src\FractalPrivate.h
;	COMDAT ?StaticClass@UWaveTexture@@SAPAVUClass@@XZ
_TEXT	SEGMENT
?StaticClass@UWaveTexture@@SAPAVUClass@@XZ PROC NEAR	; UWaveTexture::StaticClass, COMDAT

; 361  : 	DECLARE_CLASS(UWaveTexture,UWaterTexture,0)

  00000	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?PrivateStaticClass@UWaveTexture@@0VUClass@@A ; UWaveTexture::PrivateStaticClass
  00005	c3		 ret	 0
?StaticClass@UWaveTexture@@SAPAVUClass@@XZ ENDP		; UWaveTexture::StaticClass
_TEXT	ENDS
PUBLIC	??2UWaveTexture@@SAPAXIPAVUObject@@VFName@@K@Z	; UWaveTexture::operator new
; Function compile flags: /Ogty
;	COMDAT ??2UWaveTexture@@SAPAXIPAVUObject@@VFName@@K@Z
_TEXT	SEGMENT
_Outer$ = 12
_Name$ = 16
_SetFlags$ = 20
??2UWaveTexture@@SAPAXIPAVUObject@@VFName@@K@Z PROC NEAR ; UWaveTexture::operator new, COMDAT

; 361  : 	DECLARE_CLASS(UWaveTexture,UWaterTexture,0)

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?GError@@3PAVFOutputDeviceError@@A
  00005	8b 08		 mov	 ecx, DWORD PTR [eax]
  00007	8b 54 24 10	 mov	 edx, DWORD PTR _SetFlags$[esp-4]
  0000b	8b 44 24 0c	 mov	 eax, DWORD PTR _Name$[esp-4]
  0000f	6a 00		 push	 0
  00011	51		 push	 ecx
  00012	8b 4c 24 10	 mov	 ecx, DWORD PTR _Outer$[esp+4]
  00016	6a 00		 push	 0
  00018	52		 push	 edx
  00019	50		 push	 eax
  0001a	51		 push	 ecx
  0001b	68 00 00 00 00	 push	 OFFSET FLAT:?PrivateStaticClass@UWaveTexture@@0VUClass@@A ; UWaveTexture::PrivateStaticClass
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?StaticAllocateObject@UObject@@SAPAV1@PAVUClass@@PAV1@VFName@@K1PAVFOutputDevice@@1@Z
  00026	83 c4 1c	 add	 esp, 28			; 0000001cH
  00029	c3		 ret	 0
??2UWaveTexture@@SAPAXIPAVUObject@@VFName@@K@Z ENDP	; UWaveTexture::operator new
_TEXT	ENDS
PUBLIC	??2UWaveTexture@@SAPAXIPAW4EInternal@@@Z	; UWaveTexture::operator new
; Function compile flags: /Ogty
;	COMDAT ??2UWaveTexture@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT
_Mem$ = 12
??2UWaveTexture@@SAPAXIPAW4EInternal@@@Z PROC NEAR	; UWaveTexture::operator new, COMDAT

; 361  : 	DECLARE_CLASS(UWaveTexture,UWaterTexture,0)

  00000	8b 44 24 08	 mov	 eax, DWORD PTR _Mem$[esp-4]
  00004	c3		 ret	 0
??2UWaveTexture@@SAPAXIPAW4EInternal@@@Z ENDP		; UWaveTexture::operator new
_TEXT	ENDS
PUBLIC	??1UWaveTexture@@UAE@XZ				; UWaveTexture::~UWaveTexture
;	COMDAT xdata$x
; File ..\..\Engine\Inc\UnTex.h
xdata$x	SEGMENT
$T138848 DD	0ffffffffH
	DD	FLAT:$L138585
	DD	0ffffffffH
	DD	FLAT:$L138587
	DD	0ffffffffH
	DD	FLAT:$L138589
	DD	0ffffffffH
	DD	FLAT:$L138591
	DD	0ffffffffH
	DD	FLAT:$L138593
	DD	04H
	DD	FLAT:$L138594
	DD	05H
	DD	FLAT:$L138595
	DD	05H
	DD	FLAT:$L138597
	DD	04H
	DD	FLAT:$L138638
	DD	0ffffffffH
	DD	FLAT:$L138679
$T138839 DD	019930520H
	DD	0aH
	DD	FLAT:$T138848
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File C:\duke4\Fire\Src\FractalPrivate.h
xdata$x	ENDS
;	COMDAT ??1UWaveTexture@@UAE@XZ
_TEXT	SEGMENT
_this$ = -20
$T138636 = -16
$T138677 = -16
__$EHRec$ = -12
??1UWaveTexture@@UAE@XZ PROC NEAR			; UWaveTexture::~UWaveTexture, COMDAT
; _this$ = ecx

; 361  : 	DECLARE_CLASS(UWaveTexture,UWaterTexture,0)

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 $L138847
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00018	53		 push	 ebx
  00019	55		 push	 ebp
  0001a	56		 push	 esi
  0001b	8b f1		 mov	 esi, ecx
  0001d	57		 push	 edi
  0001e	89 74 24 14	 mov	 DWORD PTR _this$[esp+40], esi
  00022	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7UWaveTexture@@6B@ ; UWaveTexture::`vftable'
  00028	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp_?ConditionalDestroy@UObject@@QAEHXZ
  0002e	33 ed		 xor	 ebp, ebp
  00030	89 6c 24 24	 mov	 DWORD PTR __$EHRec$[esp+48], ebp
  00034	ff d7		 call	 edi
  00036	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7UWaterTexture@@6B@ ; UWaterTexture::`vftable'
  0003c	8b ce		 mov	 ecx, esi
  0003e	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+48], 1
  00046	ff d7		 call	 edi
  00048	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7UFractalTexture@@6B@ ; UFractalTexture::`vftable'
  0004e	8b ce		 mov	 ecx, esi
  00050	c7 44 24 24 02
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+48], 2
  00058	ff d7		 call	 edi
  0005a	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_??_7UProceduralTexture@@6B@
  0005f	89 06		 mov	 DWORD PTR [esi], eax
  00061	8b ce		 mov	 ecx, esi
  00063	c7 44 24 24 03
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+48], 3
  0006b	ff d7		 call	 edi
  0006d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_??_7UTexture@@6B@
  00073	89 0e		 mov	 DWORD PTR [esi], ecx
  00075	8b ce		 mov	 ecx, esi
  00077	c7 44 24 24 06
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+48], 6
  0007f	ff d7		 call	 edi
  00081	8d be b4 00 00
	00		 lea	 edi, DWORD PTR [esi+180]
  00087	89 7c 24 18	 mov	 DWORD PTR $T138636[esp+40], edi
  0008b	8b 5f 04	 mov	 ebx, DWORD PTR [edi+4]
  0008e	3b dd		 cmp	 ebx, ebp
  00090	c6 44 24 24 07	 mov	 BYTE PTR __$EHRec$[esp+48], 7
  00095	7d 18		 jge	 SHORT $L138810
  00097	68 fd 01 00 00	 push	 509			; 000001fdH
  0009c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@MLGP@?4?4?2?4?4?2Core?2Inc?2UnTemplate?4h?$AA@ ; `string'
  000a1	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BA@FEMP@Index?$DM?$DNArrayNum?$AA@ ; `string'
  000a6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?appFailAssert@@YAXPBD0H@Z
  000ac	83 c4 0c	 add	 esp, 12			; 0000000cH
$L138810:
  000af	3b 5f 04	 cmp	 ebx, DWORD PTR [edi+4]
  000b2	7e 18		 jle	 SHORT $L138811
  000b4	68 fe 01 00 00	 push	 510			; 000001feH
  000b9	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@MLGP@?4?4?2?4?4?2Core?2Inc?2UnTemplate?4h?$AA@ ; `string'
  000be	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BG@BEDF@Index?$CLCount?$DM?$DNArrayNum?$AA@ ; `string'
  000c3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?appFailAssert@@YAXPBD0H@Z
  000c9	83 c4 0c	 add	 esp, 12			; 0000000cH
$L138811:
  000cc	3b dd		 cmp	 ebx, ebp
  000ce	7e 1d		 jle	 SHORT $L138816
  000d0	89 5c 24 10	 mov	 DWORD PTR -24+[esp+40], ebx
$L138814:
  000d4	8b 0f		 mov	 ecx, DWORD PTR [edi]
  000d6	6a 00		 push	 0
  000d8	03 cd		 add	 ecx, ebp
  000da	e8 00 00 00 00	 call	 ??_GFMipmap@@QAEPAXI@Z	; FMipmap::`scalar deleting destructor'
  000df	8b 44 24 10	 mov	 eax, DWORD PTR -24+[esp+40]
  000e3	83 c5 28	 add	 ebp, 40			; 00000028H
  000e6	48		 dec	 eax
  000e7	89 44 24 10	 mov	 DWORD PTR -24+[esp+40], eax
  000eb	75 e7		 jne	 SHORT $L138814
$L138816:
  000ed	6a 28		 push	 40			; 00000028H
  000ef	53		 push	 ebx
  000f0	6a 00		 push	 0
  000f2	8b cf		 mov	 ecx, edi
  000f4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Remove@FArray@@QAEXHHH@Z
  000fa	8b cf		 mov	 ecx, edi
  000fc	c6 44 24 24 05	 mov	 BYTE PTR __$EHRec$[esp+48], 5
  00101	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1FArray@@QAE@XZ
  00107	8d be a8 00 00
	00		 lea	 edi, DWORD PTR [esi+168]
  0010d	89 7c 24 18	 mov	 DWORD PTR $T138677[esp+40], edi
  00111	8b 6f 04	 mov	 ebp, DWORD PTR [edi+4]
  00114	85 ed		 test	 ebp, ebp
  00116	c6 44 24 24 08	 mov	 BYTE PTR __$EHRec$[esp+48], 8
  0011b	7d 18		 jge	 SHORT $L138826
  0011d	68 fd 01 00 00	 push	 509			; 000001fdH
  00122	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@MLGP@?4?4?2?4?4?2Core?2Inc?2UnTemplate?4h?$AA@ ; `string'
  00127	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BA@FEMP@Index?$DM?$DNArrayNum?$AA@ ; `string'
  0012c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?appFailAssert@@YAXPBD0H@Z
  00132	83 c4 0c	 add	 esp, 12			; 0000000cH
$L138826:
  00135	3b 6f 04	 cmp	 ebp, DWORD PTR [edi+4]
  00138	7e 18		 jle	 SHORT $L138827
  0013a	68 fe 01 00 00	 push	 510			; 000001feH
  0013f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@MLGP@?4?4?2?4?4?2Core?2Inc?2UnTemplate?4h?$AA@ ; `string'
  00144	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BG@BEDF@Index?$CLCount?$DM?$DNArrayNum?$AA@ ; `string'
  00149	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?appFailAssert@@YAXPBD0H@Z
  0014f	83 c4 0c	 add	 esp, 12			; 0000000cH
$L138827:
  00152	85 ed		 test	 ebp, ebp
  00154	7e 23		 jle	 SHORT $L138832
  00156	33 db		 xor	 ebx, ebx
  00158	89 6c 24 10	 mov	 DWORD PTR -24+[esp+40], ebp
  0015c	8d 64 24 00	 npad	 4
$L138830:
  00160	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00162	6a 00		 push	 0
  00164	03 cb		 add	 ecx, ebx
  00166	e8 00 00 00 00	 call	 ??_GFMipmap@@QAEPAXI@Z	; FMipmap::`scalar deleting destructor'
  0016b	8b 44 24 10	 mov	 eax, DWORD PTR -24+[esp+40]
  0016f	83 c3 28	 add	 ebx, 40			; 00000028H
  00172	48		 dec	 eax
  00173	89 44 24 10	 mov	 DWORD PTR -24+[esp+40], eax
  00177	75 e7		 jne	 SHORT $L138830
$L138832:
  00179	6a 28		 push	 40			; 00000028H
  0017b	55		 push	 ebp
  0017c	6a 00		 push	 0
  0017e	8b cf		 mov	 ecx, edi
  00180	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Remove@FArray@@QAEXHHH@Z
  00186	8b cf		 mov	 ecx, edi
  00188	c6 44 24 24 04	 mov	 BYTE PTR __$EHRec$[esp+48], 4
  0018d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1FArray@@QAE@XZ
  00193	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR __imp_??_7UBitmap@@6B@
  00199	89 16		 mov	 DWORD PTR [esi], edx
  0019b	8b ce		 mov	 ecx, esi
  0019d	c7 44 24 24 09
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+48], 9
  001a5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?ConditionalDestroy@UObject@@QAEHXZ
  001ab	8b ce		 mov	 ecx, esi
  001ad	c7 44 24 24 ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+48], -1
  001b5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1UObject@@UAE@XZ
  001bb	8b 4c 24 1c	 mov	 ecx, DWORD PTR __$EHRec$[esp+40]
  001bf	5f		 pop	 edi
  001c0	5e		 pop	 esi
  001c1	5d		 pop	 ebp
  001c2	5b		 pop	 ebx
  001c3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  001ca	83 c4 18	 add	 esp, 24			; 00000018H
  001cd	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L138585:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1UWaterTexture@@UAE@XZ ; UWaterTexture::~UWaterTexture
$L138587:
  00008	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1UFractalTexture@@UAE@XZ ; UFractalTexture::~UFractalTexture
$L138589:
  00010	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1UProceduralTexture@@UAE@XZ
$L138591:
  00019	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1UTexture@@UAE@XZ
$L138593:
  00022	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1UBitmap@@UAE@XZ
$L138594:
  0002b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	81 c1 a8 00 00
	00		 add	 ecx, 168		; 000000a8H
  00034	e9 00 00 00 00	 jmp	 ??1?$TArray@UFMipmap@@@@QAE@XZ ; TArray<FMipmap>::~TArray<FMipmap>
$L138595:
  00039	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0003c	81 c1 b4 00 00
	00		 add	 ecx, 180		; 000000b4H
  00042	e9 00 00 00 00	 jmp	 ??1?$TArray@UFMipmap@@@@QAE@XZ ; TArray<FMipmap>::~TArray<FMipmap>
$L138597:
  00047	8b 4d f0	 mov	 ecx, DWORD PTR $T138636[ebp]
  0004a	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1FArray@@QAE@XZ
$L138638:
  00050	8b 4d f0	 mov	 ecx, DWORD PTR $T138677[ebp]
  00053	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1FArray@@QAE@XZ
$L138679:
  00059	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0005c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1UObject@@UAE@XZ
$L138847:
  00062	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T138839
  00067	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??1UWaveTexture@@UAE@XZ ENDP				; UWaveTexture::~UWaveTexture
; Function compile flags: /Ogty
;	COMDAT ?InternalConstructor@UWaveTexture@@SAXPAX@Z
_TEXT	SEGMENT
_X$ = 8
?InternalConstructor@UWaveTexture@@SAXPAX@Z PROC NEAR	; UWaveTexture::InternalConstructor, COMDAT

; 361  : 	DECLARE_CLASS(UWaveTexture,UWaterTexture,0)

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR _X$[esp-4]
  00004	85 c9		 test	 ecx, ecx
  00006	74 05		 je	 SHORT $L138855
  00008	e9 00 00 00 00	 jmp	 ??0UWaveTexture@@QAE@XZ	; UWaveTexture::UWaveTexture
$L138855:
  0000d	c3		 ret	 0
?InternalConstructor@UWaveTexture@@SAXPAX@Z ENDP	; UWaveTexture::InternalConstructor
_TEXT	ENDS
PUBLIC	??0UWaveTexture@@QAE@ABV0@@Z			; UWaveTexture::UWaveTexture
; Function compile flags: /Ogty
;	COMDAT ??0UWaveTexture@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8
??0UWaveTexture@@QAE@ABV0@@Z PROC NEAR			; UWaveTexture::UWaveTexture, COMDAT
; _this$ = ecx
  00000	53		 push	 ebx
  00001	55		 push	 ebp
  00002	8b 6c 24 0c	 mov	 ebp, DWORD PTR ___that$[esp+4]
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	55		 push	 ebp
  00009	8b d9		 mov	 ebx, ecx
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0UTexture@@QAE@ABV0@@Z
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_??_7UProceduralTexture@@6B@
  00016	89 03		 mov	 DWORD PTR [ebx], eax
  00018	8b 8d c8 00 00
	00		 mov	 ecx, DWORD PTR [ebp+200]
  0001e	89 8b c8 00 00
	00		 mov	 DWORD PTR [ebx+200], ecx
  00024	8b 95 cc 00 00
	00		 mov	 edx, DWORD PTR [ebp+204]
  0002a	89 93 cc 00 00
	00		 mov	 DWORD PTR [ebx+204], edx
  00030	8b 85 d0 00 00
	00		 mov	 eax, DWORD PTR [ebp+208]
  00036	89 83 d0 00 00
	00		 mov	 DWORD PTR [ebx+208], eax
  0003c	8b 8d d4 00 00
	00		 mov	 ecx, DWORD PTR [ebp+212]
  00042	89 8b d4 00 00
	00		 mov	 DWORD PTR [ebx+212], ecx
  00048	8b 95 d8 00 00
	00		 mov	 edx, DWORD PTR [ebp+216]
  0004e	89 93 d8 00 00
	00		 mov	 DWORD PTR [ebx+216], edx
  00054	8a 85 dc 00 00
	00		 mov	 al, BYTE PTR [ebp+220]
  0005a	88 83 dc 00 00
	00		 mov	 BYTE PTR [ebx+220], al
  00060	8a 8d dd 00 00
	00		 mov	 cl, BYTE PTR [ebp+221]
  00066	88 8b dd 00 00
	00		 mov	 BYTE PTR [ebx+221], cl
  0006c	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], OFFSET FLAT:??_7UFractalTexture@@6B@ ; UFractalTexture::`vftable'
  00072	8a 95 e0 00 00
	00		 mov	 dl, BYTE PTR [ebp+224]
  00078	88 93 e0 00 00
	00		 mov	 BYTE PTR [ebx+224], dl
  0007e	8a 85 e1 00 00
	00		 mov	 al, BYTE PTR [ebp+225]
  00084	88 83 e1 00 00
	00		 mov	 BYTE PTR [ebx+225], al
  0008a	8a 8d e2 00 00
	00		 mov	 cl, BYTE PTR [ebp+226]
  00090	88 8b e2 00 00
	00		 mov	 BYTE PTR [ebx+226], cl
  00096	8a 95 e3 00 00
	00		 mov	 dl, BYTE PTR [ebp+227]
  0009c	88 93 e3 00 00
	00		 mov	 BYTE PTR [ebx+227], dl
  000a2	8a 85 e4 00 00
	00		 mov	 al, BYTE PTR [ebp+228]
  000a8	88 83 e4 00 00
	00		 mov	 BYTE PTR [ebx+228], al
  000ae	8a 8d e5 00 00
	00		 mov	 cl, BYTE PTR [ebp+229]
  000b4	88 8b e5 00 00
	00		 mov	 BYTE PTR [ebx+229], cl
  000ba	8a 95 e6 00 00
	00		 mov	 dl, BYTE PTR [ebp+230]
  000c0	88 93 e6 00 00
	00		 mov	 BYTE PTR [ebx+230], dl
  000c6	8a 85 e7 00 00
	00		 mov	 al, BYTE PTR [ebp+231]
  000cc	88 83 e7 00 00
	00		 mov	 BYTE PTR [ebx+231], al
  000d2	8a 8d e8 00 00
	00		 mov	 cl, BYTE PTR [ebp+232]
  000d8	88 8b e8 00 00
	00		 mov	 BYTE PTR [ebx+232], cl
  000de	8a 95 e9 00 00
	00		 mov	 dl, BYTE PTR [ebp+233]
  000e4	88 93 e9 00 00
	00		 mov	 BYTE PTR [ebx+233], dl
  000ea	8b 85 ec 00 00
	00		 mov	 eax, DWORD PTR [ebp+236]
  000f0	89 83 ec 00 00
	00		 mov	 DWORD PTR [ebx+236], eax
  000f6	8d b5 f0 00 00
	00		 lea	 esi, DWORD PTR [ebp+240]
  000fc	8d bb f0 00 00
	00		 lea	 edi, DWORD PTR [ebx+240]
  00102	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  00107	f3 a5		 rep movsd
  00109	8b 8d f0 08 00
	00		 mov	 ecx, DWORD PTR [ebp+2288]
  0010f	89 8b f0 08 00
	00		 mov	 DWORD PTR [ebx+2288], ecx
  00115	8d b5 f4 08 00
	00		 lea	 esi, DWORD PTR [ebp+2292]
  0011b	8d bb f4 08 00
	00		 lea	 edi, DWORD PTR [ebx+2292]
  00121	b9 01 01 00 00	 mov	 ecx, 257		; 00000101H
  00126	f3 a5		 rep movsd
  00128	8d b5 f8 0c 00
	00		 lea	 esi, DWORD PTR [ebp+3320]
  0012e	8d bb f8 0c 00
	00		 lea	 edi, DWORD PTR [ebx+3320]
  00134	b9 80 01 00 00	 mov	 ecx, 384		; 00000180H
  00139	f3 a5		 rep movsd
  0013b	8a 95 f8 12 00
	00		 mov	 dl, BYTE PTR [ebp+4856]
  00141	88 93 f8 12 00
	00		 mov	 BYTE PTR [ebx+4856], dl
  00147	8b 85 fc 12 00
	00		 mov	 eax, DWORD PTR [ebp+4860]
  0014d	89 83 fc 12 00
	00		 mov	 DWORD PTR [ebx+4860], eax
  00153	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], OFFSET FLAT:??_7UWaterTexture@@6B@ ; UWaterTexture::`vftable'
  00159	8a 8d 00 13 00
	00		 mov	 cl, BYTE PTR [ebp+4864]
  0015f	88 8b 00 13 00
	00		 mov	 BYTE PTR [ebx+4864], cl
  00165	8a 95 01 13 00
	00		 mov	 dl, BYTE PTR [ebp+4865]
  0016b	88 93 01 13 00
	00		 mov	 BYTE PTR [ebx+4865], dl
  00171	8a 85 02 13 00
	00		 mov	 al, BYTE PTR [ebp+4866]
  00177	5f		 pop	 edi
  00178	88 83 02 13 00
	00		 mov	 BYTE PTR [ebx+4866], al
  0017e	8a 8d 03 13 00
	00		 mov	 cl, BYTE PTR [ebp+4867]
  00184	5e		 pop	 esi
  00185	5d		 pop	 ebp
  00186	88 8b 03 13 00
	00		 mov	 BYTE PTR [ebx+4867], cl
  0018c	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], OFFSET FLAT:??_7UWaveTexture@@6B@ ; UWaveTexture::`vftable'
  00192	8b c3		 mov	 eax, ebx
  00194	5b		 pop	 ebx
  00195	c2 04 00	 ret	 4
??0UWaveTexture@@QAE@ABV0@@Z ENDP			; UWaveTexture::UWaveTexture
_TEXT	ENDS
PUBLIC	??4UWaveTexture@@QAEAAV0@ABV0@@Z		; UWaveTexture::operator=
EXTRN	__imp_??4UBitmap@@QAEAAV0@ABV0@@Z:NEAR
; Function compile flags: /Ogty
;	COMDAT ??4UWaveTexture@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8
??4UWaveTexture@@QAEAAV0@ABV0@@Z PROC NEAR		; UWaveTexture::operator=, COMDAT
; _this$ = ecx
  00000	53		 push	 ebx
  00001	55		 push	 ebp
  00002	56		 push	 esi
  00003	57		 push	 edi
  00004	8b 7c 24 14	 mov	 edi, DWORD PTR ___that$[esp+12]
  00008	57		 push	 edi
  00009	8b f1		 mov	 esi, ecx
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4UBitmap@@QAEAAV0@ABV0@@Z
  00011	8b 47 54	 mov	 eax, DWORD PTR [edi+84]
  00014	89 46 54	 mov	 DWORD PTR [esi+84], eax
  00017	8b 4f 58	 mov	 ecx, DWORD PTR [edi+88]
  0001a	89 4e 58	 mov	 DWORD PTR [esi+88], ecx
  0001d	8b 57 5c	 mov	 edx, DWORD PTR [edi+92]
  00020	89 56 5c	 mov	 DWORD PTR [esi+92], edx
  00023	8b 47 60	 mov	 eax, DWORD PTR [edi+96]
  00026	89 46 60	 mov	 DWORD PTR [esi+96], eax
  00029	8b 4f 64	 mov	 ecx, DWORD PTR [edi+100]
  0002c	89 4e 64	 mov	 DWORD PTR [esi+100], ecx
  0002f	8b 57 68	 mov	 edx, DWORD PTR [edi+104]
  00032	89 56 68	 mov	 DWORD PTR [esi+104], edx
  00035	8b 47 6c	 mov	 eax, DWORD PTR [edi+108]
  00038	89 46 6c	 mov	 DWORD PTR [esi+108], eax
  0003b	8b 4f 70	 mov	 ecx, DWORD PTR [edi+112]
  0003e	89 4e 70	 mov	 DWORD PTR [esi+112], ecx
  00041	8b 57 74	 mov	 edx, DWORD PTR [edi+116]
  00044	89 56 74	 mov	 DWORD PTR [esi+116], edx
  00047	8b 47 78	 mov	 eax, DWORD PTR [edi+120]
  0004a	89 46 78	 mov	 DWORD PTR [esi+120], eax
  0004d	8b 4f 7c	 mov	 ecx, DWORD PTR [edi+124]
  00050	89 4e 7c	 mov	 DWORD PTR [esi+124], ecx
  00053	8b 97 80 00 00
	00		 mov	 edx, DWORD PTR [edi+128]
  00059	8b 8e 88 00 00
	00		 mov	 ecx, DWORD PTR [esi+136]
  0005f	89 96 80 00 00
	00		 mov	 DWORD PTR [esi+128], edx
  00065	8b 87 84 00 00
	00		 mov	 eax, DWORD PTR [edi+132]
  0006b	89 86 84 00 00
	00		 mov	 DWORD PTR [esi+132], eax
  00071	8b 87 88 00 00
	00		 mov	 eax, DWORD PTR [edi+136]
  00077	33 c1		 xor	 eax, ecx
  00079	83 e0 01	 and	 eax, 1
  0007c	33 c1		 xor	 eax, ecx
  0007e	89 86 88 00 00
	00		 mov	 DWORD PTR [esi+136], eax
  00084	8b 8f 88 00 00
	00		 mov	 ecx, DWORD PTR [edi+136]
  0008a	33 c8		 xor	 ecx, eax
  0008c	83 e1 02	 and	 ecx, 2
  0008f	33 c8		 xor	 ecx, eax
  00091	89 8e 88 00 00
	00		 mov	 DWORD PTR [esi+136], ecx
  00097	8b 87 88 00 00
	00		 mov	 eax, DWORD PTR [edi+136]
  0009d	33 c1		 xor	 eax, ecx
  0009f	83 e0 04	 and	 eax, 4
  000a2	33 c1		 xor	 eax, ecx
  000a4	89 86 88 00 00
	00		 mov	 DWORD PTR [esi+136], eax
  000aa	8b 8f 88 00 00
	00		 mov	 ecx, DWORD PTR [edi+136]
  000b0	33 c8		 xor	 ecx, eax
  000b2	83 e1 08	 and	 ecx, 8
  000b5	33 c8		 xor	 ecx, eax
  000b7	89 8e 88 00 00
	00		 mov	 DWORD PTR [esi+136], ecx
  000bd	8b 87 88 00 00
	00		 mov	 eax, DWORD PTR [edi+136]
  000c3	33 c1		 xor	 eax, ecx
  000c5	83 e0 10	 and	 eax, 16			; 00000010H
  000c8	33 c1		 xor	 eax, ecx
  000ca	89 86 88 00 00
	00		 mov	 DWORD PTR [esi+136], eax
  000d0	8b 8f 88 00 00
	00		 mov	 ecx, DWORD PTR [edi+136]
  000d6	33 c8		 xor	 ecx, eax
  000d8	83 e1 20	 and	 ecx, 32			; 00000020H
  000db	33 c8		 xor	 ecx, eax
  000dd	89 8e 88 00 00
	00		 mov	 DWORD PTR [esi+136], ecx
  000e3	8a 97 8c 00 00
	00		 mov	 dl, BYTE PTR [edi+140]
  000e9	88 96 8c 00 00
	00		 mov	 BYTE PTR [esi+140], dl
  000ef	8b 87 90 00 00
	00		 mov	 eax, DWORD PTR [edi+144]
  000f5	89 86 90 00 00
	00		 mov	 DWORD PTR [esi+144], eax
  000fb	8b 8f 94 00 00
	00		 mov	 ecx, DWORD PTR [edi+148]
  00101	89 8e 94 00 00
	00		 mov	 DWORD PTR [esi+148], ecx
  00107	8a 97 98 00 00
	00		 mov	 dl, BYTE PTR [edi+152]
  0010d	88 96 98 00 00
	00		 mov	 BYTE PTR [esi+152], dl
  00113	8a 87 99 00 00
	00		 mov	 al, BYTE PTR [edi+153]
  00119	88 86 99 00 00
	00		 mov	 BYTE PTR [esi+153], al
  0011f	8b 8f 9c 00 00
	00		 mov	 ecx, DWORD PTR [edi+156]
  00125	89 8e 9c 00 00
	00		 mov	 DWORD PTR [esi+156], ecx
  0012b	8b 97 a0 00 00
	00		 mov	 edx, DWORD PTR [edi+160]
  00131	89 96 a0 00 00
	00		 mov	 DWORD PTR [esi+160], edx
  00137	8b 87 a4 00 00
	00		 mov	 eax, DWORD PTR [edi+164]
  0013d	89 86 a4 00 00
	00		 mov	 DWORD PTR [esi+164], eax
  00143	8d 8f a8 00 00
	00		 lea	 ecx, DWORD PTR [edi+168]
  00149	51		 push	 ecx
  0014a	8d 8e a8 00 00
	00		 lea	 ecx, DWORD PTR [esi+168]
  00150	e8 00 00 00 00	 call	 ??4?$TArray@UFMipmap@@@@QAEAAV0@ABV0@@Z ; TArray<FMipmap>::operator=
  00155	8d 97 b4 00 00
	00		 lea	 edx, DWORD PTR [edi+180]
  0015b	52		 push	 edx
  0015c	8d 8e b4 00 00
	00		 lea	 ecx, DWORD PTR [esi+180]
  00162	e8 00 00 00 00	 call	 ??4?$TArray@UFMipmap@@@@QAEAAV0@ABV0@@Z ; TArray<FMipmap>::operator=
  00167	8a 87 c0 00 00
	00		 mov	 al, BYTE PTR [edi+192]
  0016d	88 86 c0 00 00
	00		 mov	 BYTE PTR [esi+192], al
  00173	8b 8f c4 00 00
	00		 mov	 ecx, DWORD PTR [edi+196]
  00179	89 8e c4 00 00
	00		 mov	 DWORD PTR [esi+196], ecx
  0017f	8b 97 c8 00 00
	00		 mov	 edx, DWORD PTR [edi+200]
  00185	89 96 c8 00 00
	00		 mov	 DWORD PTR [esi+200], edx
  0018b	8b 87 cc 00 00
	00		 mov	 eax, DWORD PTR [edi+204]
  00191	89 86 cc 00 00
	00		 mov	 DWORD PTR [esi+204], eax
  00197	8b 8f d0 00 00
	00		 mov	 ecx, DWORD PTR [edi+208]
  0019d	89 8e d0 00 00
	00		 mov	 DWORD PTR [esi+208], ecx
  001a3	8b 97 d4 00 00
	00		 mov	 edx, DWORD PTR [edi+212]
  001a9	89 96 d4 00 00
	00		 mov	 DWORD PTR [esi+212], edx
  001af	8b 87 d8 00 00
	00		 mov	 eax, DWORD PTR [edi+216]
  001b5	89 86 d8 00 00
	00		 mov	 DWORD PTR [esi+216], eax
  001bb	8a 8f dc 00 00
	00		 mov	 cl, BYTE PTR [edi+220]
  001c1	88 8e dc 00 00
	00		 mov	 BYTE PTR [esi+220], cl
  001c7	8a 97 dd 00 00
	00		 mov	 dl, BYTE PTR [edi+221]
  001cd	88 96 dd 00 00
	00		 mov	 BYTE PTR [esi+221], dl
  001d3	8a 87 e0 00 00
	00		 mov	 al, BYTE PTR [edi+224]
  001d9	88 86 e0 00 00
	00		 mov	 BYTE PTR [esi+224], al
  001df	8a 8f e1 00 00
	00		 mov	 cl, BYTE PTR [edi+225]
  001e5	88 8e e1 00 00
	00		 mov	 BYTE PTR [esi+225], cl
  001eb	8a 97 e2 00 00
	00		 mov	 dl, BYTE PTR [edi+226]
  001f1	88 96 e2 00 00
	00		 mov	 BYTE PTR [esi+226], dl
  001f7	8a 87 e3 00 00
	00		 mov	 al, BYTE PTR [edi+227]
  001fd	88 86 e3 00 00
	00		 mov	 BYTE PTR [esi+227], al
  00203	8a 8f e4 00 00
	00		 mov	 cl, BYTE PTR [edi+228]
  00209	88 8e e4 00 00
	00		 mov	 BYTE PTR [esi+228], cl
  0020f	8a 97 e5 00 00
	00		 mov	 dl, BYTE PTR [edi+229]
  00215	88 96 e5 00 00
	00		 mov	 BYTE PTR [esi+229], dl
  0021b	8a 87 e6 00 00
	00		 mov	 al, BYTE PTR [edi+230]
  00221	88 86 e6 00 00
	00		 mov	 BYTE PTR [esi+230], al
  00227	8a 8f e7 00 00
	00		 mov	 cl, BYTE PTR [edi+231]
  0022d	88 8e e7 00 00
	00		 mov	 BYTE PTR [esi+231], cl
  00233	8a 97 e8 00 00
	00		 mov	 dl, BYTE PTR [edi+232]
  00239	88 96 e8 00 00
	00		 mov	 BYTE PTR [esi+232], dl
  0023f	8a 87 e9 00 00
	00		 mov	 al, BYTE PTR [edi+233]
  00245	88 86 e9 00 00
	00		 mov	 BYTE PTR [esi+233], al
  0024b	8b 8f ec 00 00
	00		 mov	 ecx, DWORD PTR [edi+236]
  00251	89 8e ec 00 00
	00		 mov	 DWORD PTR [esi+236], ecx
  00257	8b cf		 mov	 ecx, edi
  00259	8d 86 f0 00 00
	00		 lea	 eax, DWORD PTR [esi+240]
  0025f	2b ce		 sub	 ecx, esi
  00261	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
$L138903:
  00266	8b 1c 01	 mov	 ebx, DWORD PTR [ecx+eax]
  00269	89 18		 mov	 DWORD PTR [eax], ebx
  0026b	8b 5c 01 04	 mov	 ebx, DWORD PTR [ecx+eax+4]
  0026f	89 58 04	 mov	 DWORD PTR [eax+4], ebx
  00272	83 c0 08	 add	 eax, 8
  00275	4a		 dec	 edx
  00276	75 ee		 jne	 SHORT $L138903
  00278	8b 97 f0 08 00
	00		 mov	 edx, DWORD PTR [edi+2288]
  0027e	bd 0c f7 ff ff	 mov	 ebp, -2292		; fffff70cH
  00283	89 96 f0 08 00
	00		 mov	 DWORD PTR [esi+2288], edx
  00289	8d 86 f4 08 00
	00		 lea	 eax, DWORD PTR [esi+2292]
  0028f	2b ee		 sub	 ebp, esi
$L138907:
  00291	8a 14 08	 mov	 dl, BYTE PTR [eax+ecx]
  00294	88 10		 mov	 BYTE PTR [eax], dl
  00296	40		 inc	 eax
  00297	8d 14 28	 lea	 edx, DWORD PTR [eax+ebp]
  0029a	81 fa 04 04 00
	00		 cmp	 edx, 1028		; 00000404H
  002a0	72 ef		 jb	 SHORT $L138907
  002a2	bd 08 f3 ff ff	 mov	 ebp, -3320		; fffff308H
  002a7	8d 86 f8 0c 00
	00		 lea	 eax, DWORD PTR [esi+3320]
  002ad	2b ee		 sub	 ebp, esi
  002af	90		 npad	 1
$L138911:
  002b0	8a 14 08	 mov	 dl, BYTE PTR [eax+ecx]
  002b3	88 10		 mov	 BYTE PTR [eax], dl
  002b5	40		 inc	 eax
  002b6	8d 14 28	 lea	 edx, DWORD PTR [eax+ebp]
  002b9	81 fa 00 06 00
	00		 cmp	 edx, 1536		; 00000600H
  002bf	72 ef		 jb	 SHORT $L138911
  002c1	8a 87 f8 12 00
	00		 mov	 al, BYTE PTR [edi+4856]
  002c7	88 86 f8 12 00
	00		 mov	 BYTE PTR [esi+4856], al
  002cd	8b 8f fc 12 00
	00		 mov	 ecx, DWORD PTR [edi+4860]
  002d3	89 8e fc 12 00
	00		 mov	 DWORD PTR [esi+4860], ecx
  002d9	8a 97 00 13 00
	00		 mov	 dl, BYTE PTR [edi+4864]
  002df	88 96 00 13 00
	00		 mov	 BYTE PTR [esi+4864], dl
  002e5	8a 87 01 13 00
	00		 mov	 al, BYTE PTR [edi+4865]
  002eb	88 86 01 13 00
	00		 mov	 BYTE PTR [esi+4865], al
  002f1	8a 8f 02 13 00
	00		 mov	 cl, BYTE PTR [edi+4866]
  002f7	88 8e 02 13 00
	00		 mov	 BYTE PTR [esi+4866], cl
  002fd	8a 97 03 13 00
	00		 mov	 dl, BYTE PTR [edi+4867]
  00303	5f		 pop	 edi
  00304	88 96 03 13 00
	00		 mov	 BYTE PTR [esi+4867], dl
  0030a	8b c6		 mov	 eax, esi
  0030c	5e		 pop	 esi
  0030d	5d		 pop	 ebp
  0030e	5b		 pop	 ebx
  0030f	c2 04 00	 ret	 4
??4UWaveTexture@@QAEAAV0@ABV0@@Z ENDP			; UWaveTexture::operator=
_TEXT	ENDS
PUBLIC	??_GUWaveTexture@@UAEPAXI@Z			; UWaveTexture::`scalar deleting destructor'
; Function compile flags: /Ogty
;	COMDAT ??_GUWaveTexture@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_GUWaveTexture@@UAEPAXI@Z PROC NEAR			; UWaveTexture::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	e8 00 00 00 00	 call	 ??1UWaveTexture@@UAE@XZ	; UWaveTexture::~UWaveTexture
  00008	f6 44 24 08 01	 test	 BYTE PTR ___flags$[esp], 1
  0000d	74 0d		 je	 SHORT $L138933
  0000f	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?GMalloc@@3PAVFMalloc@@A
  00014	8b 08		 mov	 ecx, DWORD PTR [eax]
  00016	8b 11		 mov	 edx, DWORD PTR [ecx]
  00018	56		 push	 esi
  00019	ff 52 08	 call	 DWORD PTR [edx+8]
$L138933:
  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi
  0001f	c2 04 00	 ret	 4
??_GUWaveTexture@@UAEPAXI@Z ENDP			; UWaveTexture::`scalar deleting destructor'
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??_EUWaveTexture@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_EUWaveTexture@@UAEPAXI@Z PROC NEAR			; UWaveTexture::`vector deleting destructor', COMDAT
; _this$ = ecx
  00000	53		 push	 ebx
  00001	8a 5c 24 08	 mov	 bl, BYTE PTR ___flags$[esp]
  00005	f6 c3 02	 test	 bl, 2
  00008	56		 push	 esi
  00009	8b f1		 mov	 esi, ecx
  0000b	74 33		 je	 SHORT $L123364
  0000d	8b 46 fc	 mov	 eax, DWORD PTR [esi-4]
  00010	57		 push	 edi
  00011	68 00 00 00 00	 push	 OFFSET FLAT:??1UWaveTexture@@UAE@XZ ; UWaveTexture::~UWaveTexture
  00016	8d 7e fc	 lea	 edi, DWORD PTR [esi-4]
  00019	50		 push	 eax
  0001a	68 04 13 00 00	 push	 4868			; 00001304H
  0001f	56		 push	 esi
  00020	e8 00 00 00 00	 call	 ??_M@YGXPAXIHP6EX0@Z@Z	; `eh vector destructor iterator'
  00025	f6 c3 01	 test	 bl, 1
  00028	74 0e		 je	 SHORT $L138939
  0002a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?GMalloc@@3PAVFMalloc@@A
  00030	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00032	8b 11		 mov	 edx, DWORD PTR [ecx]
  00034	57		 push	 edi
  00035	ff 52 08	 call	 DWORD PTR [edx+8]
$L138939:
  00038	8b c7		 mov	 eax, edi
  0003a	5f		 pop	 edi
  0003b	5e		 pop	 esi
  0003c	5b		 pop	 ebx
  0003d	c2 04 00	 ret	 4
$L123364:
  00040	8b ce		 mov	 ecx, esi
  00042	e8 00 00 00 00	 call	 ??1UWaveTexture@@UAE@XZ	; UWaveTexture::~UWaveTexture
  00047	f6 c3 01	 test	 bl, 1
  0004a	74 0d		 je	 SHORT $L138941
  0004c	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?GMalloc@@3PAVFMalloc@@A
  00051	8b 08		 mov	 ecx, DWORD PTR [eax]
  00053	8b 11		 mov	 edx, DWORD PTR [ecx]
  00055	56		 push	 esi
  00056	ff 52 08	 call	 DWORD PTR [edx+8]
$L138941:
  00059	8b c6		 mov	 eax, esi
  0005b	5e		 pop	 esi
  0005c	5b		 pop	 ebx
  0005d	c2 04 00	 ret	 4
??_EUWaveTexture@@UAEPAXI@Z ENDP			; UWaveTexture::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	?StaticClass@UWetTexture@@SAPAVUClass@@XZ	; UWetTexture::StaticClass
; Function compile flags: /Ogty
;	COMDAT ?StaticClass@UWetTexture@@SAPAVUClass@@XZ
_TEXT	SEGMENT
?StaticClass@UWetTexture@@SAPAVUClass@@XZ PROC NEAR	; UWetTexture::StaticClass, COMDAT

; 390  : 	DECLARE_CLASS(UWetTexture,UWaterTexture,0)

  00000	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?PrivateStaticClass@UWetTexture@@0VUClass@@A ; UWetTexture::PrivateStaticClass
  00005	c3		 ret	 0
?StaticClass@UWetTexture@@SAPAVUClass@@XZ ENDP		; UWetTexture::StaticClass
_TEXT	ENDS
PUBLIC	??2UWetTexture@@SAPAXIPAVUObject@@VFName@@K@Z	; UWetTexture::operator new
; Function compile flags: /Ogty
;	COMDAT ??2UWetTexture@@SAPAXIPAVUObject@@VFName@@K@Z
_TEXT	SEGMENT
_Outer$ = 12
_Name$ = 16
_SetFlags$ = 20
??2UWetTexture@@SAPAXIPAVUObject@@VFName@@K@Z PROC NEAR	; UWetTexture::operator new, COMDAT

; 390  : 	DECLARE_CLASS(UWetTexture,UWaterTexture,0)

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?GError@@3PAVFOutputDeviceError@@A
  00005	8b 08		 mov	 ecx, DWORD PTR [eax]
  00007	8b 54 24 10	 mov	 edx, DWORD PTR _SetFlags$[esp-4]
  0000b	8b 44 24 0c	 mov	 eax, DWORD PTR _Name$[esp-4]
  0000f	6a 00		 push	 0
  00011	51		 push	 ecx
  00012	8b 4c 24 10	 mov	 ecx, DWORD PTR _Outer$[esp+4]
  00016	6a 00		 push	 0
  00018	52		 push	 edx
  00019	50		 push	 eax
  0001a	51		 push	 ecx
  0001b	68 00 00 00 00	 push	 OFFSET FLAT:?PrivateStaticClass@UWetTexture@@0VUClass@@A ; UWetTexture::PrivateStaticClass
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?StaticAllocateObject@UObject@@SAPAV1@PAVUClass@@PAV1@VFName@@K1PAVFOutputDevice@@1@Z
  00026	83 c4 1c	 add	 esp, 28			; 0000001cH
  00029	c3		 ret	 0
??2UWetTexture@@SAPAXIPAVUObject@@VFName@@K@Z ENDP	; UWetTexture::operator new
_TEXT	ENDS
PUBLIC	??2UWetTexture@@SAPAXIPAW4EInternal@@@Z		; UWetTexture::operator new
; Function compile flags: /Ogty
;	COMDAT ??2UWetTexture@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT
_Mem$ = 12
??2UWetTexture@@SAPAXIPAW4EInternal@@@Z PROC NEAR	; UWetTexture::operator new, COMDAT

; 390  : 	DECLARE_CLASS(UWetTexture,UWaterTexture,0)

  00000	8b 44 24 08	 mov	 eax, DWORD PTR _Mem$[esp-4]
  00004	c3		 ret	 0
??2UWetTexture@@SAPAXIPAW4EInternal@@@Z ENDP		; UWetTexture::operator new
_TEXT	ENDS
PUBLIC	??1UWetTexture@@UAE@XZ				; UWetTexture::~UWetTexture
;	COMDAT xdata$x
; File ..\..\Engine\Inc\UnTex.h
xdata$x	SEGMENT
$T139221 DD	0ffffffffH
	DD	FLAT:$L138958
	DD	0ffffffffH
	DD	FLAT:$L138960
	DD	0ffffffffH
	DD	FLAT:$L138962
	DD	0ffffffffH
	DD	FLAT:$L138964
	DD	0ffffffffH
	DD	FLAT:$L138966
	DD	04H
	DD	FLAT:$L138967
	DD	05H
	DD	FLAT:$L138968
	DD	05H
	DD	FLAT:$L138970
	DD	04H
	DD	FLAT:$L139011
	DD	0ffffffffH
	DD	FLAT:$L139052
$T139212 DD	019930520H
	DD	0aH
	DD	FLAT:$T139221
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File C:\duke4\Fire\Src\FractalPrivate.h
xdata$x	ENDS
;	COMDAT ??1UWetTexture@@UAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12
_this$ = -20
$T139009 = -16
$T139050 = -16
??1UWetTexture@@UAE@XZ PROC NEAR			; UWetTexture::~UWetTexture, COMDAT
; _this$ = ecx

; 390  : 	DECLARE_CLASS(UWetTexture,UWaterTexture,0)

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 $L139220
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00018	53		 push	 ebx
  00019	55		 push	 ebp
  0001a	56		 push	 esi
  0001b	8b f1		 mov	 esi, ecx
  0001d	57		 push	 edi
  0001e	89 74 24 14	 mov	 DWORD PTR _this$[esp+40], esi
  00022	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7UWetTexture@@6B@ ; UWetTexture::`vftable'
  00028	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp_?ConditionalDestroy@UObject@@QAEHXZ
  0002e	33 ed		 xor	 ebp, ebp
  00030	89 6c 24 24	 mov	 DWORD PTR __$EHRec$[esp+48], ebp
  00034	ff d7		 call	 edi
  00036	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7UWaterTexture@@6B@ ; UWaterTexture::`vftable'
  0003c	8b ce		 mov	 ecx, esi
  0003e	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+48], 1
  00046	ff d7		 call	 edi
  00048	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7UFractalTexture@@6B@ ; UFractalTexture::`vftable'
  0004e	8b ce		 mov	 ecx, esi
  00050	c7 44 24 24 02
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+48], 2
  00058	ff d7		 call	 edi
  0005a	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_??_7UProceduralTexture@@6B@
  0005f	89 06		 mov	 DWORD PTR [esi], eax
  00061	8b ce		 mov	 ecx, esi
  00063	c7 44 24 24 03
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+48], 3
  0006b	ff d7		 call	 edi
  0006d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_??_7UTexture@@6B@
  00073	89 0e		 mov	 DWORD PTR [esi], ecx
  00075	8b ce		 mov	 ecx, esi
  00077	c7 44 24 24 06
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+48], 6
  0007f	ff d7		 call	 edi
  00081	8d be b4 00 00
	00		 lea	 edi, DWORD PTR [esi+180]
  00087	89 7c 24 18	 mov	 DWORD PTR $T139009[esp+40], edi
  0008b	8b 5f 04	 mov	 ebx, DWORD PTR [edi+4]
  0008e	3b dd		 cmp	 ebx, ebp
  00090	c6 44 24 24 07	 mov	 BYTE PTR __$EHRec$[esp+48], 7
  00095	7d 18		 jge	 SHORT $L139185
  00097	68 fd 01 00 00	 push	 509			; 000001fdH
  0009c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@MLGP@?4?4?2?4?4?2Core?2Inc?2UnTemplate?4h?$AA@ ; `string'
  000a1	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BA@FEMP@Index?$DM?$DNArrayNum?$AA@ ; `string'
  000a6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?appFailAssert@@YAXPBD0H@Z
  000ac	83 c4 0c	 add	 esp, 12			; 0000000cH
$L139185:
  000af	3b 5f 04	 cmp	 ebx, DWORD PTR [edi+4]
  000b2	7e 18		 jle	 SHORT $L139186
  000b4	68 fe 01 00 00	 push	 510			; 000001feH
  000b9	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@MLGP@?4?4?2?4?4?2Core?2Inc?2UnTemplate?4h?$AA@ ; `string'
  000be	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BG@BEDF@Index?$CLCount?$DM?$DNArrayNum?$AA@ ; `string'
  000c3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?appFailAssert@@YAXPBD0H@Z
  000c9	83 c4 0c	 add	 esp, 12			; 0000000cH
$L139186:
  000cc	3b dd		 cmp	 ebx, ebp
  000ce	7e 1d		 jle	 SHORT $L139191
  000d0	89 5c 24 10	 mov	 DWORD PTR -24+[esp+40], ebx
$L139189:
  000d4	8b 0f		 mov	 ecx, DWORD PTR [edi]
  000d6	6a 00		 push	 0
  000d8	03 cd		 add	 ecx, ebp
  000da	e8 00 00 00 00	 call	 ??_GFMipmap@@QAEPAXI@Z	; FMipmap::`scalar deleting destructor'
  000df	8b 44 24 10	 mov	 eax, DWORD PTR -24+[esp+40]
  000e3	83 c5 28	 add	 ebp, 40			; 00000028H
  000e6	48		 dec	 eax
  000e7	89 44 24 10	 mov	 DWORD PTR -24+[esp+40], eax
  000eb	75 e7		 jne	 SHORT $L139189
$L139191:
  000ed	6a 28		 push	 40			; 00000028H
  000ef	53		 push	 ebx
  000f0	6a 00		 push	 0
  000f2	8b cf		 mov	 ecx, edi
  000f4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Remove@FArray@@QAEXHHH@Z
  000fa	8b cf		 mov	 ecx, edi
  000fc	c6 44 24 24 05	 mov	 BYTE PTR __$EHRec$[esp+48], 5
  00101	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1FArray@@QAE@XZ
  00107	8d be a8 00 00
	00		 lea	 edi, DWORD PTR [esi+168]
  0010d	89 7c 24 18	 mov	 DWORD PTR $T139050[esp+40], edi
  00111	8b 6f 04	 mov	 ebp, DWORD PTR [edi+4]
  00114	85 ed		 test	 ebp, ebp
  00116	c6 44 24 24 08	 mov	 BYTE PTR __$EHRec$[esp+48], 8
  0011b	7d 18		 jge	 SHORT $L139202
  0011d	68 fd 01 00 00	 push	 509			; 000001fdH
  00122	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@MLGP@?4?4?2?4?4?2Core?2Inc?2UnTemplate?4h?$AA@ ; `string'
  00127	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BA@FEMP@Index?$DM?$DNArrayNum?$AA@ ; `string'
  0012c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?appFailAssert@@YAXPBD0H@Z
  00132	83 c4 0c	 add	 esp, 12			; 0000000cH
$L139202:
  00135	3b 6f 04	 cmp	 ebp, DWORD PTR [edi+4]
  00138	7e 18		 jle	 SHORT $L139203
  0013a	68 fe 01 00 00	 push	 510			; 000001feH
  0013f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@MLGP@?4?4?2?4?4?2Core?2Inc?2UnTemplate?4h?$AA@ ; `string'
  00144	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BG@BEDF@Index?$CLCount?$DM?$DNArrayNum?$AA@ ; `string'
  00149	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?appFailAssert@@YAXPBD0H@Z
  0014f	83 c4 0c	 add	 esp, 12			; 0000000cH
$L139203:
  00152	85 ed		 test	 ebp, ebp
  00154	7e 23		 jle	 SHORT $L139208
  00156	33 db		 xor	 ebx, ebx
  00158	89 6c 24 10	 mov	 DWORD PTR -24+[esp+40], ebp
  0015c	8d 64 24 00	 npad	 4
$L139206:
  00160	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00162	6a 00		 push	 0
  00164	03 cb		 add	 ecx, ebx
  00166	e8 00 00 00 00	 call	 ??_GFMipmap@@QAEPAXI@Z	; FMipmap::`scalar deleting destructor'
  0016b	8b 44 24 10	 mov	 eax, DWORD PTR -24+[esp+40]
  0016f	83 c3 28	 add	 ebx, 40			; 00000028H
  00172	48		 dec	 eax
  00173	89 44 24 10	 mov	 DWORD PTR -24+[esp+40], eax
  00177	75 e7		 jne	 SHORT $L139206
$L139208:
  00179	6a 28		 push	 40			; 00000028H
  0017b	55		 push	 ebp
  0017c	6a 00		 push	 0
  0017e	8b cf		 mov	 ecx, edi
  00180	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Remove@FArray@@QAEXHHH@Z
  00186	8b cf		 mov	 ecx, edi
  00188	c6 44 24 24 04	 mov	 BYTE PTR __$EHRec$[esp+48], 4
  0018d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1FArray@@QAE@XZ
  00193	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR __imp_??_7UBitmap@@6B@
  00199	89 16		 mov	 DWORD PTR [esi], edx
  0019b	8b ce		 mov	 ecx, esi
  0019d	c7 44 24 24 09
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+48], 9
  001a5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?ConditionalDestroy@UObject@@QAEHXZ
  001ab	8b ce		 mov	 ecx, esi
  001ad	c7 44 24 24 ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+48], -1
  001b5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1UObject@@UAE@XZ
  001bb	8b 4c 24 1c	 mov	 ecx, DWORD PTR __$EHRec$[esp+40]
  001bf	5f		 pop	 edi
  001c0	5e		 pop	 esi
  001c1	5d		 pop	 ebp
  001c2	5b		 pop	 ebx
  001c3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  001ca	83 c4 18	 add	 esp, 24			; 00000018H
  001cd	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L138958:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1UWaterTexture@@UAE@XZ ; UWaterTexture::~UWaterTexture
$L138960:
  00008	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1UFractalTexture@@UAE@XZ ; UFractalTexture::~UFractalTexture
$L138962:
  00010	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1UProceduralTexture@@UAE@XZ
$L138964:
  00019	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1UTexture@@UAE@XZ
$L138966:
  00022	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1UBitmap@@UAE@XZ
$L138967:
  0002b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	81 c1 a8 00 00
	00		 add	 ecx, 168		; 000000a8H
  00034	e9 00 00 00 00	 jmp	 ??1?$TArray@UFMipmap@@@@QAE@XZ ; TArray<FMipmap>::~TArray<FMipmap>
$L138968:
  00039	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0003c	81 c1 b4 00 00
	00		 add	 ecx, 180		; 000000b4H
  00042	e9 00 00 00 00	 jmp	 ??1?$TArray@UFMipmap@@@@QAE@XZ ; TArray<FMipmap>::~TArray<FMipmap>
$L138970:
  00047	8b 4d f0	 mov	 ecx, DWORD PTR $T139009[ebp]
  0004a	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1FArray@@QAE@XZ
$L139011:
  00050	8b 4d f0	 mov	 ecx, DWORD PTR $T139050[ebp]
  00053	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1FArray@@QAE@XZ
$L139052:
  00059	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0005c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1UObject@@UAE@XZ
$L139220:
  00062	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T139212
  00067	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??1UWetTexture@@UAE@XZ ENDP				; UWetTexture::~UWetTexture
; Function compile flags: /Ogty
;	COMDAT ?InternalConstructor@UWetTexture@@SAXPAX@Z
_TEXT	SEGMENT
_X$ = 8
?InternalConstructor@UWetTexture@@SAXPAX@Z PROC NEAR	; UWetTexture::InternalConstructor, COMDAT

; 390  : 	DECLARE_CLASS(UWetTexture,UWaterTexture,0)

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR _X$[esp-4]
  00004	85 c9		 test	 ecx, ecx
  00006	74 05		 je	 SHORT $L139228
  00008	e9 00 00 00 00	 jmp	 ??0UWetTexture@@QAE@XZ	; UWetTexture::UWetTexture
$L139228:
  0000d	c3		 ret	 0
?InternalConstructor@UWetTexture@@SAXPAX@Z ENDP		; UWetTexture::InternalConstructor
_TEXT	ENDS
EXTRN	__imp_?Lock@UTexture@@UAIXAAUFTextureInfo@@NHPAVURenderDevice@@@Z:NEAR
; Function compile flags: /Ogty
;	COMDAT ?Lock@UWetTexture@@UAIXAAUFTextureInfo@@NHPAVURenderDevice@@@Z
_TEXT	SEGMENT
_Time$ = 8
_RenDev$ = 20
_TempInfo$123442 = -128
?Lock@UWetTexture@@UAIXAAUFTextureInfo@@NHPAVURenderDevice@@@Z PROC NEAR ; UWetTexture::Lock, COMDAT
; _this$ = ecx
; _TextureInfo$ = edx

; 411  : 	{

  00000	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H
  00006	53		 push	 ebx

; 412  : 		if( SourceTexture )

  00007	8b 9c 24 88 00
	00 00		 mov	 ebx, DWORD PTR _Time$[esp+128]
  0000e	55		 push	 ebp
  0000f	56		 push	 esi
  00010	8b f1		 mov	 esi, ecx
  00012	8b 8e 00 13 00
	00		 mov	 ecx, DWORD PTR [esi+4864]
  00018	85 c9		 test	 ecx, ecx
  0001a	57		 push	 edi
  0001b	8b bc 24 98 00
	00 00		 mov	 edi, DWORD PTR _Time$[esp+144]
  00022	8b ea		 mov	 ebp, edx
  00024	74 22		 je	 SHORT $L123443

; 413  : 		{
; 414  : 			FTextureInfo TempInfo;
; 415  : 			if( SourceTexture != this )

  00026	3b ce		 cmp	 ecx, esi
  00028	74 1e		 je	 SHORT $L123443

; 416  : 			{
; 417  : 				SourceTexture->Lock( TempInfo, Time, 0, NULL );

  0002a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0002c	6a 00		 push	 0
  0002e	6a 00		 push	 0
  00030	57		 push	 edi
  00031	53		 push	 ebx
  00032	8d 54 24 20	 lea	 edx, DWORD PTR _TempInfo$123442[esp+160]
  00036	ff 50 48	 call	 DWORD PTR [eax+72]

; 418  : 				SourceTexture->Unlock( TempInfo );

  00039	8b 8e 00 13 00
	00		 mov	 ecx, DWORD PTR [esi+4864]
  0003f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00041	8d 54 24 10	 lea	 edx, DWORD PTR _TempInfo$123442[esp+144]
  00045	ff 50 4c	 call	 DWORD PTR [eax+76]
$L123443:

; 419  : 			}
; 420  : 		}
; 421  : 		Super::Lock( TextureInfo, Time, 0, RenDev );

  00048	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR _RenDev$[esp+140]
  0004f	51		 push	 ecx
  00050	6a 00		 push	 0
  00052	57		 push	 edi
  00053	53		 push	 ebx
  00054	8b d5		 mov	 edx, ebp
  00056	8b ce		 mov	 ecx, esi
  00058	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Lock@UTexture@@UAIXAAUFTextureInfo@@NHPAVURenderDevice@@@Z
  0005e	5f		 pop	 edi
  0005f	5e		 pop	 esi
  00060	5d		 pop	 ebp
  00061	5b		 pop	 ebx

; 422  : 	}

  00062	81 c4 80 00 00
	00		 add	 esp, 128		; 00000080H
  00068	c2 10 00	 ret	 16			; 00000010H
?Lock@UWetTexture@@UAIXAAUFTextureInfo@@NHPAVURenderDevice@@@Z ENDP ; UWetTexture::Lock
_TEXT	ENDS
PUBLIC	??0UWetTexture@@QAE@ABV0@@Z			; UWetTexture::UWetTexture
; Function compile flags: /Ogty
;	COMDAT ??0UWetTexture@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8
??0UWetTexture@@QAE@ABV0@@Z PROC NEAR			; UWetTexture::UWetTexture, COMDAT
; _this$ = ecx
  00000	53		 push	 ebx
  00001	55		 push	 ebp
  00002	8b 6c 24 0c	 mov	 ebp, DWORD PTR ___that$[esp+4]
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	55		 push	 ebp
  00009	8b d9		 mov	 ebx, ecx
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0UTexture@@QAE@ABV0@@Z
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_??_7UProceduralTexture@@6B@
  00016	89 03		 mov	 DWORD PTR [ebx], eax
  00018	8b 8d c8 00 00
	00		 mov	 ecx, DWORD PTR [ebp+200]
  0001e	89 8b c8 00 00
	00		 mov	 DWORD PTR [ebx+200], ecx
  00024	8b 95 cc 00 00
	00		 mov	 edx, DWORD PTR [ebp+204]
  0002a	89 93 cc 00 00
	00		 mov	 DWORD PTR [ebx+204], edx
  00030	8b 85 d0 00 00
	00		 mov	 eax, DWORD PTR [ebp+208]
  00036	89 83 d0 00 00
	00		 mov	 DWORD PTR [ebx+208], eax
  0003c	8b 8d d4 00 00
	00		 mov	 ecx, DWORD PTR [ebp+212]
  00042	89 8b d4 00 00
	00		 mov	 DWORD PTR [ebx+212], ecx
  00048	8b 95 d8 00 00
	00		 mov	 edx, DWORD PTR [ebp+216]
  0004e	89 93 d8 00 00
	00		 mov	 DWORD PTR [ebx+216], edx
  00054	8a 85 dc 00 00
	00		 mov	 al, BYTE PTR [ebp+220]
  0005a	88 83 dc 00 00
	00		 mov	 BYTE PTR [ebx+220], al
  00060	8a 8d dd 00 00
	00		 mov	 cl, BYTE PTR [ebp+221]
  00066	88 8b dd 00 00
	00		 mov	 BYTE PTR [ebx+221], cl
  0006c	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], OFFSET FLAT:??_7UFractalTexture@@6B@ ; UFractalTexture::`vftable'
  00072	8a 95 e0 00 00
	00		 mov	 dl, BYTE PTR [ebp+224]
  00078	88 93 e0 00 00
	00		 mov	 BYTE PTR [ebx+224], dl
  0007e	8a 85 e1 00 00
	00		 mov	 al, BYTE PTR [ebp+225]
  00084	88 83 e1 00 00
	00		 mov	 BYTE PTR [ebx+225], al
  0008a	8a 8d e2 00 00
	00		 mov	 cl, BYTE PTR [ebp+226]
  00090	88 8b e2 00 00
	00		 mov	 BYTE PTR [ebx+226], cl
  00096	8a 95 e3 00 00
	00		 mov	 dl, BYTE PTR [ebp+227]
  0009c	88 93 e3 00 00
	00		 mov	 BYTE PTR [ebx+227], dl
  000a2	8a 85 e4 00 00
	00		 mov	 al, BYTE PTR [ebp+228]
  000a8	88 83 e4 00 00
	00		 mov	 BYTE PTR [ebx+228], al
  000ae	8a 8d e5 00 00
	00		 mov	 cl, BYTE PTR [ebp+229]
  000b4	88 8b e5 00 00
	00		 mov	 BYTE PTR [ebx+229], cl
  000ba	8a 95 e6 00 00
	00		 mov	 dl, BYTE PTR [ebp+230]
  000c0	88 93 e6 00 00
	00		 mov	 BYTE PTR [ebx+230], dl
  000c6	8a 85 e7 00 00
	00		 mov	 al, BYTE PTR [ebp+231]
  000cc	88 83 e7 00 00
	00		 mov	 BYTE PTR [ebx+231], al
  000d2	8a 8d e8 00 00
	00		 mov	 cl, BYTE PTR [ebp+232]
  000d8	88 8b e8 00 00
	00		 mov	 BYTE PTR [ebx+232], cl
  000de	8a 95 e9 00 00
	00		 mov	 dl, BYTE PTR [ebp+233]
  000e4	88 93 e9 00 00
	00		 mov	 BYTE PTR [ebx+233], dl
  000ea	8b 85 ec 00 00
	00		 mov	 eax, DWORD PTR [ebp+236]
  000f0	89 83 ec 00 00
	00		 mov	 DWORD PTR [ebx+236], eax
  000f6	8d b5 f0 00 00
	00		 lea	 esi, DWORD PTR [ebp+240]
  000fc	8d bb f0 00 00
	00		 lea	 edi, DWORD PTR [ebx+240]
  00102	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  00107	f3 a5		 rep movsd
  00109	8b 8d f0 08 00
	00		 mov	 ecx, DWORD PTR [ebp+2288]
  0010f	89 8b f0 08 00
	00		 mov	 DWORD PTR [ebx+2288], ecx
  00115	8d b5 f4 08 00
	00		 lea	 esi, DWORD PTR [ebp+2292]
  0011b	8d bb f4 08 00
	00		 lea	 edi, DWORD PTR [ebx+2292]
  00121	b9 01 01 00 00	 mov	 ecx, 257		; 00000101H
  00126	f3 a5		 rep movsd
  00128	8d b5 f8 0c 00
	00		 lea	 esi, DWORD PTR [ebp+3320]
  0012e	8d bb f8 0c 00
	00		 lea	 edi, DWORD PTR [ebx+3320]
  00134	b9 80 01 00 00	 mov	 ecx, 384		; 00000180H
  00139	f3 a5		 rep movsd
  0013b	8a 95 f8 12 00
	00		 mov	 dl, BYTE PTR [ebp+4856]
  00141	88 93 f8 12 00
	00		 mov	 BYTE PTR [ebx+4856], dl
  00147	8b 85 fc 12 00
	00		 mov	 eax, DWORD PTR [ebp+4860]
  0014d	89 83 fc 12 00
	00		 mov	 DWORD PTR [ebx+4860], eax
  00153	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], OFFSET FLAT:??_7UWaterTexture@@6B@ ; UWaterTexture::`vftable'
  00159	8b 8d 00 13 00
	00		 mov	 ecx, DWORD PTR [ebp+4864]
  0015f	89 8b 00 13 00
	00		 mov	 DWORD PTR [ebx+4864], ecx
  00165	8b 95 04 13 00
	00		 mov	 edx, DWORD PTR [ebp+4868]
  0016b	5f		 pop	 edi
  0016c	89 93 04 13 00
	00		 mov	 DWORD PTR [ebx+4868], edx
  00172	8b 85 08 13 00
	00		 mov	 eax, DWORD PTR [ebp+4872]
  00178	5e		 pop	 esi
  00179	89 83 08 13 00
	00		 mov	 DWORD PTR [ebx+4872], eax
  0017f	5d		 pop	 ebp
  00180	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], OFFSET FLAT:??_7UWetTexture@@6B@ ; UWetTexture::`vftable'
  00186	8b c3		 mov	 eax, ebx
  00188	5b		 pop	 ebx
  00189	c2 04 00	 ret	 4
??0UWetTexture@@QAE@ABV0@@Z ENDP			; UWetTexture::UWetTexture
_TEXT	ENDS
PUBLIC	??4UWetTexture@@QAEAAV0@ABV0@@Z			; UWetTexture::operator=
; Function compile flags: /Ogty
;	COMDAT ??4UWetTexture@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8
??4UWetTexture@@QAEAAV0@ABV0@@Z PROC NEAR		; UWetTexture::operator=, COMDAT
; _this$ = ecx
  00000	53		 push	 ebx
  00001	55		 push	 ebp
  00002	56		 push	 esi
  00003	57		 push	 edi
  00004	8b 7c 24 14	 mov	 edi, DWORD PTR ___that$[esp+12]
  00008	57		 push	 edi
  00009	8b f1		 mov	 esi, ecx
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4UBitmap@@QAEAAV0@ABV0@@Z
  00011	8b 47 54	 mov	 eax, DWORD PTR [edi+84]
  00014	89 46 54	 mov	 DWORD PTR [esi+84], eax
  00017	8b 4f 58	 mov	 ecx, DWORD PTR [edi+88]
  0001a	89 4e 58	 mov	 DWORD PTR [esi+88], ecx
  0001d	8b 57 5c	 mov	 edx, DWORD PTR [edi+92]
  00020	89 56 5c	 mov	 DWORD PTR [esi+92], edx
  00023	8b 47 60	 mov	 eax, DWORD PTR [edi+96]
  00026	89 46 60	 mov	 DWORD PTR [esi+96], eax
  00029	8b 4f 64	 mov	 ecx, DWORD PTR [edi+100]
  0002c	89 4e 64	 mov	 DWORD PTR [esi+100], ecx
  0002f	8b 57 68	 mov	 edx, DWORD PTR [edi+104]
  00032	89 56 68	 mov	 DWORD PTR [esi+104], edx
  00035	8b 47 6c	 mov	 eax, DWORD PTR [edi+108]
  00038	89 46 6c	 mov	 DWORD PTR [esi+108], eax
  0003b	8b 4f 70	 mov	 ecx, DWORD PTR [edi+112]
  0003e	89 4e 70	 mov	 DWORD PTR [esi+112], ecx
  00041	8b 57 74	 mov	 edx, DWORD PTR [edi+116]
  00044	89 56 74	 mov	 DWORD PTR [esi+116], edx
  00047	8b 47 78	 mov	 eax, DWORD PTR [edi+120]
  0004a	89 46 78	 mov	 DWORD PTR [esi+120], eax
  0004d	8b 4f 7c	 mov	 ecx, DWORD PTR [edi+124]
  00050	89 4e 7c	 mov	 DWORD PTR [esi+124], ecx
  00053	8b 97 80 00 00
	00		 mov	 edx, DWORD PTR [edi+128]
  00059	8b 8e 88 00 00
	00		 mov	 ecx, DWORD PTR [esi+136]
  0005f	89 96 80 00 00
	00		 mov	 DWORD PTR [esi+128], edx
  00065	8b 87 84 00 00
	00		 mov	 eax, DWORD PTR [edi+132]
  0006b	89 86 84 00 00
	00		 mov	 DWORD PTR [esi+132], eax
  00071	8b 87 88 00 00
	00		 mov	 eax, DWORD PTR [edi+136]
  00077	33 c1		 xor	 eax, ecx
  00079	83 e0 01	 and	 eax, 1
  0007c	33 c1		 xor	 eax, ecx
  0007e	89 86 88 00 00
	00		 mov	 DWORD PTR [esi+136], eax
  00084	8b 8f 88 00 00
	00		 mov	 ecx, DWORD PTR [edi+136]
  0008a	33 c8		 xor	 ecx, eax
  0008c	83 e1 02	 and	 ecx, 2
  0008f	33 c8		 xor	 ecx, eax
  00091	89 8e 88 00 00
	00		 mov	 DWORD PTR [esi+136], ecx
  00097	8b 87 88 00 00
	00		 mov	 eax, DWORD PTR [edi+136]
  0009d	33 c1		 xor	 eax, ecx
  0009f	83 e0 04	 and	 eax, 4
  000a2	33 c1		 xor	 eax, ecx
  000a4	89 86 88 00 00
	00		 mov	 DWORD PTR [esi+136], eax
  000aa	8b 8f 88 00 00
	00		 mov	 ecx, DWORD PTR [edi+136]
  000b0	33 c8		 xor	 ecx, eax
  000b2	83 e1 08	 and	 ecx, 8
  000b5	33 c8		 xor	 ecx, eax
  000b7	89 8e 88 00 00
	00		 mov	 DWORD PTR [esi+136], ecx
  000bd	8b 87 88 00 00
	00		 mov	 eax, DWORD PTR [edi+136]
  000c3	33 c1		 xor	 eax, ecx
  000c5	83 e0 10	 and	 eax, 16			; 00000010H
  000c8	33 c1		 xor	 eax, ecx
  000ca	89 86 88 00 00
	00		 mov	 DWORD PTR [esi+136], eax
  000d0	8b 8f 88 00 00
	00		 mov	 ecx, DWORD PTR [edi+136]
  000d6	33 c8		 xor	 ecx, eax
  000d8	83 e1 20	 and	 ecx, 32			; 00000020H
  000db	33 c8		 xor	 ecx, eax
  000dd	89 8e 88 00 00
	00		 mov	 DWORD PTR [esi+136], ecx
  000e3	8a 97 8c 00 00
	00		 mov	 dl, BYTE PTR [edi+140]
  000e9	88 96 8c 00 00
	00		 mov	 BYTE PTR [esi+140], dl
  000ef	8b 87 90 00 00
	00		 mov	 eax, DWORD PTR [edi+144]
  000f5	89 86 90 00 00
	00		 mov	 DWORD PTR [esi+144], eax
  000fb	8b 8f 94 00 00
	00		 mov	 ecx, DWORD PTR [edi+148]
  00101	89 8e 94 00 00
	00		 mov	 DWORD PTR [esi+148], ecx
  00107	8a 97 98 00 00
	00		 mov	 dl, BYTE PTR [edi+152]
  0010d	88 96 98 00 00
	00		 mov	 BYTE PTR [esi+152], dl
  00113	8a 87 99 00 00
	00		 mov	 al, BYTE PTR [edi+153]
  00119	88 86 99 00 00
	00		 mov	 BYTE PTR [esi+153], al
  0011f	8b 8f 9c 00 00
	00		 mov	 ecx, DWORD PTR [edi+156]
  00125	89 8e 9c 00 00
	00		 mov	 DWORD PTR [esi+156], ecx
  0012b	8b 97 a0 00 00
	00		 mov	 edx, DWORD PTR [edi+160]
  00131	89 96 a0 00 00
	00		 mov	 DWORD PTR [esi+160], edx
  00137	8b 87 a4 00 00
	00		 mov	 eax, DWORD PTR [edi+164]
  0013d	89 86 a4 00 00
	00		 mov	 DWORD PTR [esi+164], eax
  00143	8d 8f a8 00 00
	00		 lea	 ecx, DWORD PTR [edi+168]
  00149	51		 push	 ecx
  0014a	8d 8e a8 00 00
	00		 lea	 ecx, DWORD PTR [esi+168]
  00150	e8 00 00 00 00	 call	 ??4?$TArray@UFMipmap@@@@QAEAAV0@ABV0@@Z ; TArray<FMipmap>::operator=
  00155	8d 97 b4 00 00
	00		 lea	 edx, DWORD PTR [edi+180]
  0015b	52		 push	 edx
  0015c	8d 8e b4 00 00
	00		 lea	 ecx, DWORD PTR [esi+180]
  00162	e8 00 00 00 00	 call	 ??4?$TArray@UFMipmap@@@@QAEAAV0@ABV0@@Z ; TArray<FMipmap>::operator=
  00167	8a 87 c0 00 00
	00		 mov	 al, BYTE PTR [edi+192]
  0016d	88 86 c0 00 00
	00		 mov	 BYTE PTR [esi+192], al
  00173	8b 8f c4 00 00
	00		 mov	 ecx, DWORD PTR [edi+196]
  00179	89 8e c4 00 00
	00		 mov	 DWORD PTR [esi+196], ecx
  0017f	8b 97 c8 00 00
	00		 mov	 edx, DWORD PTR [edi+200]
  00185	89 96 c8 00 00
	00		 mov	 DWORD PTR [esi+200], edx
  0018b	8b 87 cc 00 00
	00		 mov	 eax, DWORD PTR [edi+204]
  00191	89 86 cc 00 00
	00		 mov	 DWORD PTR [esi+204], eax
  00197	8b 8f d0 00 00
	00		 mov	 ecx, DWORD PTR [edi+208]
  0019d	89 8e d0 00 00
	00		 mov	 DWORD PTR [esi+208], ecx
  001a3	8b 97 d4 00 00
	00		 mov	 edx, DWORD PTR [edi+212]
  001a9	89 96 d4 00 00
	00		 mov	 DWORD PTR [esi+212], edx
  001af	8b 87 d8 00 00
	00		 mov	 eax, DWORD PTR [edi+216]
  001b5	89 86 d8 00 00
	00		 mov	 DWORD PTR [esi+216], eax
  001bb	8a 8f dc 00 00
	00		 mov	 cl, BYTE PTR [edi+220]
  001c1	88 8e dc 00 00
	00		 mov	 BYTE PTR [esi+220], cl
  001c7	8a 97 dd 00 00
	00		 mov	 dl, BYTE PTR [edi+221]
  001cd	88 96 dd 00 00
	00		 mov	 BYTE PTR [esi+221], dl
  001d3	8a 87 e0 00 00
	00		 mov	 al, BYTE PTR [edi+224]
  001d9	88 86 e0 00 00
	00		 mov	 BYTE PTR [esi+224], al
  001df	8a 8f e1 00 00
	00		 mov	 cl, BYTE PTR [edi+225]
  001e5	88 8e e1 00 00
	00		 mov	 BYTE PTR [esi+225], cl
  001eb	8a 97 e2 00 00
	00		 mov	 dl, BYTE PTR [edi+226]
  001f1	88 96 e2 00 00
	00		 mov	 BYTE PTR [esi+226], dl
  001f7	8a 87 e3 00 00
	00		 mov	 al, BYTE PTR [edi+227]
  001fd	88 86 e3 00 00
	00		 mov	 BYTE PTR [esi+227], al
  00203	8a 8f e4 00 00
	00		 mov	 cl, BYTE PTR [edi+228]
  00209	88 8e e4 00 00
	00		 mov	 BYTE PTR [esi+228], cl
  0020f	8a 97 e5 00 00
	00		 mov	 dl, BYTE PTR [edi+229]
  00215	88 96 e5 00 00
	00		 mov	 BYTE PTR [esi+229], dl
  0021b	8a 87 e6 00 00
	00		 mov	 al, BYTE PTR [edi+230]
  00221	88 86 e6 00 00
	00		 mov	 BYTE PTR [esi+230], al
  00227	8a 8f e7 00 00
	00		 mov	 cl, BYTE PTR [edi+231]
  0022d	88 8e e7 00 00
	00		 mov	 BYTE PTR [esi+231], cl
  00233	8a 97 e8 00 00
	00		 mov	 dl, BYTE PTR [edi+232]
  00239	88 96 e8 00 00
	00		 mov	 BYTE PTR [esi+232], dl
  0023f	8a 87 e9 00 00
	00		 mov	 al, BYTE PTR [edi+233]
  00245	88 86 e9 00 00
	00		 mov	 BYTE PTR [esi+233], al
  0024b	8b 8f ec 00 00
	00		 mov	 ecx, DWORD PTR [edi+236]
  00251	89 8e ec 00 00
	00		 mov	 DWORD PTR [esi+236], ecx
  00257	8b cf		 mov	 ecx, edi
  00259	8d 86 f0 00 00
	00		 lea	 eax, DWORD PTR [esi+240]
  0025f	2b ce		 sub	 ecx, esi
  00261	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
$L139294:
  00266	8b 1c 01	 mov	 ebx, DWORD PTR [ecx+eax]
  00269	89 18		 mov	 DWORD PTR [eax], ebx
  0026b	8b 5c 01 04	 mov	 ebx, DWORD PTR [ecx+eax+4]
  0026f	89 58 04	 mov	 DWORD PTR [eax+4], ebx
  00272	83 c0 08	 add	 eax, 8
  00275	4a		 dec	 edx
  00276	75 ee		 jne	 SHORT $L139294
  00278	8b 97 f0 08 00
	00		 mov	 edx, DWORD PTR [edi+2288]
  0027e	bd 0c f7 ff ff	 mov	 ebp, -2292		; fffff70cH
  00283	89 96 f0 08 00
	00		 mov	 DWORD PTR [esi+2288], edx
  00289	8d 86 f4 08 00
	00		 lea	 eax, DWORD PTR [esi+2292]
  0028f	2b ee		 sub	 ebp, esi
$L139298:
  00291	8a 14 08	 mov	 dl, BYTE PTR [eax+ecx]
  00294	88 10		 mov	 BYTE PTR [eax], dl
  00296	40		 inc	 eax
  00297	8d 14 28	 lea	 edx, DWORD PTR [eax+ebp]
  0029a	81 fa 04 04 00
	00		 cmp	 edx, 1028		; 00000404H
  002a0	72 ef		 jb	 SHORT $L139298
  002a2	bd 08 f3 ff ff	 mov	 ebp, -3320		; fffff308H
  002a7	8d 86 f8 0c 00
	00		 lea	 eax, DWORD PTR [esi+3320]
  002ad	2b ee		 sub	 ebp, esi
  002af	90		 npad	 1
$L139302:
  002b0	8a 14 08	 mov	 dl, BYTE PTR [eax+ecx]
  002b3	88 10		 mov	 BYTE PTR [eax], dl
  002b5	40		 inc	 eax
  002b6	8d 14 28	 lea	 edx, DWORD PTR [eax+ebp]
  002b9	81 fa 00 06 00
	00		 cmp	 edx, 1536		; 00000600H
  002bf	72 ef		 jb	 SHORT $L139302
  002c1	8a 87 f8 12 00
	00		 mov	 al, BYTE PTR [edi+4856]
  002c7	88 86 f8 12 00
	00		 mov	 BYTE PTR [esi+4856], al
  002cd	8b 8f fc 12 00
	00		 mov	 ecx, DWORD PTR [edi+4860]
  002d3	89 8e fc 12 00
	00		 mov	 DWORD PTR [esi+4860], ecx
  002d9	8b 97 00 13 00
	00		 mov	 edx, DWORD PTR [edi+4864]
  002df	89 96 00 13 00
	00		 mov	 DWORD PTR [esi+4864], edx
  002e5	8b 87 04 13 00
	00		 mov	 eax, DWORD PTR [edi+4868]
  002eb	89 86 04 13 00
	00		 mov	 DWORD PTR [esi+4868], eax
  002f1	8b 8f 08 13 00
	00		 mov	 ecx, DWORD PTR [edi+4872]
  002f7	5f		 pop	 edi
  002f8	89 8e 08 13 00
	00		 mov	 DWORD PTR [esi+4872], ecx
  002fe	8b c6		 mov	 eax, esi
  00300	5e		 pop	 esi
  00301	5d		 pop	 ebp
  00302	5b		 pop	 ebx
  00303	c2 04 00	 ret	 4
??4UWetTexture@@QAEAAV0@ABV0@@Z ENDP			; UWetTexture::operator=
_TEXT	ENDS
PUBLIC	??_GUWetTexture@@UAEPAXI@Z			; UWetTexture::`scalar deleting destructor'
; Function compile flags: /Ogty
;	COMDAT ??_GUWetTexture@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_GUWetTexture@@UAEPAXI@Z PROC NEAR			; UWetTexture::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	e8 00 00 00 00	 call	 ??1UWetTexture@@UAE@XZ	; UWetTexture::~UWetTexture
  00008	f6 44 24 08 01	 test	 BYTE PTR ___flags$[esp], 1
  0000d	74 0d		 je	 SHORT $L139317
  0000f	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?GMalloc@@3PAVFMalloc@@A
  00014	8b 08		 mov	 ecx, DWORD PTR [eax]
  00016	8b 11		 mov	 edx, DWORD PTR [ecx]
  00018	56		 push	 esi
  00019	ff 52 08	 call	 DWORD PTR [edx+8]
$L139317:
  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi
  0001f	c2 04 00	 ret	 4
??_GUWetTexture@@UAEPAXI@Z ENDP				; UWetTexture::`scalar deleting destructor'
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??_EUWetTexture@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_EUWetTexture@@UAEPAXI@Z PROC NEAR			; UWetTexture::`vector deleting destructor', COMDAT
; _this$ = ecx
  00000	53		 push	 ebx
  00001	8a 5c 24 08	 mov	 bl, BYTE PTR ___flags$[esp]
  00005	f6 c3 02	 test	 bl, 2
  00008	56		 push	 esi
  00009	8b f1		 mov	 esi, ecx
  0000b	74 33		 je	 SHORT $L123457
  0000d	8b 46 fc	 mov	 eax, DWORD PTR [esi-4]
  00010	57		 push	 edi
  00011	68 00 00 00 00	 push	 OFFSET FLAT:??1UWetTexture@@UAE@XZ ; UWetTexture::~UWetTexture
  00016	8d 7e fc	 lea	 edi, DWORD PTR [esi-4]
  00019	50		 push	 eax
  0001a	68 0c 13 00 00	 push	 4876			; 0000130cH
  0001f	56		 push	 esi
  00020	e8 00 00 00 00	 call	 ??_M@YGXPAXIHP6EX0@Z@Z	; `eh vector destructor iterator'
  00025	f6 c3 01	 test	 bl, 1
  00028	74 0e		 je	 SHORT $L139323
  0002a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?GMalloc@@3PAVFMalloc@@A
  00030	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00032	8b 11		 mov	 edx, DWORD PTR [ecx]
  00034	57		 push	 edi
  00035	ff 52 08	 call	 DWORD PTR [edx+8]
$L139323:
  00038	8b c7		 mov	 eax, edi
  0003a	5f		 pop	 edi
  0003b	5e		 pop	 esi
  0003c	5b		 pop	 ebx
  0003d	c2 04 00	 ret	 4
$L123457:
  00040	8b ce		 mov	 ecx, esi
  00042	e8 00 00 00 00	 call	 ??1UWetTexture@@UAE@XZ	; UWetTexture::~UWetTexture
  00047	f6 c3 01	 test	 bl, 1
  0004a	74 0d		 je	 SHORT $L139325
  0004c	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?GMalloc@@3PAVFMalloc@@A
  00051	8b 08		 mov	 ecx, DWORD PTR [eax]
  00053	8b 11		 mov	 edx, DWORD PTR [ecx]
  00055	56		 push	 esi
  00056	ff 52 08	 call	 DWORD PTR [edx+8]
$L139325:
  00059	8b c6		 mov	 eax, esi
  0005b	5e		 pop	 esi
  0005c	5b		 pop	 ebx
  0005d	c2 04 00	 ret	 4
??_EUWetTexture@@UAEPAXI@Z ENDP				; UWetTexture::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??4KeyPoint@@QAEAAU0@ABU0@@Z			; KeyPoint::operator=
; Function compile flags: /Ogty
;	COMDAT ??4KeyPoint@@QAEAAU0@ABU0@@Z
_TEXT	SEGMENT
___that$ = 8
??4KeyPoint@@QAEAAU0@ABU0@@Z PROC NEAR			; KeyPoint::operator=, COMDAT
; _this$ = ecx
  00000	8b c1		 mov	 eax, ecx
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR ___that$[esp-4]
  00006	8b 11		 mov	 edx, DWORD PTR [ecx]
  00008	89 10		 mov	 DWORD PTR [eax], edx
  0000a	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0000d	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00010	c2 04 00	 ret	 4
??4KeyPoint@@QAEAAU0@ABU0@@Z ENDP			; KeyPoint::operator=
_TEXT	ENDS
PUBLIC	?StaticClass@UIceTexture@@SAPAVUClass@@XZ	; UIceTexture::StaticClass
; Function compile flags: /Ogty
;	COMDAT ?StaticClass@UIceTexture@@SAPAVUClass@@XZ
_TEXT	SEGMENT
?StaticClass@UIceTexture@@SAPAVUClass@@XZ PROC NEAR	; UIceTexture::StaticClass, COMDAT

; 469  : 	DECLARE_CLASS(UIceTexture,UFractalTexture,0)

  00000	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?PrivateStaticClass@UIceTexture@@0VUClass@@A ; UIceTexture::PrivateStaticClass
  00005	c3		 ret	 0
?StaticClass@UIceTexture@@SAPAVUClass@@XZ ENDP		; UIceTexture::StaticClass
_TEXT	ENDS
PUBLIC	??2UIceTexture@@SAPAXIPAVUObject@@VFName@@K@Z	; UIceTexture::operator new
; Function compile flags: /Ogty
;	COMDAT ??2UIceTexture@@SAPAXIPAVUObject@@VFName@@K@Z
_TEXT	SEGMENT
_Outer$ = 12
_Name$ = 16
_SetFlags$ = 20
??2UIceTexture@@SAPAXIPAVUObject@@VFName@@K@Z PROC NEAR	; UIceTexture::operator new, COMDAT

; 469  : 	DECLARE_CLASS(UIceTexture,UFractalTexture,0)

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?GError@@3PAVFOutputDeviceError@@A
  00005	8b 08		 mov	 ecx, DWORD PTR [eax]
  00007	8b 54 24 10	 mov	 edx, DWORD PTR _SetFlags$[esp-4]
  0000b	8b 44 24 0c	 mov	 eax, DWORD PTR _Name$[esp-4]
  0000f	6a 00		 push	 0
  00011	51		 push	 ecx
  00012	8b 4c 24 10	 mov	 ecx, DWORD PTR _Outer$[esp+4]
  00016	6a 00		 push	 0
  00018	52		 push	 edx
  00019	50		 push	 eax
  0001a	51		 push	 ecx
  0001b	68 00 00 00 00	 push	 OFFSET FLAT:?PrivateStaticClass@UIceTexture@@0VUClass@@A ; UIceTexture::PrivateStaticClass
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?StaticAllocateObject@UObject@@SAPAV1@PAVUClass@@PAV1@VFName@@K1PAVFOutputDevice@@1@Z
  00026	83 c4 1c	 add	 esp, 28			; 0000001cH
  00029	c3		 ret	 0
??2UIceTexture@@SAPAXIPAVUObject@@VFName@@K@Z ENDP	; UIceTexture::operator new
_TEXT	ENDS
PUBLIC	??2UIceTexture@@SAPAXIPAW4EInternal@@@Z		; UIceTexture::operator new
; Function compile flags: /Ogty
;	COMDAT ??2UIceTexture@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT
_Mem$ = 12
??2UIceTexture@@SAPAXIPAW4EInternal@@@Z PROC NEAR	; UIceTexture::operator new, COMDAT

; 469  : 	DECLARE_CLASS(UIceTexture,UFractalTexture,0)

  00000	8b 44 24 08	 mov	 eax, DWORD PTR _Mem$[esp-4]
  00004	c3		 ret	 0
??2UIceTexture@@SAPAXIPAW4EInternal@@@Z ENDP		; UIceTexture::operator new
_TEXT	ENDS
PUBLIC	??1UIceTexture@@UAE@XZ				; UIceTexture::~UIceTexture
;	COMDAT xdata$x
; File ..\..\Engine\Inc\UnTex.h
xdata$x	SEGMENT
$T139580 DD	0ffffffffH
	DD	FLAT:$L139345
	DD	0ffffffffH
	DD	FLAT:$L139347
	DD	0ffffffffH
	DD	FLAT:$L139349
	DD	0ffffffffH
	DD	FLAT:$L139351
	DD	03H
	DD	FLAT:$L139352
	DD	04H
	DD	FLAT:$L139353
	DD	04H
	DD	FLAT:$L139355
	DD	03H
	DD	FLAT:$L139403
	DD	0ffffffffH
	DD	FLAT:$L139444
$T139571 DD	019930520H
	DD	09H
	DD	FLAT:$T139580
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File C:\duke4\Fire\Src\FractalPrivate.h
xdata$x	ENDS
;	COMDAT ??1UIceTexture@@UAE@XZ
_TEXT	SEGMENT
$T139401 = -16
$T139442 = -16
__$EHRec$ = -12
_this$ = -20
??1UIceTexture@@UAE@XZ PROC NEAR			; UIceTexture::~UIceTexture, COMDAT
; _this$ = ecx

; 469  : 	DECLARE_CLASS(UIceTexture,UFractalTexture,0)

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 $L139579
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00018	53		 push	 ebx
  00019	55		 push	 ebp
  0001a	56		 push	 esi
  0001b	8b f1		 mov	 esi, ecx
  0001d	57		 push	 edi
  0001e	89 74 24 14	 mov	 DWORD PTR _this$[esp+40], esi
  00022	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7UIceTexture@@6B@ ; UIceTexture::`vftable'
  00028	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp_?ConditionalDestroy@UObject@@QAEHXZ
  0002e	33 ed		 xor	 ebp, ebp
  00030	89 6c 24 24	 mov	 DWORD PTR __$EHRec$[esp+48], ebp
  00034	ff d7		 call	 edi
  00036	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7UFractalTexture@@6B@ ; UFractalTexture::`vftable'
  0003c	8b ce		 mov	 ecx, esi
  0003e	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+48], 1
  00046	ff d7		 call	 edi
  00048	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_??_7UProceduralTexture@@6B@
  0004d	89 06		 mov	 DWORD PTR [esi], eax
  0004f	8b ce		 mov	 ecx, esi
  00051	c7 44 24 24 02
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+48], 2
  00059	ff d7		 call	 edi
  0005b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_??_7UTexture@@6B@
  00061	89 0e		 mov	 DWORD PTR [esi], ecx
  00063	8b ce		 mov	 ecx, esi
  00065	c7 44 24 24 05
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+48], 5
  0006d	ff d7		 call	 edi
  0006f	8d be b4 00 00
	00		 lea	 edi, DWORD PTR [esi+180]
  00075	89 7c 24 18	 mov	 DWORD PTR $T139401[esp+40], edi
  00079	8b 5f 04	 mov	 ebx, DWORD PTR [edi+4]
  0007c	3b dd		 cmp	 ebx, ebp
  0007e	c6 44 24 24 06	 mov	 BYTE PTR __$EHRec$[esp+48], 6
  00083	7d 18		 jge	 SHORT $L139539
  00085	68 fd 01 00 00	 push	 509			; 000001fdH
  0008a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@MLGP@?4?4?2?4?4?2Core?2Inc?2UnTemplate?4h?$AA@ ; `string'
  0008f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BA@FEMP@Index?$DM?$DNArrayNum?$AA@ ; `string'
  00094	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?appFailAssert@@YAXPBD0H@Z
  0009a	83 c4 0c	 add	 esp, 12			; 0000000cH
$L139539:
  0009d	3b 5f 04	 cmp	 ebx, DWORD PTR [edi+4]
  000a0	7e 18		 jle	 SHORT $L139540
  000a2	68 fe 01 00 00	 push	 510			; 000001feH
  000a7	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@MLGP@?4?4?2?4?4?2Core?2Inc?2UnTemplate?4h?$AA@ ; `string'
  000ac	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BG@BEDF@Index?$CLCount?$DM?$DNArrayNum?$AA@ ; `string'
  000b1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?appFailAssert@@YAXPBD0H@Z
  000b7	83 c4 0c	 add	 esp, 12			; 0000000cH
$L139540:
  000ba	3b dd		 cmp	 ebx, ebp
  000bc	7e 1f		 jle	 SHORT $L139545
  000be	89 5c 24 10	 mov	 DWORD PTR -24+[esp+40], ebx
$L139543:
  000c2	8b 0f		 mov	 ecx, DWORD PTR [edi]
  000c4	6a 00		 push	 0
  000c6	03 cd		 add	 ecx, ebp
  000c8	e8 00 00 00 00	 call	 ??_GFMipmap@@QAEPAXI@Z	; FMipmap::`scalar deleting destructor'
  000cd	8b 44 24 10	 mov	 eax, DWORD PTR -24+[esp+40]
  000d1	83 c5 28	 add	 ebp, 40			; 00000028H
  000d4	48		 dec	 eax
  000d5	89 44 24 10	 mov	 DWORD PTR -24+[esp+40], eax
  000d9	75 e7		 jne	 SHORT $L139543
  000db	33 ed		 xor	 ebp, ebp
$L139545:
  000dd	6a 28		 push	 40			; 00000028H
  000df	53		 push	 ebx
  000e0	55		 push	 ebp
  000e1	8b cf		 mov	 ecx, edi
  000e3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Remove@FArray@@QAEXHHH@Z
  000e9	8b 07		 mov	 eax, DWORD PTR [edi]
  000eb	3b c5		 cmp	 eax, ebp
  000ed	c6 44 24 24 04	 mov	 BYTE PTR __$EHRec$[esp+48], 4
  000f2	74 0e		 je	 SHORT $L139548
  000f4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR __imp_?GMalloc@@3PAVFMalloc@@A
  000fa	8b 0a		 mov	 ecx, DWORD PTR [edx]
  000fc	8b 11		 mov	 edx, DWORD PTR [ecx]
  000fe	50		 push	 eax
  000ff	ff 52 08	 call	 DWORD PTR [edx+8]
$L139548:
  00102	89 2f		 mov	 DWORD PTR [edi], ebp
  00104	89 6f 08	 mov	 DWORD PTR [edi+8], ebp
  00107	89 6f 04	 mov	 DWORD PTR [edi+4], ebp
  0010a	8d be a8 00 00
	00		 lea	 edi, DWORD PTR [esi+168]
  00110	89 7c 24 18	 mov	 DWORD PTR $T139442[esp+40], edi
  00114	8b 6f 04	 mov	 ebp, DWORD PTR [edi+4]
  00117	85 ed		 test	 ebp, ebp
  00119	c6 44 24 24 07	 mov	 BYTE PTR __$EHRec$[esp+48], 7
  0011e	7d 18		 jge	 SHORT $L139558
  00120	68 fd 01 00 00	 push	 509			; 000001fdH
  00125	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@MLGP@?4?4?2?4?4?2Core?2Inc?2UnTemplate?4h?$AA@ ; `string'
  0012a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BA@FEMP@Index?$DM?$DNArrayNum?$AA@ ; `string'
  0012f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?appFailAssert@@YAXPBD0H@Z
  00135	83 c4 0c	 add	 esp, 12			; 0000000cH
$L139558:
  00138	3b 6f 04	 cmp	 ebp, DWORD PTR [edi+4]
  0013b	7e 18		 jle	 SHORT $L139559
  0013d	68 fe 01 00 00	 push	 510			; 000001feH
  00142	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@MLGP@?4?4?2?4?4?2Core?2Inc?2UnTemplate?4h?$AA@ ; `string'
  00147	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BG@BEDF@Index?$CLCount?$DM?$DNArrayNum?$AA@ ; `string'
  0014c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?appFailAssert@@YAXPBD0H@Z
  00152	83 c4 0c	 add	 esp, 12			; 0000000cH
$L139559:
  00155	85 ed		 test	 ebp, ebp
  00157	7e 20		 jle	 SHORT $L139564
  00159	33 db		 xor	 ebx, ebx
  0015b	89 6c 24 10	 mov	 DWORD PTR -24+[esp+40], ebp
  0015f	90		 npad	 1
$L139562:
  00160	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00162	6a 00		 push	 0
  00164	03 cb		 add	 ecx, ebx
  00166	e8 00 00 00 00	 call	 ??_GFMipmap@@QAEPAXI@Z	; FMipmap::`scalar deleting destructor'
  0016b	8b 44 24 10	 mov	 eax, DWORD PTR -24+[esp+40]
  0016f	83 c3 28	 add	 ebx, 40			; 00000028H
  00172	48		 dec	 eax
  00173	89 44 24 10	 mov	 DWORD PTR -24+[esp+40], eax
  00177	75 e7		 jne	 SHORT $L139562
$L139564:
  00179	6a 28		 push	 40			; 00000028H
  0017b	55		 push	 ebp
  0017c	6a 00		 push	 0
  0017e	8b cf		 mov	 ecx, edi
  00180	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Remove@FArray@@QAEXHHH@Z
  00186	8b cf		 mov	 ecx, edi
  00188	c6 44 24 24 03	 mov	 BYTE PTR __$EHRec$[esp+48], 3
  0018d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1FArray@@QAE@XZ
  00193	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_??_7UBitmap@@6B@
  00198	89 06		 mov	 DWORD PTR [esi], eax
  0019a	8b ce		 mov	 ecx, esi
  0019c	c7 44 24 24 08
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+48], 8
  001a4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?ConditionalDestroy@UObject@@QAEHXZ
  001aa	8b ce		 mov	 ecx, esi
  001ac	c7 44 24 24 ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+48], -1
  001b4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1UObject@@UAE@XZ
  001ba	8b 4c 24 1c	 mov	 ecx, DWORD PTR __$EHRec$[esp+40]
  001be	5f		 pop	 edi
  001bf	5e		 pop	 esi
  001c0	5d		 pop	 ebp
  001c1	5b		 pop	 ebx
  001c2	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  001c9	83 c4 18	 add	 esp, 24			; 00000018H
  001cc	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L139345:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1UFractalTexture@@UAE@XZ ; UFractalTexture::~UFractalTexture
$L139347:
  00008	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1UProceduralTexture@@UAE@XZ
$L139349:
  00011	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1UTexture@@UAE@XZ
$L139351:
  0001a	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1UBitmap@@UAE@XZ
$L139352:
  00023	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	81 c1 a8 00 00
	00		 add	 ecx, 168		; 000000a8H
  0002c	e9 00 00 00 00	 jmp	 ??1?$TArray@UFMipmap@@@@QAE@XZ ; TArray<FMipmap>::~TArray<FMipmap>
$L139353:
  00031	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	81 c1 b4 00 00
	00		 add	 ecx, 180		; 000000b4H
  0003a	e9 00 00 00 00	 jmp	 ??1?$TArray@UFMipmap@@@@QAE@XZ ; TArray<FMipmap>::~TArray<FMipmap>
$L139355:
  0003f	8b 4d f0	 mov	 ecx, DWORD PTR $T139401[ebp]
  00042	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1FArray@@QAE@XZ
$L139403:
  00048	8b 4d f0	 mov	 ecx, DWORD PTR $T139442[ebp]
  0004b	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1FArray@@QAE@XZ
$L139444:
  00051	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00054	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1UObject@@UAE@XZ
$L139579:
  0005a	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T139571
  0005f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??1UIceTexture@@UAE@XZ ENDP				; UIceTexture::~UIceTexture
; Function compile flags: /Ogty
;	COMDAT ?InternalConstructor@UIceTexture@@SAXPAX@Z
_TEXT	SEGMENT
_X$ = 8
?InternalConstructor@UIceTexture@@SAXPAX@Z PROC NEAR	; UIceTexture::InternalConstructor, COMDAT

; 469  : 	DECLARE_CLASS(UIceTexture,UFractalTexture,0)

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR _X$[esp-4]
  00004	85 c9		 test	 ecx, ecx
  00006	74 05		 je	 SHORT $L139587
  00008	e9 00 00 00 00	 jmp	 ??0UIceTexture@@QAE@XZ	; UIceTexture::UIceTexture
$L139587:
  0000d	c3		 ret	 0
?InternalConstructor@UIceTexture@@SAXPAX@Z ENDP		; UIceTexture::InternalConstructor
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?Lock@UIceTexture@@UAIXAAUFTextureInfo@@NHPAVURenderDevice@@@Z
_TEXT	SEGMENT
_Time$ = 8
_RenDev$ = 20
_TempInfo$123595 = -128
_TempInfo$123598 = -128
?Lock@UIceTexture@@UAIXAAUFTextureInfo@@NHPAVURenderDevice@@@Z PROC NEAR ; UIceTexture::Lock, COMDAT
; _this$ = ecx
; _TextureInfo$ = edx

; 511  : 	{

  00000	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H
  00006	53		 push	 ebx

; 512  : 		if( GlassTexture )

  00007	8b 9c 24 88 00
	00 00		 mov	 ebx, DWORD PTR _Time$[esp+128]
  0000e	55		 push	 ebp
  0000f	56		 push	 esi
  00010	8b f1		 mov	 esi, ecx
  00012	8b 8e e0 00 00
	00		 mov	 ecx, DWORD PTR [esi+224]
  00018	85 c9		 test	 ecx, ecx
  0001a	57		 push	 edi
  0001b	8b bc 24 98 00
	00 00		 mov	 edi, DWORD PTR _Time$[esp+144]
  00022	8b ea		 mov	 ebp, edx
  00024	74 22		 je	 SHORT $L123596

; 513  : 		{
; 514  : 			FTextureInfo TempInfo;
; 515  : 			if( GlassTexture != this )

  00026	3b ce		 cmp	 ecx, esi
  00028	74 1e		 je	 SHORT $L123596

; 516  : 			{
; 517  : 				GlassTexture->Lock( TempInfo, Time, 0, NULL );

  0002a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0002c	6a 00		 push	 0
  0002e	6a 00		 push	 0
  00030	57		 push	 edi
  00031	53		 push	 ebx
  00032	8d 54 24 20	 lea	 edx, DWORD PTR _TempInfo$123595[esp+160]
  00036	ff 50 48	 call	 DWORD PTR [eax+72]

; 518  : 				GlassTexture->Unlock( TempInfo );

  00039	8b 8e e0 00 00
	00		 mov	 ecx, DWORD PTR [esi+224]
  0003f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00041	8d 54 24 10	 lea	 edx, DWORD PTR _TempInfo$123595[esp+144]
  00045	ff 50 4c	 call	 DWORD PTR [eax+76]
$L123596:

; 519  : 			}
; 520  : 		}
; 521  : 		if( SourceTexture )

  00048	8b 8e e4 00 00
	00		 mov	 ecx, DWORD PTR [esi+228]
  0004e	85 c9		 test	 ecx, ecx
  00050	74 22		 je	 SHORT $L123599

; 522  : 		{
; 523  : 			FTextureInfo TempInfo;
; 524  : 			if( SourceTexture != this )

  00052	3b ce		 cmp	 ecx, esi
  00054	74 1e		 je	 SHORT $L123599

; 525  : 			{
; 526  : 				SourceTexture->Lock( TempInfo, Time, 0, NULL );

  00056	8b 01		 mov	 eax, DWORD PTR [ecx]
  00058	6a 00		 push	 0
  0005a	6a 00		 push	 0
  0005c	57		 push	 edi
  0005d	53		 push	 ebx
  0005e	8d 54 24 20	 lea	 edx, DWORD PTR _TempInfo$123598[esp+160]
  00062	ff 50 48	 call	 DWORD PTR [eax+72]

; 527  : 				SourceTexture->Unlock(TempInfo);

  00065	8b 8e e4 00 00
	00		 mov	 ecx, DWORD PTR [esi+228]
  0006b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0006d	8d 54 24 10	 lea	 edx, DWORD PTR _TempInfo$123598[esp+144]
  00071	ff 50 4c	 call	 DWORD PTR [eax+76]
$L123599:

; 528  : 			}
; 529  : 		}
; 530  : 		Super::Lock( TextureInfo, Time, 0, RenDev );

  00074	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR _RenDev$[esp+140]
  0007b	51		 push	 ecx
  0007c	6a 00		 push	 0
  0007e	57		 push	 edi
  0007f	53		 push	 ebx
  00080	8b d5		 mov	 edx, ebp
  00082	8b ce		 mov	 ecx, esi
  00084	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Lock@UTexture@@UAIXAAUFTextureInfo@@NHPAVURenderDevice@@@Z
  0008a	5f		 pop	 edi
  0008b	5e		 pop	 esi
  0008c	5d		 pop	 ebp
  0008d	5b		 pop	 ebx

; 531  : 	}

  0008e	81 c4 80 00 00
	00		 add	 esp, 128		; 00000080H
  00094	c2 10 00	 ret	 16			; 00000010H
?Lock@UIceTexture@@UAIXAAUFTextureInfo@@NHPAVURenderDevice@@@Z ENDP ; UIceTexture::Lock
_TEXT	ENDS
PUBLIC	??0UIceTexture@@QAE@ABV0@@Z			; UIceTexture::UIceTexture
;	COMDAT xdata$x
xdata$x	SEGMENT
$T139648 DD	0ffffffffH
	DD	FLAT:$L139620
	DD	00H
	DD	FLAT:$L139621
$T139646 DD	019930520H
	DD	02H
	DD	FLAT:$T139648
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ??0UIceTexture@@QAE@ABV0@@Z
_TEXT	SEGMENT
__$EHRec$ = -12
___that$ = 8
_this$ = -16
??0UIceTexture@@QAE@ABV0@@Z PROC NEAR			; UIceTexture::UIceTexture, COMDAT
; _this$ = ecx
  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 $L139647
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	51		 push	 ecx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	8b 7c 24 1c	 mov	 edi, DWORD PTR ___that$[esp+20]
  0001c	8b f1		 mov	 esi, ecx
  0001e	57		 push	 edi
  0001f	89 74 24 0c	 mov	 DWORD PTR _this$[esp+28], esi
  00023	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0UObject@@QAE@ABV0@@Z
  00029	8a 47 28	 mov	 al, BYTE PTR [edi+40]
  0002c	88 46 28	 mov	 BYTE PTR [esi+40], al
  0002f	8b 4f 2c	 mov	 ecx, DWORD PTR [edi+44]
  00032	89 4e 2c	 mov	 DWORD PTR [esi+44], ecx
  00035	8a 57 30	 mov	 dl, BYTE PTR [edi+48]
  00038	88 56 30	 mov	 BYTE PTR [esi+48], dl
  0003b	8a 47 31	 mov	 al, BYTE PTR [edi+49]
  0003e	88 46 31	 mov	 BYTE PTR [esi+49], al
  00041	8b 4f 34	 mov	 ecx, DWORD PTR [edi+52]
  00044	89 4e 34	 mov	 DWORD PTR [esi+52], ecx
  00047	8b 57 38	 mov	 edx, DWORD PTR [edi+56]
  0004a	89 56 38	 mov	 DWORD PTR [esi+56], edx
  0004d	8b 47 3c	 mov	 eax, DWORD PTR [edi+60]
  00050	89 46 3c	 mov	 DWORD PTR [esi+60], eax
  00053	8b 4f 40	 mov	 ecx, DWORD PTR [edi+64]
  00056	89 4e 40	 mov	 DWORD PTR [esi+64], ecx
  00059	8b 57 44	 mov	 edx, DWORD PTR [edi+68]
  0005c	89 56 44	 mov	 DWORD PTR [esi+68], edx
  0005f	8b 47 48	 mov	 eax, DWORD PTR [edi+72]
  00062	89 46 48	 mov	 DWORD PTR [esi+72], eax
  00065	8b 4f 4c	 mov	 ecx, DWORD PTR [edi+76]
  00068	89 4e 4c	 mov	 DWORD PTR [esi+76], ecx
  0006b	8b 57 50	 mov	 edx, DWORD PTR [edi+80]
  0006e	89 56 50	 mov	 DWORD PTR [esi+80], edx
  00071	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_??_7UBitmap@@6B@
  00076	89 06		 mov	 DWORD PTR [esi], eax
  00078	8b 4f 54	 mov	 ecx, DWORD PTR [edi+84]
  0007b	89 4e 54	 mov	 DWORD PTR [esi+84], ecx
  0007e	8b 57 58	 mov	 edx, DWORD PTR [edi+88]
  00081	89 56 58	 mov	 DWORD PTR [esi+88], edx
  00084	8b 47 5c	 mov	 eax, DWORD PTR [edi+92]
  00087	89 46 5c	 mov	 DWORD PTR [esi+92], eax
  0008a	8b 4f 60	 mov	 ecx, DWORD PTR [edi+96]
  0008d	89 4e 60	 mov	 DWORD PTR [esi+96], ecx
  00090	8b 57 64	 mov	 edx, DWORD PTR [edi+100]
  00093	89 56 64	 mov	 DWORD PTR [esi+100], edx
  00096	8b 47 68	 mov	 eax, DWORD PTR [edi+104]
  00099	89 46 68	 mov	 DWORD PTR [esi+104], eax
  0009c	8b 4f 6c	 mov	 ecx, DWORD PTR [edi+108]
  0009f	89 4e 6c	 mov	 DWORD PTR [esi+108], ecx
  000a2	8b 57 70	 mov	 edx, DWORD PTR [edi+112]
  000a5	89 56 70	 mov	 DWORD PTR [esi+112], edx
  000a8	8b 47 74	 mov	 eax, DWORD PTR [edi+116]
  000ab	89 46 74	 mov	 DWORD PTR [esi+116], eax
  000ae	8b 4f 78	 mov	 ecx, DWORD PTR [edi+120]
  000b1	89 4e 78	 mov	 DWORD PTR [esi+120], ecx
  000b4	8b 57 7c	 mov	 edx, DWORD PTR [edi+124]
  000b7	89 56 7c	 mov	 DWORD PTR [esi+124], edx
  000ba	8b 87 80 00 00
	00		 mov	 eax, DWORD PTR [edi+128]
  000c0	89 86 80 00 00
	00		 mov	 DWORD PTR [esi+128], eax
  000c6	8b 8f 84 00 00
	00		 mov	 ecx, DWORD PTR [edi+132]
  000cc	89 8e 84 00 00
	00		 mov	 DWORD PTR [esi+132], ecx
  000d2	8b 8e 88 00 00
	00		 mov	 ecx, DWORD PTR [esi+136]
  000d8	8b 87 88 00 00
	00		 mov	 eax, DWORD PTR [edi+136]
  000de	33 c1		 xor	 eax, ecx
  000e0	83 e0 01	 and	 eax, 1
  000e3	33 c1		 xor	 eax, ecx
  000e5	89 86 88 00 00
	00		 mov	 DWORD PTR [esi+136], eax
  000eb	8b 8f 88 00 00
	00		 mov	 ecx, DWORD PTR [edi+136]
  000f1	33 c8		 xor	 ecx, eax
  000f3	83 e1 02	 and	 ecx, 2
  000f6	33 c8		 xor	 ecx, eax
  000f8	89 8e 88 00 00
	00		 mov	 DWORD PTR [esi+136], ecx
  000fe	8b 87 88 00 00
	00		 mov	 eax, DWORD PTR [edi+136]
  00104	33 c1		 xor	 eax, ecx
  00106	83 e0 04	 and	 eax, 4
  00109	33 c1		 xor	 eax, ecx
  0010b	89 86 88 00 00
	00		 mov	 DWORD PTR [esi+136], eax
  00111	8b 8f 88 00 00
	00		 mov	 ecx, DWORD PTR [edi+136]
  00117	33 c8		 xor	 ecx, eax
  00119	83 e1 08	 and	 ecx, 8
  0011c	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+32], 0
  00124	33 c8		 xor	 ecx, eax
  00126	89 8e 88 00 00
	00		 mov	 DWORD PTR [esi+136], ecx
  0012c	8b 87 88 00 00
	00		 mov	 eax, DWORD PTR [edi+136]
  00132	33 c1		 xor	 eax, ecx
  00134	83 e0 10	 and	 eax, 16			; 00000010H
  00137	33 c1		 xor	 eax, ecx
  00139	89 86 88 00 00
	00		 mov	 DWORD PTR [esi+136], eax
  0013f	8b 97 88 00 00
	00		 mov	 edx, DWORD PTR [edi+136]
  00145	33 d0		 xor	 edx, eax
  00147	83 e2 20	 and	 edx, 32			; 00000020H
  0014a	33 d0		 xor	 edx, eax
  0014c	89 96 88 00 00
	00		 mov	 DWORD PTR [esi+136], edx
  00152	8a 87 8c 00 00
	00		 mov	 al, BYTE PTR [edi+140]
  00158	88 86 8c 00 00
	00		 mov	 BYTE PTR [esi+140], al
  0015e	8b 8f 90 00 00
	00		 mov	 ecx, DWORD PTR [edi+144]
  00164	89 8e 90 00 00
	00		 mov	 DWORD PTR [esi+144], ecx
  0016a	8b 97 94 00 00
	00		 mov	 edx, DWORD PTR [edi+148]
  00170	89 96 94 00 00
	00		 mov	 DWORD PTR [esi+148], edx
  00176	8a 87 98 00 00
	00		 mov	 al, BYTE PTR [edi+152]
  0017c	88 86 98 00 00
	00		 mov	 BYTE PTR [esi+152], al
  00182	8a 8f 99 00 00
	00		 mov	 cl, BYTE PTR [edi+153]
  00188	88 8e 99 00 00
	00		 mov	 BYTE PTR [esi+153], cl
  0018e	8b 97 9c 00 00
	00		 mov	 edx, DWORD PTR [edi+156]
  00194	89 96 9c 00 00
	00		 mov	 DWORD PTR [esi+156], edx
  0019a	8b 87 a0 00 00
	00		 mov	 eax, DWORD PTR [edi+160]
  001a0	89 86 a0 00 00
	00		 mov	 DWORD PTR [esi+160], eax
  001a6	8b 8f a4 00 00
	00		 mov	 ecx, DWORD PTR [edi+164]
  001ac	8d 97 a8 00 00
	00		 lea	 edx, DWORD PTR [edi+168]
  001b2	89 8e a4 00 00
	00		 mov	 DWORD PTR [esi+164], ecx
  001b8	52		 push	 edx
  001b9	8d 8e a8 00 00
	00		 lea	 ecx, DWORD PTR [esi+168]
  001bf	e8 00 00 00 00	 call	 ??0?$TArray@UFMipmap@@@@QAE@ABV0@@Z ; TArray<FMipmap>::TArray<FMipmap>
  001c4	8d 87 b4 00 00
	00		 lea	 eax, DWORD PTR [edi+180]
  001ca	50		 push	 eax
  001cb	8d 8e b4 00 00
	00		 lea	 ecx, DWORD PTR [esi+180]
  001d1	c6 44 24 18 01	 mov	 BYTE PTR __$EHRec$[esp+36], 1
  001d6	e8 00 00 00 00	 call	 ??0?$TArray@UFMipmap@@@@QAE@ABV0@@Z ; TArray<FMipmap>::TArray<FMipmap>
  001db	8a 8f c0 00 00
	00		 mov	 cl, BYTE PTR [edi+192]
  001e1	88 8e c0 00 00
	00		 mov	 BYTE PTR [esi+192], cl
  001e7	8b 97 c4 00 00
	00		 mov	 edx, DWORD PTR [edi+196]
  001ed	89 96 c4 00 00
	00		 mov	 DWORD PTR [esi+196], edx
  001f3	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_??_7UTexture@@6B@
  001f8	89 06		 mov	 DWORD PTR [esi], eax
  001fa	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_??_7UProceduralTexture@@6B@
  00200	89 0e		 mov	 DWORD PTR [esi], ecx
  00202	8b 97 c8 00 00
	00		 mov	 edx, DWORD PTR [edi+200]
  00208	89 96 c8 00 00
	00		 mov	 DWORD PTR [esi+200], edx
  0020e	8b 87 cc 00 00
	00		 mov	 eax, DWORD PTR [edi+204]
  00214	89 86 cc 00 00
	00		 mov	 DWORD PTR [esi+204], eax
  0021a	8b 8f d0 00 00
	00		 mov	 ecx, DWORD PTR [edi+208]
  00220	89 8e d0 00 00
	00		 mov	 DWORD PTR [esi+208], ecx
  00226	8b 97 d4 00 00
	00		 mov	 edx, DWORD PTR [edi+212]
  0022c	89 96 d4 00 00
	00		 mov	 DWORD PTR [esi+212], edx
  00232	8b 87 d8 00 00
	00		 mov	 eax, DWORD PTR [edi+216]
  00238	89 86 d8 00 00
	00		 mov	 DWORD PTR [esi+216], eax
  0023e	8a 8f dc 00 00
	00		 mov	 cl, BYTE PTR [edi+220]
  00244	88 8e dc 00 00
	00		 mov	 BYTE PTR [esi+220], cl
  0024a	8a 97 dd 00 00
	00		 mov	 dl, BYTE PTR [edi+221]
  00250	88 96 dd 00 00
	00		 mov	 BYTE PTR [esi+221], dl
  00256	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7UFractalTexture@@6B@ ; UFractalTexture::`vftable'
  0025c	8b 87 e0 00 00
	00		 mov	 eax, DWORD PTR [edi+224]
  00262	89 86 e0 00 00
	00		 mov	 DWORD PTR [esi+224], eax
  00268	8b 8f e4 00 00
	00		 mov	 ecx, DWORD PTR [edi+228]
  0026e	89 8e e4 00 00
	00		 mov	 DWORD PTR [esi+228], ecx
  00274	8a 97 e8 00 00
	00		 mov	 dl, BYTE PTR [edi+232]
  0027a	88 96 e8 00 00
	00		 mov	 BYTE PTR [esi+232], dl
  00280	8a 87 e9 00 00
	00		 mov	 al, BYTE PTR [edi+233]
  00286	88 86 e9 00 00
	00		 mov	 BYTE PTR [esi+233], al
  0028c	8a 8f ea 00 00
	00		 mov	 cl, BYTE PTR [edi+234]
  00292	88 8e ea 00 00
	00		 mov	 BYTE PTR [esi+234], cl
  00298	8a 97 eb 00 00
	00		 mov	 dl, BYTE PTR [edi+235]
  0029e	88 96 eb 00 00
	00		 mov	 BYTE PTR [esi+235], dl
  002a4	8a 87 ec 00 00
	00		 mov	 al, BYTE PTR [edi+236]
  002aa	88 86 ec 00 00
	00		 mov	 BYTE PTR [esi+236], al
  002b0	8a 8f ed 00 00
	00		 mov	 cl, BYTE PTR [edi+237]
  002b6	8b 86 f0 00 00
	00		 mov	 eax, DWORD PTR [esi+240]
  002bc	88 8e ed 00 00
	00		 mov	 BYTE PTR [esi+237], cl
  002c2	8b 97 f0 00 00
	00		 mov	 edx, DWORD PTR [edi+240]
  002c8	33 d0		 xor	 edx, eax
  002ca	83 e2 01	 and	 edx, 1
  002cd	33 d0		 xor	 edx, eax
  002cf	89 96 f0 00 00
	00		 mov	 DWORD PTR [esi+240], edx
  002d5	8b 87 f4 00 00
	00		 mov	 eax, DWORD PTR [edi+244]
  002db	89 86 f4 00 00
	00		 mov	 DWORD PTR [esi+244], eax
  002e1	8b 8f f8 00 00
	00		 mov	 ecx, DWORD PTR [edi+248]
  002e7	89 8e f8 00 00
	00		 mov	 DWORD PTR [esi+248], ecx
  002ed	8b 97 fc 00 00
	00		 mov	 edx, DWORD PTR [edi+252]
  002f3	89 96 fc 00 00
	00		 mov	 DWORD PTR [esi+252], edx
  002f9	8b 87 00 01 00
	00		 mov	 eax, DWORD PTR [edi+256]
  002ff	89 86 00 01 00
	00		 mov	 DWORD PTR [esi+256], eax
  00305	8b 8f 04 01 00
	00		 mov	 ecx, DWORD PTR [edi+260]
  0030b	89 8e 04 01 00
	00		 mov	 DWORD PTR [esi+260], ecx
  00311	8b 97 08 01 00
	00		 mov	 edx, DWORD PTR [edi+264]
  00317	89 96 08 01 00
	00		 mov	 DWORD PTR [esi+264], edx
  0031d	8b 87 0c 01 00
	00		 mov	 eax, DWORD PTR [edi+268]
  00323	89 86 0c 01 00
	00		 mov	 DWORD PTR [esi+268], eax
  00329	8b 8f 10 01 00
	00		 mov	 ecx, DWORD PTR [edi+272]
  0032f	89 8e 10 01 00
	00		 mov	 DWORD PTR [esi+272], ecx
  00335	8b 97 14 01 00
	00		 mov	 edx, DWORD PTR [edi+276]
  0033b	89 96 14 01 00
	00		 mov	 DWORD PTR [esi+276], edx
  00341	8b 87 18 01 00
	00		 mov	 eax, DWORD PTR [edi+280]
  00347	89 86 18 01 00
	00		 mov	 DWORD PTR [esi+280], eax
  0034d	8b 8f 1c 01 00
	00		 mov	 ecx, DWORD PTR [edi+284]
  00353	89 8e 1c 01 00
	00		 mov	 DWORD PTR [esi+284], ecx
  00359	8b 97 20 01 00
	00		 mov	 edx, DWORD PTR [edi+288]
  0035f	8b 4c 24 0c	 mov	 ecx, DWORD PTR __$EHRec$[esp+24]
  00363	89 96 20 01 00
	00		 mov	 DWORD PTR [esi+288], edx
  00369	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7UIceTexture@@6B@ ; UIceTexture::`vftable'
  0036f	5f		 pop	 edi
  00370	8b c6		 mov	 eax, esi
  00372	5e		 pop	 esi
  00373	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0037a	83 c4 10	 add	 esp, 16			; 00000010H
  0037d	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L139620:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1UBitmap@@UAE@XZ
$L139621:
  00009	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	81 c1 a8 00 00
	00		 add	 ecx, 168		; 000000a8H
  00012	e9 00 00 00 00	 jmp	 ??1?$TArray@UFMipmap@@@@QAE@XZ ; TArray<FMipmap>::~TArray<FMipmap>
$L139647:
  00017	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T139646
  0001c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0UIceTexture@@QAE@ABV0@@Z ENDP			; UIceTexture::UIceTexture
PUBLIC	??4UIceTexture@@QAEAAV0@ABV0@@Z			; UIceTexture::operator=
; Function compile flags: /Ogty
;	COMDAT ??4UIceTexture@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
_i$139728 = -4
___that$ = 8
??4UIceTexture@@QAEAAV0@ABV0@@Z PROC NEAR		; UIceTexture::operator=, COMDAT
; _this$ = ecx
  00000	51		 push	 ecx
  00001	53		 push	 ebx
  00002	55		 push	 ebp
  00003	56		 push	 esi
  00004	57		 push	 edi
  00005	8b 7c 24 18	 mov	 edi, DWORD PTR ___that$[esp+16]
  00009	57		 push	 edi
  0000a	8b f1		 mov	 esi, ecx
  0000c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4UObject@@QAEAAV0@ABV0@@Z
  00012	8a 47 28	 mov	 al, BYTE PTR [edi+40]
  00015	88 46 28	 mov	 BYTE PTR [esi+40], al
  00018	8b 4f 2c	 mov	 ecx, DWORD PTR [edi+44]
  0001b	89 4e 2c	 mov	 DWORD PTR [esi+44], ecx
  0001e	8a 57 30	 mov	 dl, BYTE PTR [edi+48]
  00021	88 56 30	 mov	 BYTE PTR [esi+48], dl
  00024	8a 47 31	 mov	 al, BYTE PTR [edi+49]
  00027	88 46 31	 mov	 BYTE PTR [esi+49], al
  0002a	8b 4f 34	 mov	 ecx, DWORD PTR [edi+52]
  0002d	89 4e 34	 mov	 DWORD PTR [esi+52], ecx
  00030	8b 57 38	 mov	 edx, DWORD PTR [edi+56]
  00033	89 56 38	 mov	 DWORD PTR [esi+56], edx
  00036	8b 47 3c	 mov	 eax, DWORD PTR [edi+60]
  00039	89 46 3c	 mov	 DWORD PTR [esi+60], eax
  0003c	8b 4f 40	 mov	 ecx, DWORD PTR [edi+64]
  0003f	89 4e 40	 mov	 DWORD PTR [esi+64], ecx
  00042	8b 57 44	 mov	 edx, DWORD PTR [edi+68]
  00045	89 56 44	 mov	 DWORD PTR [esi+68], edx
  00048	8b 47 48	 mov	 eax, DWORD PTR [edi+72]
  0004b	89 46 48	 mov	 DWORD PTR [esi+72], eax
  0004e	8b 4f 4c	 mov	 ecx, DWORD PTR [edi+76]
  00051	89 4e 4c	 mov	 DWORD PTR [esi+76], ecx
  00054	8b 57 50	 mov	 edx, DWORD PTR [edi+80]
  00057	89 56 50	 mov	 DWORD PTR [esi+80], edx
  0005a	8b 47 54	 mov	 eax, DWORD PTR [edi+84]
  0005d	89 46 54	 mov	 DWORD PTR [esi+84], eax
  00060	8b 4f 58	 mov	 ecx, DWORD PTR [edi+88]
  00063	89 4e 58	 mov	 DWORD PTR [esi+88], ecx
  00066	8b 57 5c	 mov	 edx, DWORD PTR [edi+92]
  00069	89 56 5c	 mov	 DWORD PTR [esi+92], edx
  0006c	8b 47 60	 mov	 eax, DWORD PTR [edi+96]
  0006f	89 46 60	 mov	 DWORD PTR [esi+96], eax
  00072	8b 4f 64	 mov	 ecx, DWORD PTR [edi+100]
  00075	89 4e 64	 mov	 DWORD PTR [esi+100], ecx
  00078	8b 57 68	 mov	 edx, DWORD PTR [edi+104]
  0007b	89 56 68	 mov	 DWORD PTR [esi+104], edx
  0007e	8b 47 6c	 mov	 eax, DWORD PTR [edi+108]
  00081	89 46 6c	 mov	 DWORD PTR [esi+108], eax
  00084	8b 4f 70	 mov	 ecx, DWORD PTR [edi+112]
  00087	89 4e 70	 mov	 DWORD PTR [esi+112], ecx
  0008a	8b 57 74	 mov	 edx, DWORD PTR [edi+116]
  0008d	89 56 74	 mov	 DWORD PTR [esi+116], edx
  00090	8b 47 78	 mov	 eax, DWORD PTR [edi+120]
  00093	89 46 78	 mov	 DWORD PTR [esi+120], eax
  00096	8b 4f 7c	 mov	 ecx, DWORD PTR [edi+124]
  00099	89 4e 7c	 mov	 DWORD PTR [esi+124], ecx
  0009c	8b 97 80 00 00
	00		 mov	 edx, DWORD PTR [edi+128]
  000a2	8b 8e 88 00 00
	00		 mov	 ecx, DWORD PTR [esi+136]
  000a8	89 96 80 00 00
	00		 mov	 DWORD PTR [esi+128], edx
  000ae	8b 87 84 00 00
	00		 mov	 eax, DWORD PTR [edi+132]
  000b4	89 86 84 00 00
	00		 mov	 DWORD PTR [esi+132], eax
  000ba	8b 87 88 00 00
	00		 mov	 eax, DWORD PTR [edi+136]
  000c0	33 c1		 xor	 eax, ecx
  000c2	83 e0 01	 and	 eax, 1
  000c5	33 c1		 xor	 eax, ecx
  000c7	89 86 88 00 00
	00		 mov	 DWORD PTR [esi+136], eax
  000cd	8b 8f 88 00 00
	00		 mov	 ecx, DWORD PTR [edi+136]
  000d3	33 c8		 xor	 ecx, eax
  000d5	83 e1 02	 and	 ecx, 2
  000d8	33 c8		 xor	 ecx, eax
  000da	89 8e 88 00 00
	00		 mov	 DWORD PTR [esi+136], ecx
  000e0	8b 87 88 00 00
	00		 mov	 eax, DWORD PTR [edi+136]
  000e6	33 c1		 xor	 eax, ecx
  000e8	83 e0 04	 and	 eax, 4
  000eb	33 c1		 xor	 eax, ecx
  000ed	89 86 88 00 00
	00		 mov	 DWORD PTR [esi+136], eax
  000f3	8b 8f 88 00 00
	00		 mov	 ecx, DWORD PTR [edi+136]
  000f9	33 c8		 xor	 ecx, eax
  000fb	83 e1 08	 and	 ecx, 8
  000fe	33 c8		 xor	 ecx, eax
  00100	89 8e 88 00 00
	00		 mov	 DWORD PTR [esi+136], ecx
  00106	8b 87 88 00 00
	00		 mov	 eax, DWORD PTR [edi+136]
  0010c	33 c1		 xor	 eax, ecx
  0010e	83 e0 10	 and	 eax, 16			; 00000010H
  00111	33 c1		 xor	 eax, ecx
  00113	89 86 88 00 00
	00		 mov	 DWORD PTR [esi+136], eax
  00119	8b 8f 88 00 00
	00		 mov	 ecx, DWORD PTR [edi+136]
  0011f	33 c8		 xor	 ecx, eax
  00121	83 e1 20	 and	 ecx, 32			; 00000020H
  00124	33 c8		 xor	 ecx, eax
  00126	89 8e 88 00 00
	00		 mov	 DWORD PTR [esi+136], ecx
  0012c	8a 97 8c 00 00
	00		 mov	 dl, BYTE PTR [edi+140]
  00132	88 96 8c 00 00
	00		 mov	 BYTE PTR [esi+140], dl
  00138	8b 87 90 00 00
	00		 mov	 eax, DWORD PTR [edi+144]
  0013e	89 86 90 00 00
	00		 mov	 DWORD PTR [esi+144], eax
  00144	8b 8f 94 00 00
	00		 mov	 ecx, DWORD PTR [edi+148]
  0014a	89 8e 94 00 00
	00		 mov	 DWORD PTR [esi+148], ecx
  00150	8a 97 98 00 00
	00		 mov	 dl, BYTE PTR [edi+152]
  00156	88 96 98 00 00
	00		 mov	 BYTE PTR [esi+152], dl
  0015c	8a 87 99 00 00
	00		 mov	 al, BYTE PTR [edi+153]
  00162	88 86 99 00 00
	00		 mov	 BYTE PTR [esi+153], al
  00168	8b 8f 9c 00 00
	00		 mov	 ecx, DWORD PTR [edi+156]
  0016e	89 8e 9c 00 00
	00		 mov	 DWORD PTR [esi+156], ecx
  00174	8b 97 a0 00 00
	00		 mov	 edx, DWORD PTR [edi+160]
  0017a	89 96 a0 00 00
	00		 mov	 DWORD PTR [esi+160], edx
  00180	8b 87 a4 00 00
	00		 mov	 eax, DWORD PTR [edi+164]
  00186	8d 9f a8 00 00
	00		 lea	 ebx, DWORD PTR [edi+168]
  0018c	8d ae a8 00 00
	00		 lea	 ebp, DWORD PTR [esi+168]
  00192	3b eb		 cmp	 ebp, ebx
  00194	89 86 a4 00 00
	00		 mov	 DWORD PTR [esi+164], eax
  0019a	74 55		 je	 SHORT $L139731
  0019c	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  0019f	51		 push	 ecx
  001a0	8b cd		 mov	 ecx, ebp
  001a2	e8 00 00 00 00	 call	 ?Empty@?$TArray@UFMipmap@@@@QAEXH@Z ; TArray<FMipmap>::Empty
  001a7	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  001aa	33 c0		 xor	 eax, eax
  001ac	3b c8		 cmp	 ecx, eax
  001ae	89 44 24 10	 mov	 DWORD PTR _i$139728[esp+20], eax
  001b2	7e 3d		 jle	 SHORT $L139731
  001b4	89 44 24 18	 mov	 DWORD PTR 8+[esp+16], eax
$L139729:
  001b8	55		 push	 ebp
  001b9	6a 28		 push	 40			; 00000028H
  001bb	e8 00 00 00 00	 call	 ??2@YAPAXIAAV?$TArray@UFMipmap@@@@@Z ; operator new
  001c0	83 c4 08	 add	 esp, 8
  001c3	85 c0		 test	 eax, eax
  001c5	74 0f		 je	 SHORT $L139730
  001c7	8b 13		 mov	 edx, DWORD PTR [ebx]
  001c9	03 54 24 18	 add	 edx, DWORD PTR 8+[esp+16]
  001cd	52		 push	 edx
  001ce	8b c8		 mov	 ecx, eax
  001d0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0FMipmap@@QAE@ABU0@@Z
$L139730:
  001d6	8b 44 24 10	 mov	 eax, DWORD PTR _i$139728[esp+20]
  001da	8b 54 24 18	 mov	 edx, DWORD PTR 8+[esp+16]
  001de	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  001e1	40		 inc	 eax
  001e2	83 c2 28	 add	 edx, 40			; 00000028H
  001e5	3b c1		 cmp	 eax, ecx
  001e7	89 44 24 10	 mov	 DWORD PTR _i$139728[esp+20], eax
  001eb	89 54 24 18	 mov	 DWORD PTR 8+[esp+16], edx
  001ef	7c c7		 jl	 SHORT $L139729
$L139731:
  001f1	8d 87 b4 00 00
	00		 lea	 eax, DWORD PTR [edi+180]
  001f7	50		 push	 eax
  001f8	8d 8e b4 00 00
	00		 lea	 ecx, DWORD PTR [esi+180]
  001fe	e8 00 00 00 00	 call	 ??4?$TArray@UFMipmap@@@@QAEAAV0@ABV0@@Z ; TArray<FMipmap>::operator=
  00203	8a 8f c0 00 00
	00		 mov	 cl, BYTE PTR [edi+192]
  00209	88 8e c0 00 00
	00		 mov	 BYTE PTR [esi+192], cl
  0020f	8b 97 c4 00 00
	00		 mov	 edx, DWORD PTR [edi+196]
  00215	89 96 c4 00 00
	00		 mov	 DWORD PTR [esi+196], edx
  0021b	8b 87 c8 00 00
	00		 mov	 eax, DWORD PTR [edi+200]
  00221	89 86 c8 00 00
	00		 mov	 DWORD PTR [esi+200], eax
  00227	8b 8f cc 00 00
	00		 mov	 ecx, DWORD PTR [edi+204]
  0022d	89 8e cc 00 00
	00		 mov	 DWORD PTR [esi+204], ecx
  00233	8b 97 d0 00 00
	00		 mov	 edx, DWORD PTR [edi+208]
  00239	89 96 d0 00 00
	00		 mov	 DWORD PTR [esi+208], edx
  0023f	8b 87 d4 00 00
	00		 mov	 eax, DWORD PTR [edi+212]
  00245	89 86 d4 00 00
	00		 mov	 DWORD PTR [esi+212], eax
  0024b	8b 8f d8 00 00
	00		 mov	 ecx, DWORD PTR [edi+216]
  00251	89 8e d8 00 00
	00		 mov	 DWORD PTR [esi+216], ecx
  00257	8a 97 dc 00 00
	00		 mov	 dl, BYTE PTR [edi+220]
  0025d	88 96 dc 00 00
	00		 mov	 BYTE PTR [esi+220], dl
  00263	8a 87 dd 00 00
	00		 mov	 al, BYTE PTR [edi+221]
  00269	88 86 dd 00 00
	00		 mov	 BYTE PTR [esi+221], al
  0026f	8b 8f e0 00 00
	00		 mov	 ecx, DWORD PTR [edi+224]
  00275	89 8e e0 00 00
	00		 mov	 DWORD PTR [esi+224], ecx
  0027b	8b 97 e4 00 00
	00		 mov	 edx, DWORD PTR [edi+228]
  00281	89 96 e4 00 00
	00		 mov	 DWORD PTR [esi+228], edx
  00287	8a 87 e8 00 00
	00		 mov	 al, BYTE PTR [edi+232]
  0028d	88 86 e8 00 00
	00		 mov	 BYTE PTR [esi+232], al
  00293	8a 8f e9 00 00
	00		 mov	 cl, BYTE PTR [edi+233]
  00299	88 8e e9 00 00
	00		 mov	 BYTE PTR [esi+233], cl
  0029f	8a 97 ea 00 00
	00		 mov	 dl, BYTE PTR [edi+234]
  002a5	88 96 ea 00 00
	00		 mov	 BYTE PTR [esi+234], dl
  002ab	8a 87 eb 00 00
	00		 mov	 al, BYTE PTR [edi+235]
  002b1	88 86 eb 00 00
	00		 mov	 BYTE PTR [esi+235], al
  002b7	8a 8f ec 00 00
	00		 mov	 cl, BYTE PTR [edi+236]
  002bd	8b 86 f0 00 00
	00		 mov	 eax, DWORD PTR [esi+240]
  002c3	88 8e ec 00 00
	00		 mov	 BYTE PTR [esi+236], cl
  002c9	8a 97 ed 00 00
	00		 mov	 dl, BYTE PTR [edi+237]
  002cf	88 96 ed 00 00
	00		 mov	 BYTE PTR [esi+237], dl
  002d5	8b 8f f0 00 00
	00		 mov	 ecx, DWORD PTR [edi+240]
  002db	33 c8		 xor	 ecx, eax
  002dd	83 e1 01	 and	 ecx, 1
  002e0	33 c8		 xor	 ecx, eax
  002e2	89 8e f0 00 00
	00		 mov	 DWORD PTR [esi+240], ecx
  002e8	8b 97 f4 00 00
	00		 mov	 edx, DWORD PTR [edi+244]
  002ee	89 96 f4 00 00
	00		 mov	 DWORD PTR [esi+244], edx
  002f4	8b 87 f8 00 00
	00		 mov	 eax, DWORD PTR [edi+248]
  002fa	89 86 f8 00 00
	00		 mov	 DWORD PTR [esi+248], eax
  00300	8b 8f fc 00 00
	00		 mov	 ecx, DWORD PTR [edi+252]
  00306	89 8e fc 00 00
	00		 mov	 DWORD PTR [esi+252], ecx
  0030c	8b 97 00 01 00
	00		 mov	 edx, DWORD PTR [edi+256]
  00312	89 96 00 01 00
	00		 mov	 DWORD PTR [esi+256], edx
  00318	8b 87 04 01 00
	00		 mov	 eax, DWORD PTR [edi+260]
  0031e	89 86 04 01 00
	00		 mov	 DWORD PTR [esi+260], eax
  00324	8b 8f 08 01 00
	00		 mov	 ecx, DWORD PTR [edi+264]
  0032a	89 8e 08 01 00
	00		 mov	 DWORD PTR [esi+264], ecx
  00330	8b 97 0c 01 00
	00		 mov	 edx, DWORD PTR [edi+268]
  00336	89 96 0c 01 00
	00		 mov	 DWORD PTR [esi+268], edx
  0033c	8b 87 10 01 00
	00		 mov	 eax, DWORD PTR [edi+272]
  00342	89 86 10 01 00
	00		 mov	 DWORD PTR [esi+272], eax
  00348	8b 8f 14 01 00
	00		 mov	 ecx, DWORD PTR [edi+276]
  0034e	89 8e 14 01 00
	00		 mov	 DWORD PTR [esi+276], ecx
  00354	8b 97 18 01 00
	00		 mov	 edx, DWORD PTR [edi+280]
  0035a	89 96 18 01 00
	00		 mov	 DWORD PTR [esi+280], edx
  00360	8b 87 1c 01 00
	00		 mov	 eax, DWORD PTR [edi+284]
  00366	89 86 1c 01 00
	00		 mov	 DWORD PTR [esi+284], eax
  0036c	8b 8f 20 01 00
	00		 mov	 ecx, DWORD PTR [edi+288]
  00372	5f		 pop	 edi
  00373	89 8e 20 01 00
	00		 mov	 DWORD PTR [esi+288], ecx
  00379	8b c6		 mov	 eax, esi
  0037b	5e		 pop	 esi
  0037c	5d		 pop	 ebp
  0037d	5b		 pop	 ebx
  0037e	59		 pop	 ecx
  0037f	c2 04 00	 ret	 4
??4UIceTexture@@QAEAAV0@ABV0@@Z ENDP			; UIceTexture::operator=
_TEXT	ENDS
PUBLIC	??_GUIceTexture@@UAEPAXI@Z			; UIceTexture::`scalar deleting destructor'
; Function compile flags: /Ogty
;	COMDAT ??_GUIceTexture@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_GUIceTexture@@UAEPAXI@Z PROC NEAR			; UIceTexture::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	e8 00 00 00 00	 call	 ??1UIceTexture@@UAE@XZ	; UIceTexture::~UIceTexture
  00008	f6 44 24 08 01	 test	 BYTE PTR ___flags$[esp], 1
  0000d	74 0d		 je	 SHORT $L139743
  0000f	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?GMalloc@@3PAVFMalloc@@A
  00014	8b 08		 mov	 ecx, DWORD PTR [eax]
  00016	8b 11		 mov	 edx, DWORD PTR [ecx]
  00018	56		 push	 esi
  00019	ff 52 08	 call	 DWORD PTR [edx+8]
$L139743:
  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi
  0001f	c2 04 00	 ret	 4
??_GUIceTexture@@UAEPAXI@Z ENDP				; UIceTexture::`scalar deleting destructor'
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??_EUIceTexture@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_EUIceTexture@@UAEPAXI@Z PROC NEAR			; UIceTexture::`vector deleting destructor', COMDAT
; _this$ = ecx
  00000	53		 push	 ebx
  00001	8a 5c 24 08	 mov	 bl, BYTE PTR ___flags$[esp]
  00005	f6 c3 02	 test	 bl, 2
  00008	56		 push	 esi
  00009	8b f1		 mov	 esi, ecx
  0000b	74 33		 je	 SHORT $L123613
  0000d	8b 46 fc	 mov	 eax, DWORD PTR [esi-4]
  00010	57		 push	 edi
  00011	68 00 00 00 00	 push	 OFFSET FLAT:??1UIceTexture@@UAE@XZ ; UIceTexture::~UIceTexture
  00016	8d 7e fc	 lea	 edi, DWORD PTR [esi-4]
  00019	50		 push	 eax
  0001a	68 24 01 00 00	 push	 292			; 00000124H
  0001f	56		 push	 esi
  00020	e8 00 00 00 00	 call	 ??_M@YGXPAXIHP6EX0@Z@Z	; `eh vector destructor iterator'
  00025	f6 c3 01	 test	 bl, 1
  00028	74 0e		 je	 SHORT $L139749
  0002a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?GMalloc@@3PAVFMalloc@@A
  00030	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00032	8b 11		 mov	 edx, DWORD PTR [ecx]
  00034	57		 push	 edi
  00035	ff 52 08	 call	 DWORD PTR [edx+8]
$L139749:
  00038	8b c7		 mov	 eax, edi
  0003a	5f		 pop	 edi
  0003b	5e		 pop	 esi
  0003c	5b		 pop	 ebx
  0003d	c2 04 00	 ret	 4
$L123613:
  00040	8b ce		 mov	 ecx, esi
  00042	e8 00 00 00 00	 call	 ??1UIceTexture@@UAE@XZ	; UIceTexture::~UIceTexture
  00047	f6 c3 01	 test	 bl, 1
  0004a	74 0d		 je	 SHORT $L139751
  0004c	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?GMalloc@@3PAVFMalloc@@A
  00051	8b 08		 mov	 ecx, DWORD PTR [eax]
  00053	8b 11		 mov	 edx, DWORD PTR [ecx]
  00055	56		 push	 esi
  00056	ff 52 08	 call	 DWORD PTR [edx+8]
$L139751:
  00059	8b c6		 mov	 eax, esi
  0005b	5e		 pop	 esi
  0005c	5b		 pop	 ebx
  0005d	c2 04 00	 ret	 4
??_EUIceTexture@@UAEPAXI@Z ENDP				; UIceTexture::`vector deleting destructor'
_TEXT	ENDS
END
